{
    "3a4167a67e4fc318e2a7ef19500ca6da5910eaac": [
        [
            "TcpCommunicationSpiFaultyClientTest::FakeServer::FakeServer()",
            " 217  \n 218  \n 219  \n 220  \n 221 -\n 222  ",
            "        /**\n         * Default constructor.\n         */\n        FakeServer() throws IOException {\n            this.srv = new ServerSocket(47200, 50, InetAddress.getByName(\"127.0.0.1\"));\n        }",
            " 238  \n 239  \n 240  \n 241  \n 242 +\n 243  ",
            "        /**\n         * Default constructor.\n         */\n        FakeServer() throws IOException {\n            srv = new ServerSocket(47200, 50, InetAddress.getByName(\"127.0.0.1\"));\n        }"
        ],
        [
            "TcpCommunicationSpiFaultyClientTest::beforeTestsStarted()",
            "  93  \n  94  \n  95  \n  96  \n  97 -\n  98  ",
            "    /** {@inheritDoc} */\n    @Override protected void beforeTestsStarted() throws Exception {\n        super.beforeTestsStarted();\n\n        System.setProperty(IgniteSystemProperties.IGNITE_ENABLE_FORCIBLE_NODE_KILL,\"true\");\n    }",
            "  96  \n  97  \n  98  \n  99  \n 100 +\n 101  ",
            "    /** {@inheritDoc} */\n    @Override protected void beforeTestsStarted() throws Exception {\n        super.beforeTestsStarted();\n\n        System.setProperty(IgniteSystemProperties.IGNITE_ENABLE_FORCIBLE_NODE_KILL, \"true\");\n    }"
        ],
        [
            "TcpCommunicationSpiFaultyClientTest::getConfiguration(String)",
            "  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82 -\n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  ",
            "    /** {@inheritDoc} */\n    @Override protected IgniteConfiguration getConfiguration(String gridName) throws Exception {\n        IgniteConfiguration cfg = super.getConfiguration(gridName);\n\n        cfg.setFailureDetectionTimeout(1000);\n        cfg.setClientMode(clientMode);\n\n        TestCommunicationSpi spi = new TestCommunicationSpi();\n\n        spi.setIdleConnectionTimeout(100);\n        spi.setSharedMemoryPort(-1);\n\n        TcpDiscoverySpi discoSpi = (TcpDiscoverySpi) cfg.getDiscoverySpi();\n\n        discoSpi.setIpFinder(IP_FINDER);\n        discoSpi.setClientReconnectDisabled(true);\n\n        cfg.setCommunicationSpi(spi);\n        cfg.setDiscoverySpi(discoSpi);\n\n        return cfg;\n    }",
            "  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85 +\n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  ",
            "    /** {@inheritDoc} */\n    @Override protected IgniteConfiguration getConfiguration(String gridName) throws Exception {\n        IgniteConfiguration cfg = super.getConfiguration(gridName);\n\n        cfg.setFailureDetectionTimeout(1000);\n        cfg.setClientMode(clientMode);\n\n        TestCommunicationSpi spi = new TestCommunicationSpi();\n\n        spi.setIdleConnectionTimeout(100);\n        spi.setSharedMemoryPort(-1);\n\n        TcpDiscoverySpi discoSpi = (TcpDiscoverySpi)cfg.getDiscoverySpi();\n\n        discoSpi.setIpFinder(IP_FINDER);\n        discoSpi.setClientReconnectDisabled(true);\n\n        cfg.setCommunicationSpi(spi);\n        cfg.setDiscoverySpi(discoSpi);\n\n        return cfg;\n    }"
        ],
        [
            "TcpCommunicationSpiFaultyClientTest::testFailClient(FakeServer)",
            " 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153 -\n 154  \n 155  \n 156  \n 157  \n 158 -\n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174 -\n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  ",
            "    /**\n     * @param srv Server.\n     * @throws Exception If failed.\n     */\n    private void testFailClient(FakeServer srv) throws Exception {\n        IgniteInternalFuture<Long> fut = null;\n\n        try {\n            if (srv != null)\n                fut = GridTestUtils.runMultiThreadedAsync(srv, 1, \"fake-server\");\n\n            clientMode = false;\n\n            startGrids(2);\n\n            clientMode = true;\n\n            startGrid(2);\n            startGrid(3);\n\n            U.sleep(1000); // Wait for write timeout and closing idle connections.\n\n            final CountDownLatch latch = new CountDownLatch(1);\n\n            grid(0).events().localListen(new IgnitePredicate<Event>() {\n                @Override public boolean apply(Event event) {\n                    latch.countDown();\n\n                    return true;\n                }\n            }, EVT_NODE_FAILED);\n\n            block = true;\n\n            try {\n                grid(0).compute(grid(0).cluster().forClients()).withNoFailover().broadcast(new IgniteRunnable() {\n                    @Override public void run() {\n                        // No-op.\n                    }\n                });\n            }\n            catch (IgniteException e) {\n                // No-op.\n            }\n\n            assertTrue(latch.await(3, TimeUnit.SECONDS));\n\n            assertTrue(GridTestUtils.waitForCondition(new GridAbsPredicate() {\n                @Override public boolean apply() {\n                    return grid(0).cluster().forClients().nodes().size() == 1;\n                }\n            }, 5000));\n\n            for (int i = 0; i < 5; i++) {\n                U.sleep(1000);\n\n                log.info(\"Check topology (\" + (i + 1) + \"): \" + grid(0).cluster().nodes());\n\n                assertEquals(1, grid(0).cluster().forClients().nodes().size());\n            }\n        }\n        finally {\n            if (srv != null) {\n                srv.stop();\n\n                assert fut != null;\n\n                fut.get();\n            }\n\n            stopAllGrids();\n        }\n    }",
            " 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156 +\n 157 +\n 158 +\n 159 +\n 160 +\n 161 +\n 162 +\n 163 +\n 164 +\n 165 +\n 166 +\n 167 +\n 168 +\n 169 +\n 170 +\n 171 +\n 172 +\n 173 +\n 174 +\n 175  \n 176  \n 177  \n 178  \n 179 +\n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195 +\n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  ",
            "    /**\n     * @param srv Server.\n     * @throws Exception If failed.\n     */\n    private void testFailClient(FakeServer srv) throws Exception {\n        IgniteInternalFuture<Long> fut = null;\n\n        try {\n            if (srv != null)\n                fut = GridTestUtils.runMultiThreadedAsync(srv, 1, \"fake-server\");\n\n            clientMode = false;\n\n            startGrids(2);\n\n            clientMode = true;\n\n            startGrid(2);\n            startGrid(3);\n\n            // Need to wait for PME to avoid opening new connections during closing idle connections.\n            awaitPartitionMapExchange();\n\n            CommunicationSpi commSpi = grid(0).configuration().getCommunicationSpi();\n\n            ConcurrentMap<UUID, GridCommunicationClient[]> clients = U.field(commSpi, \"clients\");\n\n            // Wait for write timeout and closing idle connections.\n            assertTrue(\"Failed to wait for closing idle connections.\",\n                GridTestUtils.waitForCondition(() -> {\n                    for (GridCommunicationClient[] clients0 : clients.values()) {\n                        for (GridCommunicationClient client : clients0) {\n                            if (client != null)\n                                return false;\n                        }\n                    }\n\n                    return true;\n                }, 1000));\n\n            final CountDownLatch latch = new CountDownLatch(1);\n\n            grid(0).events().localListen(new IgnitePredicate<Event>() {\n                @Override public boolean apply(Event evt) {\n                    latch.countDown();\n\n                    return true;\n                }\n            }, EVT_NODE_FAILED);\n\n            block = true;\n\n            try {\n                grid(0).compute(grid(0).cluster().forClients()).withNoFailover().broadcast(new IgniteRunnable() {\n                    @Override public void run() {\n                        // No-op.\n                    }\n                });\n            }\n            catch (IgniteException ignored) {\n                // No-op.\n            }\n\n            assertTrue(latch.await(3, TimeUnit.SECONDS));\n\n            assertTrue(GridTestUtils.waitForCondition(new GridAbsPredicate() {\n                @Override public boolean apply() {\n                    return grid(0).cluster().forClients().nodes().size() == 1;\n                }\n            }, 5000));\n\n            for (int i = 0; i < 5; i++) {\n                U.sleep(1000);\n\n                log.info(\"Check topology (\" + (i + 1) + \"): \" + grid(0).cluster().nodes());\n\n                assertEquals(1, grid(0).cluster().forClients().nodes().size());\n            }\n        }\n        finally {\n            if (srv != null) {\n                srv.stop();\n\n                assert fut != null;\n\n                fut.get();\n            }\n\n            stopAllGrids();\n        }\n    }"
        ],
        [
            "TcpCommunicationSpiFaultyClientTest::FakeServer::run()",
            " 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238 -\n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  ",
            "        /** {@inheritDoc} */\n        @Override public void run() {\n            try {\n                while (!stop) {\n                    try {\n                        U.sleep(10);\n                    }\n                    catch (IgniteInterruptedCheckedException e) {\n                        // No-op.\n                    }\n                }\n            }\n            finally {\n                U.closeQuiet(srv);\n            }\n        }",
            " 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259 +\n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  ",
            "        /** {@inheritDoc} */\n        @Override public void run() {\n            try {\n                while (!stop) {\n                    try {\n                        U.sleep(10);\n                    }\n                    catch (IgniteInterruptedCheckedException ignored) {\n                        // No-op.\n                    }\n                }\n            }\n            finally {\n                U.closeQuiet(srv);\n            }\n        }"
        ],
        [
            "TcpCommunicationSpiFaultyClientTest::afterTestsStopped()",
            " 100  \n 101 -\n 102  \n 103  ",
            "    /** {@inheritDoc} */\n    @Override protected void afterTestsStopped() throws Exception {\n        System.clearProperty(IgniteSystemProperties.IGNITE_ENABLE_FORCIBLE_NODE_KILL);\n    }",
            " 103  \n 104 +\n 105  \n 106  ",
            "    /** {@inheritDoc} */\n    @Override protected void afterTestsStopped() {\n        System.clearProperty(IgniteSystemProperties.IGNITE_ENABLE_FORCIBLE_NODE_KILL);\n    }"
        ]
    ],
    "b3ae58eccb35369041342e4a5d9bb5f661417d41": [
        [
            "GridCacheDatabaseSharedManager::restorePartitionState(Map)",
            "1528  \n1529  \n1530  \n1531  \n1532  \n1533  \n1534  \n1535  \n1536  \n1537  \n1538  \n1539  \n1540  \n1541  \n1542  \n1543  \n1544  \n1545  \n1546  \n1547  \n1548  \n1549  \n1550  \n1551  \n1552  \n1553  \n1554  \n1555  \n1556  \n1557  \n1558  \n1559  \n1560  \n1561  \n1562  \n1563  \n1564 -\n1565 -\n1566 -\n1567 -\n1568  \n1569  \n1570  \n1571  \n1572  \n1573  \n1574  \n1575  \n1576  \n1577  \n1578  \n1579  \n1580  \n1581  \n1582  \n1583  \n1584  \n1585  \n1586  \n1587  \n1588  \n1589  \n1590  \n1591  \n1592  \n1593  \n1594  \n1595  \n1596  \n1597  \n1598  ",
            "    /**\n     * @param partStates Partition states.\n     * @throws IgniteCheckedException If failed to restore.\n     */\n    private void restorePartitionState(\n        Map<T2<Integer, Integer>, T2<Integer, Long>> partStates\n    ) throws IgniteCheckedException {\n        for (CacheGroupContext grp : cctx.cache().cacheGroups()) {\n            if (grp.isLocal() || !grp.affinityNode()) {\n                // Local cache has no partitions and its states.\n                continue;\n            }\n\n            int grpId = grp.groupId();\n\n            PageMemoryEx pageMem = (PageMemoryEx)grp.memoryPolicy().pageMemory();\n\n            for (int i = 0; i < grp.affinity().partitions(); i++) {\n                if (storeMgr.exists(grpId, i)) {\n                    storeMgr.ensure(grpId, i);\n\n                    if (storeMgr.pages(grpId, i) <= 1)\n                        continue;\n\n                    long partMetaId = pageMem.partitionMetaPageId(grpId, i);\n                    long partMetaPage = pageMem.acquirePage(grpId, partMetaId);\n                    try {\n                        long pageAddr = pageMem.writeLock(grpId, partMetaId, partMetaPage);\n\n                        boolean changed = false;\n\n                        try {\n                            PagePartitionMetaIO io = PagePartitionMetaIO.VERSIONS.forPage(pageAddr);\n\n                            T2<Integer, Long> fromWal = partStates.get(new T2<>(grpId, i));\n\n                            GridDhtLocalPartition part = grp.topology().forceCreatePartition(i);\n\n                            assert part != null;\n\n                            if (fromWal != null) {\n                                int stateId = fromWal.get1();\n\n                                io.setPartitionState(pageAddr, (byte)stateId);\n\n                                changed = updateState(part, stateId);\n\n                                if (stateId == GridDhtPartitionState.OWNING.ordinal()) {\n                                    grp.offheap().onPartitionInitialCounterUpdated(i, fromWal.get2());\n\n                                    if (part.initialUpdateCounter() < fromWal.get2()) {\n                                        part.initialUpdateCounter(fromWal.get2());\n\n                                        changed = true;\n                                    }\n                                }\n                            }\n                            else\n                                changed = updateState(part, (int)io.getPartitionState(pageAddr));\n                        }\n                        finally {\n                            pageMem.writeUnlock(grpId, partMetaId, partMetaPage, null, changed);\n                        }\n                    }\n                    finally {\n                        pageMem.releasePage(grpId, partMetaId, partMetaPage);\n                    }\n                }\n            }\n        }\n    }",
            "1528  \n1529  \n1530  \n1531  \n1532  \n1533  \n1534  \n1535  \n1536  \n1537  \n1538  \n1539  \n1540  \n1541  \n1542  \n1543  \n1544  \n1545  \n1546  \n1547  \n1548  \n1549  \n1550  \n1551  \n1552 +\n1553 +\n1554 +\n1555 +\n1556 +\n1557 +\n1558 +\n1559  \n1560  \n1561  \n1562  \n1563  \n1564  \n1565  \n1566  \n1567  \n1568  \n1569  \n1570  \n1571  \n1572  \n1573  \n1574  \n1575  \n1576  \n1577  \n1578  \n1579  \n1580  \n1581  \n1582  \n1583  \n1584  \n1585  \n1586  \n1587  \n1588  \n1589  \n1590  \n1591  \n1592  \n1593  \n1594  \n1595  \n1596  \n1597  \n1598  \n1599  \n1600  \n1601  ",
            "    /**\n     * @param partStates Partition states.\n     * @throws IgniteCheckedException If failed to restore.\n     */\n    private void restorePartitionState(\n        Map<T2<Integer, Integer>, T2<Integer, Long>> partStates\n    ) throws IgniteCheckedException {\n        for (CacheGroupContext grp : cctx.cache().cacheGroups()) {\n            if (grp.isLocal() || !grp.affinityNode()) {\n                // Local cache has no partitions and its states.\n                continue;\n            }\n\n            int grpId = grp.groupId();\n\n            PageMemoryEx pageMem = (PageMemoryEx)grp.memoryPolicy().pageMemory();\n\n            for (int i = 0; i < grp.affinity().partitions(); i++) {\n                if (storeMgr.exists(grpId, i)) {\n                    storeMgr.ensure(grpId, i);\n\n                    if (storeMgr.pages(grpId, i) <= 1)\n                        continue;\n\n                    GridDhtLocalPartition part = grp.topology().forceCreatePartition(i);\n\n                    assert part != null;\n\n                    // TODO: https://issues.apache.org/jira/browse/IGNITE-6097\n                    grp.offheap().onPartitionInitialCounterUpdated(i, 0);\n\n                    long partMetaId = pageMem.partitionMetaPageId(grpId, i);\n                    long partMetaPage = pageMem.acquirePage(grpId, partMetaId);\n                    try {\n                        long pageAddr = pageMem.writeLock(grpId, partMetaId, partMetaPage);\n\n                        boolean changed = false;\n\n                        try {\n                            PagePartitionMetaIO io = PagePartitionMetaIO.VERSIONS.forPage(pageAddr);\n\n                            T2<Integer, Long> fromWal = partStates.get(new T2<>(grpId, i));\n\n                            if (fromWal != null) {\n                                int stateId = fromWal.get1();\n\n                                io.setPartitionState(pageAddr, (byte)stateId);\n\n                                changed = updateState(part, stateId);\n\n                                if (stateId == GridDhtPartitionState.OWNING.ordinal()) {\n                                    grp.offheap().onPartitionInitialCounterUpdated(i, fromWal.get2());\n\n                                    if (part.initialUpdateCounter() < fromWal.get2()) {\n                                        part.initialUpdateCounter(fromWal.get2());\n\n                                        changed = true;\n                                    }\n                                }\n                            }\n                            else\n                                changed = updateState(part, (int)io.getPartitionState(pageAddr));\n                        }\n                        finally {\n                            pageMem.writeUnlock(grpId, partMetaId, partMetaPage, null, changed);\n                        }\n                    }\n                    finally {\n                        pageMem.releasePage(grpId, partMetaId, partMetaPage);\n                    }\n                }\n            }\n        }\n    }"
        ],
        [
            "PageMemoryImpl::refreshOutdatedPage(Segment,int,long,boolean)",
            " 625  \n 626  \n 627  \n 628  \n 629  \n 630  \n 631  \n 632  \n 633  \n 634  \n 635  \n 636  \n 637  \n 638  \n 639  \n 640  \n 641  \n 642  \n 643  \n 644  \n 645  \n 646  \n 647  \n 648  \n 649 -\n 650  \n 651  \n 652  \n 653  \n 654  \n 655  \n 656  \n 657  \n 658  \n 659  \n 660  \n 661  ",
            "    /**\n     * @param seg Segment.\n     * @param cacheId Cache ID.\n     * @param pageId Page ID.\n     * @param rmv {@code True} if page should be removed.\n     * @return Relative pointer to refreshed page.\n     */\n    private long refreshOutdatedPage(Segment seg, int cacheId, long pageId, boolean rmv) {\n        assert seg.writeLock().isHeldByCurrentThread();\n\n        int tag = seg.partTag(cacheId, PageIdUtils.partId(pageId));\n\n        long relPtr = seg.loadedPages.refresh(cacheId, PageIdUtils.effectivePageId(pageId), tag);\n\n        long absPtr = seg.absolute(relPtr);\n\n        GridUnsafe.setMemory(absPtr + PAGE_OVERHEAD, pageSize(), (byte)0);\n\n        long tmpBufPtr = PageHeader.tempBufferPointer(absPtr);\n\n        if (tmpBufPtr != INVALID_REL_PTR) {\n            GridUnsafe.setMemory(checkpointPool.absolute(tmpBufPtr) + PAGE_OVERHEAD, pageSize(), (byte)0);\n\n            PageHeader.tempBufferPointer(absPtr, INVALID_REL_PTR);\n            PageHeader.dirty(absPtr, false);\n\n            // We pinned the page when allocated the temp buffer, release it now.\n            PageHeader.releasePage(absPtr);\n\n            checkpointPool.releaseFreePage(tmpBufPtr);\n        }\n\n        if (rmv)\n            seg.loadedPages.remove(cacheId, PageIdUtils.effectivePageId(pageId), tag);\n\n        return relPtr;\n    }",
            " 625  \n 626  \n 627  \n 628  \n 629  \n 630  \n 631  \n 632  \n 633  \n 634  \n 635  \n 636  \n 637  \n 638  \n 639  \n 640  \n 641  \n 642  \n 643 +\n 644 +\n 645  \n 646  \n 647  \n 648  \n 649  \n 650  \n 651  \n 652  \n 653  \n 654  \n 655  \n 656  \n 657  \n 658  \n 659  \n 660  \n 661 +\n 662 +\n 663 +\n 664 +\n 665 +\n 666 +\n 667  \n 668  ",
            "    /**\n     * @param seg Segment.\n     * @param cacheId Cache ID.\n     * @param pageId Page ID.\n     * @param rmv {@code True} if page should be removed.\n     * @return Relative pointer to refreshed page.\n     */\n    private long refreshOutdatedPage(Segment seg, int cacheId, long pageId, boolean rmv) {\n        assert seg.writeLock().isHeldByCurrentThread();\n\n        int tag = seg.partTag(cacheId, PageIdUtils.partId(pageId));\n\n        long relPtr = seg.loadedPages.refresh(cacheId, PageIdUtils.effectivePageId(pageId), tag);\n\n        long absPtr = seg.absolute(relPtr);\n\n        GridUnsafe.setMemory(absPtr + PAGE_OVERHEAD, pageSize(), (byte)0);\n\n        PageHeader.dirty(absPtr, false);\n\n        long tmpBufPtr = PageHeader.tempBufferPointer(absPtr);\n\n        if (tmpBufPtr != INVALID_REL_PTR) {\n            GridUnsafe.setMemory(checkpointPool.absolute(tmpBufPtr) + PAGE_OVERHEAD, pageSize(), (byte)0);\n\n            PageHeader.tempBufferPointer(absPtr, INVALID_REL_PTR);\n\n            // We pinned the page when allocated the temp buffer, release it now.\n            PageHeader.releasePage(absPtr);\n\n            checkpointPool.releaseFreePage(tmpBufPtr);\n        }\n\n        if (rmv)\n            seg.loadedPages.remove(cacheId, PageIdUtils.effectivePageId(pageId), tag);\n\n        if (seg.segCheckpointPages != null)\n            seg.segCheckpointPages.remove(new FullPageId(pageId, cacheId));\n\n        if (seg.dirtyPages != null)\n            seg.dirtyPages.remove(new FullPageId(pageId, cacheId));\n\n        return relPtr;\n    }"
        ],
        [
            "GridDhtPartitionTopologyImpl::createPartition(int)",
            " 653  \n 654  \n 655  \n 656  \n 657  \n 658  \n 659  \n 660  \n 661  \n 662  \n 663  \n 664  \n 665  \n 666  \n 667  \n 668  \n 669  \n 670  \n 671  \n 672  \n 673  \n 674  \n 675  \n 676  \n 677  \n 678  \n 679  \n 680  \n 681  \n 682  ",
            "    /**\n     * @param p Partition number.\n     * @return Partition.\n     */\n    private GridDhtLocalPartition createPartition(int p) {\n        assert lock.isWriteLockedByCurrentThread();\n\n        GridDhtLocalPartition loc = locParts.get(p);\n\n        if (loc == null || loc.state() == EVICTED) {\n            locParts.set(p, loc = new GridDhtLocalPartition(ctx, grp, p));\n\n            T2<Long, Long> cntr = cntrMap.get(p);\n\n            if (cntr != null)\n                loc.updateCounter(cntr.get2());\n\n            if (ctx.pageStore() != null) {\n                try {\n                    ctx.pageStore().onPartitionCreated(grp.groupId(), p);\n                }\n                catch (IgniteCheckedException e) {\n                    // TODO ignite-db\n                    throw new IgniteException(e);\n                }\n            }\n        }\n\n        return loc;\n    }",
            " 653  \n 654  \n 655  \n 656  \n 657  \n 658  \n 659  \n 660  \n 661  \n 662  \n 663 +\n 664 +\n 665 +\n 666 +\n 667 +\n 668 +\n 669 +\n 670 +\n 671 +\n 672  \n 673  \n 674  \n 675  \n 676  \n 677  \n 678  \n 679  \n 680  \n 681  \n 682  \n 683  \n 684  \n 685  \n 686  \n 687  \n 688  \n 689  \n 690  \n 691  ",
            "    /**\n     * @param p Partition number.\n     * @return Partition.\n     */\n    private GridDhtLocalPartition createPartition(int p) {\n        assert lock.isWriteLockedByCurrentThread();\n\n        GridDhtLocalPartition loc = locParts.get(p);\n\n        if (loc == null || loc.state() == EVICTED) {\n            if (loc != null) {\n                try {\n                    loc.rent(false).get();\n                }\n                catch (IgniteCheckedException e) {\n                    throw new IgniteException(e);\n                }\n            }\n\n            locParts.set(p, loc = new GridDhtLocalPartition(ctx, grp, p));\n\n            T2<Long, Long> cntr = cntrMap.get(p);\n\n            if (cntr != null)\n                loc.updateCounter(cntr.get2());\n\n            if (ctx.pageStore() != null) {\n                try {\n                    ctx.pageStore().onPartitionCreated(grp.groupId(), p);\n                }\n                catch (IgniteCheckedException e) {\n                    // TODO ignite-db\n                    throw new IgniteException(e);\n                }\n            }\n        }\n\n        return loc;\n    }"
        ],
        [
            "GridDhtPartitionTopologyImpl::localPartition0(int,AffinityTopologyVersion,boolean,boolean,boolean)",
            " 707  \n 708  \n 709  \n 710  \n 711  \n 712  \n 713  \n 714  \n 715  \n 716  \n 717  \n 718  \n 719  \n 720  \n 721  \n 722  \n 723  \n 724  \n 725  \n 726  \n 727  \n 728  \n 729  \n 730  \n 731  \n 732  \n 733  \n 734  \n 735  \n 736  \n 737  \n 738  \n 739  \n 740  \n 741  \n 742  \n 743  \n 744  \n 745  \n 746  \n 747  \n 748  \n 749  \n 750  \n 751  \n 752  \n 753  \n 754  \n 755  \n 756  \n 757  \n 758  \n 759  \n 760  \n 761  \n 762  \n 763  \n 764  \n 765  \n 766  \n 767  \n 768  \n 769  \n 770  \n 771  \n 772  \n 773  \n 774  \n 775  \n 776  \n 777  \n 778  \n 779  \n 780  \n 781  \n 782  \n 783  \n 784  \n 785  \n 786  \n 787  \n 788  ",
            "    /**\n     * @param p Partition number.\n     * @param topVer Topology version.\n     * @param create Create flag.\n     * @param updateSeq Update sequence.\n     * @return Local partition.\n     */\n    @SuppressWarnings(\"TooBroadScope\")\n    private GridDhtLocalPartition localPartition0(int p,\n        AffinityTopologyVersion topVer,\n        boolean create,\n        boolean showRenting,\n        boolean updateSeq) {\n        GridDhtLocalPartition loc;\n\n        loc = locParts.get(p);\n\n        GridDhtPartitionState state = loc != null ? loc.state() : null;\n\n        if (loc != null && state != EVICTED && (state != RENTING || showRenting))\n            return loc;\n\n        if (!create)\n            return null;\n\n        boolean created = false;\n\n        lock.writeLock().lock();\n\n        try {\n            loc = locParts.get(p);\n\n            state = loc != null ? loc.state() : null;\n\n            boolean belongs = partitionLocalNode(p, topVer);\n\n            if (loc != null && state == EVICTED) {\n                locParts.set(p, loc = null);\n\n                if (!belongs)\n                    throw new GridDhtInvalidPartitionException(p, \"Adding entry to evicted partition \" +\n                        \"(often may be caused by inconsistent 'key.hashCode()' implementation) \" +\n                        \"[part=\" + p + \", topVer=\" + topVer + \", this.topVer=\" + this.topVer + ']');\n            }\n            else if (loc != null && state == RENTING && !showRenting)\n                throw new GridDhtInvalidPartitionException(p, \"Adding entry to partition that is concurrently \" +\n                    \"evicted [part=\" + p + \", shouldBeMoving=\" + loc.reload() + \", belongs=\" + belongs +\n                    \", topVer=\" + topVer + \", curTopVer=\" + this.topVer + \"]\");\n\n            if (loc == null) {\n                if (!belongs)\n                    throw new GridDhtInvalidPartitionException(p, \"Creating partition which does not belong to \" +\n                        \"local node (often may be caused by inconsistent 'key.hashCode()' implementation) \" +\n                        \"[part=\" + p + \", topVer=\" + topVer + \", this.topVer=\" + this.topVer + ']');\n\n                locParts.set(p, loc = new GridDhtLocalPartition(ctx, grp, p));\n\n                if (updateSeq)\n                    this.updateSeq.incrementAndGet();\n\n                created = true;\n\n                if (log.isDebugEnabled())\n                    log.debug(\"Created local partition: \" + loc);\n            }\n        }\n        finally {\n            lock.writeLock().unlock();\n        }\n\n        if (created && ctx.pageStore() != null) {\n            try {\n                ctx.pageStore().onPartitionCreated(grp.groupId(), p);\n            }\n            catch (IgniteCheckedException e) {\n                // TODO ignite-db\n                throw new IgniteException(e);\n            }\n        }\n\n        return loc;\n    }",
            " 716  \n 717  \n 718  \n 719  \n 720  \n 721  \n 722  \n 723  \n 724  \n 725  \n 726  \n 727  \n 728  \n 729  \n 730  \n 731  \n 732  \n 733  \n 734  \n 735  \n 736  \n 737  \n 738  \n 739  \n 740  \n 741  \n 742  \n 743  \n 744  \n 745  \n 746  \n 747  \n 748  \n 749  \n 750  \n 751  \n 752  \n 753 +\n 754 +\n 755 +\n 756 +\n 757 +\n 758 +\n 759 +\n 760  \n 761  \n 762  \n 763  \n 764  \n 765  \n 766  \n 767  \n 768  \n 769  \n 770  \n 771  \n 772  \n 773  \n 774  \n 775  \n 776  \n 777  \n 778  \n 779  \n 780  \n 781  \n 782  \n 783  \n 784  \n 785  \n 786  \n 787  \n 788  \n 789  \n 790  \n 791  \n 792  \n 793  \n 794  \n 795  \n 796  \n 797  \n 798  \n 799  \n 800  \n 801  \n 802  \n 803  \n 804  ",
            "    /**\n     * @param p Partition number.\n     * @param topVer Topology version.\n     * @param create Create flag.\n     * @param updateSeq Update sequence.\n     * @return Local partition.\n     */\n    @SuppressWarnings(\"TooBroadScope\")\n    private GridDhtLocalPartition localPartition0(int p,\n        AffinityTopologyVersion topVer,\n        boolean create,\n        boolean showRenting,\n        boolean updateSeq) {\n        GridDhtLocalPartition loc;\n\n        loc = locParts.get(p);\n\n        GridDhtPartitionState state = loc != null ? loc.state() : null;\n\n        if (loc != null && state != EVICTED && (state != RENTING || showRenting))\n            return loc;\n\n        if (!create)\n            return null;\n\n        boolean created = false;\n\n        lock.writeLock().lock();\n\n        try {\n            loc = locParts.get(p);\n\n            state = loc != null ? loc.state() : null;\n\n            boolean belongs = partitionLocalNode(p, topVer);\n\n            if (loc != null && state == EVICTED) {\n                try {\n                    loc.rent(false).get();\n                }\n                catch (IgniteCheckedException ex) {\n                    throw new IgniteException(ex);\n                }\n\n                locParts.set(p, loc = null);\n\n                if (!belongs)\n                    throw new GridDhtInvalidPartitionException(p, \"Adding entry to evicted partition \" +\n                        \"(often may be caused by inconsistent 'key.hashCode()' implementation) \" +\n                        \"[part=\" + p + \", topVer=\" + topVer + \", this.topVer=\" + this.topVer + ']');\n            }\n            else if (loc != null && state == RENTING && !showRenting)\n                throw new GridDhtInvalidPartitionException(p, \"Adding entry to partition that is concurrently \" +\n                    \"evicted [part=\" + p + \", shouldBeMoving=\" + loc.reload() + \", belongs=\" + belongs +\n                    \", topVer=\" + topVer + \", curTopVer=\" + this.topVer + \"]\");\n\n            if (loc == null) {\n                if (!belongs)\n                    throw new GridDhtInvalidPartitionException(p, \"Creating partition which does not belong to \" +\n                        \"local node (often may be caused by inconsistent 'key.hashCode()' implementation) \" +\n                        \"[part=\" + p + \", topVer=\" + topVer + \", this.topVer=\" + this.topVer + ']');\n\n                locParts.set(p, loc = new GridDhtLocalPartition(ctx, grp, p));\n\n                if (updateSeq)\n                    this.updateSeq.incrementAndGet();\n\n                created = true;\n\n                if (log.isDebugEnabled())\n                    log.debug(\"Created local partition: \" + loc);\n            }\n        }\n        finally {\n            lock.writeLock().unlock();\n        }\n\n        if (created && ctx.pageStore() != null) {\n            try {\n                ctx.pageStore().onPartitionCreated(grp.groupId(), p);\n            }\n            catch (IgniteCheckedException e) {\n                // TODO ignite-db\n                throw new IgniteException(e);\n            }\n        }\n\n        return loc;\n    }"
        ]
    ]
}