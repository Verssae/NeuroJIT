{
    "f2864a8236536148a618474fa28d27c74f563a45": [
        [
            "TraitComposer::applyTrait(ClassNode,ClassNode,TraitHelpersTuple)",
            " 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197 -\n 198  \n 199  \n 200 -\n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209 -\n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  ",
            "    private static void applyTrait(final ClassNode trait, final ClassNode cNode, final TraitHelpersTuple helpers) {\n        boolean isTraitForceOverride = !trait.getAnnotations(Traits.FORCEOVERRIDE_CLASSNODE).isEmpty();\n        ClassNode helperClassNode = helpers.getHelper();\n        ClassNode fieldHelperClassNode = helpers.getFieldHelper();\n        Map genericsSpec = GenericsUtils.createGenericsSpec(cNode, new HashMap());\n        genericsSpec = GenericsUtils.createGenericsSpec(trait, genericsSpec);\n\n        for (MethodNode methodNode : helperClassNode.getAllDeclaredMethods()) {\n            boolean isForceOverride = isTraitForceOverride || Traits.isForceOverride(methodNode);\n            String name = methodNode.getName();\n            Parameter[] helperMethodParams = methodNode.getParameters();\n            boolean isAbstract = methodNode.isAbstract();\n            if (!isAbstract && helperMethodParams.length > 0 && ((methodNode.getModifiers() & Opcodes.ACC_STATIC) == Opcodes.ACC_STATIC) && !name.contains(\"$\")) {\n                ArgumentListExpression argList = new ArgumentListExpression();\n                argList.addExpression(new VariableExpression(\"this\"));\n                Parameter[] origParams = new Parameter[helperMethodParams.length - 1];\n                Parameter[] params = new Parameter[helperMethodParams.length - 1];\n                for (int i = 1; i < helperMethodParams.length; i++) {\n                    Parameter parameter = helperMethodParams[i];\n                    ClassNode originType = parameter.getOriginType();\n                    ClassNode fixedType = AbstractASTTransformation.correctToGenericsSpecRecurse(genericsSpec, originType);\n                    Parameter newParam = new Parameter(fixedType, \"arg\" + i);\n                    List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n                    List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n                    AbstractASTTransformation.copyAnnotatedNodeAnnotations(parameter, copied, notCopied);\n                    newParam.addAnnotations(copied);\n                    params[i - 1] = newParam;\n                    origParams[i-1] = parameter;\n                    argList.addExpression(new VariableExpression(params[i - 1]));\n                }\n                if (shouldSkipMethod(cNode, name, params, isForceOverride)) {\n                    continue;\n                }\n                createForwarderMethod(trait, cNode, methodNode, helperClassNode, genericsSpec, helperMethodParams, origParams, params, argList);\n            }\n        }\n        cNode.addObjectInitializerStatements(new ExpressionStatement(\n                new MethodCallExpression(\n                        new ClassExpression(helperClassNode),\n                        Traits.INIT_METHOD,\n                        new ArgumentListExpression(new VariableExpression(\"this\")))\n        ));\n        cNode.addStaticInitializerStatements(Collections.<Statement>singletonList(new ExpressionStatement(\n                new MethodCallExpression(\n                        new ClassExpression(helperClassNode),\n                        Traits.STATIC_INIT_METHOD,\n                        new ArgumentListExpression(new VariableExpression(\"this\")))\n        )), false);\n        if (fieldHelperClassNode != null) {\n            // we should implement the field helper interface too\n            cNode.addInterface(fieldHelperClassNode);\n            // implementation of methods\n            List<MethodNode> declaredMethods = fieldHelperClassNode.getAllDeclaredMethods();\n            Collections.sort(declaredMethods, GETTER_FIRST_COMPARATOR);\n            for (MethodNode methodNode : declaredMethods) {\n                String fieldName = methodNode.getName();\n                if (fieldName.endsWith(Traits.DIRECT_GETTER_SUFFIX) || fieldName.endsWith(Traits.DIRECT_SETTER_SUFFIX)) {\n                    int suffixIdx = fieldName.lastIndexOf(\"$\");\n                    fieldName = fieldName.substring(0, suffixIdx);\n                    String operation = methodNode.getName().substring(suffixIdx + 1);\n                    boolean getter = \"get\".equals(operation);\n                    ClassNode returnType = AbstractASTTransformation.correctToGenericsSpecRecurse(genericsSpec, methodNode.getReturnType());\n                    int isStatic = 0;\n                    FieldNode helperField = fieldHelperClassNode.getField(fieldName);\n                    if (helperField==null) {\n                        // try to find a static one\n                        helperField = fieldHelperClassNode.getField(Traits.STATIC_FIELD_PREFIX+fieldName);\n                        isStatic = Opcodes.ACC_STATIC;\n                    }\n                    if (getter) {\n                        // add field\n                        if (helperField!=null) {\n                            List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n                            List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n                            AbstractASTTransformation.copyAnnotatedNodeAnnotations(helperField, copied, notCopied);\n                            FieldNode fieldNode = cNode.addField(fieldName, Opcodes.ACC_PRIVATE | isStatic, returnType, null);\n                            fieldNode.addAnnotations(copied);\n                        }\n                    }\n                    Parameter[] newParams;\n                    if (getter) {\n                        newParams = Parameter.EMPTY_ARRAY;\n                    } else {\n                        ClassNode originType = methodNode.getParameters()[0].getOriginType();\n                        ClassNode fixedType = originType.isGenericsPlaceHolder()?ClassHelper.OBJECT_TYPE:AbstractASTTransformation.correctToGenericsSpecRecurse(genericsSpec, originType);\n                        newParams = new Parameter[]{new Parameter(fixedType, \"val\")};\n                    }\n\n                    Expression fieldExpr = new VariableExpression(cNode.getField(fieldName));\n                    Statement body =\n                            getter ? new ReturnStatement(fieldExpr) :\n                                    new ExpressionStatement(\n                                            new BinaryExpression(\n                                                    fieldExpr,\n                                                    Token.newSymbol(Types.EQUAL, 0, 0),\n                                                    new VariableExpression(newParams[0])\n                                            )\n                                    );\n                    MethodNode impl = new MethodNode(\n                            methodNode.getName(),\n                            Opcodes.ACC_PUBLIC | isStatic,\n                            returnType,\n                            newParams,\n                            ClassNode.EMPTY_ARRAY,\n                            body\n                    );\n                    impl.addAnnotation(new AnnotationNode(COMPILESTATIC_CLASSNODE));\n                    cNode.addMethod(impl);\n                }\n            }\n        }\n    }",
            " 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197 +\n 198 +\n 199  \n 200 +\n 201 +\n 202 +\n 203 +\n 204 +\n 205  \n 206 +\n 207 +\n 208 +\n 209 +\n 210 +\n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219 +\n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  ",
            "    private static void applyTrait(final ClassNode trait, final ClassNode cNode, final TraitHelpersTuple helpers) {\n        boolean isTraitForceOverride = !trait.getAnnotations(Traits.FORCEOVERRIDE_CLASSNODE).isEmpty();\n        ClassNode helperClassNode = helpers.getHelper();\n        ClassNode fieldHelperClassNode = helpers.getFieldHelper();\n        Map genericsSpec = GenericsUtils.createGenericsSpec(cNode, new HashMap());\n        genericsSpec = GenericsUtils.createGenericsSpec(trait, genericsSpec);\n\n        for (MethodNode methodNode : helperClassNode.getAllDeclaredMethods()) {\n            boolean isForceOverride = isTraitForceOverride || Traits.isForceOverride(methodNode);\n            String name = methodNode.getName();\n            Parameter[] helperMethodParams = methodNode.getParameters();\n            boolean isAbstract = methodNode.isAbstract();\n            if (!isAbstract && helperMethodParams.length > 0 && ((methodNode.getModifiers() & Opcodes.ACC_STATIC) == Opcodes.ACC_STATIC) && !name.contains(\"$\")) {\n                ArgumentListExpression argList = new ArgumentListExpression();\n                argList.addExpression(new VariableExpression(\"this\"));\n                Parameter[] origParams = new Parameter[helperMethodParams.length - 1];\n                Parameter[] params = new Parameter[helperMethodParams.length - 1];\n                for (int i = 1; i < helperMethodParams.length; i++) {\n                    Parameter parameter = helperMethodParams[i];\n                    ClassNode originType = parameter.getOriginType();\n                    ClassNode fixedType = AbstractASTTransformation.correctToGenericsSpecRecurse(genericsSpec, originType);\n                    Parameter newParam = new Parameter(fixedType, \"arg\" + i);\n                    List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n                    List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n                    AbstractASTTransformation.copyAnnotatedNodeAnnotations(parameter, copied, notCopied);\n                    newParam.addAnnotations(copied);\n                    params[i - 1] = newParam;\n                    origParams[i-1] = parameter;\n                    argList.addExpression(new VariableExpression(params[i - 1]));\n                }\n                if (shouldSkipMethod(cNode, name, params, isForceOverride)) {\n                    continue;\n                }\n                createForwarderMethod(trait, cNode, methodNode, helperClassNode, genericsSpec, helperMethodParams, origParams, params, argList);\n            }\n        }\n        cNode.addObjectInitializerStatements(new ExpressionStatement(\n                new MethodCallExpression(\n                        new ClassExpression(helperClassNode),\n                        Traits.INIT_METHOD,\n                        new ArgumentListExpression(new VariableExpression(\"this\")))\n        ));\n        cNode.addStaticInitializerStatements(Collections.<Statement>singletonList(new ExpressionStatement(\n                new MethodCallExpression(\n                        new ClassExpression(helperClassNode),\n                        Traits.STATIC_INIT_METHOD,\n                        new ArgumentListExpression(new VariableExpression(\"this\")))\n        )), false);\n        if (fieldHelperClassNode != null) {\n            // we should implement the field helper interface too\n            cNode.addInterface(fieldHelperClassNode);\n            // implementation of methods\n            List<MethodNode> declaredMethods = fieldHelperClassNode.getAllDeclaredMethods();\n            Collections.sort(declaredMethods, GETTER_FIRST_COMPARATOR);\n            for (MethodNode methodNode : declaredMethods) {\n                String fieldName = methodNode.getName();\n                if (fieldName.endsWith(Traits.DIRECT_GETTER_SUFFIX) || fieldName.endsWith(Traits.DIRECT_SETTER_SUFFIX)) {\n                    int suffixIdx = fieldName.lastIndexOf(\"$\");\n                    fieldName = fieldName.substring(0, suffixIdx);\n                    String operation = methodNode.getName().substring(suffixIdx + 1);\n                    boolean getter = \"get\".equals(operation);\n                    ClassNode returnType = AbstractASTTransformation.correctToGenericsSpecRecurse(genericsSpec, methodNode.getReturnType());\n                    int isStatic = 0;\n                    boolean publicField = true;\n                    FieldNode helperField = fieldHelperClassNode.getField(Traits.FIELD_PREFIX + Traits.PUBLIC_FIELD_PREFIX + fieldName);\n                    if (helperField==null) {\n                        publicField = false;\n                        helperField = fieldHelperClassNode.getField(Traits.FIELD_PREFIX + Traits.PRIVATE_FIELD_PREFIX + fieldName);\n                    }\n                    if (helperField==null) {\n                        publicField = true;\n                        // try to find a static one\n                        helperField = fieldHelperClassNode.getField(Traits.STATIC_FIELD_PREFIX+Traits.PUBLIC_FIELD_PREFIX+fieldName);\n                        if (helperField==null) {\n                            publicField = false;\n                            helperField = fieldHelperClassNode.getField(Traits.STATIC_FIELD_PREFIX+Traits.PRIVATE_FIELD_PREFIX +fieldName);\n                        }\n                        isStatic = Opcodes.ACC_STATIC;\n                    }\n                    if (getter) {\n                        // add field\n                        if (helperField!=null) {\n                            List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n                            List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n                            AbstractASTTransformation.copyAnnotatedNodeAnnotations(helperField, copied, notCopied);\n                            FieldNode fieldNode = cNode.addField(fieldName, (publicField?Opcodes.ACC_PUBLIC:Opcodes.ACC_PRIVATE) | isStatic, returnType, null);\n                            fieldNode.addAnnotations(copied);\n                        }\n                    }\n                    Parameter[] newParams;\n                    if (getter) {\n                        newParams = Parameter.EMPTY_ARRAY;\n                    } else {\n                        ClassNode originType = methodNode.getParameters()[0].getOriginType();\n                        ClassNode fixedType = originType.isGenericsPlaceHolder()?ClassHelper.OBJECT_TYPE:AbstractASTTransformation.correctToGenericsSpecRecurse(genericsSpec, originType);\n                        newParams = new Parameter[]{new Parameter(fixedType, \"val\")};\n                    }\n\n                    Expression fieldExpr = new VariableExpression(cNode.getField(fieldName));\n                    Statement body =\n                            getter ? new ReturnStatement(fieldExpr) :\n                                    new ExpressionStatement(\n                                            new BinaryExpression(\n                                                    fieldExpr,\n                                                    Token.newSymbol(Types.EQUAL, 0, 0),\n                                                    new VariableExpression(newParams[0])\n                                            )\n                                    );\n                    MethodNode impl = new MethodNode(\n                            methodNode.getName(),\n                            Opcodes.ACC_PUBLIC | isStatic,\n                            returnType,\n                            newParams,\n                            ClassNode.EMPTY_ARRAY,\n                            body\n                    );\n                    impl.addAnnotation(new AnnotationNode(COMPILESTATIC_CLASSNODE));\n                    cNode.addMethod(impl);\n                }\n            }\n        }\n    }"
        ],
        [
            "TraitASTTransformation::processField(FieldNode,MethodNode,MethodNode,ClassNode,ClassNode,Set)",
            " 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388  \n 389 -\n 390 -\n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  ",
            "    private void processField(final FieldNode field, final MethodNode initializer, final MethodNode staticInitializer, final ClassNode fieldHelper, final ClassNode trait, final Set<String> knownFields) {\n        Expression initialExpression = field.getInitialExpression();\n        MethodNode selectedMethod = field.isStatic()?staticInitializer:initializer;\n        if (initialExpression != null) {\n            VariableExpression thisObject = new VariableExpression(selectedMethod.getParameters()[0]);\n            ExpressionStatement initCode = new ExpressionStatement(initialExpression);\n            processBody(thisObject, selectedMethod, initCode, trait, fieldHelper, knownFields);\n            BlockStatement code = (BlockStatement) selectedMethod.getCode();\n            MethodCallExpression mce = new MethodCallExpression(\n                    new CastExpression(createReceiverType(field.isStatic(), fieldHelper), thisObject),\n                    Traits.helperSetterName(field),\n                    initCode.getExpression()\n            );\n            mce.setImplicitThis(false);\n            mce.setSourcePosition(initialExpression);\n            code.addStatement(new ExpressionStatement(mce));\n        }\n        // define setter/getter helper methods\n        fieldHelper.addMethod(\n                Traits.helperSetterName(field),\n                ACC_PUBLIC | ACC_ABSTRACT,\n                ClassHelper.VOID_TYPE,\n                new Parameter[]{new Parameter(field.getOriginType(), \"val\")},\n                ClassNode.EMPTY_ARRAY,\n                null\n        );\n        fieldHelper.addMethod(\n                Traits.helperGetterName(field),\n                ACC_PUBLIC | ACC_ABSTRACT,\n                field.getOriginType(),\n                Parameter.EMPTY_ARRAY,\n                ClassNode.EMPTY_ARRAY,\n                null\n        );\n\n        // dummy fields are only used to carry annotations if instance field\n        // and to differentiate from static fields otherwise\n        FieldNode dummyField = new FieldNode(\n                (field.isStatic()?Traits.STATIC_FIELD_PREFIX:\"\")+Traits.remappedFieldName(field.getOwner(),field.getName()),\n                ACC_STATIC|ACC_PUBLIC | ACC_FINAL | ACC_SYNTHETIC,\n                field.getOriginType(),\n                fieldHelper,\n                null\n        );\n        // copy annotations from field to dummy field\n        List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n        List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n        copyAnnotatedNodeAnnotations(field, copied, notCopied);\n        dummyField.addAnnotations(copied);\n        fieldHelper.addField(dummyField);\n    }",
            " 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388 +\n 389 +\n 390 +\n 391  \n 392 +\n 393 +\n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  ",
            "    private void processField(final FieldNode field, final MethodNode initializer, final MethodNode staticInitializer, final ClassNode fieldHelper, final ClassNode trait, final Set<String> knownFields) {\n        Expression initialExpression = field.getInitialExpression();\n        MethodNode selectedMethod = field.isStatic()?staticInitializer:initializer;\n        if (initialExpression != null) {\n            VariableExpression thisObject = new VariableExpression(selectedMethod.getParameters()[0]);\n            ExpressionStatement initCode = new ExpressionStatement(initialExpression);\n            processBody(thisObject, selectedMethod, initCode, trait, fieldHelper, knownFields);\n            BlockStatement code = (BlockStatement) selectedMethod.getCode();\n            MethodCallExpression mce = new MethodCallExpression(\n                    new CastExpression(createReceiverType(field.isStatic(), fieldHelper), thisObject),\n                    Traits.helperSetterName(field),\n                    initCode.getExpression()\n            );\n            mce.setImplicitThis(false);\n            mce.setSourcePosition(initialExpression);\n            code.addStatement(new ExpressionStatement(mce));\n        }\n        // define setter/getter helper methods\n        fieldHelper.addMethod(\n                Traits.helperSetterName(field),\n                ACC_PUBLIC | ACC_ABSTRACT,\n                ClassHelper.VOID_TYPE,\n                new Parameter[]{new Parameter(field.getOriginType(), \"val\")},\n                ClassNode.EMPTY_ARRAY,\n                null\n        );\n        fieldHelper.addMethod(\n                Traits.helperGetterName(field),\n                ACC_PUBLIC | ACC_ABSTRACT,\n                field.getOriginType(),\n                Parameter.EMPTY_ARRAY,\n                ClassNode.EMPTY_ARRAY,\n                null\n        );\n\n        // dummy fields are only used to carry annotations if instance field\n        // and to differentiate from static fields otherwise\n        String dummyFieldName = (field.isStatic() ? Traits.STATIC_FIELD_PREFIX : Traits.FIELD_PREFIX) +\n                (field.isPublic()? Traits.PUBLIC_FIELD_PREFIX : Traits.PRIVATE_FIELD_PREFIX)+\n                Traits.remappedFieldName(field.getOwner(), field.getName());\n        FieldNode dummyField = new FieldNode(\n                dummyFieldName,\n                ACC_STATIC | ACC_PUBLIC | ACC_FINAL | ACC_SYNTHETIC,\n                field.getOriginType(),\n                fieldHelper,\n                null\n        );\n        // copy annotations from field to dummy field\n        List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n        List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n        copyAnnotatedNodeAnnotations(field, copied, notCopied);\n        dummyField.addAnnotations(copied);\n        fieldHelper.addField(dummyField);\n    }"
        ]
    ],
    "622742192996de555c29eb9c39b743429b95c1bd": [
        [
            "StaticTypeCheckingVisitor::doInferClosureParameterTypes(ClassNode,Expression,ClosureExpression,MethodNode,Expression,Expression)",
            "2098  \n2099  \n2100  \n2101  \n2102  \n2103  \n2104  \n2105  \n2106  \n2107  \n2108  \n2109  \n2110  \n2111  \n2112  \n2113  \n2114  \n2115  \n2116  \n2117  \n2118  \n2119  \n2120  \n2121  \n2122  \n2123  \n2124  \n2125  \n2126  \n2127  \n2128  \n2129  \n2130  \n2131  \n2132  \n2133  \n2134  \n2135  \n2136  \n2137  \n2138  \n2139  \n2140  \n2141  \n2142  \n2143  \n2144  \n2145  \n2146  \n2147  \n2148  \n2149  \n2150  \n2151  \n2152  \n2153  \n2154  \n2155  \n2156  \n2157  \n2158  \n2159  \n2160  \n2161  \n2162  \n2163  \n2164  \n2165  \n2166  \n2167  \n2168  \n2169  \n2170  \n2171  \n2172  \n2173  \n2174  \n2175  \n2176  \n2177  \n2178  \n2179  \n2180  \n2181  \n2182  \n2183  \n2184  \n2185  \n2186  \n2187  \n2188  \n2189  \n2190  \n2191  \n2192  \n2193  \n2194  \n2195  \n2196  \n2197  \n2198  \n2199  \n2200  \n2201  \n2202  \n2203  \n2204  \n2205 -\n2206  \n2207  \n2208  \n2209  \n2210  \n2211  \n2212  ",
            "    private void doInferClosureParameterTypes(final ClassNode receiver, final Expression arguments, final ClosureExpression expression, final MethodNode selectedMethod, final Expression hintClass, final Expression options) {\n        List<ClassNode[]> closureSignatures = getSignaturesFromHint(expression,selectedMethod,hintClass,options);\n        List<ClassNode[]> candidates = new LinkedList<ClassNode[]>();\n        for (ClassNode[] signature : closureSignatures) {\n            // in order to compute the inferred types of the closure parameters, we're using the following trick:\n            // 1. create a dummy MethodNode for which the return type is a class node for which the generic types are the types returned by the hint\n            // 2. call inferReturnTypeGenerics\n            // 3. fetch inferred types from the result of inferReturnTypeGenerics\n            // In practice, it could be done differently but it has the main advantage of reusing\n            // existing code, hence reducing the amount of code to debug in case of failure.\n            final int id = System.identityHashCode(expression);\n            ClassNode dummyResultNode = new ClassNode(\"cl$\" + id, 0, OBJECT_TYPE).getPlainNodeReference();\n            final GenericsType[] genericTypes = new GenericsType[signature.length];\n            for (int i = 0; i < signature.length; i++) {\n                genericTypes[i] = new GenericsType(signature[i]);\n            }\n            dummyResultNode.setGenericsTypes(genericTypes);\n            MethodNode dummyMN = selectedMethod instanceof ExtensionMethodNode ? ((ExtensionMethodNode) selectedMethod).getExtensionMethodNode() : selectedMethod;\n            dummyMN = new MethodNode(\n                    dummyMN.getName(),\n                    dummyMN.getModifiers(),\n                    dummyResultNode,\n                    dummyMN.getParameters(),\n                    dummyMN.getExceptions(),\n                    EmptyStatement.INSTANCE\n                    );\n            dummyMN.setDeclaringClass(selectedMethod.getDeclaringClass());\n            dummyMN.setGenericsTypes(selectedMethod.getGenericsTypes());\n            if (selectedMethod instanceof ExtensionMethodNode) {\n                ExtensionMethodNode orig = (ExtensionMethodNode) selectedMethod;\n                dummyMN = new ExtensionMethodNode(\n                        dummyMN,\n                        dummyMN.getName(),\n                        dummyMN.getModifiers(),\n                        dummyResultNode,\n                        orig.getParameters(),\n                        orig.getExceptions(),\n                        EmptyStatement.INSTANCE,\n                        orig.isStaticExtension()\n                        );\n                dummyMN.setDeclaringClass(orig.getDeclaringClass());\n                dummyMN.setGenericsTypes(orig.getGenericsTypes());\n            }\n            ClassNode classNode = inferReturnTypeGenerics(receiver, dummyMN, arguments);\n            ClassNode[] inferred = new ClassNode[classNode.getGenericsTypes().length];\n            for (int i = 0; i < classNode.getGenericsTypes().length; i++) {\n                GenericsType genericsType = classNode.getGenericsTypes()[i];\n                ClassNode value = createUsableClassNodeFromGenericsType(genericsType);\n                inferred[i] = value;\n            }\n            Parameter[] closureParams = expression.getParameters();\n            if (signature.length == closureParams.length // same number of arguments\n                    || (signature.length == 1 && closureParams.length == 0) // implicit it\n                    || (closureParams.length > signature.length && inferred[inferred.length - 1].isArray())) { // vargs\n                candidates.add(inferred);\n            }\n        }\n        Parameter[] closureParams = expression.getParameters();\n        if (candidates.size()>1) {\n            Iterator<ClassNode[]> candIt = candidates.iterator();\n            while (candIt.hasNext()) {\n                ClassNode[] inferred = candIt.next();\n                final int length = closureParams.length;\n                for (int i = 0; i < length; i++) {\n                    Parameter closureParam = closureParams[i];\n                    final ClassNode originType = closureParam.getOriginType();\n                    ClassNode inferredType;\n                    if (i<inferred.length-1 || inferred.length==closureParams.length) {\n                        inferredType = inferred[i];\n                    } else { // vargs?\n                        ClassNode lastArgInferred = inferred[inferred.length-1];\n                        if (lastArgInferred.isArray()) {\n                            inferredType = lastArgInferred.getComponentType();\n                        } else {\n                            candIt.remove();\n                            continue;\n                        }\n                    }\n                    if (!typeCheckMethodArgumentWithGenerics(originType, inferredType, i== length -1)) {\n                        candIt.remove();\n                    }\n                }\n            }\n            if (candidates.size()>1) {\n                addError(\"Ambiguous prototypes for closure. More than one target method matches. Please use explicit argument types.\", expression);\n            }\n        }\n        if (candidates.size()==1) {\n            ClassNode[] inferred = candidates.get(0);\n            if (closureParams.length==0 && inferred.length==1) {\n                expression.putNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS, inferred);\n            } else {\n                final int length = closureParams.length;\n                for (int i = 0; i < length; i++) {\n                    Parameter closureParam = closureParams[i];\n                    final ClassNode originType = closureParam.getOriginType();\n                    ClassNode inferredType = OBJECT_TYPE;\n                    if (i<inferred.length-1 || inferred.length==closureParams.length) {\n                        inferredType = inferred[i];\n                    } else { // vargs?\n                            ClassNode lastArgInferred = inferred[inferred.length-1];\n                            if (lastArgInferred.isArray()) {\n                                inferredType = lastArgInferred.getComponentType();\n                            } else {\n                                addError(\"Incorrect number of parameters. Expected \"+inferred.length+\" but found \"+closureParams.length, expression);\n                            }\n                    }\n                    if (!typeCheckMethodArgumentWithGenerics(originType, inferredType, i== length -1)) {\n                        addError(\"Expected parameter of type \"+ inferredType.toString(false)+\" but got \"+originType.toString(false), closureParam.getType());\n                    }\n                    typeCheckingContext.controlStructureVariables.put(closureParam, inferredType);\n                }\n            }\n        }\n    }",
            "2098  \n2099  \n2100  \n2101  \n2102  \n2103  \n2104  \n2105  \n2106  \n2107  \n2108  \n2109  \n2110  \n2111  \n2112  \n2113  \n2114  \n2115  \n2116  \n2117  \n2118  \n2119  \n2120  \n2121  \n2122  \n2123  \n2124  \n2125  \n2126  \n2127  \n2128  \n2129  \n2130  \n2131  \n2132  \n2133  \n2134  \n2135  \n2136  \n2137  \n2138  \n2139  \n2140  \n2141  \n2142  \n2143  \n2144  \n2145  \n2146  \n2147  \n2148  \n2149  \n2150  \n2151  \n2152  \n2153  \n2154  \n2155  \n2156  \n2157  \n2158  \n2159  \n2160  \n2161  \n2162  \n2163  \n2164  \n2165  \n2166  \n2167  \n2168  \n2169  \n2170  \n2171  \n2172  \n2173  \n2174  \n2175  \n2176  \n2177  \n2178  \n2179  \n2180  \n2181  \n2182  \n2183  \n2184  \n2185  \n2186  \n2187  \n2188  \n2189  \n2190  \n2191  \n2192  \n2193  \n2194  \n2195  \n2196  \n2197  \n2198  \n2199  \n2200  \n2201  \n2202  \n2203  \n2204  \n2205 +\n2206 +\n2207 +\n2208 +\n2209 +\n2210 +\n2211  \n2212  \n2213  \n2214  \n2215  \n2216  \n2217  ",
            "    private void doInferClosureParameterTypes(final ClassNode receiver, final Expression arguments, final ClosureExpression expression, final MethodNode selectedMethod, final Expression hintClass, final Expression options) {\n        List<ClassNode[]> closureSignatures = getSignaturesFromHint(expression,selectedMethod,hintClass,options);\n        List<ClassNode[]> candidates = new LinkedList<ClassNode[]>();\n        for (ClassNode[] signature : closureSignatures) {\n            // in order to compute the inferred types of the closure parameters, we're using the following trick:\n            // 1. create a dummy MethodNode for which the return type is a class node for which the generic types are the types returned by the hint\n            // 2. call inferReturnTypeGenerics\n            // 3. fetch inferred types from the result of inferReturnTypeGenerics\n            // In practice, it could be done differently but it has the main advantage of reusing\n            // existing code, hence reducing the amount of code to debug in case of failure.\n            final int id = System.identityHashCode(expression);\n            ClassNode dummyResultNode = new ClassNode(\"cl$\" + id, 0, OBJECT_TYPE).getPlainNodeReference();\n            final GenericsType[] genericTypes = new GenericsType[signature.length];\n            for (int i = 0; i < signature.length; i++) {\n                genericTypes[i] = new GenericsType(signature[i]);\n            }\n            dummyResultNode.setGenericsTypes(genericTypes);\n            MethodNode dummyMN = selectedMethod instanceof ExtensionMethodNode ? ((ExtensionMethodNode) selectedMethod).getExtensionMethodNode() : selectedMethod;\n            dummyMN = new MethodNode(\n                    dummyMN.getName(),\n                    dummyMN.getModifiers(),\n                    dummyResultNode,\n                    dummyMN.getParameters(),\n                    dummyMN.getExceptions(),\n                    EmptyStatement.INSTANCE\n                    );\n            dummyMN.setDeclaringClass(selectedMethod.getDeclaringClass());\n            dummyMN.setGenericsTypes(selectedMethod.getGenericsTypes());\n            if (selectedMethod instanceof ExtensionMethodNode) {\n                ExtensionMethodNode orig = (ExtensionMethodNode) selectedMethod;\n                dummyMN = new ExtensionMethodNode(\n                        dummyMN,\n                        dummyMN.getName(),\n                        dummyMN.getModifiers(),\n                        dummyResultNode,\n                        orig.getParameters(),\n                        orig.getExceptions(),\n                        EmptyStatement.INSTANCE,\n                        orig.isStaticExtension()\n                        );\n                dummyMN.setDeclaringClass(orig.getDeclaringClass());\n                dummyMN.setGenericsTypes(orig.getGenericsTypes());\n            }\n            ClassNode classNode = inferReturnTypeGenerics(receiver, dummyMN, arguments);\n            ClassNode[] inferred = new ClassNode[classNode.getGenericsTypes().length];\n            for (int i = 0; i < classNode.getGenericsTypes().length; i++) {\n                GenericsType genericsType = classNode.getGenericsTypes()[i];\n                ClassNode value = createUsableClassNodeFromGenericsType(genericsType);\n                inferred[i] = value;\n            }\n            Parameter[] closureParams = expression.getParameters();\n            if (signature.length == closureParams.length // same number of arguments\n                    || (signature.length == 1 && closureParams.length == 0) // implicit it\n                    || (closureParams.length > signature.length && inferred[inferred.length - 1].isArray())) { // vargs\n                candidates.add(inferred);\n            }\n        }\n        Parameter[] closureParams = expression.getParameters();\n        if (candidates.size()>1) {\n            Iterator<ClassNode[]> candIt = candidates.iterator();\n            while (candIt.hasNext()) {\n                ClassNode[] inferred = candIt.next();\n                final int length = closureParams.length;\n                for (int i = 0; i < length; i++) {\n                    Parameter closureParam = closureParams[i];\n                    final ClassNode originType = closureParam.getOriginType();\n                    ClassNode inferredType;\n                    if (i<inferred.length-1 || inferred.length==closureParams.length) {\n                        inferredType = inferred[i];\n                    } else { // vargs?\n                        ClassNode lastArgInferred = inferred[inferred.length-1];\n                        if (lastArgInferred.isArray()) {\n                            inferredType = lastArgInferred.getComponentType();\n                        } else {\n                            candIt.remove();\n                            continue;\n                        }\n                    }\n                    if (!typeCheckMethodArgumentWithGenerics(originType, inferredType, i== length -1)) {\n                        candIt.remove();\n                    }\n                }\n            }\n            if (candidates.size()>1) {\n                addError(\"Ambiguous prototypes for closure. More than one target method matches. Please use explicit argument types.\", expression);\n            }\n        }\n        if (candidates.size()==1) {\n            ClassNode[] inferred = candidates.get(0);\n            if (closureParams.length==0 && inferred.length==1) {\n                expression.putNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS, inferred);\n            } else {\n                final int length = closureParams.length;\n                for (int i = 0; i < length; i++) {\n                    Parameter closureParam = closureParams[i];\n                    final ClassNode originType = closureParam.getOriginType();\n                    ClassNode inferredType = OBJECT_TYPE;\n                    if (i<inferred.length-1 || inferred.length==closureParams.length) {\n                        inferredType = inferred[i];\n                    } else { // vargs?\n                            ClassNode lastArgInferred = inferred[inferred.length-1];\n                            if (lastArgInferred.isArray()) {\n                                inferredType = lastArgInferred.getComponentType();\n                            } else {\n                                addError(\"Incorrect number of parameters. Expected \"+inferred.length+\" but found \"+closureParams.length, expression);\n                            }\n                    }\n                    boolean lastArg = i == length - 1;\n                    if (lastArg && inferredType.isArray()) {\n                        if (inferredType.getComponentType().equals(originType)) {\n                            inferredType = originType;\n                        }\n                    } else if (!typeCheckMethodArgumentWithGenerics(originType, inferredType, lastArg)) {\n                        addError(\"Expected parameter of type \"+ inferredType.toString(false)+\" but got \"+originType.toString(false), closureParam.getType());\n                    }\n                    typeCheckingContext.controlStructureVariables.put(closureParam, inferredType);\n                }\n            }\n        }\n    }"
        ]
    ],
    "ab0c1a46dcac49b07519e99857ca07a2b72af9bb": [
        [
            "StaticTypeCheckingVisitor::existsProperty(PropertyExpression,boolean,ClassCodeVisitorSupport)",
            " 946  \n 947  \n 948  \n 949  \n 950  \n 951  \n 952  \n 953  \n 954  \n 955  \n 956  \n 957  \n 958  \n 959  \n 960  \n 961  \n 962  \n 963  \n 964  \n 965  \n 966  \n 967  \n 968  \n 969  \n 970  \n 971  \n 972  \n 973  \n 974  \n 975  \n 976  \n 977  \n 978  \n 979  \n 980  \n 981  \n 982  \n 983  \n 984  \n 985  \n 986  \n 987  \n 988  \n 989  \n 990  \n 991  \n 992  \n 993  \n 994  \n 995  \n 996  \n 997  \n 998  \n 999  \n1000  \n1001  \n1002  \n1003  \n1004  \n1005  \n1006  \n1007  \n1008  \n1009  \n1010  \n1011  \n1012  \n1013  \n1014  \n1015  \n1016  \n1017  \n1018  \n1019  \n1020  \n1021  \n1022  \n1023  \n1024  \n1025  \n1026  \n1027  \n1028  \n1029  \n1030  \n1031  \n1032  \n1033  \n1034  \n1035  \n1036  \n1037  \n1038  \n1039  \n1040  \n1041  \n1042  \n1043  \n1044  \n1045  \n1046  \n1047  \n1048  \n1049  \n1050  \n1051  \n1052  \n1053  \n1054  \n1055  \n1056  \n1057  \n1058  \n1059  \n1060  \n1061  \n1062  \n1063  \n1064  \n1065  \n1066  \n1067  \n1068  \n1069  \n1070  \n1071  \n1072  \n1073  \n1074  \n1075  \n1076  \n1077  \n1078  \n1079  \n1080  \n1081  \n1082  \n1083  \n1084  \n1085  \n1086  \n1087  \n1088  \n1089  \n1090  \n1091  \n1092  \n1093  \n1094  \n1095  \n1096  \n1097  \n1098  \n1099  ",
            "    /**\n     * Checks whether a property exists on the receiver, or on any of the possible receiver classes (found in the\n     * temporary type information table)\n     *\n     * @param pexp             a property expression\n     * @param readMode         if true, look for property read, else for property set\n     * @param visitor          if not null, when the property node is found, visit it with the provided visitor\n     * @return true if the property is defined in any of the possible receiver classes\n     */\n    protected boolean existsProperty(final PropertyExpression pexp, final boolean readMode, final ClassCodeVisitorSupport visitor) {\n        super.visitPropertyExpression(pexp);\n\n        String propertyName = pexp.getPropertyAsString();\n        if (propertyName == null) return false;\n\n        Expression objectExpression = pexp.getObjectExpression();\n        final ClassNode objectExpressionType = getType(objectExpression);\n\n        boolean staticOnlyAccess = isClassClassNodeWrappingConcreteType(objectExpressionType);\n        if (objectExpressionType.isArray() && \"length\".equals(pexp.getPropertyAsString())) {\n            storeType(pexp, int_TYPE);\n            if (visitor != null) {\n                PropertyNode node = new PropertyNode(\"length\", Opcodes.ACC_PUBLIC | Opcodes.ACC_FINAL, int_TYPE, objectExpressionType, null, null, null);\n                visitor.visitProperty(node);\n            }\n            return true;\n        }\n\n        boolean foundGetterOrSetter = false;\n        List<Receiver<String>> receivers = new LinkedList<Receiver<String>>();\n        List<Receiver<String>> owners = makeOwnerList(objectExpression);\n        addReceivers(receivers, owners, pexp.isImplicitThis());\n\n        String capName = MetaClassHelper.capitalize(propertyName);\n        boolean isAttributeExpression = pexp instanceof AttributeExpression;\n        HashSet<ClassNode> handledNodes = new HashSet<ClassNode>();\n        for (Receiver<String> receiver : receivers) {\n            ClassNode testClass = receiver.getType();\n                LinkedList<ClassNode> queue = new LinkedList<ClassNode>();\n                queue.add(testClass);\n                while (!queue.isEmpty()) {\n                    ClassNode current = queue.removeFirst();\n                    if (handledNodes.contains(current)) continue;\n                    handledNodes.add(current);\n                    Set<ClassNode> allInterfaces = current.getAllInterfaces();\n                    for (ClassNode intf : allInterfaces) {\n                        //TODO: apply right generics here!\n                        queue.add(GenericsUtils.parameterizeType(current, intf));\n                    }\n\n                    // in case of a lookup on Class we look for instance methods on Class\n                    // as well, since in case of a static property access we have the class\n                    // itself in the list of receivers already;\n                    boolean staticOnly;\n                    if (isClassClassNodeWrappingConcreteType(current)) {\n                        staticOnly = false;\n                    } else {\n                        staticOnly = staticOnlyAccess;\n                    }\n\n                    FieldNode field = current.getDeclaredField(propertyName);\n                    field  = allowStaticAccessToMember(field, staticOnly);\n                    if (storeField(field, isAttributeExpression, pexp, current, visitor, receiver.getData())) return true;\n\n                    PropertyNode propertyNode = current.getProperty(propertyName);\n                    propertyNode = allowStaticAccessToMember(propertyNode, staticOnly);\n                    if (storeProperty(propertyNode, pexp, current, visitor, receiver.getData())) return true;\n\n                    boolean isThisExpression = objectExpression instanceof VariableExpression && \n                                                ((VariableExpression)objectExpression).isThisExpression();\n                    if (storeField(field, isThisExpression, pexp, receiver.getType(), visitor, receiver.getData())) return true;\n\n                    MethodNode getter = current.getGetterMethod(\"get\" + capName);\n                    getter = allowStaticAccessToMember(getter, staticOnly);\n                    if (getter == null) getter = current.getGetterMethod(\"is\" + capName);\n                    getter = allowStaticAccessToMember(getter, staticOnly);\n                    MethodNode setter = current.getSetterMethod(\"set\" + capName, false);\n                    setter = allowStaticAccessToMember(setter, staticOnly);\n\n                    // TODO: remove this visit\n                    // need to visit even if we only look for a setter for compatibility\n                    if (visitor != null && getter!=null) visitor.visitMethod(getter);\n\n                    if (readMode) {\n                        if (getter!=null) {\n                            ClassNode cn = inferReturnTypeGenerics(current, getter, ArgumentListExpression.EMPTY_ARGUMENTS);\n                            storeInferredTypeForPropertyExpression(pexp, cn);\n                            pexp.removeNodeMetaData(StaticTypesMarker.READONLY_PROPERTY);\n                            String delegationData = receiver.getData();\n                            if (delegationData!=null) pexp.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER, delegationData);\n                            return true;\n                        }\n                    } else {\n                        if (setter != null) {\n                            // TODO: remove this visit\n                            // need to visit even if we only look for a setter for compatibility\n                            if (visitor != null && field!=null) visitor.visitField(field);\n\n                            //TODO: apply generics on parameter[0]? \n                            storeType(pexp, setter.getParameters()[0].getType());\n                            SetterInfo info = new SetterInfo(current, setter);\n                            BinaryExpression enclosingBinaryExpression = typeCheckingContext.getEnclosingBinaryExpression();\n                            if (enclosingBinaryExpression!=null) putSetterInfo(enclosingBinaryExpression.getLeftExpression(), info);\n                            String delegationData = receiver.getData();\n                            if (delegationData!=null) pexp.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER, delegationData);\n                            return true;\n                        } else if (getter!=null) {\n                            pexp.putNodeMetaData(StaticTypesMarker.READONLY_PROPERTY, true);\n                        }\n                    }\n                    foundGetterOrSetter = foundGetterOrSetter || setter!=null || getter!=null;\n\n                    if (storeField(field, true, pexp, current, visitor, receiver.getData())) return true;\n                    // if the property expression is an attribute expression (o.@attr), then\n                    // we stop now, otherwise we must check the parent class\n                    if (/*!isAttributeExpression && */current.getSuperClass() != null) {\n                        queue.add(current.getUnresolvedSuperClass());\n                    }\n                }\n                // GROOVY-5568, the property may be defined by DGM\n                List<MethodNode> methods = findDGMMethodsByNameAndArguments(getTransformLoader(), testClass, \"get\" + capName, ClassNode.EMPTY_ARRAY);\n                if (!methods.isEmpty()) {\n                    List<MethodNode> methodNodes = chooseBestMethod(testClass, methods, ClassNode.EMPTY_ARRAY);\n                    if (methodNodes.size() == 1) {\n                        MethodNode getter = methodNodes.get(0);\n                        if (visitor != null) {\n                            visitor.visitMethod(getter);\n                        }\n                        ClassNode cn = inferReturnTypeGenerics(testClass, getter, ArgumentListExpression.EMPTY_ARGUMENTS);\n                        storeInferredTypeForPropertyExpression(pexp, cn);\n\n                        return true;\n                    }\n                }\n        }\n\n        for (Receiver<String> receiver : receivers) {\n            ClassNode testClass = receiver.getType();\n            ClassNode propertyType = getTypeForMapPropertyExpression(testClass, objectExpressionType, pexp);\n            if (propertyType==null) propertyType = getTypeForListPropertyExpression(testClass, objectExpressionType, pexp);\n            if (propertyType==null) propertyType = getTypeForSpreadExpression(testClass, objectExpressionType, pexp);\n            if (propertyType==null) continue;\n            if (visitor!=null) {\n                // todo : type inference on maps and lists, if possible\n                PropertyNode node = new PropertyNode(propertyName, Opcodes.ACC_PUBLIC, propertyType, objectExpressionType, null, null, null);\n                visitor.visitProperty(node);\n            }\n            storeType(pexp, propertyType);\n            String delegationData = receiver.getData();\n            if (delegationData!=null) pexp.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER, delegationData);\n            return true;\n        }\n        return foundGetterOrSetter;\n    }",
            " 946  \n 947  \n 948  \n 949  \n 950  \n 951  \n 952  \n 953  \n 954  \n 955  \n 956  \n 957  \n 958  \n 959  \n 960  \n 961  \n 962  \n 963  \n 964  \n 965 +\n 966 +\n 967 +\n 968 +\n 969 +\n 970 +\n 971 +\n 972 +\n 973 +\n 974 +\n 975 +\n 976 +\n 977 +\n 978  \n 979  \n 980  \n 981  \n 982  \n 983  \n 984  \n 985  \n 986  \n 987  \n 988  \n 989  \n 990  \n 991  \n 992  \n 993  \n 994  \n 995  \n 996  \n 997  \n 998  \n 999  \n1000  \n1001  \n1002  \n1003  \n1004  \n1005  \n1006  \n1007  \n1008  \n1009  \n1010  \n1011  \n1012  \n1013  \n1014  \n1015  \n1016  \n1017  \n1018  \n1019  \n1020  \n1021  \n1022  \n1023  \n1024  \n1025  \n1026  \n1027  \n1028  \n1029  \n1030  \n1031  \n1032  \n1033  \n1034  \n1035  \n1036  \n1037  \n1038  \n1039  \n1040  \n1041  \n1042  \n1043  \n1044  \n1045  \n1046  \n1047  \n1048  \n1049  \n1050  \n1051  \n1052  \n1053  \n1054  \n1055  \n1056  \n1057  \n1058  \n1059  \n1060  \n1061  \n1062  \n1063  \n1064  \n1065  \n1066  \n1067  \n1068  \n1069  \n1070  \n1071  \n1072  \n1073  \n1074  \n1075  \n1076  \n1077  \n1078  \n1079  \n1080  \n1081  \n1082  \n1083  \n1084  \n1085  \n1086  \n1087  \n1088  \n1089  \n1090  \n1091  \n1092  \n1093  \n1094  \n1095  \n1096  \n1097  \n1098  \n1099  \n1100  \n1101  \n1102  \n1103  \n1104  \n1105  \n1106  \n1107  \n1108  \n1109  \n1110  \n1111  \n1112  ",
            "    /**\n     * Checks whether a property exists on the receiver, or on any of the possible receiver classes (found in the\n     * temporary type information table)\n     *\n     * @param pexp             a property expression\n     * @param readMode         if true, look for property read, else for property set\n     * @param visitor          if not null, when the property node is found, visit it with the provided visitor\n     * @return true if the property is defined in any of the possible receiver classes\n     */\n    protected boolean existsProperty(final PropertyExpression pexp, final boolean readMode, final ClassCodeVisitorSupport visitor) {\n        super.visitPropertyExpression(pexp);\n\n        String propertyName = pexp.getPropertyAsString();\n        if (propertyName == null) return false;\n\n        Expression objectExpression = pexp.getObjectExpression();\n        final ClassNode objectExpressionType = getType(objectExpression);\n\n        boolean staticOnlyAccess = isClassClassNodeWrappingConcreteType(objectExpressionType);\n        if (\"this\".equals(propertyName) && staticOnlyAccess) {\n            // Outer.this\n            ClassNode outerNode = objectExpressionType.getGenericsTypes()[0].getType();\n            ClassNode current = typeCheckingContext.getEnclosingClassNode();\n            if (!current.isStaticClass() && current instanceof InnerClassNode) {\n                InnerClassNode icn = (InnerClassNode) current;\n                if (outerNode.equals(icn.getOuterClass())) {\n                    storeType(pexp, outerNode);\n                    return true;\n                }\n            }\n        }\n\n        if (objectExpressionType.isArray() && \"length\".equals(pexp.getPropertyAsString())) {\n            storeType(pexp, int_TYPE);\n            if (visitor != null) {\n                PropertyNode node = new PropertyNode(\"length\", Opcodes.ACC_PUBLIC | Opcodes.ACC_FINAL, int_TYPE, objectExpressionType, null, null, null);\n                visitor.visitProperty(node);\n            }\n            return true;\n        }\n\n        boolean foundGetterOrSetter = false;\n        List<Receiver<String>> receivers = new LinkedList<Receiver<String>>();\n        List<Receiver<String>> owners = makeOwnerList(objectExpression);\n        addReceivers(receivers, owners, pexp.isImplicitThis());\n\n        String capName = MetaClassHelper.capitalize(propertyName);\n        boolean isAttributeExpression = pexp instanceof AttributeExpression;\n        HashSet<ClassNode> handledNodes = new HashSet<ClassNode>();\n        for (Receiver<String> receiver : receivers) {\n            ClassNode testClass = receiver.getType();\n                LinkedList<ClassNode> queue = new LinkedList<ClassNode>();\n                queue.add(testClass);\n                while (!queue.isEmpty()) {\n                    ClassNode current = queue.removeFirst();\n                    if (handledNodes.contains(current)) continue;\n                    handledNodes.add(current);\n                    Set<ClassNode> allInterfaces = current.getAllInterfaces();\n                    for (ClassNode intf : allInterfaces) {\n                        //TODO: apply right generics here!\n                        queue.add(GenericsUtils.parameterizeType(current, intf));\n                    }\n\n                    // in case of a lookup on Class we look for instance methods on Class\n                    // as well, since in case of a static property access we have the class\n                    // itself in the list of receivers already;\n                    boolean staticOnly;\n                    if (isClassClassNodeWrappingConcreteType(current)) {\n                        staticOnly = false;\n                    } else {\n                        staticOnly = staticOnlyAccess;\n                    }\n\n                    FieldNode field = current.getDeclaredField(propertyName);\n                    field  = allowStaticAccessToMember(field, staticOnly);\n                    if (storeField(field, isAttributeExpression, pexp, current, visitor, receiver.getData())) return true;\n\n                    PropertyNode propertyNode = current.getProperty(propertyName);\n                    propertyNode = allowStaticAccessToMember(propertyNode, staticOnly);\n                    if (storeProperty(propertyNode, pexp, current, visitor, receiver.getData())) return true;\n\n                    boolean isThisExpression = objectExpression instanceof VariableExpression && \n                                                ((VariableExpression)objectExpression).isThisExpression();\n                    if (storeField(field, isThisExpression, pexp, receiver.getType(), visitor, receiver.getData())) return true;\n\n                    MethodNode getter = current.getGetterMethod(\"get\" + capName);\n                    getter = allowStaticAccessToMember(getter, staticOnly);\n                    if (getter == null) getter = current.getGetterMethod(\"is\" + capName);\n                    getter = allowStaticAccessToMember(getter, staticOnly);\n                    MethodNode setter = current.getSetterMethod(\"set\" + capName, false);\n                    setter = allowStaticAccessToMember(setter, staticOnly);\n\n                    // TODO: remove this visit\n                    // need to visit even if we only look for a setter for compatibility\n                    if (visitor != null && getter!=null) visitor.visitMethod(getter);\n\n                    if (readMode) {\n                        if (getter!=null) {\n                            ClassNode cn = inferReturnTypeGenerics(current, getter, ArgumentListExpression.EMPTY_ARGUMENTS);\n                            storeInferredTypeForPropertyExpression(pexp, cn);\n                            pexp.removeNodeMetaData(StaticTypesMarker.READONLY_PROPERTY);\n                            String delegationData = receiver.getData();\n                            if (delegationData!=null) pexp.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER, delegationData);\n                            return true;\n                        }\n                    } else {\n                        if (setter != null) {\n                            // TODO: remove this visit\n                            // need to visit even if we only look for a setter for compatibility\n                            if (visitor != null && field!=null) visitor.visitField(field);\n\n                            //TODO: apply generics on parameter[0]? \n                            storeType(pexp, setter.getParameters()[0].getType());\n                            SetterInfo info = new SetterInfo(current, setter);\n                            BinaryExpression enclosingBinaryExpression = typeCheckingContext.getEnclosingBinaryExpression();\n                            if (enclosingBinaryExpression!=null) putSetterInfo(enclosingBinaryExpression.getLeftExpression(), info);\n                            String delegationData = receiver.getData();\n                            if (delegationData!=null) pexp.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER, delegationData);\n                            return true;\n                        } else if (getter!=null) {\n                            pexp.putNodeMetaData(StaticTypesMarker.READONLY_PROPERTY, true);\n                        }\n                    }\n                    foundGetterOrSetter = foundGetterOrSetter || setter!=null || getter!=null;\n\n                    if (storeField(field, true, pexp, current, visitor, receiver.getData())) return true;\n                    // if the property expression is an attribute expression (o.@attr), then\n                    // we stop now, otherwise we must check the parent class\n                    if (/*!isAttributeExpression && */current.getSuperClass() != null) {\n                        queue.add(current.getUnresolvedSuperClass());\n                    }\n                }\n                // GROOVY-5568, the property may be defined by DGM\n                List<MethodNode> methods = findDGMMethodsByNameAndArguments(getTransformLoader(), testClass, \"get\" + capName, ClassNode.EMPTY_ARRAY);\n                if (!methods.isEmpty()) {\n                    List<MethodNode> methodNodes = chooseBestMethod(testClass, methods, ClassNode.EMPTY_ARRAY);\n                    if (methodNodes.size() == 1) {\n                        MethodNode getter = methodNodes.get(0);\n                        if (visitor != null) {\n                            visitor.visitMethod(getter);\n                        }\n                        ClassNode cn = inferReturnTypeGenerics(testClass, getter, ArgumentListExpression.EMPTY_ARGUMENTS);\n                        storeInferredTypeForPropertyExpression(pexp, cn);\n\n                        return true;\n                    }\n                }\n        }\n\n        for (Receiver<String> receiver : receivers) {\n            ClassNode testClass = receiver.getType();\n            ClassNode propertyType = getTypeForMapPropertyExpression(testClass, objectExpressionType, pexp);\n            if (propertyType==null) propertyType = getTypeForListPropertyExpression(testClass, objectExpressionType, pexp);\n            if (propertyType==null) propertyType = getTypeForSpreadExpression(testClass, objectExpressionType, pexp);\n            if (propertyType==null) continue;\n            if (visitor!=null) {\n                // todo : type inference on maps and lists, if possible\n                PropertyNode node = new PropertyNode(propertyName, Opcodes.ACC_PUBLIC, propertyType, objectExpressionType, null, null, null);\n                visitor.visitProperty(node);\n            }\n            storeType(pexp, propertyType);\n            String delegationData = receiver.getData();\n            if (delegationData!=null) pexp.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER, delegationData);\n            return true;\n        }\n        return foundGetterOrSetter;\n    }"
        ]
    ],
    "36a5a8dfdd4827663961cbca6b5dce2cc0a918b6": [
        [
            "DefaultStrategy::buildClass(BuilderASTTransformation,ClassNode,AnnotationNode)",
            " 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197 -\n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  ",
            "    public void buildClass(BuilderASTTransformation transform, ClassNode buildee, AnnotationNode anno) {\n        List<String> excludes = new ArrayList<String>();\n        List<String> includes = new ArrayList<String>();\n        if (!getIncludeExclude(transform, anno, buildee, excludes, includes)) return;\n        String prefix = transform.getMemberStringValue(anno, \"prefix\", \"\");\n        if (unsupportedAttribute(transform, anno, \"forClass\")) return;\n        final int visibility = ACC_PUBLIC | ACC_STATIC | ACC_SYNTHETIC;\n        String builderClassName = transform.getMemberStringValue(anno, \"builderClassName\", buildee.getName() + \"Builder\");\n        final String fullName = buildee.getName() + \"$\" + builderClassName;\n        ClassNode builder = new InnerClassNode(buildee, fullName, visibility, ClassHelper.OBJECT_TYPE);\n        buildee.getModule().addClass(builder);\n        buildee.addMethod(createBuilderMethod(transform, anno, builder));\n        List<FieldNode> fields = getInstancePropertyFields(buildee);\n        List<FieldNode> filteredFields = selectFieldsFromExistingClass(fields, includes, excludes);\n        for (FieldNode fieldNode : filteredFields) {\n            builder.addField(createFieldCopy(buildee, fieldNode));\n            builder.addMethod(createBuilderMethodForProp(builder, new PropertyInfo(fieldNode.getName(), fieldNode.getType()), prefix));\n        }\n        builder.addMethod(createBuildMethod(transform, anno, buildee, filteredFields));\n    }",
            " 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196 +\n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  ",
            "    public void buildClass(BuilderASTTransformation transform, ClassNode buildee, AnnotationNode anno) {\n        List<String> excludes = new ArrayList<String>();\n        List<String> includes = new ArrayList<String>();\n        if (!getIncludeExclude(transform, anno, buildee, excludes, includes)) return;\n        String prefix = transform.getMemberStringValue(anno, \"prefix\", \"\");\n        if (unsupportedAttribute(transform, anno, \"forClass\")) return;\n        final int visibility = ACC_PUBLIC | ACC_STATIC;\n        String builderClassName = transform.getMemberStringValue(anno, \"builderClassName\", buildee.getName() + \"Builder\");\n        final String fullName = buildee.getName() + \"$\" + builderClassName;\n        ClassNode builder = new InnerClassNode(buildee, fullName, visibility, ClassHelper.OBJECT_TYPE);\n        buildee.getModule().addClass(builder);\n        buildee.addMethod(createBuilderMethod(transform, anno, builder));\n        List<FieldNode> fields = getInstancePropertyFields(buildee);\n        List<FieldNode> filteredFields = selectFieldsFromExistingClass(fields, includes, excludes);\n        for (FieldNode fieldNode : filteredFields) {\n            builder.addField(createFieldCopy(buildee, fieldNode));\n            builder.addMethod(createBuilderMethodForProp(builder, new PropertyInfo(fieldNode.getName(), fieldNode.getType()), prefix));\n        }\n        builder.addMethod(createBuildMethod(transform, anno, buildee, filteredFields));\n    }"
        ],
        [
            "DefaultStrategy::buildMethod(BuilderASTTransformation,MethodNode,AnnotationNode)",
            " 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177 -\n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  ",
            "    public void buildMethod(BuilderASTTransformation transform, MethodNode mNode, AnnotationNode anno) {\n        if (transform.getMemberValue(anno, \"includes\") != null || transform.getMemberValue(anno, \"includes\") != null) {\n            transform.addError(\"Error during \" + BuilderASTTransformation.MY_TYPE_NAME +\n                    \" processing: includes/excludes only allowed on classes\", anno);\n        }\n        String prefix = transform.getMemberStringValue(anno, \"prefix\", \"\");\n        if (unsupportedAttribute(transform, anno, \"forClass\")) return;\n        final int visibility = ACC_PUBLIC | ACC_STATIC | ACC_SYNTHETIC;\n        ClassNode buildee = mNode.getDeclaringClass();\n        String builderClassName = transform.getMemberStringValue(anno, \"builderClassName\", buildee.getName() + \"Builder\");\n        final String fullName = buildee.getName() + \"$\" + builderClassName;\n        ClassNode builder = new InnerClassNode(buildee, fullName, visibility, ClassHelper.OBJECT_TYPE);\n        buildee.getModule().addClass(builder);\n        buildee.addMethod(createBuilderMethod(transform, anno, builder));\n        for (Parameter parameter : mNode.getParameters()) {\n            builder.addField(createFieldCopy(buildee, parameter));\n            builder.addMethod(createBuilderMethodForProp(builder, new PropertyInfo(parameter.getName(), parameter.getType()), prefix));\n        }\n        builder.addMethod(createBuildMethodForMethod(transform, anno, buildee, mNode, mNode.getParameters()));\n    }",
            " 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176 +\n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  ",
            "    public void buildMethod(BuilderASTTransformation transform, MethodNode mNode, AnnotationNode anno) {\n        if (transform.getMemberValue(anno, \"includes\") != null || transform.getMemberValue(anno, \"includes\") != null) {\n            transform.addError(\"Error during \" + BuilderASTTransformation.MY_TYPE_NAME +\n                    \" processing: includes/excludes only allowed on classes\", anno);\n        }\n        String prefix = transform.getMemberStringValue(anno, \"prefix\", \"\");\n        if (unsupportedAttribute(transform, anno, \"forClass\")) return;\n        final int visibility = ACC_PUBLIC | ACC_STATIC;\n        ClassNode buildee = mNode.getDeclaringClass();\n        String builderClassName = transform.getMemberStringValue(anno, \"builderClassName\", buildee.getName() + \"Builder\");\n        final String fullName = buildee.getName() + \"$\" + builderClassName;\n        ClassNode builder = new InnerClassNode(buildee, fullName, visibility, ClassHelper.OBJECT_TYPE);\n        buildee.getModule().addClass(builder);\n        buildee.addMethod(createBuilderMethod(transform, anno, builder));\n        for (Parameter parameter : mNode.getParameters()) {\n            builder.addField(createFieldCopy(buildee, parameter));\n            builder.addMethod(createBuilderMethodForProp(builder, new PropertyInfo(parameter.getName(), parameter.getType()), prefix));\n        }\n        builder.addMethod(createBuildMethodForMethod(transform, anno, buildee, mNode, mNode.getParameters()));\n    }"
        ],
        [
            "InitializerStrategy::createBuildeeConstructors(BuilderASTTransformation,ClassNode,ClassNode,List)",
            " 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201 -\n 202 -\n 203  \n 204  \n 205  \n 206  \n 207  \n 208  ",
            "    private static void createBuildeeConstructors(BuilderASTTransformation transform, ClassNode buildee, ClassNode builder, List<FieldNode> fields) {\n        ClassNode paramType = makeClassSafeWithGenerics(builder, setGenTypes(fields.size()));\n        List<Expression> argsList = new ArrayList<Expression>();\n        for (FieldNode fieldNode : fields) {\n            argsList.add(propX(varX(\"initializer\"), fieldNode.getName()));\n        }\n        Expression args = new ArgumentListExpression(argsList);\n        buildee.addConstructor(ACC_PUBLIC | ACC_SYNTHETIC, params(param(paramType, \"initializer\")), NO_EXCEPTIONS, block(ctorThisS(args)));\n        if (!transform.hasAnnotation(buildee, ImmutableASTTransformation.MY_TYPE)) {\n            final BlockStatement body = new BlockStatement();\n            body.addStatement(ctorSuperS());\n            initializeFields(fields, body);\n            buildee.addConstructor(ACC_PRIVATE | ACC_SYNTHETIC, getParams(fields), NO_EXCEPTIONS, body);\n        }\n    }",
            " 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202 +\n 203 +\n 204 +\n 205 +\n 206  \n 207  \n 208  \n 209  \n 210  \n 211  ",
            "    private static void createBuildeeConstructors(BuilderASTTransformation transform, ClassNode buildee, ClassNode builder, List<FieldNode> fields) {\n        ClassNode paramType = makeClassSafeWithGenerics(builder, setGenTypes(fields.size()));\n        List<Expression> argsList = new ArrayList<Expression>();\n        for (FieldNode fieldNode : fields) {\n            argsList.add(propX(varX(\"initializer\"), fieldNode.getName()));\n        }\n        Expression args = new ArgumentListExpression(argsList);\n        ConstructorNode initializer = buildee.addConstructor(ACC_PUBLIC, params(param(paramType, \"initializer\")), NO_EXCEPTIONS, block(ctorThisS(args)));\n        if (transform.hasAnnotation(buildee, ImmutableASTTransformation.MY_TYPE)) {\n            initializer.putNodeMetaData(ImmutableASTTransformation.IMMUTABLE_SAFE_FLAG, Boolean.TRUE);\n        } else {\n            final BlockStatement body = new BlockStatement();\n            body.addStatement(ctorSuperS());\n            initializeFields(fields, body);\n            buildee.addConstructor(ACC_PRIVATE | ACC_SYNTHETIC, getParams(fields), NO_EXCEPTIONS, body);\n        }\n    }"
        ],
        [
            "InitializerStrategy::createInnerHelperClass(ClassNode,String,List)",
            " 149  \n 150  \n 151 -\n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  ",
            "    private ClassNode createInnerHelperClass(ClassNode buildee, String builderClassName, List<FieldNode> fields) {\n        final String fullName = buildee.getName() + \"$\" + builderClassName;\n        final int visibility = ACC_PUBLIC | ACC_STATIC | ACC_SYNTHETIC;\n        ClassNode builder = new InnerClassNode(buildee, fullName, visibility, ClassHelper.OBJECT_TYPE);\n        GenericsType[] gtypes = new GenericsType[fields.size()];\n        for (int i = 0; i < gtypes.length; i++) {\n            gtypes[i] = makePlaceholder(i);\n        }\n        builder.setGenericsTypes(gtypes);\n        return builder;\n    }",
            " 150  \n 151  \n 152 +\n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  ",
            "    private ClassNode createInnerHelperClass(ClassNode buildee, String builderClassName, List<FieldNode> fields) {\n        final String fullName = buildee.getName() + \"$\" + builderClassName;\n        final int visibility = ACC_PUBLIC | ACC_STATIC;\n        ClassNode builder = new InnerClassNode(buildee, fullName, visibility, ClassHelper.OBJECT_TYPE);\n        GenericsType[] gtypes = new GenericsType[fields.size()];\n        for (int i = 0; i < gtypes.length; i++) {\n            gtypes[i] = makePlaceholder(i);\n        }\n        builder.setGenericsTypes(gtypes);\n        return builder;\n    }"
        ],
        [
            "DefaultStrategy::createBuilderMethod(BuilderASTTransformation,AnnotationNode,ClassNode)",
            " 226  \n 227  \n 228  \n 229  \n 230 -\n 231  \n 232  ",
            "    private static MethodNode createBuilderMethod(BuilderASTTransformation transform, AnnotationNode anno, ClassNode builder) {\n        String builderMethodName = transform.getMemberStringValue(anno, \"builderMethodName\", \"builder\");\n        final BlockStatement body = new BlockStatement();\n        body.addStatement(returnS(ctorX(builder)));\n        final int visibility = ACC_PUBLIC | ACC_STATIC | ACC_SYNTHETIC;\n        return new MethodNode(builderMethodName, visibility, builder, NO_PARAMS, NO_EXCEPTIONS, body);\n    }",
            " 225  \n 226  \n 227  \n 228  \n 229 +\n 230  \n 231  ",
            "    private static MethodNode createBuilderMethod(BuilderASTTransformation transform, AnnotationNode anno, ClassNode builder) {\n        String builderMethodName = transform.getMemberStringValue(anno, \"builderMethodName\", \"builder\");\n        final BlockStatement body = new BlockStatement();\n        body.addStatement(returnS(ctorX(builder)));\n        final int visibility = ACC_PUBLIC | ACC_STATIC;\n        return new MethodNode(builderMethodName, visibility, builder, NO_PARAMS, NO_EXCEPTIONS, body);\n    }"
        ],
        [
            "InitializerStrategy::createBuilderMethod(BuilderASTTransformation,AnnotationNode,String,ClassNode,int)",
            " 161  \n 162  \n 163  \n 164  \n 165 -\n 166  \n 167  \n 168  ",
            "    private static MethodNode createBuilderMethod(BuilderASTTransformation transform, AnnotationNode anno, String buildMethodName, ClassNode builder, int numFields) {\n        String builderMethodName = transform.getMemberStringValue(anno, \"builderMethodName\", \"createInitializer\");\n        final BlockStatement body = new BlockStatement();\n        body.addStatement(returnS(callX(builder, buildMethodName)));\n        final int visibility = ACC_PUBLIC | ACC_STATIC | ACC_SYNTHETIC;\n        ClassNode returnType = makeClassSafeWithGenerics(builder, unsetGenTypes(numFields));\n        return new MethodNode(builderMethodName, visibility, returnType, NO_PARAMS, NO_EXCEPTIONS, body);\n    }",
            " 162  \n 163  \n 164  \n 165  \n 166 +\n 167  \n 168  \n 169  ",
            "    private static MethodNode createBuilderMethod(BuilderASTTransformation transform, AnnotationNode anno, String buildMethodName, ClassNode builder, int numFields) {\n        String builderMethodName = transform.getMemberStringValue(anno, \"builderMethodName\", \"createInitializer\");\n        final BlockStatement body = new BlockStatement();\n        body.addStatement(returnS(callX(builder, buildMethodName)));\n        final int visibility = ACC_PUBLIC | ACC_STATIC;\n        ClassNode returnType = makeClassSafeWithGenerics(builder, unsetGenTypes(numFields));\n        return new MethodNode(builderMethodName, visibility, returnType, NO_PARAMS, NO_EXCEPTIONS, body);\n    }"
        ],
        [
            "ImmutableASTTransformation::validateConstructors(ClassNode)",
            " 415  \n 416  \n 417  \n 418 -\n 419 -\n 420  \n 421  \n 422  \n 423  \n 424  \n 425  \n 426  \n 427  ",
            "    private boolean validateConstructors(ClassNode cNode) {\n        List<ConstructorNode> declaredConstructors = cNode.getDeclaredConstructors();\n        for (ConstructorNode constructorNode : declaredConstructors) {\n            // allow Synthetic constructors added by other transforms\n            if ((constructorNode.getModifiers() & ACC_SYNTHETIC) != 0) {\n                continue;\n            }\n            // TODO: allow constructors which only call provided constructor?\n            addError(\"Explicit constructors not allowed for \" + MY_TYPE_NAME + \" class: \" + cNode.getNameWithoutPackage(), constructorNode);\n            return false;\n        }\n        return true;\n    }",
            " 416  \n 417  \n 418  \n 419 +\n 420 +\n 421 +\n 422  \n 423  \n 424  \n 425  \n 426  \n 427  \n 428  \n 429  ",
            "    private boolean validateConstructors(ClassNode cNode) {\n        List<ConstructorNode> declaredConstructors = cNode.getDeclaredConstructors();\n        for (ConstructorNode constructorNode : declaredConstructors) {\n            // allow constructors added by other transforms if flagged as safe\n            Object nodeMetaData = constructorNode.getNodeMetaData(IMMUTABLE_SAFE_FLAG);\n            if (nodeMetaData != null && ((Boolean)nodeMetaData)) {\n                continue;\n            }\n            // TODO: allow constructors which only call provided constructor?\n            addError(\"Explicit constructors not allowed for \" + MY_TYPE_NAME + \" class: \" + cNode.getNameWithoutPackage(), constructorNode);\n            return false;\n        }\n        return true;\n    }"
        ]
    ],
    "02e9f85250015563ad21198794f60c7ee412012a": [
        [
            "StaticTypeCheckingSupport::getMaximumInterfaceDistance(ClassNode,ClassNode)",
            " 833  \n 834  \n 835  \n 836  \n 837  \n 838  \n 839  \n 840 -\n 841  \n 842  \n 843  \n 844  \n 845  \n 846 -\n 847  \n 848  \n 849  \n 850  \n 851  \n 852  \n 853  ",
            "    private static int getMaximumInterfaceDistance(ClassNode c, ClassNode interfaceClass) {\n        // -1 means a mismatch\n        if (c == null) return -1;\n        // 0 means a direct match\n        if (c.equals(interfaceClass)) return 0;\n        ClassNode[] interfaces = c.getInterfaces();\n        int max = -1;\n        for (ClassNode anInterface : interfaces) {\n            int sub = getMaximumInterfaceDistance(anInterface, interfaceClass);\n            // we need to keep the -1 to track the mismatch, a +1\n            // by any means could let it look like a direct match\n            // we want to add one, because there is an interface between\n            // the interface we search for and the interface we are in.\n            if (sub != -1) sub++;\n            // we are interested in the longest path only\n            max = Math.max(max, sub);\n        }\n        // we do not add one for super classes, only for interfaces\n        int superClassMax = getMaximumInterfaceDistance(c.getSuperClass(), interfaceClass);\n        return Math.max(max, superClassMax);\n    }",
            " 833  \n 834  \n 835  \n 836  \n 837  \n 838  \n 839  \n 840 +\n 841 +\n 842  \n 843  \n 844  \n 845  \n 846  \n 847 +\n 848 +\n 849 +\n 850  \n 851  \n 852  \n 853  \n 854  \n 855  \n 856  ",
            "    private static int getMaximumInterfaceDistance(ClassNode c, ClassNode interfaceClass) {\n        // -1 means a mismatch\n        if (c == null) return -1;\n        // 0 means a direct match\n        if (c.equals(interfaceClass)) return 0;\n        ClassNode[] interfaces = c.getInterfaces();\n        int max = -1;\n        for (int i = 0; i < interfaces.length; i++) {\n            final ClassNode anInterface = interfaces[i];\n            int sub = getMaximumInterfaceDistance(anInterface, interfaceClass);\n            // we need to keep the -1 to track the mismatch, a +1\n            // by any means could let it look like a direct match\n            // we want to add one, because there is an interface between\n            // the interface we search for and the interface we are in.\n            if (sub != -1) {\n                sub+=(i+1); // GROOVY-6970: Make sure we can choose between equivalent methods\n            }\n            // we are interested in the longest path only\n            max = Math.max(max, sub);\n        }\n        // we do not add one for super classes, only for interfaces\n        int superClassMax = getMaximumInterfaceDistance(c.getSuperClass(), interfaceClass);\n        return Math.max(max, superClassMax);\n    }"
        ],
        [
            "StaticTypeCheckingSupport::chooseBestMethod(ClassNode,Collection,ClassNode)",
            " 912  \n 913  \n 914  \n 915  \n 916  \n 917  \n 918  \n 919  \n 920  \n 921  \n 922  \n 923  \n 924  \n 925  \n 926  \n 927  \n 928  \n 929  \n 930  \n 931  \n 932  \n 933  \n 934  \n 935  \n 936  \n 937  \n 938  \n 939  \n 940  \n 941  \n 942  \n 943  \n 944  \n 945  \n 946  \n 947  \n 948  \n 949  \n 950  \n 951  \n 952  \n 953  \n 954  \n 955  \n 956  \n 957  \n 958  \n 959  \n 960  \n 961  \n 962  \n 963  \n 964  \n 965  \n 966  \n 967  \n 968  \n 969  \n 970  \n 971  \n 972  \n 973  \n 974  \n 975  \n 976  \n 977  \n 978  \n 979  \n 980  \n 981  \n 982  \n 983  \n 984  \n 985  \n 986  \n 987  \n 988  \n 989  \n 990  \n 991  \n 992  \n 993  \n 994  \n 995  \n 996  \n 997  \n 998  \n 999  \n1000  \n1001  \n1002  \n1003  \n1004  \n1005  \n1006  \n1007  \n1008  \n1009  \n1010  \n1011  \n1012  \n1013  \n1014  \n1015  \n1016  \n1017  \n1018  \n1019  \n1020  \n1021  \n1022  \n1023  \n1024  \n1025  \n1026  \n1027  \n1028  \n1029  \n1030  \n1031  \n1032  \n1033  \n1034  \n1035  \n1036  \n1037  ",
            "    /**\n     * Given a list of candidate methods, returns the one which best matches the argument types\n     *\n     * @param receiver\n     * @param methods candidate methods\n     * @param args argument types\n     * @return the list of methods which best matches the argument types. It is still possible that multiple\n     * methods match the argument types.\n     */\n    public static List<MethodNode> chooseBestMethod(final ClassNode receiver, Collection<MethodNode> methods, ClassNode... args) {\n        if (methods.isEmpty()) return Collections.emptyList();\n        if (isUsingUncheckedGenerics(receiver)) {\n            ClassNode raw = makeRawType(receiver);\n            return chooseBestMethod(raw, methods, args);\n        }\n        List<MethodNode> bestChoices = new LinkedList<MethodNode>();\n        int bestDist = Integer.MAX_VALUE;\n        Collection<MethodNode> choicesLeft = removeCovariants(methods);\n        for (MethodNode candidateNode : choicesLeft) {\n            ClassNode declaringClass = candidateNode.getDeclaringClass();\n            ClassNode actualReceiver = receiver!=null?receiver: declaringClass;\n            final ClassNode declaringClassForDistance = declaringClass;\n            final ClassNode actualReceiverForDistance = actualReceiver;\n            MethodNode safeNode = candidateNode;\n            ClassNode[] safeArgs = args;\n            boolean isExtensionMethodNode = candidateNode instanceof ExtensionMethodNode;\n            if (isExtensionMethodNode) {\n                safeArgs = new ClassNode[args.length+1];\n                System.arraycopy(args, 0, safeArgs, 1, args.length);\n                safeArgs[0] = receiver;\n                safeNode = ((ExtensionMethodNode) candidateNode).getExtensionMethodNode();\n                declaringClass = safeNode.getDeclaringClass();\n                actualReceiver = declaringClass;\n            }\n\n            // todo : corner case\n            /*\n                class B extends A {}\n\n                Animal foo(A o) {...}\n                Person foo(B i){...}\n\n                B  a = new B()\n                Person p = foo(b)\n             */\n\n            Parameter[] params = makeRawTypes(safeNode.getParameters());\n            if (params.length == safeArgs.length) {\n                int allPMatch = allParametersAndArgumentsMatch(params, safeArgs);\n                boolean firstParamMatches = true;\n                // check first parameters\n                if (safeArgs.length > 0) {\n                    Parameter[] firstParams = new Parameter[params.length - 1];\n                    System.arraycopy(params, 0, firstParams, 0, firstParams.length);\n                    firstParamMatches = allParametersAndArgumentsMatch(firstParams, safeArgs) >= 0;\n                }\n                int lastArgMatch = isVargs(params) && firstParamMatches?lastArgMatchesVarg(params, safeArgs):-1;\n                if (lastArgMatch>=0) {\n                    lastArgMatch += 256-params.length; // ensure exact matches are preferred over vargs\n                }\n                int dist = allPMatch>=0?Math.max(allPMatch, lastArgMatch):lastArgMatch;\n                if (dist>=0 && !actualReceiverForDistance.equals(declaringClassForDistance)) dist+=getDistance(actualReceiverForDistance, declaringClassForDistance);\n                if (dist>=0 && !isExtensionMethodNode) {\n                    dist++;\n                }\n                if (dist>=0 && dist<bestDist) {\n                    bestChoices.clear();\n                    bestChoices.add(candidateNode);\n                    bestDist = dist;\n                } else if (dist>=0 && dist==bestDist) {\n                    bestChoices.add(candidateNode);\n                }\n            } else if (isVargs(params)) {\n                boolean firstParamMatches = true;\n                int dist = -1;\n                // check first parameters\n                if (safeArgs.length > 0) {\n                    Parameter[] firstParams = new Parameter[params.length - 1];\n                    System.arraycopy(params, 0, firstParams, 0, firstParams.length);\n                    dist = allParametersAndArgumentsMatch(firstParams, safeArgs);\n                    firstParamMatches =  dist >= 0;\n                } else {\n                    dist = 0;\n                }\n                if (firstParamMatches) {\n                    // there are three case for vargs\n                    // (1) varg part is left out\n                    if (params.length == safeArgs.length + 1) {\n                        if (dist>=0) {\n                            dist += 256-params.length; // ensure exact matches are preferred over vargs\n                        }\n                        if (bestDist > 1+dist) {\n                            bestChoices.clear();\n                            bestChoices.add(candidateNode);\n                            bestDist = 1+dist; // 1+dist to discriminate foo(Object,String) vs foo(Object,String, Object...)\n                        }\n                    } else {\n                        // (2) last argument is put in the vargs array\n                        //      that case is handled above already\n                        // (3) there is more than one argument for the vargs array\n                        int excessArgumentsDistance = excessArgumentsMatchesVargsParameter(params, safeArgs);\n                        if (excessArgumentsDistance < 0) continue;\n                        dist += excessArgumentsDistance;\n                        if (dist >= 0 && !actualReceiverForDistance.equals(declaringClassForDistance)) dist+=getDistance(actualReceiverForDistance, declaringClassForDistance);\n                        // varargs methods must not be preferred to methods without varargs\n                        // for example :\n                        // int sum(int x) should be preferred to int sum(int x, int... y)\n                        dist+=256-params.length;\n                        if (dist>=0 && !isExtensionMethodNode) {\n                            dist++;\n                        }\n                        if (params.length < safeArgs.length && dist >= 0) {\n                            if (dist >= 0 && dist < bestDist) {\n                                bestChoices.clear();\n                                bestChoices.add(candidateNode);\n                                bestDist = dist;\n                            } else if (dist >= 0 && dist == bestDist) {\n                                bestChoices.add(candidateNode);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return bestChoices;\n    }",
            " 915  \n 916  \n 917  \n 918  \n 919  \n 920  \n 921  \n 922  \n 923  \n 924  \n 925  \n 926  \n 927  \n 928  \n 929  \n 930  \n 931  \n 932  \n 933  \n 934  \n 935  \n 936  \n 937  \n 938  \n 939  \n 940  \n 941  \n 942  \n 943  \n 944  \n 945  \n 946  \n 947  \n 948  \n 949  \n 950  \n 951  \n 952  \n 953  \n 954  \n 955  \n 956  \n 957  \n 958  \n 959  \n 960  \n 961  \n 962  \n 963  \n 964  \n 965  \n 966  \n 967  \n 968  \n 969  \n 970  \n 971  \n 972  \n 973  \n 974  \n 975  \n 976  \n 977  \n 978  \n 979  \n 980  \n 981  \n 982  \n 983  \n 984  \n 985  \n 986  \n 987  \n 988  \n 989  \n 990  \n 991  \n 992  \n 993  \n 994  \n 995  \n 996  \n 997  \n 998  \n 999  \n1000  \n1001  \n1002  \n1003  \n1004  \n1005  \n1006  \n1007  \n1008  \n1009  \n1010  \n1011  \n1012  \n1013  \n1014  \n1015  \n1016  \n1017  \n1018  \n1019  \n1020  \n1021  \n1022  \n1023  \n1024  \n1025  \n1026  \n1027  \n1028  \n1029  \n1030  \n1031  \n1032  \n1033  \n1034  \n1035  \n1036  \n1037  \n1038  \n1039 +\n1040 +\n1041 +\n1042 +\n1043 +\n1044 +\n1045 +\n1046 +\n1047 +\n1048 +\n1049 +\n1050 +\n1051  \n1052  ",
            "    /**\n     * Given a list of candidate methods, returns the one which best matches the argument types\n     *\n     * @param receiver\n     * @param methods candidate methods\n     * @param args argument types\n     * @return the list of methods which best matches the argument types. It is still possible that multiple\n     * methods match the argument types.\n     */\n    public static List<MethodNode> chooseBestMethod(final ClassNode receiver, Collection<MethodNode> methods, ClassNode... args) {\n        if (methods.isEmpty()) return Collections.emptyList();\n        if (isUsingUncheckedGenerics(receiver)) {\n            ClassNode raw = makeRawType(receiver);\n            return chooseBestMethod(raw, methods, args);\n        }\n        List<MethodNode> bestChoices = new LinkedList<MethodNode>();\n        int bestDist = Integer.MAX_VALUE;\n        Collection<MethodNode> choicesLeft = removeCovariants(methods);\n        for (MethodNode candidateNode : choicesLeft) {\n            ClassNode declaringClass = candidateNode.getDeclaringClass();\n            ClassNode actualReceiver = receiver!=null?receiver: declaringClass;\n            final ClassNode declaringClassForDistance = declaringClass;\n            final ClassNode actualReceiverForDistance = actualReceiver;\n            MethodNode safeNode = candidateNode;\n            ClassNode[] safeArgs = args;\n            boolean isExtensionMethodNode = candidateNode instanceof ExtensionMethodNode;\n            if (isExtensionMethodNode) {\n                safeArgs = new ClassNode[args.length+1];\n                System.arraycopy(args, 0, safeArgs, 1, args.length);\n                safeArgs[0] = receiver;\n                safeNode = ((ExtensionMethodNode) candidateNode).getExtensionMethodNode();\n                declaringClass = safeNode.getDeclaringClass();\n                actualReceiver = declaringClass;\n            }\n\n            // todo : corner case\n            /*\n                class B extends A {}\n\n                Animal foo(A o) {...}\n                Person foo(B i){...}\n\n                B  a = new B()\n                Person p = foo(b)\n             */\n\n            Parameter[] params = makeRawTypes(safeNode.getParameters());\n            if (params.length == safeArgs.length) {\n                int allPMatch = allParametersAndArgumentsMatch(params, safeArgs);\n                boolean firstParamMatches = true;\n                // check first parameters\n                if (safeArgs.length > 0) {\n                    Parameter[] firstParams = new Parameter[params.length - 1];\n                    System.arraycopy(params, 0, firstParams, 0, firstParams.length);\n                    firstParamMatches = allParametersAndArgumentsMatch(firstParams, safeArgs) >= 0;\n                }\n                int lastArgMatch = isVargs(params) && firstParamMatches?lastArgMatchesVarg(params, safeArgs):-1;\n                if (lastArgMatch>=0) {\n                    lastArgMatch += 256-params.length; // ensure exact matches are preferred over vargs\n                }\n                int dist = allPMatch>=0?Math.max(allPMatch, lastArgMatch):lastArgMatch;\n                if (dist>=0 && !actualReceiverForDistance.equals(declaringClassForDistance)) dist+=getDistance(actualReceiverForDistance, declaringClassForDistance);\n                if (dist>=0 && !isExtensionMethodNode) {\n                    dist++;\n                }\n                if (dist>=0 && dist<bestDist) {\n                    bestChoices.clear();\n                    bestChoices.add(candidateNode);\n                    bestDist = dist;\n                } else if (dist>=0 && dist==bestDist) {\n                    bestChoices.add(candidateNode);\n                }\n            } else if (isVargs(params)) {\n                boolean firstParamMatches = true;\n                int dist = -1;\n                // check first parameters\n                if (safeArgs.length > 0) {\n                    Parameter[] firstParams = new Parameter[params.length - 1];\n                    System.arraycopy(params, 0, firstParams, 0, firstParams.length);\n                    dist = allParametersAndArgumentsMatch(firstParams, safeArgs);\n                    firstParamMatches =  dist >= 0;\n                } else {\n                    dist = 0;\n                }\n                if (firstParamMatches) {\n                    // there are three case for vargs\n                    // (1) varg part is left out\n                    if (params.length == safeArgs.length + 1) {\n                        if (dist>=0) {\n                            dist += 256-params.length; // ensure exact matches are preferred over vargs\n                        }\n                        if (bestDist > 1+dist) {\n                            bestChoices.clear();\n                            bestChoices.add(candidateNode);\n                            bestDist = 1+dist; // 1+dist to discriminate foo(Object,String) vs foo(Object,String, Object...)\n                        }\n                    } else {\n                        // (2) last argument is put in the vargs array\n                        //      that case is handled above already\n                        // (3) there is more than one argument for the vargs array\n                        int excessArgumentsDistance = excessArgumentsMatchesVargsParameter(params, safeArgs);\n                        if (excessArgumentsDistance < 0) continue;\n                        dist += excessArgumentsDistance;\n                        if (dist >= 0 && !actualReceiverForDistance.equals(declaringClassForDistance)) dist+=getDistance(actualReceiverForDistance, declaringClassForDistance);\n                        // varargs methods must not be preferred to methods without varargs\n                        // for example :\n                        // int sum(int x) should be preferred to int sum(int x, int... y)\n                        dist+=256-params.length;\n                        if (dist>=0 && !isExtensionMethodNode) {\n                            dist++;\n                        }\n                        if (params.length < safeArgs.length && dist >= 0) {\n                            if (dist >= 0 && dist < bestDist) {\n                                bestChoices.clear();\n                                bestChoices.add(candidateNode);\n                                bestDist = dist;\n                            } else if (dist >= 0 && dist == bestDist) {\n                                bestChoices.add(candidateNode);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (bestChoices.size()>1) {\n            // GROOVY-6849: prefer extension methods in case of ambiguity\n            List<MethodNode> onlyExtensionMethods = new LinkedList<MethodNode>();\n            for (MethodNode choice : bestChoices) {\n                if (choice instanceof ExtensionMethodNode) {\n                    onlyExtensionMethods.add(choice);\n                }\n            }\n            if (onlyExtensionMethods.size()==1) {\n                return onlyExtensionMethods;\n            }\n        }\n        return bestChoices;\n    }"
        ]
    ],
    "8827857771434e4eef4a9b8bf75a4bc4d7bc64e8": [
        [
            "CharScanner::parseJsonNumber(char,int,int,int)",
            " 611  \n 612  \n 613  \n 614  \n 615  \n 616  \n 617  \n 618  \n 619  \n 620  \n 621  \n 622  \n 623  \n 624  \n 625  \n 626  \n 627  \n 628  \n 629  \n 630  \n 631  \n 632  \n 633  \n 634  \n 635  \n 636  \n 637  \n 638  \n 639  \n 640  \n 641  \n 642  \n 643  \n 644  \n 645  \n 646  \n 647  \n 648  \n 649  \n 650  \n 651  \n 652  \n 653  \n 654  \n 655  \n 656  \n 657  \n 658  \n 659  \n 660  \n 661  \n 662  \n 663  \n 664  \n 665  \n 666  \n 667  \n 668  \n 669  \n 670  \n 671  \n 672  \n 673  \n 674  \n 675  \n 676  ",
            "    public static Number parseJsonNumber(char[] buffer, int from, int max, int size[]) {\n        Number value = null;\n        boolean simple = true;\n        int digitsPastPoint = 0;\n\n        int index = from;\n\n        if (buffer[index] == '-') {\n            index++;\n        }\n\n        boolean foundDot = false;\n        for (; index < max; index++) {\n            char ch = buffer[index];\n            if (isNumberDigit(ch)) {\n                if (foundDot == true) {\n                    digitsPastPoint++;\n                }\n            } else if (ch <= 32 || isDelimiter(ch)) {\n                break;\n            } else if (ch == '.') {\n                foundDot = true;\n            } else if (ch == 'E' || ch == 'e' || ch == '-' || ch == '+') {\n                simple = false;\n            } else {\n                die(\"unexpected character \" + ch);\n            }\n        }\n\n        if (digitsPastPoint >= powersOf10.length - 1) {\n            simple = false;\n        }\n\n        final int length = index - from;\n\n        if (!foundDot && simple) {\n            if (isInteger(buffer, from, length)) {\n                value = parseIntFromTo(buffer, from, index);\n            } else {\n                value = parseLongFromTo(buffer, from, index);\n            }\n        } else if (foundDot && simple) {\n            BigDecimal lvalue;\n\n            if (length < powersOf10.length) {\n                if (isInteger(buffer, from, length)) {\n                    lvalue = new BigDecimal(parseIntFromToIgnoreDot(buffer, from, index));\n                } else {\n                    lvalue = new BigDecimal(parseLongFromToIgnoreDot(buffer, from, index));\n                }\n\n                BigDecimal power = new BigDecimal(powersOf10[digitsPastPoint]);\n                value = lvalue.divide(power);\n            } else {\n                value = new BigDecimal(new String(buffer, from, length));\n            }\n        } else {\n            value = new BigDecimal(new String(buffer, from, index - from));\n        }\n\n        if (size != null) {\n            size[0] = index;\n        }\n\n        return value;\n    }",
            " 611  \n 612  \n 613  \n 614  \n 615  \n 616  \n 617  \n 618  \n 619  \n 620  \n 621  \n 622  \n 623  \n 624  \n 625  \n 626  \n 627  \n 628  \n 629  \n 630  \n 631  \n 632 +\n 633 +\n 634 +\n 635  \n 636  \n 637  \n 638  \n 639  \n 640  \n 641  \n 642  \n 643  \n 644  \n 645  \n 646  \n 647  \n 648  \n 649  \n 650  \n 651  \n 652  \n 653  \n 654  \n 655  \n 656  \n 657  \n 658  \n 659  \n 660  \n 661  \n 662  \n 663  \n 664  \n 665  \n 666  \n 667  \n 668  \n 669  \n 670  \n 671  \n 672  \n 673  \n 674  \n 675  \n 676  \n 677  \n 678  \n 679  ",
            "    public static Number parseJsonNumber(char[] buffer, int from, int max, int size[]) {\n        Number value = null;\n        boolean simple = true;\n        int digitsPastPoint = 0;\n\n        int index = from;\n\n        if (buffer[index] == '-') {\n            index++;\n        }\n\n        boolean foundDot = false;\n        for (; index < max; index++) {\n            char ch = buffer[index];\n            if (isNumberDigit(ch)) {\n                if (foundDot == true) {\n                    digitsPastPoint++;\n                }\n            } else if (ch <= 32 || isDelimiter(ch)) {\n                break;\n            } else if (ch == '.') {\n                if (foundDot) {\n                    die(\"unexpected character \" + ch);\n                }\n                foundDot = true;\n            } else if (ch == 'E' || ch == 'e' || ch == '-' || ch == '+') {\n                simple = false;\n            } else {\n                die(\"unexpected character \" + ch);\n            }\n        }\n\n        if (digitsPastPoint >= powersOf10.length - 1) {\n            simple = false;\n        }\n\n        final int length = index - from;\n\n        if (!foundDot && simple) {\n            if (isInteger(buffer, from, length)) {\n                value = parseIntFromTo(buffer, from, index);\n            } else {\n                value = parseLongFromTo(buffer, from, index);\n            }\n        } else if (foundDot && simple) {\n            BigDecimal lvalue;\n\n            if (length < powersOf10.length) {\n                if (isInteger(buffer, from, length)) {\n                    lvalue = new BigDecimal(parseIntFromToIgnoreDot(buffer, from, index));\n                } else {\n                    lvalue = new BigDecimal(parseLongFromToIgnoreDot(buffer, from, index));\n                }\n\n                BigDecimal power = new BigDecimal(powersOf10[digitsPastPoint]);\n                value = lvalue.divide(power);\n            } else {\n                value = new BigDecimal(new String(buffer, from, length));\n            }\n        } else {\n            value = new BigDecimal(new String(buffer, from, index - from));\n        }\n\n        if (size != null) {\n            size[0] = index;\n        }\n\n        return value;\n    }"
        ],
        [
            "CharScanner::parseDouble(char,int,int)",
            " 694  \n 695  \n 696  \n 697  \n 698  \n 699  \n 700  \n 701  \n 702  \n 703  \n 704  \n 705  \n 706  \n 707  \n 708  \n 709  \n 710  \n 711  \n 712  \n 713  \n 714  \n 715  \n 716  \n 717  \n 718  \n 719  \n 720  \n 721  \n 722  \n 723  \n 724  \n 725  \n 726  \n 727  \n 728  \n 729  \n 730  \n 731  \n 732  \n 733  \n 734  \n 735  \n 736  \n 737  \n 738  \n 739  \n 740  \n 741  \n 742  \n 743  \n 744  \n 745  \n 746  \n 747  \n 748  \n 749  \n 750  \n 751  \n 752  \n 753  ",
            "    public static double parseDouble(char[] buffer, int from, int to) {\n        double value;\n        boolean simple = true;\n        int digitsPastPoint = 0;\n\n        int index = from;\n\n        if (buffer[index] == '-') {\n            index++;\n        }\n\n        boolean foundDot = false;\n        for (; index < to; index++) {\n            char ch = buffer[index];\n            if (isNumberDigit(ch)) {\n                if (foundDot == true) {\n                    digitsPastPoint++;\n                }\n            } else if (ch == '.') {\n                foundDot = true;\n            } else if (ch == 'E' || ch == 'e' || ch == '-' || ch == '+') {\n                simple = false;\n            } else {\n                die(\"unexpected character \" + ch);\n            }\n        }\n\n        if (digitsPastPoint >= powersOf10.length - 1) {\n            simple = false;\n        }\n\n        final int length = index - from;\n\n        if (!foundDot && simple) {\n            if (isInteger(buffer, from, length)) {\n                value = parseIntFromTo(buffer, from, index);\n            } else {\n                value = parseLongFromTo(buffer, from, index);\n            }\n        } else if (foundDot && simple) {\n            long lvalue;\n\n            if (length < powersOf10.length) {\n                if (isInteger(buffer, from, length)) {\n                    lvalue = parseIntFromToIgnoreDot(buffer, from, index);\n                } else {\n                    lvalue = parseLongFromToIgnoreDot(buffer, from, index);\n                }\n\n                double power = powersOf10[digitsPastPoint];\n                value = lvalue / power;\n            } else {\n                value = Double.parseDouble(new String(buffer, from, length));\n            }\n        } else {\n            value = Double.parseDouble(new String(buffer, from, index - from));\n        }\n\n        return value;\n    }",
            " 697  \n 698  \n 699  \n 700  \n 701  \n 702  \n 703  \n 704  \n 705  \n 706  \n 707  \n 708  \n 709  \n 710  \n 711  \n 712  \n 713  \n 714  \n 715  \n 716 +\n 717 +\n 718 +\n 719  \n 720  \n 721  \n 722  \n 723  \n 724  \n 725  \n 726  \n 727  \n 728  \n 729  \n 730  \n 731  \n 732  \n 733  \n 734  \n 735  \n 736  \n 737  \n 738  \n 739  \n 740  \n 741  \n 742  \n 743  \n 744  \n 745  \n 746  \n 747  \n 748  \n 749  \n 750  \n 751  \n 752  \n 753  \n 754  \n 755  \n 756  \n 757  \n 758  \n 759  ",
            "    public static double parseDouble(char[] buffer, int from, int to) {\n        double value;\n        boolean simple = true;\n        int digitsPastPoint = 0;\n\n        int index = from;\n\n        if (buffer[index] == '-') {\n            index++;\n        }\n\n        boolean foundDot = false;\n        for (; index < to; index++) {\n            char ch = buffer[index];\n            if (isNumberDigit(ch)) {\n                if (foundDot == true) {\n                    digitsPastPoint++;\n                }\n            } else if (ch == '.') {\n                if (foundDot) {\n                    die(\"unexpected character \" + ch);\n                }\n                foundDot = true;\n            } else if (ch == 'E' || ch == 'e' || ch == '-' || ch == '+') {\n                simple = false;\n            } else {\n                die(\"unexpected character \" + ch);\n            }\n        }\n\n        if (digitsPastPoint >= powersOf10.length - 1) {\n            simple = false;\n        }\n\n        final int length = index - from;\n\n        if (!foundDot && simple) {\n            if (isInteger(buffer, from, length)) {\n                value = parseIntFromTo(buffer, from, index);\n            } else {\n                value = parseLongFromTo(buffer, from, index);\n            }\n        } else if (foundDot && simple) {\n            long lvalue;\n\n            if (length < powersOf10.length) {\n                if (isInteger(buffer, from, length)) {\n                    lvalue = parseIntFromToIgnoreDot(buffer, from, index);\n                } else {\n                    lvalue = parseLongFromToIgnoreDot(buffer, from, index);\n                }\n\n                double power = powersOf10[digitsPastPoint];\n                value = lvalue / power;\n            } else {\n                value = Double.parseDouble(new String(buffer, from, length));\n            }\n        } else {\n            value = Double.parseDouble(new String(buffer, from, index - from));\n        }\n\n        return value;\n    }"
        ],
        [
            "NumberValue::bigDecimalValue()",
            " 147  \n 148 -\n 149  ",
            "    public BigDecimal bigDecimalValue() {\n        return new BigDecimal(buffer, startIndex, endIndex - startIndex);\n    }",
            " 149  \n 150 +\n 151 +\n 152 +\n 153 +\n 154 +\n 155  ",
            "    public BigDecimal bigDecimalValue() {\n        try {\n            return new BigDecimal(buffer, startIndex, endIndex - startIndex);\n        } catch (NumberFormatException e) {\n            throw new JsonException(\"unable to parse \" + new String(buffer, startIndex, endIndex - startIndex), e);\n        }\n    }"
        ]
    ],
    "569d68a9ba5ef7ff6cea683203a70646211fdee9": [
        [
            "MapConstructorASTTransformation::visit(ASTNode,SourceUnit)",
            "  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93 -\n  94 -\n  95 -\n  96 -\n  97 -\n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  ",
            "    public void visit(ASTNode[] nodes, SourceUnit source) {\n        init(nodes, source);\n        AnnotatedNode parent = (AnnotatedNode) nodes[1];\n        AnnotationNode anno = (AnnotationNode) nodes[0];\n        if (!MY_TYPE.equals(anno.getClassNode())) return;\n\n        if (parent instanceof ClassNode) {\n            ClassNode cNode = (ClassNode) parent;\n            if (!checkNotInterface(cNode, MY_TYPE_NAME)) return;\n            boolean includeFields = memberHasValue(anno, \"includeFields\", true);\n            boolean includeProperties = !memberHasValue(anno, \"includeProperties\", false);\n            boolean includeSuperProperties = memberHasValue(anno, \"includeSuperProperties\", true);\n            boolean useSetters = memberHasValue(anno, \"useSetters\", true);\n            List<String> excludes = getMemberList(anno, \"excludes\");\n            List<String> includes = getMemberList(anno, \"includes\");\n            if (hasAnnotation(cNode, CanonicalASTTransformation.MY_TYPE)) {\n                AnnotationNode canonical = cNode.getAnnotations(CanonicalASTTransformation.MY_TYPE).get(0);\n                if (excludes == null || excludes.isEmpty()) excludes = getMemberList(canonical, \"excludes\");\n                if (includes == null || includes.isEmpty()) includes = getMemberList(canonical, \"includes\");\n            }\n            if (!checkIncludeExclude(anno, excludes, includes, MY_TYPE_NAME)) return;\n            // if @Immutable is found, let it pick up options and do work so we'll skip\n            if (hasAnnotation(cNode, ImmutableASTTransformation.MY_TYPE)) return;\n\n            Expression pre = anno.getMember(\"pre\");\n            if (pre != null && !(pre instanceof ClosureExpression)) {\n                addError(\"Expected closure value for annotation parameter 'pre'. Found \" + pre, cNode);\n                return;\n            }\n            Expression post = anno.getMember(\"post\");\n            if (post != null && !(post instanceof ClosureExpression)) {\n                addError(\"Expected closure value for annotation parameter 'post'. Found \" + post, cNode);\n                return;\n            }\n\n            createConstructor(cNode, includeFields, includeProperties, includeSuperProperties, useSetters, excludes, includes, (ClosureExpression) pre, (ClosureExpression) post, source);\n            if (pre != null) {\n                anno.setMember(\"pre\", new ClosureExpression(new Parameter[0], new EmptyStatement()));\n            }\n            if (post != null) {\n                anno.setMember(\"post\", new ClosureExpression(new Parameter[0], new EmptyStatement()));\n            }\n        }\n    }",
            "  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94 +\n  95 +\n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  ",
            "    public void visit(ASTNode[] nodes, SourceUnit source) {\n        init(nodes, source);\n        AnnotatedNode parent = (AnnotatedNode) nodes[1];\n        AnnotationNode anno = (AnnotationNode) nodes[0];\n        if (!MY_TYPE.equals(anno.getClassNode())) return;\n\n        if (parent instanceof ClassNode) {\n            ClassNode cNode = (ClassNode) parent;\n            if (!checkNotInterface(cNode, MY_TYPE_NAME)) return;\n            boolean includeFields = memberHasValue(anno, \"includeFields\", true);\n            boolean includeProperties = !memberHasValue(anno, \"includeProperties\", false);\n            boolean includeSuperProperties = memberHasValue(anno, \"includeSuperProperties\", true);\n            boolean useSetters = memberHasValue(anno, \"useSetters\", true);\n            List<String> excludes = getMemberList(anno, \"excludes\");\n            List<String> includes = getMemberList(anno, \"includes\");\n            if (!checkIncludeExclude(anno, excludes, includes, MY_TYPE_NAME)) return;\n            if (!checkPropertyList(cNode, includes, \"includes\", anno, MY_TYPE_NAME, includeFields)) return;\n            if (!checkPropertyList(cNode, excludes, \"excludes\", anno, MY_TYPE_NAME, includeFields)) return;\n            // if @Immutable is found, let it pick up options and do work so we'll skip\n            if (hasAnnotation(cNode, ImmutableASTTransformation.MY_TYPE)) return;\n\n            Expression pre = anno.getMember(\"pre\");\n            if (pre != null && !(pre instanceof ClosureExpression)) {\n                addError(\"Expected closure value for annotation parameter 'pre'. Found \" + pre, cNode);\n                return;\n            }\n            Expression post = anno.getMember(\"post\");\n            if (post != null && !(post instanceof ClosureExpression)) {\n                addError(\"Expected closure value for annotation parameter 'post'. Found \" + post, cNode);\n                return;\n            }\n\n            createConstructor(cNode, includeFields, includeProperties, includeSuperProperties, useSetters, excludes, includes, (ClosureExpression) pre, (ClosureExpression) post, source);\n            if (pre != null) {\n                anno.setMember(\"pre\", new ClosureExpression(new Parameter[0], new EmptyStatement()));\n            }\n            if (post != null) {\n                anno.setMember(\"post\", new ClosureExpression(new Parameter[0], new EmptyStatement()));\n            }\n        }\n    }"
        ]
    ],
    "61e898c630aeb805616099c3b7b5abc18ff0e92e": [
        [
            "Verifier::addCovariantMethods(ClassNode)",
            "1176  \n1177  \n1178  \n1179  \n1180  \n1181  \n1182  \n1183  \n1184  \n1185  \n1186  \n1187  \n1188  \n1189  \n1190  \n1191  \n1192  \n1193  \n1194  \n1195  \n1196  \n1197  \n1198  \n1199  \n1200  \n1201  \n1202  \n1203  \n1204  \n1205  \n1206  \n1207  \n1208  \n1209  \n1210  \n1211  \n1212  \n1213 -\n1214  \n1215  \n1216  \n1217  \n1218  \n1219  \n1220  \n1221  \n1222  \n1223  \n1224  \n1225  \n1226  \n1227  ",
            "    protected void addCovariantMethods(ClassNode classNode) {\n        Map methodsToAdd = new HashMap();\n        Map genericsSpec = new HashMap();\n\n        // unimplemented abstract methods from interfaces\n        Map abstractMethods = new HashMap();\n        Map<String, MethodNode> allInterfaceMethods = new HashMap<String, MethodNode>();\n        ClassNode[] interfaces = classNode.getInterfaces();\n        for (ClassNode iface : interfaces) {\n            Map ifaceMethodsMap = iface.getDeclaredMethodsMap();\n            abstractMethods.putAll(ifaceMethodsMap);\n            allInterfaceMethods.putAll(ifaceMethodsMap);\n        }\n\n        collectSuperInterfaceMethods(classNode, allInterfaceMethods);\n\n        List<MethodNode> declaredMethods = new ArrayList<MethodNode>(classNode.getMethods());\n        // remove all static, private and package private methods\n        for (Iterator methodsIterator = declaredMethods.iterator(); methodsIterator.hasNext();) {\n            MethodNode m = (MethodNode) methodsIterator.next();\n            abstractMethods.remove(m.getTypeDescriptor());\n            if (m.isStatic() || !(m.isPublic() || m.isProtected())) {\n                methodsIterator.remove();\n            }\n            MethodNode intfMethod = allInterfaceMethods.get(m.getTypeDescriptor());\n            if (intfMethod != null && ((m.getModifiers() & ACC_SYNTHETIC) == 0)\n                    && !m.isPublic() && !m.isStaticConstructor()) {\n                throw new RuntimeParserException(\"The method \" + m.getName() +\n                        \" should be public as it implements the corresponding method from interface \" +\n                        intfMethod.getDeclaringClass(), m);\n\n            }\n        }\n\n        addCovariantMethods(classNode, declaredMethods, abstractMethods, methodsToAdd, genericsSpec);\n\n        Map<String, MethodNode> declaredMethodsMap = new HashMap<String, MethodNode>();\n        if (methodsToAdd.size() > 0) {\n            for (MethodNode mn : declaredMethods) {\n                declaredMethodsMap.put(mn.getTypeDescriptor(), mn);\n            }\n        }\n\n        for (Object o : methodsToAdd.entrySet()) {\n            Map.Entry entry = (Map.Entry) o;\n            MethodNode method = (MethodNode) entry.getValue();\n            // we skip bridge methods implemented in current class already\n            MethodNode mn = declaredMethodsMap.get(entry.getKey());\n            if (mn != null && mn.getDeclaringClass().equals(classNode)) continue;\n            addPropertyMethod(method);\n        }\n    }",
            "1176  \n1177  \n1178  \n1179  \n1180  \n1181  \n1182  \n1183  \n1184  \n1185  \n1186  \n1187  \n1188  \n1189  \n1190  \n1191  \n1192  \n1193  \n1194  \n1195  \n1196  \n1197  \n1198  \n1199  \n1200  \n1201  \n1202  \n1203  \n1204  \n1205  \n1206  \n1207  \n1208  \n1209  \n1210  \n1211  \n1212  \n1213 +\n1214  \n1215  \n1216  \n1217  \n1218  \n1219  \n1220  \n1221  \n1222  \n1223  \n1224  \n1225  \n1226  \n1227  ",
            "    protected void addCovariantMethods(ClassNode classNode) {\n        Map methodsToAdd = new HashMap();\n        Map genericsSpec = new HashMap();\n\n        // unimplemented abstract methods from interfaces\n        Map abstractMethods = new HashMap();\n        Map<String, MethodNode> allInterfaceMethods = new HashMap<String, MethodNode>();\n        ClassNode[] interfaces = classNode.getInterfaces();\n        for (ClassNode iface : interfaces) {\n            Map ifaceMethodsMap = iface.getDeclaredMethodsMap();\n            abstractMethods.putAll(ifaceMethodsMap);\n            allInterfaceMethods.putAll(ifaceMethodsMap);\n        }\n\n        collectSuperInterfaceMethods(classNode, allInterfaceMethods);\n\n        List<MethodNode> declaredMethods = new ArrayList<MethodNode>(classNode.getMethods());\n        // remove all static, private and package private methods\n        for (Iterator methodsIterator = declaredMethods.iterator(); methodsIterator.hasNext();) {\n            MethodNode m = (MethodNode) methodsIterator.next();\n            abstractMethods.remove(m.getTypeDescriptor());\n            if (m.isStatic() || !(m.isPublic() || m.isProtected())) {\n                methodsIterator.remove();\n            }\n            MethodNode intfMethod = allInterfaceMethods.get(m.getTypeDescriptor());\n            if (intfMethod != null && ((m.getModifiers() & ACC_SYNTHETIC) == 0)\n                    && !m.isPublic() && !m.isStaticConstructor()) {\n                throw new RuntimeParserException(\"The method \" + m.getName() +\n                        \" should be public as it implements the corresponding method from interface \" +\n                        intfMethod.getDeclaringClass(), m);\n\n            }\n        }\n\n        addCovariantMethods(classNode, declaredMethods, abstractMethods, methodsToAdd, genericsSpec);\n\n        Map<String, MethodNode> declaredMethodsMap = new HashMap<String, MethodNode>();\n        if (!methodsToAdd.isEmpty()) {\n            for (MethodNode mn : declaredMethods) {\n                declaredMethodsMap.put(mn.getTypeDescriptor(), mn);\n            }\n        }\n\n        for (Object o : methodsToAdd.entrySet()) {\n            Map.Entry entry = (Map.Entry) o;\n            MethodNode method = (MethodNode) entry.getValue();\n            // we skip bridge methods implemented in current class already\n            MethodNode mn = declaredMethodsMap.get(entry.getKey());\n            if (mn != null && mn.getDeclaringClass().equals(classNode)) continue;\n            addPropertyMethod(method);\n        }\n    }"
        ],
        [
            "ErrorCollector::write(PrintWriter,Janitor,List,String)",
            " 318  \n 319 -\n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  ",
            "    private void write(PrintWriter writer, Janitor janitor, List messages, String txt) {\n        if (messages==null || messages.size()==0) return;\n        Iterator iterator = messages.iterator();\n        while (iterator.hasNext()) {\n            Message message = (Message) iterator.next();\n            message.write(writer, janitor);\n            \n            if (configuration.getDebug() && (message instanceof SyntaxErrorMessage)){\n                SyntaxErrorMessage sem = (SyntaxErrorMessage) message;\n                sem.getCause().printStackTrace(writer);\n            } \n            writer.println();\n        }\n\n        writer.print(messages.size());\n        writer.print(\" \"+txt);\n        if (messages.size()>1) writer.print(\"s\");\n        writer.println();\n    }",
            " 318  \n 319 +\n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  ",
            "    private void write(PrintWriter writer, Janitor janitor, List messages, String txt) {\n        if (messages==null || messages.isEmpty()) return;\n        Iterator iterator = messages.iterator();\n        while (iterator.hasNext()) {\n            Message message = (Message) iterator.next();\n            message.write(writer, janitor);\n            \n            if (configuration.getDebug() && (message instanceof SyntaxErrorMessage)){\n                SyntaxErrorMessage sem = (SyntaxErrorMessage) message;\n                sem.getCause().printStackTrace(writer);\n            } \n            writer.println();\n        }\n\n        writer.print(messages.size());\n        writer.print(\" \"+txt);\n        if (messages.size()>1) writer.print(\"s\");\n        writer.println();\n    }"
        ],
        [
            "EnumVisitor::addInit(ClassNode,FieldNode,FieldNode,FieldNode,boolean)",
            " 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344  \n 345  \n 346  \n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364 -\n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  ",
            "    private void addInit(ClassNode enumClass, FieldNode minValue,\r\n                         FieldNode maxValue, FieldNode values,\r\n                         boolean isAic) {\r\n        // constructor helper\r\n        // This method is used instead of calling the constructor as\r\n        // calling the constructor may require a table with MetaClass\r\n        // selecting the constructor for each enum value. So instead we\r\n        // use this method to have a central point for constructor selection\r\n        // and only one table. The whole construction is needed because \r\n        // Reflection forbids access to the enum constructor.\r\n        // code:\r\n        // def $INIT(Object[] para) {\r\n        //  return this(*para)\r\n        // }\r\n        ClassNode enumRef = enumClass.getPlainNodeReference();\r\n        Parameter[] parameter = new Parameter[]{new Parameter(ClassHelper.OBJECT_TYPE.makeArray(), \"para\")};\r\n        MethodNode initMethod = new MethodNode(\"$INIT\", PUBLIC_FS | Opcodes.ACC_SYNTHETIC, enumRef, parameter, ClassNode.EMPTY_ARRAY, null);\r\n        initMethod.setSynthetic(true);\r\n        ConstructorCallExpression cce = new ConstructorCallExpression(\r\n                ClassNode.THIS,\r\n                new ArgumentListExpression(\r\n                        new SpreadExpression(new VariableExpression(\"para\"))\r\n                )\r\n        );\r\n        BlockStatement code = new BlockStatement();\r\n        code.addStatement(new ReturnStatement(cce));\r\n        initMethod.setCode(code);\r\n        enumClass.addMethod(initMethod);\r\n\r\n        // static init\r\n        List<FieldNode> fields = enumClass.getFields();\r\n        List<Expression> arrayInit = new ArrayList<Expression>();\r\n        int value = -1;\r\n        Token assign = Token.newSymbol(Types.ASSIGN, -1, -1);\r\n        List<Statement> block = new ArrayList<Statement>();\r\n        FieldNode tempMin = null;\r\n        FieldNode tempMax = null;\r\n        for (FieldNode field : fields) {\r\n            if ((field.getModifiers() & Opcodes.ACC_ENUM) == 0) continue;\r\n            value++;\r\n            if (tempMin == null) tempMin = field;\r\n            tempMax = field;\r\n\r\n            ClassNode enumBase = enumClass;\r\n            ArgumentListExpression args = new ArgumentListExpression();\r\n            args.addExpression(new ConstantExpression(field.getName()));\r\n            args.addExpression(new ConstantExpression(value));\r\n            if (field.getInitialExpression() == null) {\r\n                if ((enumClass.getModifiers() & Opcodes.ACC_ABSTRACT) != 0) {\r\n                    addError(field, \"The enum constant \" + field.getName() + \" must override abstract methods from \" + enumBase.getName() + \".\");\r\n                    continue;\r\n                }\r\n            } else {\r\n                ListExpression oldArgs = (ListExpression) field.getInitialExpression();\r\n                List<MapEntryExpression> savedMapEntries = new ArrayList<MapEntryExpression>();\r\n                for (Expression exp : oldArgs.getExpressions()) {\r\n                    if (exp instanceof MapEntryExpression) {\r\n                        savedMapEntries.add((MapEntryExpression) exp);\r\n                        continue;\r\n                    }\r\n\r\n                    InnerClassNode inner = null;\r\n                    if (exp instanceof ClassExpression) {\r\n                        ClassExpression clazzExp = (ClassExpression) exp;\r\n                        ClassNode ref = clazzExp.getType();\r\n                        if (ref instanceof EnumConstantClassNode) {\r\n                            inner = (InnerClassNode) ref;\r\n                        }\r\n                    }\r\n                    if (inner != null) {\r\n                        List<MethodNode> baseMethods = enumBase.getMethods();\r\n                        for (MethodNode methodNode : baseMethods) {\r\n                            if (!methodNode.isAbstract()) continue;\r\n                            MethodNode enumConstMethod = inner.getMethod(methodNode.getName(), methodNode.getParameters());\r\n                            if (enumConstMethod == null || (enumConstMethod.getModifiers() & Opcodes.ACC_ABSTRACT) != 0) {\r\n                                addError(field, \"Can't have an abstract method in enum constant \" + field.getName() + \". Implement method '\" + methodNode.getTypeDescriptor() + \"'.\");\r\n                            }\r\n                        }\r\n                        if (inner.getVariableScope() == null) {\r\n                            enumBase = inner;\r\n                            /*\r\n                             * GROOVY-3985: Remove the final modifier from $INIT method in this case\r\n                             * so that subclasses of enum generated for enum constants (aic) can provide\r\n                             * their own $INIT method\r\n                             */\r\n                            initMethod.setModifiers(initMethod.getModifiers() & ~Opcodes.ACC_FINAL);\r\n                            continue;\r\n                        }\r\n                    }\r\n                    args.addExpression(exp);\r\n                }\r\n                if (savedMapEntries.size() > 0) {\r\n                    args.getExpressions().add(2, new MapExpression(savedMapEntries));\r\n                }\r\n            }\r\n            field.setInitialValueExpression(null);\r\n            block.add(\r\n                    new ExpressionStatement(\r\n                            new BinaryExpression(\r\n                                    new FieldExpression(field),\r\n                                    assign,\r\n                                    new StaticMethodCallExpression(enumBase, \"$INIT\", args)\r\n                            )\r\n                    )\r\n            );\r\n            arrayInit.add(new FieldExpression(field));\r\n        }\r\n\r\n        if (!isAic) {\r\n            if (tempMin != null) {\r\n                block.add(\r\n                        new ExpressionStatement(\r\n                                new BinaryExpression(\r\n                                        new FieldExpression(minValue),\r\n                                        assign,\r\n                                        new FieldExpression(tempMin)\r\n                                )\r\n                        )\r\n                );\r\n                block.add(\r\n                        new ExpressionStatement(\r\n                                new BinaryExpression(\r\n                                        new FieldExpression(maxValue),\r\n                                        assign,\r\n                                        new FieldExpression(tempMax)\r\n                                )\r\n                        )\r\n                );\r\n                enumClass.addField(minValue);\r\n                enumClass.addField(maxValue);\r\n            }\r\n\r\n            block.add(\r\n                    new ExpressionStatement(\r\n                            new BinaryExpression(new FieldExpression(values), assign, new ArrayExpression(enumClass, arrayInit))\r\n                    )\r\n            );\r\n            enumClass.addField(values);\r\n        }\r\n        enumClass.addStaticInitializerStatements(block, true);\r\n    }\r",
            " 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344  \n 345  \n 346  \n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364 +\n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  ",
            "    private void addInit(ClassNode enumClass, FieldNode minValue,\r\n                         FieldNode maxValue, FieldNode values,\r\n                         boolean isAic) {\r\n        // constructor helper\r\n        // This method is used instead of calling the constructor as\r\n        // calling the constructor may require a table with MetaClass\r\n        // selecting the constructor for each enum value. So instead we\r\n        // use this method to have a central point for constructor selection\r\n        // and only one table. The whole construction is needed because \r\n        // Reflection forbids access to the enum constructor.\r\n        // code:\r\n        // def $INIT(Object[] para) {\r\n        //  return this(*para)\r\n        // }\r\n        ClassNode enumRef = enumClass.getPlainNodeReference();\r\n        Parameter[] parameter = new Parameter[]{new Parameter(ClassHelper.OBJECT_TYPE.makeArray(), \"para\")};\r\n        MethodNode initMethod = new MethodNode(\"$INIT\", PUBLIC_FS | Opcodes.ACC_SYNTHETIC, enumRef, parameter, ClassNode.EMPTY_ARRAY, null);\r\n        initMethod.setSynthetic(true);\r\n        ConstructorCallExpression cce = new ConstructorCallExpression(\r\n                ClassNode.THIS,\r\n                new ArgumentListExpression(\r\n                        new SpreadExpression(new VariableExpression(\"para\"))\r\n                )\r\n        );\r\n        BlockStatement code = new BlockStatement();\r\n        code.addStatement(new ReturnStatement(cce));\r\n        initMethod.setCode(code);\r\n        enumClass.addMethod(initMethod);\r\n\r\n        // static init\r\n        List<FieldNode> fields = enumClass.getFields();\r\n        List<Expression> arrayInit = new ArrayList<Expression>();\r\n        int value = -1;\r\n        Token assign = Token.newSymbol(Types.ASSIGN, -1, -1);\r\n        List<Statement> block = new ArrayList<Statement>();\r\n        FieldNode tempMin = null;\r\n        FieldNode tempMax = null;\r\n        for (FieldNode field : fields) {\r\n            if ((field.getModifiers() & Opcodes.ACC_ENUM) == 0) continue;\r\n            value++;\r\n            if (tempMin == null) tempMin = field;\r\n            tempMax = field;\r\n\r\n            ClassNode enumBase = enumClass;\r\n            ArgumentListExpression args = new ArgumentListExpression();\r\n            args.addExpression(new ConstantExpression(field.getName()));\r\n            args.addExpression(new ConstantExpression(value));\r\n            if (field.getInitialExpression() == null) {\r\n                if ((enumClass.getModifiers() & Opcodes.ACC_ABSTRACT) != 0) {\r\n                    addError(field, \"The enum constant \" + field.getName() + \" must override abstract methods from \" + enumBase.getName() + \".\");\r\n                    continue;\r\n                }\r\n            } else {\r\n                ListExpression oldArgs = (ListExpression) field.getInitialExpression();\r\n                List<MapEntryExpression> savedMapEntries = new ArrayList<MapEntryExpression>();\r\n                for (Expression exp : oldArgs.getExpressions()) {\r\n                    if (exp instanceof MapEntryExpression) {\r\n                        savedMapEntries.add((MapEntryExpression) exp);\r\n                        continue;\r\n                    }\r\n\r\n                    InnerClassNode inner = null;\r\n                    if (exp instanceof ClassExpression) {\r\n                        ClassExpression clazzExp = (ClassExpression) exp;\r\n                        ClassNode ref = clazzExp.getType();\r\n                        if (ref instanceof EnumConstantClassNode) {\r\n                            inner = (InnerClassNode) ref;\r\n                        }\r\n                    }\r\n                    if (inner != null) {\r\n                        List<MethodNode> baseMethods = enumBase.getMethods();\r\n                        for (MethodNode methodNode : baseMethods) {\r\n                            if (!methodNode.isAbstract()) continue;\r\n                            MethodNode enumConstMethod = inner.getMethod(methodNode.getName(), methodNode.getParameters());\r\n                            if (enumConstMethod == null || (enumConstMethod.getModifiers() & Opcodes.ACC_ABSTRACT) != 0) {\r\n                                addError(field, \"Can't have an abstract method in enum constant \" + field.getName() + \". Implement method '\" + methodNode.getTypeDescriptor() + \"'.\");\r\n                            }\r\n                        }\r\n                        if (inner.getVariableScope() == null) {\r\n                            enumBase = inner;\r\n                            /*\r\n                             * GROOVY-3985: Remove the final modifier from $INIT method in this case\r\n                             * so that subclasses of enum generated for enum constants (aic) can provide\r\n                             * their own $INIT method\r\n                             */\r\n                            initMethod.setModifiers(initMethod.getModifiers() & ~Opcodes.ACC_FINAL);\r\n                            continue;\r\n                        }\r\n                    }\r\n                    args.addExpression(exp);\r\n                }\r\n                if (!savedMapEntries.isEmpty()) {\n                    args.getExpressions().add(2, new MapExpression(savedMapEntries));\r\n                }\r\n            }\r\n            field.setInitialValueExpression(null);\r\n            block.add(\r\n                    new ExpressionStatement(\r\n                            new BinaryExpression(\r\n                                    new FieldExpression(field),\r\n                                    assign,\r\n                                    new StaticMethodCallExpression(enumBase, \"$INIT\", args)\r\n                            )\r\n                    )\r\n            );\r\n            arrayInit.add(new FieldExpression(field));\r\n        }\r\n\r\n        if (!isAic) {\r\n            if (tempMin != null) {\r\n                block.add(\r\n                        new ExpressionStatement(\r\n                                new BinaryExpression(\r\n                                        new FieldExpression(minValue),\r\n                                        assign,\r\n                                        new FieldExpression(tempMin)\r\n                                )\r\n                        )\r\n                );\r\n                block.add(\r\n                        new ExpressionStatement(\r\n                                new BinaryExpression(\r\n                                        new FieldExpression(maxValue),\r\n                                        assign,\r\n                                        new FieldExpression(tempMax)\r\n                                )\r\n                        )\r\n                );\r\n                enumClass.addField(minValue);\r\n                enumClass.addField(maxValue);\r\n            }\r\n\r\n            block.add(\r\n                    new ExpressionStatement(\r\n                            new BinaryExpression(new FieldExpression(values), assign, new ArrayExpression(enumClass, arrayInit))\r\n                    )\r\n            );\r\n            enumClass.addField(values);\r\n        }\r\n        enumClass.addStaticInitializerStatements(block, true);\r\n    }\r"
        ],
        [
            "DefaultGroovyMethods::intersect(Map,Map)",
            "11404  \n11405  \n11406  \n11407  \n11408  \n11409  \n11410  \n11411  \n11412  \n11413  \n11414  \n11415  \n11416  \n11417 -\n11418  \n11419  \n11420  \n11421  \n11422  \n11423  \n11424  \n11425  \n11426  \n11427  ",
            "    /**\n     * Create a Map composed of the intersection of both maps.\n     * Any entries that exist in both maps are added to the resultant map.\n     * <pre class=\"groovyTestCase\">assert [4:4,5:5] == [1:1,2:2,3:3,4:4,5:5].intersect([4:4,5:5,6:6,7:7,8:8])</pre>\n     * <pre class=\"groovyTestCase\">assert [1: 1, 2: 2, 3: 3, 4: 4].intersect( [1: 1.0, 2: 2, 5: 5] ) == [1:1, 2:2]</pre>\n     *\n     * @param left     a map\n     * @param right    a map\n     * @return a Map as an intersection of both maps\n     * @since 1.7.4\n     */\n    public static <K,V> Map<K,V> intersect(Map<K,V> left, Map<K,V> right) {\n        final Map<K,V> ansMap = createSimilarMap(left);\n        if (right != null && right.size() > 0) {\n            for (Map.Entry<K, V> e1 : left.entrySet()) {\n                for (Map.Entry<K, V> e2 : right.entrySet()) {\n                    if (DefaultTypeTransformation.compareEqual(e1, e2)) {\n                        ansMap.put(e1.getKey(), e1.getValue());\n                    }\n                }\n            }\n        }\n        return ansMap;\n    }",
            "11404  \n11405  \n11406  \n11407  \n11408  \n11409  \n11410  \n11411  \n11412  \n11413  \n11414  \n11415  \n11416  \n11417 +\n11418  \n11419  \n11420  \n11421  \n11422  \n11423  \n11424  \n11425  \n11426  \n11427  ",
            "    /**\n     * Create a Map composed of the intersection of both maps.\n     * Any entries that exist in both maps are added to the resultant map.\n     * <pre class=\"groovyTestCase\">assert [4:4,5:5] == [1:1,2:2,3:3,4:4,5:5].intersect([4:4,5:5,6:6,7:7,8:8])</pre>\n     * <pre class=\"groovyTestCase\">assert [1: 1, 2: 2, 3: 3, 4: 4].intersect( [1: 1.0, 2: 2, 5: 5] ) == [1:1, 2:2]</pre>\n     *\n     * @param left     a map\n     * @param right    a map\n     * @return a Map as an intersection of both maps\n     * @since 1.7.4\n     */\n    public static <K,V> Map<K,V> intersect(Map<K,V> left, Map<K,V> right) {\n        final Map<K,V> ansMap = createSimilarMap(left);\n        if (right != null && !right.isEmpty()) {\n            for (Map.Entry<K, V> e1 : left.entrySet()) {\n                for (Map.Entry<K, V> e2 : right.entrySet()) {\n                    if (DefaultTypeTransformation.compareEqual(e1, e2)) {\n                        ansMap.put(e1.getKey(), e1.getValue());\n                    }\n                }\n            }\n        }\n        return ansMap;\n    }"
        ],
        [
            "AnnotationCollectorTransform::makeListOfAnnotations(Object)",
            " 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236 -\n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  ",
            "    private static List<AnnotationNode> makeListOfAnnotations(Object[][] data) {\n        if (data.length==0) return Collections.EMPTY_LIST;\n\n        List<AnnotationNode> ret = new ArrayList<AnnotationNode>(data.length);\n        for (Object[] inner : data) {\n            Class anno = (Class) inner[0];\n            AnnotationNode toAdd = new AnnotationNode(ClassHelper.make(anno));\n            ret.add(toAdd);\n\n            @SuppressWarnings(\"unchecked\")\n            Map<String,Object> member = (Map<String, Object>) inner[1];\n            if (member.size()==0) continue;\n            Map<String, Expression> generated = new HashMap<String, Expression>(member.size());\n            for (String name : member.keySet()) {\n                Object val = member.get(name);\n                generated.put(name, makeExpression(val));\n            }\n            toAdd.getMembers().putAll(generated);\n        }\n        return ret;\n    }",
            " 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236 +\n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  ",
            "    private static List<AnnotationNode> makeListOfAnnotations(Object[][] data) {\n        if (data.length==0) return Collections.EMPTY_LIST;\n\n        List<AnnotationNode> ret = new ArrayList<AnnotationNode>(data.length);\n        for (Object[] inner : data) {\n            Class anno = (Class) inner[0];\n            AnnotationNode toAdd = new AnnotationNode(ClassHelper.make(anno));\n            ret.add(toAdd);\n\n            @SuppressWarnings(\"unchecked\")\n            Map<String,Object> member = (Map<String, Object>) inner[1];\n            if (member.isEmpty()) continue;\n            Map<String, Expression> generated = new HashMap<String, Expression>(member.size());\n            for (String name : member.keySet()) {\n                Object val = member.get(name);\n                generated.put(name, makeExpression(val));\n            }\n            toAdd.getMembers().putAll(generated);\n        }\n        return ret;\n    }"
        ],
        [
            "SimpleGroovyClassDoc::getParentInterfaces()",
            " 251  \n 252  \n 253  \n 254  \n 255  \n 256 -\n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  ",
            "    public Set<GroovyClassDoc> getParentInterfaces() {\n        Set<GroovyClassDoc> result = new HashSet<GroovyClassDoc>();\n        result.add(this);\n        Set<GroovyClassDoc> next = new HashSet<GroovyClassDoc>();\n        next.addAll(Arrays.asList(this.interfaces()));\n        while (next.size() > 0) {\n            Set<GroovyClassDoc> temp = next;\n            next = new HashSet<GroovyClassDoc>();\n            for (GroovyClassDoc t : temp) {\n                if (t instanceof SimpleGroovyClassDoc) {\n                    next.addAll(((SimpleGroovyClassDoc)t).getParentInterfaces());\n                } else if (t instanceof ExternalGroovyClassDoc) {\n                    ExternalGroovyClassDoc d = (ExternalGroovyClassDoc) t;\n                    next.addAll(getJavaInterfaces(d));\n                }\n            }\n            next = DefaultGroovyMethods.minus(next, result);\n            result.addAll(next);\n        }\n        return result;\n    }",
            " 251  \n 252  \n 253  \n 254  \n 255  \n 256 +\n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  ",
            "    public Set<GroovyClassDoc> getParentInterfaces() {\n        Set<GroovyClassDoc> result = new HashSet<GroovyClassDoc>();\n        result.add(this);\n        Set<GroovyClassDoc> next = new HashSet<GroovyClassDoc>();\n        next.addAll(Arrays.asList(this.interfaces()));\n        while (!next.isEmpty()) {\n            Set<GroovyClassDoc> temp = next;\n            next = new HashSet<GroovyClassDoc>();\n            for (GroovyClassDoc t : temp) {\n                if (t instanceof SimpleGroovyClassDoc) {\n                    next.addAll(((SimpleGroovyClassDoc)t).getParentInterfaces());\n                } else if (t instanceof ExternalGroovyClassDoc) {\n                    ExternalGroovyClassDoc d = (ExternalGroovyClassDoc) t;\n                    next.addAll(getJavaInterfaces(d));\n                }\n            }\n            next = DefaultGroovyMethods.minus(next, result);\n            result.addAll(next);\n        }\n        return result;\n    }"
        ],
        [
            "DeclarationExpression::check(Expression)",
            "  77  \n  78  \n  79  \n  80  \n  81  \n  82 -\n  83  \n  84  \n  85  \n  86  ",
            "    private void check(Expression left) {\n        if (left instanceof VariableExpression) {\n            //nothing\n        } else if (left instanceof TupleExpression) {\n            TupleExpression tuple = (TupleExpression) left;\n            if (tuple.getExpressions().size()==0) throw new GroovyBugError(\"one element required for left side\");\n        } else {\n            throw new GroovyBugError(\"illegal left expression for declaration: \"+left);\n        }\n    }",
            "  77  \n  78  \n  79  \n  80  \n  81  \n  82 +\n  83  \n  84  \n  85  \n  86  ",
            "    private void check(Expression left) {\n        if (left instanceof VariableExpression) {\n            //nothing\n        } else if (left instanceof TupleExpression) {\n            TupleExpression tuple = (TupleExpression) left;\n            if (tuple.getExpressions().isEmpty()) throw new GroovyBugError(\"one element required for left side\");\n        } else {\n            throw new GroovyBugError(\"illegal left expression for declaration: \"+left);\n        }\n    }"
        ],
        [
            "JavaAwareCompilationUnit::gotoPhase(int)",
            "  96  \n  97  \n  98  \n  99 -\n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  ",
            "    public void gotoPhase(int phase) throws CompilationFailedException {\n        super.gotoPhase(phase);\n        // compile Java and clean up\n        if (phase == Phases.SEMANTIC_ANALYSIS && javaSources.size() > 0) {\n            for (ModuleNode module : getAST().getModules()) {\n                module.setImportsResolved(false);\n            }\n            try {\n                JavaCompiler compiler = compilerFactory.createCompiler(getConfiguration());\n                compiler.compile(javaSources, this);\n            } finally {\n                if (!keepStubs) stubGenerator.clean();\n                javaSources.clear();\n            }\n        }\n    }",
            "  96  \n  97  \n  98  \n  99 +\n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  ",
            "    public void gotoPhase(int phase) throws CompilationFailedException {\n        super.gotoPhase(phase);\n        // compile Java and clean up\n        if (phase == Phases.SEMANTIC_ANALYSIS && !javaSources.isEmpty()) {\n            for (ModuleNode module : getAST().getModules()) {\n                module.setImportsResolved(false);\n            }\n            try {\n                JavaCompiler compiler = compilerFactory.createCompiler(getConfiguration());\n                compiler.compile(javaSources, this);\n            } finally {\n                if (!keepStubs) stubGenerator.clean();\n                javaSources.clear();\n            }\n        }\n    }"
        ],
        [
            "DefaultGroovyMethods::equals(Set,Set)",
            "11596  \n11597  \n11598  \n11599  \n11600  \n11601  \n11602  \n11603  \n11604  \n11605  \n11606  \n11607  \n11608  \n11609  \n11610  \n11611  \n11612  \n11613  \n11614  \n11615  \n11616  \n11617  \n11618  \n11619  \n11620  \n11621  \n11622  \n11623  \n11624  \n11625  \n11626  \n11627  \n11628  \n11629  \n11630  \n11631  \n11632  \n11633  \n11634  \n11635  \n11636  \n11637  \n11638  \n11639  \n11640  \n11641  \n11642  \n11643  \n11644  \n11645  \n11646  \n11647  \n11648  \n11649  \n11650  \n11651  \n11652 -\n11653  ",
            "    /**\n     * Compare the contents of two Sets for equality using Groovy's coercion rules.\n     * <p>\n     * Returns <tt>true</tt> if the two sets have the same size, and every member\n     * of the specified set is contained in this set (or equivalently, every member\n     * of this set is contained in the specified set).\n     * If numbers exist in the sets, then they are compared as numbers,\n     * for example 2 == 2L.  If both sets are <code>null</code>, the result\n     * is true; otherwise if either set is <code>null</code>, the result\n     * is <code>false</code>. Example usage:\n     * <pre class=\"groovyTestCase\">\n     * Set s1 = [\"a\", 2]\n     * def s2 = [2, 'a'] as Set\n     * Set s3 = [3, 'a']\n     * def s4 = [2.0, 'a'] as Set\n     * def s5 = [2L, 'a'] as Set\n     * assert s1.equals(s2)\n     * assert !s1.equals(s3)\n     * assert s1.equals(s4)\n     * assert s1.equals(s5)</pre>\n     *\n     * @param self  a Set\n     * @param other the Set being compared to\n     * @return <tt>true</tt> if the contents of both sets are identical\n     * @since 1.8.0\n     */\n    public static <T> boolean equals(Set<T> self, Set<T> other) {\n        if (self == null) {\n            return other == null;\n        }\n        if (other == null) {\n            return false;\n        }\n        if (self == other) {\n            return true;\n        }\n        if (self.size() != other.size()) {\n            return false;\n        }\n        final Iterator<T> it1 = self.iterator();\n        Collection<T> otherItems = new HashSet<T>(other);\n        while (it1.hasNext()) {\n            final Object o1 = it1.next();\n            final Iterator<T> it2 = otherItems.iterator();\n            T foundItem = null;\n            boolean found = false;\n            while (it2.hasNext() && foundItem == null) {\n                final T o2 = it2.next();\n                if (coercedEquals(o1, o2)) {\n                    foundItem = o2;\n                    found = true;\n                }\n            }\n            if (!found) return false;\n            otherItems.remove(foundItem);\n        }\n        return otherItems.size() == 0;\n    }",
            "11596  \n11597  \n11598  \n11599  \n11600  \n11601  \n11602  \n11603  \n11604  \n11605  \n11606  \n11607  \n11608  \n11609  \n11610  \n11611  \n11612  \n11613  \n11614  \n11615  \n11616  \n11617  \n11618  \n11619  \n11620  \n11621  \n11622  \n11623  \n11624  \n11625  \n11626  \n11627  \n11628  \n11629  \n11630  \n11631  \n11632  \n11633  \n11634  \n11635  \n11636  \n11637  \n11638  \n11639  \n11640  \n11641  \n11642  \n11643  \n11644  \n11645  \n11646  \n11647  \n11648  \n11649  \n11650  \n11651  \n11652 +\n11653  ",
            "    /**\n     * Compare the contents of two Sets for equality using Groovy's coercion rules.\n     * <p>\n     * Returns <tt>true</tt> if the two sets have the same size, and every member\n     * of the specified set is contained in this set (or equivalently, every member\n     * of this set is contained in the specified set).\n     * If numbers exist in the sets, then they are compared as numbers,\n     * for example 2 == 2L.  If both sets are <code>null</code>, the result\n     * is true; otherwise if either set is <code>null</code>, the result\n     * is <code>false</code>. Example usage:\n     * <pre class=\"groovyTestCase\">\n     * Set s1 = [\"a\", 2]\n     * def s2 = [2, 'a'] as Set\n     * Set s3 = [3, 'a']\n     * def s4 = [2.0, 'a'] as Set\n     * def s5 = [2L, 'a'] as Set\n     * assert s1.equals(s2)\n     * assert !s1.equals(s3)\n     * assert s1.equals(s4)\n     * assert s1.equals(s5)</pre>\n     *\n     * @param self  a Set\n     * @param other the Set being compared to\n     * @return <tt>true</tt> if the contents of both sets are identical\n     * @since 1.8.0\n     */\n    public static <T> boolean equals(Set<T> self, Set<T> other) {\n        if (self == null) {\n            return other == null;\n        }\n        if (other == null) {\n            return false;\n        }\n        if (self == other) {\n            return true;\n        }\n        if (self.size() != other.size()) {\n            return false;\n        }\n        final Iterator<T> it1 = self.iterator();\n        Collection<T> otherItems = new HashSet<T>(other);\n        while (it1.hasNext()) {\n            final Object o1 = it1.next();\n            final Iterator<T> it2 = otherItems.iterator();\n            T foundItem = null;\n            boolean found = false;\n            while (it2.hasNext() && foundItem == null) {\n                final T o2 = it2.next();\n                if (coercedEquals(o1, o2)) {\n                    foundItem = o2;\n                    found = true;\n                }\n            }\n            if (!found) return false;\n            otherItems.remove(foundItem);\n        }\n        return otherItems.isEmpty();\n    }"
        ],
        [
            "BaseDuration::toString()",
            " 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116 -\n 117  \n 118  \n 119  \n 120  \n 121  ",
            "    public String toString() {\n        List buffer = new ArrayList();\n\n        if (this.years != 0) buffer.add(this.years + \" years\");\n        if (this.months != 0) buffer.add(this.months + \" months\");\n        if (this.days != 0) buffer.add(this.days + \" days\");\n        if (this.hours != 0) buffer.add(this.hours + \" hours\");\n        if (this.minutes != 0) buffer.add(this.minutes + \" minutes\");\n\n        if (this.seconds != 0 || this.millis != 0) {\n            int norm_millis = millis % 1000;\n            int norm_seconds = seconds + DefaultGroovyMethods.intdiv(millis - norm_millis, 1000).intValue();\n            buffer.add((norm_seconds == 0 ? (norm_millis < 0 ? \"-0\" : \"0\") : norm_seconds) + \".\" + StringGroovyMethods.padLeft(\"\" + Math.abs(norm_millis), 3, \"0\") + \" seconds\");\n        }\n\n        if (buffer.size() != 0) {\n            return DefaultGroovyMethods.join(buffer.iterator(), \", \");\n        } else {\n            return \"0\";\n        }\n    }",
            " 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116 +\n 117  \n 118  \n 119  \n 120  \n 121  ",
            "    public String toString() {\n        List buffer = new ArrayList();\n\n        if (this.years != 0) buffer.add(this.years + \" years\");\n        if (this.months != 0) buffer.add(this.months + \" months\");\n        if (this.days != 0) buffer.add(this.days + \" days\");\n        if (this.hours != 0) buffer.add(this.hours + \" hours\");\n        if (this.minutes != 0) buffer.add(this.minutes + \" minutes\");\n\n        if (this.seconds != 0 || this.millis != 0) {\n            int norm_millis = millis % 1000;\n            int norm_seconds = seconds + DefaultGroovyMethods.intdiv(millis - norm_millis, 1000).intValue();\n            buffer.add((norm_seconds == 0 ? (norm_millis < 0 ? \"-0\" : \"0\") : norm_seconds) + \".\" + StringGroovyMethods.padLeft(\"\" + Math.abs(norm_millis), 3, \"0\") + \" seconds\");\n        }\n\n        if (!buffer.isEmpty()) {\n            return DefaultGroovyMethods.join(buffer.iterator(), \", \");\n        } else {\n            return \"0\";\n        }\n    }"
        ],
        [
            "AntlrParserPlugin::getAnonymousInnerClassNode(Expression)",
            "2606  \n2607  \n2608  \n2609  \n2610 -\n2611  \n2612  \n2613  \n2614  \n2615  \n2616  \n2617  \n2618  \n2619  \n2620  \n2621  \n2622  \n2623  ",
            "    private ClassNode getAnonymousInnerClassNode(Expression arguments) {\n        if (arguments instanceof TupleExpression) {\n            TupleExpression te = (TupleExpression) arguments;\n            List<Expression> expressions = te.getExpressions();\n            if (expressions.size() == 0) return null;\n            Expression last = expressions.remove(expressions.size() - 1);\n            if (last instanceof AnonymousInnerClassCarrier) {\n                AnonymousInnerClassCarrier carrier = (AnonymousInnerClassCarrier) last;\n                return carrier.innerClass;\n            } else {\n                expressions.add(last);\n            }\n        } else if (arguments instanceof AnonymousInnerClassCarrier) {\n            AnonymousInnerClassCarrier carrier = (AnonymousInnerClassCarrier) arguments;\n            return carrier.innerClass;\n        }\n        return null;\n    }",
            "2606  \n2607  \n2608  \n2609  \n2610 +\n2611  \n2612  \n2613  \n2614  \n2615  \n2616  \n2617  \n2618  \n2619  \n2620  \n2621  \n2622  \n2623  ",
            "    private ClassNode getAnonymousInnerClassNode(Expression arguments) {\n        if (arguments instanceof TupleExpression) {\n            TupleExpression te = (TupleExpression) arguments;\n            List<Expression> expressions = te.getExpressions();\n            if (expressions.isEmpty()) return null;\n            Expression last = expressions.remove(expressions.size() - 1);\n            if (last instanceof AnonymousInnerClassCarrier) {\n                AnonymousInnerClassCarrier carrier = (AnonymousInnerClassCarrier) last;\n                return carrier.innerClass;\n            } else {\n                expressions.add(last);\n            }\n        } else if (arguments instanceof AnonymousInnerClassCarrier) {\n            AnonymousInnerClassCarrier carrier = (AnonymousInnerClassCarrier) arguments;\n            return carrier.innerClass;\n        }\n        return null;\n    }"
        ],
        [
            "ObservableList::addAll(int,Collection)",
            " 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213 -\n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  ",
            "    public boolean addAll(int index, Collection c) {\n        int oldSize = size();\n        boolean success = delegate.addAll(index, c);\n\n        if (success && c != null) {\n            List values = new ArrayList();\n            for (Object element : c) {\n                if (test != null) {\n                    Object result = test.call(element);\n                    if (result != null && result instanceof Boolean && (Boolean) result) {\n                        values.add(element);\n                    }\n                } else {\n                    values.add(element);\n                }\n            }\n            if (values.size() > 0) {\n                fireMultiElementAddedEvent(index, values);\n                fireSizeChangedEvent(oldSize, size());\n            }\n        }\n\n        return success;\n    }",
            " 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213 +\n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  ",
            "    public boolean addAll(int index, Collection c) {\n        int oldSize = size();\n        boolean success = delegate.addAll(index, c);\n\n        if (success && c != null) {\n            List values = new ArrayList();\n            for (Object element : c) {\n                if (test != null) {\n                    Object result = test.call(element);\n                    if (result != null && result instanceof Boolean && (Boolean) result) {\n                        values.add(element);\n                    }\n                } else {\n                    values.add(element);\n                }\n            }\n            if (!values.isEmpty()) {\n                fireMultiElementAddedEvent(index, values);\n                fireSizeChangedEvent(oldSize, size());\n            }\n        }\n\n        return success;\n    }"
        ],
        [
            "AutoCloneASTTransformation::createSimpleClone(ClassNode,List,List)",
            " 201  \n 202 -\n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  ",
            "    private void createSimpleClone(ClassNode cNode, List<FieldNode> fieldNodes, List<String> excludes) {\r\n        if (cNode.getDeclaredConstructors().size() == 0) {\r\n            // add no-arg constructor\r\n            cNode.addConstructor(ACC_PUBLIC, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, block(EmptyStatement.INSTANCE));\r\n        }\r\n        addSimpleCloneHelperMethod(cNode, fieldNodes, excludes);\r\n        final Expression result = varX(\"_result\", cNode);\r\n        ClassNode[] exceptions = {make(CloneNotSupportedException.class)};\r\n        cNode.addMethod(\"clone\", ACC_PUBLIC, GenericsUtils.nonGeneric(cNode), Parameter.EMPTY_ARRAY, exceptions, block(\r\n            declS(result, ctorX(cNode)),\r\n            stmt(callThisX(\"cloneOrCopyMembers\", args(result))),\r\n            returnS(result)));\r\n    }\r",
            " 201  \n 202 +\n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  ",
            "    private void createSimpleClone(ClassNode cNode, List<FieldNode> fieldNodes, List<String> excludes) {\r\n        if (cNode.getDeclaredConstructors().isEmpty()) {\n            // add no-arg constructor\r\n            cNode.addConstructor(ACC_PUBLIC, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, block(EmptyStatement.INSTANCE));\r\n        }\r\n        addSimpleCloneHelperMethod(cNode, fieldNodes, excludes);\r\n        final Expression result = varX(\"_result\", cNode);\r\n        ClassNode[] exceptions = {make(CloneNotSupportedException.class)};\r\n        cNode.addMethod(\"clone\", ACC_PUBLIC, GenericsUtils.nonGeneric(cNode), Parameter.EMPTY_ARRAY, exceptions, block(\r\n            declS(result, ctorX(cNode)),\r\n            stmt(callThisX(\"cloneOrCopyMembers\", args(result))),\r\n            returnS(result)));\r\n    }\r"
        ],
        [
            "ImmutableASTTransformation::createConstructorMap(ClassNode,List,List,List)",
            " 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370 -\n 371  \n 372  \n 373  ",
            "    private void createConstructorMap(ClassNode cNode, List<PropertyNode> list, List<String> knownImmutableClasses, List<String> knownImmutables) {\n        final BlockStatement body = new BlockStatement();\n        body.addStatement(ifS(equalsNullX(varX(\"args\")), assignS(varX(\"args\"), new MapExpression())));\n        for (PropertyNode pNode : list) {\n            body.addStatement(createConstructorStatement(cNode, pNode, knownImmutableClasses, knownImmutables));\n        }\n        // check for missing properties\n        body.addStatement(stmt(callX(SELF_TYPE, \"checkPropNames\", args(\"this\", \"args\"))));\n        createConstructorMapCommon(cNode, body);\n        if (list.size() > 0) {\n            createNoArgConstructor(cNode);\n        }\n    }",
            " 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370 +\n 371  \n 372  \n 373  ",
            "    private void createConstructorMap(ClassNode cNode, List<PropertyNode> list, List<String> knownImmutableClasses, List<String> knownImmutables) {\n        final BlockStatement body = new BlockStatement();\n        body.addStatement(ifS(equalsNullX(varX(\"args\")), assignS(varX(\"args\"), new MapExpression())));\n        for (PropertyNode pNode : list) {\n            body.addStatement(createConstructorStatement(cNode, pNode, knownImmutableClasses, knownImmutables));\n        }\n        // check for missing properties\n        body.addStatement(stmt(callX(SELF_TYPE, \"checkPropNames\", args(\"this\", \"args\"))));\n        createConstructorMapCommon(cNode, body);\n        if (!list.isEmpty()) {\n            createNoArgConstructor(cNode);\n        }\n    }"
        ],
        [
            "AntlrParserPlugin::buildAST(SourceUnit,ClassLoader,Reduction)",
            " 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293 -\n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  \n 306  \n 307  ",
            "    public ModuleNode buildAST(SourceUnit sourceUnit, ClassLoader classLoader, Reduction cst) throws ParserException {\n        setClassLoader(classLoader);\n        makeModule();\n        try {\n            convertGroovy(ast);\n            if (output.getStatementBlock().isEmpty() && output.getMethods().isEmpty() && output.getClasses().isEmpty()) {\n                output.addStatement(ReturnStatement.RETURN_NULL_OR_VOID);\n            }\n\n            // set the script source position\n\n            ClassNode scriptClassNode = output.getScriptClassDummy();\n            if (scriptClassNode != null) {\n                List<Statement> statements = output.getStatementBlock().getStatements();\n                if (statements.size() > 0) {\n                    Statement firstStatement = statements.get(0);\n                    Statement lastStatement = statements.get(statements.size() - 1);\n\n                    scriptClassNode.setSourcePosition(firstStatement);\n                    scriptClassNode.setLastColumnNumber(lastStatement.getLastColumnNumber());\n                    scriptClassNode.setLastLineNumber(lastStatement.getLastLineNumber());\n                }\n            }\n        }\n        catch (ASTRuntimeException e) {\n            throw new ASTParserException(e.getMessage() + \". File: \" + sourceUnit.getName(), e);\n        }\n        return output;\n    }",
            " 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293 +\n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  \n 306  \n 307  ",
            "    public ModuleNode buildAST(SourceUnit sourceUnit, ClassLoader classLoader, Reduction cst) throws ParserException {\n        setClassLoader(classLoader);\n        makeModule();\n        try {\n            convertGroovy(ast);\n            if (output.getStatementBlock().isEmpty() && output.getMethods().isEmpty() && output.getClasses().isEmpty()) {\n                output.addStatement(ReturnStatement.RETURN_NULL_OR_VOID);\n            }\n\n            // set the script source position\n\n            ClassNode scriptClassNode = output.getScriptClassDummy();\n            if (scriptClassNode != null) {\n                List<Statement> statements = output.getStatementBlock().getStatements();\n                if (!statements.isEmpty()) {\n                    Statement firstStatement = statements.get(0);\n                    Statement lastStatement = statements.get(statements.size() - 1);\n\n                    scriptClassNode.setSourcePosition(firstStatement);\n                    scriptClassNode.setLastColumnNumber(lastStatement.getLastColumnNumber());\n                    scriptClassNode.setLastLineNumber(lastStatement.getLastLineNumber());\n                }\n            }\n        }\n        catch (ASTRuntimeException e) {\n            throw new ASTParserException(e.getMessage() + \". File: \" + sourceUnit.getName(), e);\n        }\n        return output;\n    }"
        ],
        [
            "EnumCompletionVisitor::completeEnum(ClassNode)",
            "  59  \n  60  \n  61 -\n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  ",
            "    private void completeEnum(ClassNode enumClass) {\n        boolean isAic = isAnonymousInnerClass(enumClass);\n        if (enumClass.getDeclaredConstructors().size() == 0) {\n            addImplicitConstructors(enumClass, isAic);\n        }\n\n        for (ConstructorNode ctor : enumClass.getDeclaredConstructors()) {\n            transformConstructor(ctor, isAic);\n        }\n    }",
            "  59  \n  60  \n  61 +\n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  ",
            "    private void completeEnum(ClassNode enumClass) {\n        boolean isAic = isAnonymousInnerClass(enumClass);\n        if (enumClass.getDeclaredConstructors().isEmpty()) {\n            addImplicitConstructors(enumClass, isAic);\n        }\n\n        for (ConstructorNode ctor : enumClass.getDeclaredConstructors()) {\n            transformConstructor(ctor, isAic);\n        }\n    }"
        ],
        [
            "DefaultGroovyMethods::minus(Collection,Collection)",
            "11827  \n11828  \n11829  \n11830  \n11831  \n11832  \n11833  \n11834  \n11835  \n11836  \n11837  \n11838  \n11839 -\n11840  \n11841  \n11842  \n11843  \n11844  \n11845  \n11846  \n11847  \n11848  \n11849  \n11850  \n11851  \n11852  \n11853  \n11854  \n11855  \n11856  \n11857  \n11858  \n11859  \n11860  \n11861  \n11862  \n11863  \n11864  \n11865  \n11866  \n11867  \n11868  \n11869  \n11870  \n11871  \n11872  \n11873  \n11874  \n11875  \n11876  \n11877  \n11878  \n11879  \n11880  \n11881  \n11882  \n11883  \n11884  \n11885  \n11886  \n11887  \n11888  \n11889  \n11890  \n11891  \n11892  \n11893  \n11894  \n11895  \n11896  \n11897  \n11898  \n11899  \n11900  ",
            "    /**\n     * Create a new Collection composed of the elements of the first Collection minus\n     * every occurrence of elements of the given Collection.\n     * <pre class=\"groovyTestCase\">assert [1, \"a\", true, true, false, 5.3] - [true, 5.3] == [1, \"a\", false]</pre>\n     *\n     * @param self     a Collection\n     * @param removeMe a Collection of elements to remove\n     * @return a Collection with the given elements removed\n     * @since 2.4.0\n     */\n    public static <T> Collection<T> minus(Collection<T> self, Collection<?> removeMe) {\n        Collection<T> ansCollection = createSimilarCollection(self);\n        if (self.size() == 0)\n            return ansCollection;\n        T head = self.iterator().next();\n\n        boolean nlgnSort = sameType(new Collection[]{self, removeMe});\n\n        // We can't use the same tactic as for intersection\n        // since AbstractCollection only does a remove on the first\n        // element it encounters.\n\n        Comparator<T> numberComparator = new NumberAwareComparator<T>();\n\n        if (nlgnSort && (head instanceof Comparable)) {\n            //n*LOG(n) version\n            Set<T> answer;\n            if (Number.class.isInstance(head)) {\n                answer = new TreeSet<T>(numberComparator);\n                answer.addAll(self);\n                for (T t : self) {\n                    if (Number.class.isInstance(t)) {\n                        for (Object t2 : removeMe) {\n                            if (Number.class.isInstance(t2)) {\n                                if (numberComparator.compare(t, (T)t2) == 0)\n                                    answer.remove(t);\n                            }\n                        }\n                    } else {\n                        if (removeMe.contains(t))\n                            answer.remove(t);\n                    }\n                }\n            } else {\n                answer = new TreeSet<T>(numberComparator);\n                answer.addAll(self);\n                answer.removeAll(removeMe);\n            }\n\n            for (T o : self) {\n                if (answer.contains(o))\n                    ansCollection.add(o);\n            }\n        } else {\n            //n*n version\n            List<T> tmpAnswer = new LinkedList<T>(self);\n            for (Iterator<T> iter = tmpAnswer.iterator(); iter.hasNext();) {\n                T element = iter.next();\n                boolean elementRemoved = false;\n                for (Iterator<?> iterator = removeMe.iterator(); iterator.hasNext() && !elementRemoved;) {\n                    Object elt = iterator.next();\n                    if (DefaultTypeTransformation.compareEqual(element, elt)) {\n                        iter.remove();\n                        elementRemoved = true;\n                    }\n                }\n            }\n\n            //remove duplicates\n            //can't use treeset since the base classes are different\n            ansCollection.addAll(tmpAnswer);\n        }\n        return ansCollection;\n    }",
            "11827  \n11828  \n11829  \n11830  \n11831  \n11832  \n11833  \n11834  \n11835  \n11836  \n11837  \n11838  \n11839 +\n11840  \n11841  \n11842  \n11843  \n11844  \n11845  \n11846  \n11847  \n11848  \n11849  \n11850  \n11851  \n11852  \n11853  \n11854  \n11855  \n11856  \n11857  \n11858  \n11859  \n11860  \n11861  \n11862  \n11863  \n11864  \n11865  \n11866  \n11867  \n11868  \n11869  \n11870  \n11871  \n11872  \n11873  \n11874  \n11875  \n11876  \n11877  \n11878  \n11879  \n11880  \n11881  \n11882  \n11883  \n11884  \n11885  \n11886  \n11887  \n11888  \n11889  \n11890  \n11891  \n11892  \n11893  \n11894  \n11895  \n11896  \n11897  \n11898  \n11899  \n11900  ",
            "    /**\n     * Create a new Collection composed of the elements of the first Collection minus\n     * every occurrence of elements of the given Collection.\n     * <pre class=\"groovyTestCase\">assert [1, \"a\", true, true, false, 5.3] - [true, 5.3] == [1, \"a\", false]</pre>\n     *\n     * @param self     a Collection\n     * @param removeMe a Collection of elements to remove\n     * @return a Collection with the given elements removed\n     * @since 2.4.0\n     */\n    public static <T> Collection<T> minus(Collection<T> self, Collection<?> removeMe) {\n        Collection<T> ansCollection = createSimilarCollection(self);\n        if (self.isEmpty())\n            return ansCollection;\n        T head = self.iterator().next();\n\n        boolean nlgnSort = sameType(new Collection[]{self, removeMe});\n\n        // We can't use the same tactic as for intersection\n        // since AbstractCollection only does a remove on the first\n        // element it encounters.\n\n        Comparator<T> numberComparator = new NumberAwareComparator<T>();\n\n        if (nlgnSort && (head instanceof Comparable)) {\n            //n*LOG(n) version\n            Set<T> answer;\n            if (Number.class.isInstance(head)) {\n                answer = new TreeSet<T>(numberComparator);\n                answer.addAll(self);\n                for (T t : self) {\n                    if (Number.class.isInstance(t)) {\n                        for (Object t2 : removeMe) {\n                            if (Number.class.isInstance(t2)) {\n                                if (numberComparator.compare(t, (T)t2) == 0)\n                                    answer.remove(t);\n                            }\n                        }\n                    } else {\n                        if (removeMe.contains(t))\n                            answer.remove(t);\n                    }\n                }\n            } else {\n                answer = new TreeSet<T>(numberComparator);\n                answer.addAll(self);\n                answer.removeAll(removeMe);\n            }\n\n            for (T o : self) {\n                if (answer.contains(o))\n                    ansCollection.add(o);\n            }\n        } else {\n            //n*n version\n            List<T> tmpAnswer = new LinkedList<T>(self);\n            for (Iterator<T> iter = tmpAnswer.iterator(); iter.hasNext();) {\n                T element = iter.next();\n                boolean elementRemoved = false;\n                for (Iterator<?> iterator = removeMe.iterator(); iterator.hasNext() && !elementRemoved;) {\n                    Object elt = iterator.next();\n                    if (DefaultTypeTransformation.compareEqual(element, elt)) {\n                        iter.remove();\n                        elementRemoved = true;\n                    }\n                }\n            }\n\n            //remove duplicates\n            //can't use treeset since the base classes are different\n            ansCollection.addAll(tmpAnswer);\n        }\n        return ansCollection;\n    }"
        ],
        [
            "ConfigObject::doMerge(Map,Map)",
            " 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184 -\n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  ",
            "    private Map doMerge(Map config, Map other) {\n        for (Object o : other.entrySet()) {\n            Map.Entry next = (Map.Entry) o;\n            Object key = next.getKey();\n            Object value = next.getValue();\n\n            Object configEntry = config.get(key);\n\n            if (configEntry == null) {\n                config.put(key, value);\n\n                continue;\n            } else {\n                if (configEntry instanceof Map && ((Map)configEntry).size() > 0 && value instanceof Map) {\n                    // recur\n                    doMerge((Map) configEntry, (Map) value);\n                } else {\n                    config.put(key, value);\n                }\n            }\n        }\n\n        return config;\n    }",
            " 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184 +\n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  ",
            "    private Map doMerge(Map config, Map other) {\n        for (Object o : other.entrySet()) {\n            Map.Entry next = (Map.Entry) o;\n            Object key = next.getKey();\n            Object value = next.getValue();\n\n            Object configEntry = config.get(key);\n\n            if (configEntry == null) {\n                config.put(key, value);\n\n                continue;\n            } else {\n                if (configEntry instanceof Map && !((Map) configEntry).isEmpty() && value instanceof Map) {\n                    // recur\n                    doMerge((Map) configEntry, (Map) value);\n                } else {\n                    config.put(key, value);\n                }\n            }\n        }\n\n        return config;\n    }"
        ],
        [
            "AutoCloneASTTransformation::createCloneCopyConstructor(ClassNode,List,List)",
            " 140  \n 141 -\n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  ",
            "    private void createCloneCopyConstructor(ClassNode cNode, List<FieldNode> list, List<String> excludes) {\r\n        if (cNode.getDeclaredConstructors().size() == 0) {\r\n            // add no-arg constructor\r\n            BlockStatement noArgBody = new BlockStatement();\r\n            noArgBody.addStatement(EmptyStatement.INSTANCE);\r\n            cNode.addConstructor(ACC_PUBLIC, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, noArgBody);\r\n        }\r\n        boolean hasThisCons = false;\r\n        for (ConstructorNode consNode : cNode.getDeclaredConstructors()) {\r\n            Parameter[] parameters = consNode.getParameters();\r\n            if (parameters.length == 1 && parameters[0].getType().equals(cNode)) {\r\n                hasThisCons = true;\r\n            }\r\n        }\r\n        if (!hasThisCons) {\r\n            BlockStatement initBody = new BlockStatement();\r\n            Parameter initParam = param(GenericsUtils.nonGeneric(cNode), \"other\");\r\n            final Expression other = varX(initParam);\r\n            boolean hasParent = cNode.getSuperClass() != ClassHelper.OBJECT_TYPE;\r\n            if (hasParent) {\r\n                initBody.addStatement(stmt(ctorX(ClassNode.SUPER, other)));\r\n            }\r\n            for (FieldNode fieldNode : list) {\r\n                String name = fieldNode.getName();\r\n                if (excludes != null && excludes.contains(name)) continue;\r\n                ClassNode fieldType = fieldNode.getType();\r\n                Expression direct = propX(other, name);\r\n                Expression to = propX(varX(\"this\"), name);\r\n                Statement assignDirect = assignS(to, direct);\r\n                Statement assignCloned = assignS(to, castX(fieldType, callCloneDirectX(direct)));\r\n                Statement assignClonedDynamic = assignS(to, castX(fieldType, callCloneDynamicX(direct)));\r\n                if (isCloneableType(fieldType)) {\r\n                    initBody.addStatement(assignCloned);\r\n                } else if (!possiblyCloneable(fieldType)) {\r\n                    initBody.addStatement(assignDirect);\r\n                } else {\r\n                    initBody.addStatement(ifElseS(isInstanceOfX(direct, CLONEABLE_TYPE), assignClonedDynamic, assignDirect));\r\n                }\r\n            }\r\n            cNode.addConstructor(ACC_PROTECTED, params(initParam), ClassNode.EMPTY_ARRAY, initBody);\r\n        }\r\n        ClassNode[] exceptions = {make(CloneNotSupportedException.class)};\r\n        cNode.addMethod(\"clone\", ACC_PUBLIC, GenericsUtils.nonGeneric(cNode), Parameter.EMPTY_ARRAY, exceptions, block(stmt(ctorX(cNode, args(varX(\"this\"))))));\r\n    }\r",
            " 140  \n 141 +\n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  ",
            "    private void createCloneCopyConstructor(ClassNode cNode, List<FieldNode> list, List<String> excludes) {\r\n        if (cNode.getDeclaredConstructors().isEmpty()) {\n            // add no-arg constructor\r\n            BlockStatement noArgBody = new BlockStatement();\r\n            noArgBody.addStatement(EmptyStatement.INSTANCE);\r\n            cNode.addConstructor(ACC_PUBLIC, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, noArgBody);\r\n        }\r\n        boolean hasThisCons = false;\r\n        for (ConstructorNode consNode : cNode.getDeclaredConstructors()) {\r\n            Parameter[] parameters = consNode.getParameters();\r\n            if (parameters.length == 1 && parameters[0].getType().equals(cNode)) {\r\n                hasThisCons = true;\r\n            }\r\n        }\r\n        if (!hasThisCons) {\r\n            BlockStatement initBody = new BlockStatement();\r\n            Parameter initParam = param(GenericsUtils.nonGeneric(cNode), \"other\");\r\n            final Expression other = varX(initParam);\r\n            boolean hasParent = cNode.getSuperClass() != ClassHelper.OBJECT_TYPE;\r\n            if (hasParent) {\r\n                initBody.addStatement(stmt(ctorX(ClassNode.SUPER, other)));\r\n            }\r\n            for (FieldNode fieldNode : list) {\r\n                String name = fieldNode.getName();\r\n                if (excludes != null && excludes.contains(name)) continue;\r\n                ClassNode fieldType = fieldNode.getType();\r\n                Expression direct = propX(other, name);\r\n                Expression to = propX(varX(\"this\"), name);\r\n                Statement assignDirect = assignS(to, direct);\r\n                Statement assignCloned = assignS(to, castX(fieldType, callCloneDirectX(direct)));\r\n                Statement assignClonedDynamic = assignS(to, castX(fieldType, callCloneDynamicX(direct)));\r\n                if (isCloneableType(fieldType)) {\r\n                    initBody.addStatement(assignCloned);\r\n                } else if (!possiblyCloneable(fieldType)) {\r\n                    initBody.addStatement(assignDirect);\r\n                } else {\r\n                    initBody.addStatement(ifElseS(isInstanceOfX(direct, CLONEABLE_TYPE), assignClonedDynamic, assignDirect));\r\n                }\r\n            }\r\n            cNode.addConstructor(ACC_PROTECTED, params(initParam), ClassNode.EMPTY_ARRAY, initBody);\r\n        }\r\n        ClassNode[] exceptions = {make(CloneNotSupportedException.class)};\r\n        cNode.addMethod(\"clone\", ACC_PUBLIC, GenericsUtils.nonGeneric(cNode), Parameter.EMPTY_ARRAY, exceptions, block(stmt(ctorX(cNode, args(varX(\"this\"))))));\r\n    }\r"
        ],
        [
            "ObservableList::addAll(Collection)",
            " 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188 -\n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  ",
            "    public boolean addAll(Collection c) {\n        int oldSize = size();\n        int index = size() - 1;\n        index = index < 0 ? 0 : index;\n\n        boolean success = delegate.addAll(c);\n        if (success && c != null) {\n            List values = new ArrayList();\n            for (Object element : c) {\n                if (test != null) {\n                    Object result = test.call(element);\n                    if (result != null && result instanceof Boolean && (Boolean) result) {\n                        values.add(element);\n                    }\n                } else {\n                    values.add(element);\n                }\n            }\n            if (values.size() > 0) {\n                fireMultiElementAddedEvent(index, values);\n                fireSizeChangedEvent(oldSize, size());\n            }\n        }\n\n        return success;\n    }",
            " 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188 +\n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  ",
            "    public boolean addAll(Collection c) {\n        int oldSize = size();\n        int index = size() - 1;\n        index = index < 0 ? 0 : index;\n\n        boolean success = delegate.addAll(c);\n        if (success && c != null) {\n            List values = new ArrayList();\n            for (Object element : c) {\n                if (test != null) {\n                    Object result = test.call(element);\n                    if (result != null && result instanceof Boolean && (Boolean) result) {\n                        values.add(element);\n                    }\n                } else {\n                    values.add(element);\n                }\n            }\n            if (!values.isEmpty()) {\n                fireMultiElementAddedEvent(index, values);\n                fireSizeChangedEvent(oldSize, size());\n            }\n        }\n\n        return success;\n    }"
        ],
        [
            "AnnotationCollectorTransform::visit(AnnotationNode,AnnotationNode,AnnotatedNode,SourceUnit)",
            " 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315 -\n 316  \n 317  \n 318  \n 319  \n 320  \n 321  ",
            "    /**\n     * Implementation method of the alias annotation processor. This method will \n     * get the list of annotations we aliased from the collector and adds it to\n     * aliasAnnotationUsage. The method will also map all members from \n     * aliasAnnotationUsage to the aliased nodes. Should a member stay unmapped,\n     * we will ad an error. Further processing of those members is done by the\n     * annotations.\n     * \n     * @param collector                 reference to the annotation with {@link AnnotationCollector}\n     * @param aliasAnnotationUsage      reference to the place of usage of the alias\n     * @param aliasAnnotated            reference to the node that has been annotated by the alias\n     * @param source                    source unit for error reporting\n     * @return list of the new AnnotationNodes\n     */\n    public List<AnnotationNode> visit(AnnotationNode collector, AnnotationNode aliasAnnotationUsage, AnnotatedNode aliasAnnotated, SourceUnit source) {\n        List<AnnotationNode> ret =  getTargetAnnotationList(collector, aliasAnnotationUsage, source);\n        Set<String> unusedNames = new HashSet<String>(aliasAnnotationUsage.getMembers().keySet());\n        \n        for (AnnotationNode an: ret) {\n            for (String name : aliasAnnotationUsage.getMembers().keySet()) {\n                if (an.getClassNode().hasMethod(name, Parameter.EMPTY_ARRAY)) {\n                    unusedNames.remove(name);\n                    an.setMember(name, aliasAnnotationUsage.getMember(name));\n                }\n            }\n        }\n\n        if (unusedNames.size()>0) {\n            String message = \"Annotation collector got unmapped names \"+unusedNames.toString()+\".\";\n            addError(message, aliasAnnotationUsage, source);\n        }\n\n        return ret;\n    }",
            " 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315 +\n 316  \n 317  \n 318  \n 319  \n 320  \n 321  ",
            "    /**\n     * Implementation method of the alias annotation processor. This method will \n     * get the list of annotations we aliased from the collector and adds it to\n     * aliasAnnotationUsage. The method will also map all members from \n     * aliasAnnotationUsage to the aliased nodes. Should a member stay unmapped,\n     * we will ad an error. Further processing of those members is done by the\n     * annotations.\n     * \n     * @param collector                 reference to the annotation with {@link AnnotationCollector}\n     * @param aliasAnnotationUsage      reference to the place of usage of the alias\n     * @param aliasAnnotated            reference to the node that has been annotated by the alias\n     * @param source                    source unit for error reporting\n     * @return list of the new AnnotationNodes\n     */\n    public List<AnnotationNode> visit(AnnotationNode collector, AnnotationNode aliasAnnotationUsage, AnnotatedNode aliasAnnotated, SourceUnit source) {\n        List<AnnotationNode> ret =  getTargetAnnotationList(collector, aliasAnnotationUsage, source);\n        Set<String> unusedNames = new HashSet<String>(aliasAnnotationUsage.getMembers().keySet());\n        \n        for (AnnotationNode an: ret) {\n            for (String name : aliasAnnotationUsage.getMembers().keySet()) {\n                if (an.getClassNode().hasMethod(name, Parameter.EMPTY_ARRAY)) {\n                    unusedNames.remove(name);\n                    an.setMember(name, aliasAnnotationUsage.getMember(name));\n                }\n            }\n        }\n\n        if (!unusedNames.isEmpty()) {\n            String message = \"Annotation collector got unmapped names \"+unusedNames.toString()+\".\";\n            addError(message, aliasAnnotationUsage, source);\n        }\n\n        return ret;\n    }"
        ],
        [
            "EnumCompletionVisitor::addImplicitConstructors(ClassNode,boolean)",
            "  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77 -\n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  ",
            "    /**\n     * Add map and no-arg constructor or mirror those of the superclass (i.e. base enum).\n     */\n    private void addImplicitConstructors(ClassNode enumClass, boolean aic) {\n        if (aic) {\n            ClassNode sn = enumClass.getSuperClass();\n            List<ConstructorNode> sctors = new ArrayList<ConstructorNode>(sn.getDeclaredConstructors());\n            if (sctors.size() == 0) {\n                addMapConstructors(enumClass, false);\n            } else {\n                for (ConstructorNode constructorNode : sctors) {\n                    ConstructorNode init = new ConstructorNode(Opcodes.ACC_PUBLIC, constructorNode.getParameters(), ClassNode.EMPTY_ARRAY, new BlockStatement());\n                    enumClass.addConstructor(init);\n                }\n            }\n        } else {\n            addMapConstructors(enumClass, false);\n        }\n    }",
            "  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77 +\n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  ",
            "    /**\n     * Add map and no-arg constructor or mirror those of the superclass (i.e. base enum).\n     */\n    private void addImplicitConstructors(ClassNode enumClass, boolean aic) {\n        if (aic) {\n            ClassNode sn = enumClass.getSuperClass();\n            List<ConstructorNode> sctors = new ArrayList<ConstructorNode>(sn.getDeclaredConstructors());\n            if (sctors.isEmpty()) {\n                addMapConstructors(enumClass, false);\n            } else {\n                for (ConstructorNode constructorNode : sctors) {\n                    ConstructorNode init = new ConstructorNode(Opcodes.ACC_PUBLIC, constructorNode.getParameters(), ClassNode.EMPTY_ARRAY, new BlockStatement());\n                    enumClass.addConstructor(init);\n                }\n            }\n        } else {\n            addMapConstructors(enumClass, false);\n        }\n    }"
        ],
        [
            "AntlrParserPlugin::setTypeArgumentsOnMethodCallExpression(MethodCallExpression,List)",
            "2559  \n2560  \n2561 -\n2562  \n2563  \n2564  ",
            "    private void setTypeArgumentsOnMethodCallExpression(MethodCallExpression expression,\n                                                        List<GenericsType> typeArgumentList) {\n        if (typeArgumentList != null && typeArgumentList.size() > 0) {\n            expression.setGenericsTypes(typeArgumentList.toArray(new GenericsType[typeArgumentList.size()]));\n        }\n    }",
            "2559  \n2560  \n2561 +\n2562  \n2563  \n2564  ",
            "    private void setTypeArgumentsOnMethodCallExpression(MethodCallExpression expression,\n                                                        List<GenericsType> typeArgumentList) {\n        if (typeArgumentList != null && !typeArgumentList.isEmpty()) {\n            expression.setGenericsTypes(typeArgumentList.toArray(new GenericsType[typeArgumentList.size()]));\n        }\n    }"
        ],
        [
            "DataSet::add(Map)",
            " 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235 -\n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  ",
            "    /**\n     * Adds the provided map of key-value pairs as a new row in the table represented by this DataSet.\n     *\n     * @param map the key (column-name), value pairs to add as a new row\n     * @throws SQLException if a database error occurs\n     */\n    public void add(Map<String, Object> map) throws SQLException {\n        if (withinDataSetBatch) {\n            if (batchData.size() == 0) {\n                batchKeys = map.keySet();\n            } else {\n                if (!map.keySet().equals(batchKeys)) {\n                    throw new IllegalArgumentException(\"Inconsistent keys found for batch add!\");\n                }\n            }\n            batchData.add(map);\n            return;\n        }\n        int answer = executeUpdate(buildListQuery(map), new ArrayList<Object>(map.values()));\n        if (answer != 1) {\n            LOG.warning(\"Should have updated 1 row not \" + answer + \" when trying to add: \" + map);\n        }\n    }",
            " 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235 +\n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  ",
            "    /**\n     * Adds the provided map of key-value pairs as a new row in the table represented by this DataSet.\n     *\n     * @param map the key (column-name), value pairs to add as a new row\n     * @throws SQLException if a database error occurs\n     */\n    public void add(Map<String, Object> map) throws SQLException {\n        if (withinDataSetBatch) {\n            if (batchData.isEmpty()) {\n                batchKeys = map.keySet();\n            } else {\n                if (!map.keySet().equals(batchKeys)) {\n                    throw new IllegalArgumentException(\"Inconsistent keys found for batch add!\");\n                }\n            }\n            batchData.add(map);\n            return;\n        }\n        int answer = executeUpdate(buildListQuery(map), new ArrayList<Object>(map.values()));\n        if (answer != 1) {\n            LOG.warning(\"Should have updated 1 row not \" + answer + \" when trying to add: \" + map);\n        }\n    }"
        ],
        [
            "DefaultGroovyMethodsSupport::sameType(Collection)",
            " 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309 -\n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332  \n 333  ",
            "    /**\n     * Determines if all items of this array are of the same type.\n     *\n     * @param cols an array of collections\n     * @return true if the collections are all of the same type\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected static boolean sameType(Collection[] cols) {\n        List all = new LinkedList();\n        for (Collection col : cols) {\n            all.addAll(col);\n        }\n        if (all.size() == 0)\n            return true;\n\n        Object first = all.get(0);\n\n        //trying to determine the base class of the collections\n        //special case for Numbers\n        Class baseClass;\n        if (first instanceof Number) {\n            baseClass = Number.class;\n        } else if (first == null) {\n            baseClass = NullObject.class;\n        } else {\n            baseClass = first.getClass();\n        }\n\n        for (Collection col : cols) {\n            for (Object o : col) {\n                if (!baseClass.isInstance(o)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }",
            " 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309 +\n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332  \n 333  ",
            "    /**\n     * Determines if all items of this array are of the same type.\n     *\n     * @param cols an array of collections\n     * @return true if the collections are all of the same type\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected static boolean sameType(Collection[] cols) {\n        List all = new LinkedList();\n        for (Collection col : cols) {\n            all.addAll(col);\n        }\n        if (all.isEmpty())\n            return true;\n\n        Object first = all.get(0);\n\n        //trying to determine the base class of the collections\n        //special case for Numbers\n        Class baseClass;\n        if (first instanceof Number) {\n            baseClass = Number.class;\n        } else if (first == null) {\n            baseClass = NullObject.class;\n        } else {\n            baseClass = first.getClass();\n        }\n\n        for (Collection col : cols) {\n            for (Object o : col) {\n                if (!baseClass.isInstance(o)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }"
        ],
        [
            "TextUndoManager::StructuredEdit::canUndo()",
            " 191  \n 192 -\n 193  ",
            "        public boolean canUndo() {\n            return edits.size() > 0;\n        }",
            " 191  \n 192 +\n 193  ",
            "        public boolean canUndo() {\n            return !edits.isEmpty();\n        }"
        ],
        [
            "DataSet::withBatch(int,Closure)",
            " 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214 -\n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  ",
            "    /**\n     * Performs the closure (containing batch operations) within a batch.\n     * For example:\n     * <pre>\n     * dataSet.withBatch(3) {\n     *     add(anint: 1, astring: \"Groovy\")\n     *     add(anint: 2, astring: \"rocks\")\n     *     add(anint: 3, astring: \"the\")\n     *     add(anint: 4, astring: \"casbah\")\n     * }\n     * </pre>\n     *\n     * @param batchSize partition the batch into batchSize pieces, i.e. after batchSize\n     *                  <code>addBatch()</code> invocations, call <code>executeBatch()</code> automatically;\n     *                  0 means manual calls to executeBatch are required\n     * @param closure   the closure containing batch and optionally other statements\n     * @return an array of update counts containing one element for each\n     *         command in the batch.  The elements of the array are ordered according\n     *         to the order in which commands were added to the batch.\n     * @throws SQLException if a database access error occurs, or the driver does not support batch statements.\n     *                      Throws {@link java.sql.BatchUpdateException} (a subclass of <code>SQLException</code>)\n     *                      if one of the commands sent to the database fails to execute properly.\n     */\n    @Override\n    public int[] withBatch(int batchSize, Closure closure) throws SQLException {\n        batchData = new ArrayList<Object>();\n        withinDataSetBatch = true;\n        closure.call(this);\n        withinDataSetBatch = false;\n        if (batchData.size() == 0) {\n            return EMPTY_INT_ARRAY;\n        }\n        Closure transformedClosure = new Closure(null) {\n            public void doCall(BatchingPreparedStatementWrapper stmt) throws SQLException {\n                for (Object next : batchData) {\n                    stmt.addBatch(new Object[]{next});\n                }\n            }\n        };\n        return super.withBatch(batchSize, buildMapQuery(), transformedClosure);\n    }",
            " 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214 +\n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  ",
            "    /**\n     * Performs the closure (containing batch operations) within a batch.\n     * For example:\n     * <pre>\n     * dataSet.withBatch(3) {\n     *     add(anint: 1, astring: \"Groovy\")\n     *     add(anint: 2, astring: \"rocks\")\n     *     add(anint: 3, astring: \"the\")\n     *     add(anint: 4, astring: \"casbah\")\n     * }\n     * </pre>\n     *\n     * @param batchSize partition the batch into batchSize pieces, i.e. after batchSize\n     *                  <code>addBatch()</code> invocations, call <code>executeBatch()</code> automatically;\n     *                  0 means manual calls to executeBatch are required\n     * @param closure   the closure containing batch and optionally other statements\n     * @return an array of update counts containing one element for each\n     *         command in the batch.  The elements of the array are ordered according\n     *         to the order in which commands were added to the batch.\n     * @throws SQLException if a database access error occurs, or the driver does not support batch statements.\n     *                      Throws {@link java.sql.BatchUpdateException} (a subclass of <code>SQLException</code>)\n     *                      if one of the commands sent to the database fails to execute properly.\n     */\n    @Override\n    public int[] withBatch(int batchSize, Closure closure) throws SQLException {\n        batchData = new ArrayList<Object>();\n        withinDataSetBatch = true;\n        closure.call(this);\n        withinDataSetBatch = false;\n        if (batchData.isEmpty()) {\n            return EMPTY_INT_ARRAY;\n        }\n        Closure transformedClosure = new Closure(null) {\n            public void doCall(BatchingPreparedStatementWrapper stmt) throws SQLException {\n                for (Object next : batchData) {\n                    stmt.addBatch(new Object[]{next});\n                }\n            }\n        };\n        return super.withBatch(batchSize, buildMapQuery(), transformedClosure);\n    }"
        ],
        [
            "ImmutableASTTransformation::isKnownImmutableClass(ClassNode,List)",
            " 526  \n 527  \n 528  \n 529  \n 530  \n 531  \n 532  \n 533 -\n 534  ",
            "    private boolean isKnownImmutableClass(ClassNode fieldType, List<String> knownImmutableClasses) {\n        if (inImmutableList(fieldType.getName()) || knownImmutableClasses.contains(fieldType.getName()))\n            return true;\n        if (!fieldType.isResolved())\n            return false;\n        return fieldType.isEnum() ||\n                ClassHelper.isPrimitiveType(fieldType) ||\n                fieldType.getAnnotations(MY_TYPE).size() != 0;\n    }",
            " 526  \n 527  \n 528  \n 529  \n 530  \n 531  \n 532  \n 533 +\n 534  ",
            "    private boolean isKnownImmutableClass(ClassNode fieldType, List<String> knownImmutableClasses) {\n        if (inImmutableList(fieldType.getName()) || knownImmutableClasses.contains(fieldType.getName()))\n            return true;\n        if (!fieldType.isResolved())\n            return false;\n        return fieldType.isEnum() ||\n                ClassHelper.isPrimitiveType(fieldType) ||\n                !fieldType.getAnnotations(MY_TYPE).isEmpty();\n    }"
        ],
        [
            "AntlrParserPlugin::makeGenericsBounds(AST,int)",
            "3000  \n3001  \n3002  \n3003  \n3004  \n3005  \n3006  \n3007  \n3008  \n3009  \n3010  \n3011  \n3012  \n3013  \n3014 -\n3015  \n3016  ",
            "    private ClassNode[] makeGenericsBounds(AST rn, int boundType) {\n        AST boundsRoot = rn.getNextSibling();\n        if (boundsRoot == null) return null;\n        assertNodeType(boundType, boundsRoot);\n        LinkedList bounds = new LinkedList();\n        for (AST boundsNode = boundsRoot.getFirstChild();\n             boundsNode != null;\n             boundsNode = boundsNode.getNextSibling()\n                ) {\n            ClassNode bound = null;\n            bound = makeTypeWithArguments(boundsNode);\n            configureAST(bound, boundsNode);\n            bounds.add(bound);\n        }\n        if (bounds.size() == 0) return null;\n        return (ClassNode[]) bounds.toArray(new ClassNode[bounds.size()]);\n    }",
            "3000  \n3001  \n3002  \n3003  \n3004  \n3005  \n3006  \n3007  \n3008  \n3009  \n3010  \n3011  \n3012  \n3013  \n3014 +\n3015  \n3016  ",
            "    private ClassNode[] makeGenericsBounds(AST rn, int boundType) {\n        AST boundsRoot = rn.getNextSibling();\n        if (boundsRoot == null) return null;\n        assertNodeType(boundType, boundsRoot);\n        LinkedList bounds = new LinkedList();\n        for (AST boundsNode = boundsRoot.getFirstChild();\n             boundsNode != null;\n             boundsNode = boundsNode.getNextSibling()\n                ) {\n            ClassNode bound = null;\n            bound = makeTypeWithArguments(boundsNode);\n            configureAST(bound, boundsNode);\n            bounds.add(bound);\n        }\n        if (bounds.isEmpty()) return null;\n        return (ClassNode[]) bounds.toArray(new ClassNode[bounds.size()]);\n    }"
        ],
        [
            "StaticTypeCheckingVisitor::getDeclaringClass(MethodNode,Expression)",
            "4425  \n4426  \n4427  \n4428  \n4429  \n4430  \n4431  \n4432 -\n4433  \n4434  \n4435  \n4436  \n4437  \n4438  ",
            "    private static ClassNode getDeclaringClass(MethodNode method, Expression arguments) {\n        ClassNode declaringClass = method.getDeclaringClass();\n\n        // correcting declaring class for extension methods:\n        if (arguments instanceof ArgumentListExpression) {\n            ArgumentListExpression al = (ArgumentListExpression) arguments;\n            List<Expression> list = al.getExpressions();\n            if (list.size()==0) return declaringClass;\n            Expression exp = list.get(0);\n            ClassNode cn = exp.getNodeMetaData(ExtensionMethodDeclaringClass.class);\n            if (cn!=null) return cn;\n        }\n        return declaringClass;\n    }",
            "4425  \n4426  \n4427  \n4428  \n4429  \n4430  \n4431  \n4432 +\n4433  \n4434  \n4435  \n4436  \n4437  \n4438  ",
            "    private static ClassNode getDeclaringClass(MethodNode method, Expression arguments) {\n        ClassNode declaringClass = method.getDeclaringClass();\n\n        // correcting declaring class for extension methods:\n        if (arguments instanceof ArgumentListExpression) {\n            ArgumentListExpression al = (ArgumentListExpression) arguments;\n            List<Expression> list = al.getExpressions();\n            if (list.isEmpty()) return declaringClass;\n            Expression exp = list.get(0);\n            ClassNode cn = exp.getNodeMetaData(ExtensionMethodDeclaringClass.class);\n            if (cn!=null) return cn;\n        }\n        return declaringClass;\n    }"
        ],
        [
            "ImmutableASTTransformation::visit(ASTNode,SourceUnit)",
            " 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185 -\n 186  \n 187  \n 188  \n 189  \n 190  ",
            "    public void visit(ASTNode[] nodes, SourceUnit source) {\n        init(nodes, source);\n        AnnotatedNode parent = (AnnotatedNode) nodes[1];\n        AnnotationNode node = (AnnotationNode) nodes[0];\n        // temporarily have weaker check which allows for old Deprecated Annotation\n//        if (!MY_TYPE.equals(node.getClassNode())) return;\n        if (!node.getClassNode().getName().endsWith(\".Immutable\")) return;\n        List<PropertyNode> newProperties = new ArrayList<PropertyNode>();\n\n        if (parent instanceof ClassNode) {\n            final List<String> knownImmutableClasses = getKnownImmutableClasses(node);\n            final List<String> knownImmutables = getKnownImmutables(node);\n\n            ClassNode cNode = (ClassNode) parent;\n            String cName = cNode.getName();\n            if (!checkNotInterface(cNode, MY_TYPE_NAME)) return;\n            if (!checkPropertyList(cNode, knownImmutables, \"knownImmutables\", node, MY_TYPE_NAME, false)) return;\n            makeClassFinal(cNode);\n\n            final List<PropertyNode> pList = getInstanceProperties(cNode);\n            for (PropertyNode pNode : pList) {\n                adjustPropertyForImmutability(pNode, newProperties);\n            }\n            for (PropertyNode pNode : newProperties) {\n                cNode.getProperties().remove(pNode);\n                addProperty(cNode, pNode);\n            }\n            final List<FieldNode> fList = cNode.getFields();\n            for (FieldNode fNode : fList) {\n                ensureNotPublic(cName, fNode);\n            }\n            boolean includeSuperProperties = false;\n            if (hasAnnotation(cNode, TupleConstructorASTTransformation.MY_TYPE)) {\n                AnnotationNode tupleCons = cNode.getAnnotations(TupleConstructorASTTransformation.MY_TYPE).get(0);\n                includeSuperProperties = memberHasValue(tupleCons, \"includeSuperProperties\", true);\n                if (unsupportedTupleAttribute(tupleCons, \"excludes\")) return;\n                if (unsupportedTupleAttribute(tupleCons, \"includes\")) return;\n                if (unsupportedTupleAttribute(tupleCons, \"includeFields\")) return;\n                if (unsupportedTupleAttribute(tupleCons, \"includeProperties\")) return;\n                if (unsupportedTupleAttribute(tupleCons, \"includeSuperFields\")) return;\n                if (unsupportedTupleAttribute(tupleCons, \"callSuper\")) return;\n                if (unsupportedTupleAttribute(tupleCons, \"force\")) return;\n            }\n            createConstructors(cNode, knownImmutableClasses, knownImmutables, includeSuperProperties);\n            if (!hasAnnotation(cNode, EqualsAndHashCodeASTTransformation.MY_TYPE)) {\n                createHashCode(cNode, true, false, false, null, null);\n                createEquals(cNode, false, false, false, null, null);\n            }\n            if (!hasAnnotation(cNode, ToStringASTTransformation.MY_TYPE)) {\n                createToString(cNode, false, false, null, null, false, true);\n            }\n            if( memberHasValue(node, MEMBER_ADD_COPY_WITH, true) &&\n                pList.size() > 0 &&\n                !hasDeclaredMethod(cNode, COPY_WITH_METHOD, 1) ) {\n                createCopyWith( cNode, pList ) ;\n            }\n        }\n    }",
            " 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185 +\n 186  \n 187  \n 188  \n 189  \n 190  ",
            "    public void visit(ASTNode[] nodes, SourceUnit source) {\n        init(nodes, source);\n        AnnotatedNode parent = (AnnotatedNode) nodes[1];\n        AnnotationNode node = (AnnotationNode) nodes[0];\n        // temporarily have weaker check which allows for old Deprecated Annotation\n//        if (!MY_TYPE.equals(node.getClassNode())) return;\n        if (!node.getClassNode().getName().endsWith(\".Immutable\")) return;\n        List<PropertyNode> newProperties = new ArrayList<PropertyNode>();\n\n        if (parent instanceof ClassNode) {\n            final List<String> knownImmutableClasses = getKnownImmutableClasses(node);\n            final List<String> knownImmutables = getKnownImmutables(node);\n\n            ClassNode cNode = (ClassNode) parent;\n            String cName = cNode.getName();\n            if (!checkNotInterface(cNode, MY_TYPE_NAME)) return;\n            if (!checkPropertyList(cNode, knownImmutables, \"knownImmutables\", node, MY_TYPE_NAME, false)) return;\n            makeClassFinal(cNode);\n\n            final List<PropertyNode> pList = getInstanceProperties(cNode);\n            for (PropertyNode pNode : pList) {\n                adjustPropertyForImmutability(pNode, newProperties);\n            }\n            for (PropertyNode pNode : newProperties) {\n                cNode.getProperties().remove(pNode);\n                addProperty(cNode, pNode);\n            }\n            final List<FieldNode> fList = cNode.getFields();\n            for (FieldNode fNode : fList) {\n                ensureNotPublic(cName, fNode);\n            }\n            boolean includeSuperProperties = false;\n            if (hasAnnotation(cNode, TupleConstructorASTTransformation.MY_TYPE)) {\n                AnnotationNode tupleCons = cNode.getAnnotations(TupleConstructorASTTransformation.MY_TYPE).get(0);\n                includeSuperProperties = memberHasValue(tupleCons, \"includeSuperProperties\", true);\n                if (unsupportedTupleAttribute(tupleCons, \"excludes\")) return;\n                if (unsupportedTupleAttribute(tupleCons, \"includes\")) return;\n                if (unsupportedTupleAttribute(tupleCons, \"includeFields\")) return;\n                if (unsupportedTupleAttribute(tupleCons, \"includeProperties\")) return;\n                if (unsupportedTupleAttribute(tupleCons, \"includeSuperFields\")) return;\n                if (unsupportedTupleAttribute(tupleCons, \"callSuper\")) return;\n                if (unsupportedTupleAttribute(tupleCons, \"force\")) return;\n            }\n            createConstructors(cNode, knownImmutableClasses, knownImmutables, includeSuperProperties);\n            if (!hasAnnotation(cNode, EqualsAndHashCodeASTTransformation.MY_TYPE)) {\n                createHashCode(cNode, true, false, false, null, null);\n                createEquals(cNode, false, false, false, null, null);\n            }\n            if (!hasAnnotation(cNode, ToStringASTTransformation.MY_TYPE)) {\n                createToString(cNode, false, false, null, null, false, true);\n            }\n            if( memberHasValue(node, MEMBER_ADD_COPY_WITH, true) &&\n                    !pList.isEmpty() &&\n                !hasDeclaredMethod(cNode, COPY_WITH_METHOD, 1) ) {\n                createCopyWith( cNode, pList ) ;\n            }\n        }\n    }"
        ],
        [
            "DefaultGroovyMethods::addEntry(Map,Object)",
            "3783  \n3784  \n3785  \n3786  \n3787  \n3788  \n3789 -\n3790  \n3791  \n3792  \n3793  \n3794  \n3795  \n3796  \n3797  \n3798  \n3799  \n3800  \n3801  \n3802  \n3803  \n3804  ",
            "    private static <K, V> void addEntry(Map<K, V> result, Object newEntry) {\n        if (newEntry instanceof Map) {\n            leftShift(result, (Map)newEntry);\n        } else if (newEntry instanceof List) {\n            List list = (List) newEntry;\n            // def (key, value) == list\n            Object key = list.size() == 0 ? null : list.get(0);\n            Object value = list.size() <= 1 ? null : list.get(1);\n            leftShift(result, new MapEntry(key, value));\n        } else if (newEntry.getClass().isArray()) {\n            Object[] array = (Object[]) newEntry;\n            // def (key, value) == array.toList()\n            Object key = array.length == 0 ? null : array[0];\n            Object value = array.length <= 1 ? null : array[1];\n            leftShift(result, new MapEntry(key, value));\n        } else {\n            // TODO: enforce stricter behavior?\n            // given Map.Entry is an interface, we get a proxy which gives us lots\n            // of flexibility but sometimes the error messages might be unexpected\n            leftShift(result, asType(newEntry, Map.Entry.class));\n        }\n    }",
            "3783  \n3784  \n3785  \n3786  \n3787  \n3788  \n3789 +\n3790  \n3791  \n3792  \n3793  \n3794  \n3795  \n3796  \n3797  \n3798  \n3799  \n3800  \n3801  \n3802  \n3803  \n3804  ",
            "    private static <K, V> void addEntry(Map<K, V> result, Object newEntry) {\n        if (newEntry instanceof Map) {\n            leftShift(result, (Map)newEntry);\n        } else if (newEntry instanceof List) {\n            List list = (List) newEntry;\n            // def (key, value) == list\n            Object key = list.isEmpty() ? null : list.get(0);\n            Object value = list.size() <= 1 ? null : list.get(1);\n            leftShift(result, new MapEntry(key, value));\n        } else if (newEntry.getClass().isArray()) {\n            Object[] array = (Object[]) newEntry;\n            // def (key, value) == array.toList()\n            Object key = array.length == 0 ? null : array[0];\n            Object value = array.length <= 1 ? null : array[1];\n            leftShift(result, new MapEntry(key, value));\n        } else {\n            // TODO: enforce stricter behavior?\n            // given Map.Entry is an interface, we get a proxy which gives us lots\n            // of flexibility but sometimes the error messages might be unexpected\n            leftShift(result, asType(newEntry, Map.Entry.class));\n        }\n    }"
        ],
        [
            "JavaAwareCompilationUnit::JavaAwareCompilationUnit(CompilerConfiguration,GroovyClassLoader,GroovyClassLoader)",
            "  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68 -\n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88 -\n  89  \n  90  \n  91  \n  92  \n  93  \n  94  ",
            "    public JavaAwareCompilationUnit(CompilerConfiguration configuration, GroovyClassLoader groovyClassLoader,\n                                    GroovyClassLoader transformClassLoader) {\n        super(configuration, null, groovyClassLoader, transformClassLoader);\n        javaSources = new LinkedList<String>();\n        Map options = configuration.getJointCompilationOptions();\n        generationGoal = (File) options.get(\"stubDir\");\n        boolean useJava5 = CompilerConfiguration.isPostJDK5(configuration.getTargetBytecode());\n\t\tString encoding = configuration.getSourceEncoding();\n        stubGenerator = new JavaStubGenerator(generationGoal, false, useJava5, encoding);\n        keepStubs = Boolean.TRUE.equals(options.get(\"keepStubs\"));\n\n        addPhaseOperation(new PrimaryClassNodeOperation() {\n            public void call(SourceUnit source, GeneratorContext context, ClassNode node) throws CompilationFailedException {\n                if (javaSources.size() != 0) {\n                    VariableScopeVisitor scopeVisitor = new VariableScopeVisitor(source);\n                    scopeVisitor.visitClass(node);\n                    new JavaAwareResolveVisitor(JavaAwareCompilationUnit.this).startResolving(node, source);\n                    AnnotationConstantsVisitor acv = new AnnotationConstantsVisitor();\n                    acv.visitClass(node, source);\n                }\n            }\n        }, Phases.CONVERSION);\n        addPhaseOperation(new CompilationUnit.PrimaryClassNodeOperation() {\n            public void call(SourceUnit source, GeneratorContext context, ClassNode classNode) throws CompilationFailedException {\n                ASTTransformationCollectorCodeVisitor collector =\n                        new ASTTransformationCollectorCodeVisitor(source, JavaAwareCompilationUnit.this.getTransformLoader());\n                collector.visitClass(classNode);\n            }\n        }, Phases.CONVERSION);\n\n        addPhaseOperation(new PrimaryClassNodeOperation() {\n            public void call(SourceUnit source, GeneratorContext context, ClassNode classNode) throws CompilationFailedException {\n                try {\n                    if (javaSources.size() != 0) stubGenerator.generateClass(classNode);\n                } catch (FileNotFoundException fnfe) {\n                    source.addException(fnfe);\n                }\n            }\n        }, Phases.CONVERSION);\n    }",
            "  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68 +\n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88 +\n  89  \n  90  \n  91  \n  92  \n  93  \n  94  ",
            "    public JavaAwareCompilationUnit(CompilerConfiguration configuration, GroovyClassLoader groovyClassLoader,\n                                    GroovyClassLoader transformClassLoader) {\n        super(configuration, null, groovyClassLoader, transformClassLoader);\n        javaSources = new LinkedList<String>();\n        Map options = configuration.getJointCompilationOptions();\n        generationGoal = (File) options.get(\"stubDir\");\n        boolean useJava5 = CompilerConfiguration.isPostJDK5(configuration.getTargetBytecode());\n\t\tString encoding = configuration.getSourceEncoding();\n        stubGenerator = new JavaStubGenerator(generationGoal, false, useJava5, encoding);\n        keepStubs = Boolean.TRUE.equals(options.get(\"keepStubs\"));\n\n        addPhaseOperation(new PrimaryClassNodeOperation() {\n            public void call(SourceUnit source, GeneratorContext context, ClassNode node) throws CompilationFailedException {\n                if (!javaSources.isEmpty()) {\n                    VariableScopeVisitor scopeVisitor = new VariableScopeVisitor(source);\n                    scopeVisitor.visitClass(node);\n                    new JavaAwareResolveVisitor(JavaAwareCompilationUnit.this).startResolving(node, source);\n                    AnnotationConstantsVisitor acv = new AnnotationConstantsVisitor();\n                    acv.visitClass(node, source);\n                }\n            }\n        }, Phases.CONVERSION);\n        addPhaseOperation(new CompilationUnit.PrimaryClassNodeOperation() {\n            public void call(SourceUnit source, GeneratorContext context, ClassNode classNode) throws CompilationFailedException {\n                ASTTransformationCollectorCodeVisitor collector =\n                        new ASTTransformationCollectorCodeVisitor(source, JavaAwareCompilationUnit.this.getTransformLoader());\n                collector.visitClass(classNode);\n            }\n        }, Phases.CONVERSION);\n\n        addPhaseOperation(new PrimaryClassNodeOperation() {\n            public void call(SourceUnit source, GeneratorContext context, ClassNode classNode) throws CompilationFailedException {\n                try {\n                    if (!javaSources.isEmpty()) stubGenerator.generateClass(classNode);\n                } catch (FileNotFoundException fnfe) {\n                    source.addException(fnfe);\n                }\n            }\n        }, Phases.CONVERSION);\n    }"
        ],
        [
            "GStringExpression::addValue(Expression)",
            "  88  \n  89  \n  90  \n  91 -\n  92  \n  93  \n  94  ",
            "    public void addValue(Expression value) {\n        // If the first thing is an value, then we need a dummy empty string in front of it so that when we\n        // toString it they come out in the correct order.\n        if (strings.size() == 0)\n            strings.add(ConstantExpression.EMPTY_STRING);\n        values.add(value);\n    }",
            "  88  \n  89  \n  90  \n  91 +\n  92  \n  93  \n  94  ",
            "    public void addValue(Expression value) {\n        // If the first thing is an value, then we need a dummy empty string in front of it so that when we\n        // toString it they come out in the correct order.\n        if (strings.isEmpty())\n            strings.add(ConstantExpression.EMPTY_STRING);\n        values.add(value);\n    }"
        ],
        [
            "ObservableMap::putAll(Map)",
            " 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243 -\n 244  \n 245  \n 246  \n 247  \n 248  ",
            "    public void putAll(Map map) {\r\n        int oldSize = size();\r\n        if (map != null) {\r\n            List<PropertyEvent> events = new ArrayList<PropertyEvent>();\r\n            for (Object o : map.entrySet()) {\r\n                Entry entry = (Entry) o;\r\n\r\n                String key = String.valueOf(entry.getKey());\r\n                Object newValue = entry.getValue();\r\n                Object oldValue = null;\r\n\r\n                boolean newKey = !delegate.containsKey(key);\r\n                if (test != null) {\r\n                    oldValue = delegate.put(key, newValue);\r\n                    Object result = null;\r\n                    if (test.getMaximumNumberOfParameters() == 2) {\r\n                        result = test.call(new Object[]{key, newValue});\r\n                    } else {\r\n                        result = test.call(newValue);\r\n                    }\r\n                    if (result != null && result instanceof Boolean && (Boolean) result) {\r\n                        if (newKey) {\r\n                            events.add(new PropertyAddedEvent(this, key, newValue));\r\n                        } else if (oldValue != newValue) {\r\n                            events.add(new PropertyUpdatedEvent(this, key, oldValue, newValue));\r\n                        }\r\n                    }\r\n                } else {\r\n                    oldValue = delegate.put(key, newValue);\r\n                    if (newKey) {\r\n                        events.add(new PropertyAddedEvent(this, key, newValue));\r\n                    } else if (oldValue != newValue) {\r\n                        events.add(new PropertyUpdatedEvent(this, key, oldValue, newValue));\r\n                    }\r\n                }\r\n            }\r\n            if (events.size() > 0) {\r\n                fireMultiPropertyEvent(events);\r\n                fireSizeChangedEvent(oldSize, size());\r\n            }\r\n        }\r\n    }\r",
            " 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243 +\n 244  \n 245  \n 246  \n 247  \n 248  ",
            "    public void putAll(Map map) {\r\n        int oldSize = size();\r\n        if (map != null) {\r\n            List<PropertyEvent> events = new ArrayList<PropertyEvent>();\r\n            for (Object o : map.entrySet()) {\r\n                Entry entry = (Entry) o;\r\n\r\n                String key = String.valueOf(entry.getKey());\r\n                Object newValue = entry.getValue();\r\n                Object oldValue = null;\r\n\r\n                boolean newKey = !delegate.containsKey(key);\r\n                if (test != null) {\r\n                    oldValue = delegate.put(key, newValue);\r\n                    Object result = null;\r\n                    if (test.getMaximumNumberOfParameters() == 2) {\r\n                        result = test.call(new Object[]{key, newValue});\r\n                    } else {\r\n                        result = test.call(newValue);\r\n                    }\r\n                    if (result != null && result instanceof Boolean && (Boolean) result) {\r\n                        if (newKey) {\r\n                            events.add(new PropertyAddedEvent(this, key, newValue));\r\n                        } else if (oldValue != newValue) {\r\n                            events.add(new PropertyUpdatedEvent(this, key, oldValue, newValue));\r\n                        }\r\n                    }\r\n                } else {\r\n                    oldValue = delegate.put(key, newValue);\r\n                    if (newKey) {\r\n                        events.add(new PropertyAddedEvent(this, key, newValue));\r\n                    } else if (oldValue != newValue) {\r\n                        events.add(new PropertyUpdatedEvent(this, key, oldValue, newValue));\r\n                    }\r\n                }\r\n            }\r\n            if (!events.isEmpty()) {\n                fireMultiPropertyEvent(events);\r\n                fireSizeChangedEvent(oldSize, size());\r\n            }\r\n        }\r\n    }\r"
        ],
        [
            "SourceCodeTraversal::accept(GroovySourceAST)",
            "  75  \n  76 -\n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  ",
            "    protected void accept(GroovySourceAST currentNode) {\n        if (currentNode != null && unvisitedNodes != null && unvisitedNodes.size() > 0) {\n            GroovySourceAST t = currentNode;\n\n            if (!(unvisitedNodes.contains(currentNode))) {\n                return;\n            }\n            push(t);\n            switch (t.getType()) {\n                case GroovyTokenTypes.QUESTION: // expr?foo:bar\n                    accept_FirstChild_v_SecondChild_v_ThirdChild_v(t);\n                    break;\n\n                case GroovyTokenTypes.CASE_GROUP: //\n                case GroovyTokenTypes.LITERAL_instanceof: // foo instanceof MyType\n                    accept_FirstChild_v_SecondChildsChildren_v(t);\n                    break;\n\n                case GroovyTokenTypes.ANNOTATION:\n                    accept_v_FirstChild_2ndv_SecondChild_v___LastChild_v(t);\n                    break;\n\n                case GroovyTokenTypes.CLOSURE_LIST: // (a=1; a<10; a++)\n                case GroovyTokenTypes.ELIST: // a,b,c\n                case GroovyTokenTypes.PARAMETERS: // a,b,c\n                case GroovyTokenTypes.TYPE_ARGUMENTS: // <String, Object>\n                case GroovyTokenTypes.STRING_CONSTRUCTOR: // \"foo${bar}wibble\"\n                case GroovyTokenTypes.TYPE_PARAMETER: // class Foo<T extends F>\n                case GroovyTokenTypes.TYPE_PARAMETERS: // class Foo<T>\n                case GroovyTokenTypes.TYPE_UPPER_BOUNDS: // class Foo<T extends F>\n                    accept_v_FirstChild_v_SecondChild_v___LastChild_v(t);\n                    // todo : confirm that TYPE_LOWER_BOUNDS does not have multiple children\n                    break;\n\n                case GroovyTokenTypes.VARIABLE_PARAMETER_DEF: // void f(String ... others) {}\n                    accept_v_FirstChild_SecondChild_v_ThirdChild_v(t);\n                    break;\n\n                case GroovyTokenTypes.INDEX_OP:\n                    //accept_FirstChild_v_SecondChild_v(t);\n                    accept_SecondChild_v_ThirdChild_v(t);\n                    break;\n\n                case GroovyTokenTypes.ENUM_CONSTANT_DEF: // enum Foo(THESE,ARE,THEY)\n                case GroovyTokenTypes.EXPR:\n                case GroovyTokenTypes.IMPORT:\n                case GroovyTokenTypes.STATIC_IMPORT:\n                case GroovyTokenTypes.VARIABLE_DEF:\n                case GroovyTokenTypes.METHOD_DEF:\n                case GroovyTokenTypes.OBJBLOCK: //class Foo {def bar()}  <-- this block\n                case GroovyTokenTypes.PARAMETER_DEF: // void f(String me) {}\n                case GroovyTokenTypes.SLIST: // list of expressions, variable defs etc\n                    accept_v_AllChildren_v(t);\n                    break;\n\n                case GroovyTokenTypes.ANNOTATION_MEMBER_VALUE_PAIR: // @Blue(foo=123)\n                case GroovyTokenTypes.ASSIGN: // a = b\n                case GroovyTokenTypes.BAND_ASSIGN: // a &= b\n                case GroovyTokenTypes.BOR_ASSIGN: // a |= b\n                case GroovyTokenTypes.BSR_ASSIGN: // a >>>= b\n                case GroovyTokenTypes.BXOR_ASSIGN: // a ^= b\n                case GroovyTokenTypes.COMPARE_TO: // a <=> b\n                case GroovyTokenTypes.DIV_ASSIGN: // a /= b\n                case GroovyTokenTypes.EQUAL: // a == b\n                case GroovyTokenTypes.MINUS_ASSIGN: // a -= b\n                case GroovyTokenTypes.MOD_ASSIGN: // a %= b\n                case GroovyTokenTypes.NOT_EQUAL: // a != b\n                case GroovyTokenTypes.PLUS_ASSIGN: // a += b\n                case GroovyTokenTypes.REGEX_FIND: // a =~ b\n                case GroovyTokenTypes.REGEX_MATCH: // a ==~ b\n                case GroovyTokenTypes.SL_ASSIGN: // a <<= b\n                case GroovyTokenTypes.SR_ASSIGN: // a >>= b\n                case GroovyTokenTypes.STAR_ASSIGN: // a *= b\n                case GroovyTokenTypes.STAR_STAR_ASSIGN: // x **= 3\n                    if (t.childAt(1) != null) {\n                        accept_FirstChild_v_RestOfTheChildren(t);\n                    } else {\n                        accept_v_FirstChild_v_RestOfTheChildren(t);\n                    }\n                    break;\n\n                case GroovyTokenTypes.ANNOTATION_FIELD_DEF: // @interface Foo{ int bar()...\n                    accept_FirstSecondAndThirdChild_v_v_ForthChild(t);\n                    break;\n                    \n                case GroovyTokenTypes.ANNOTATION_DEF: // @interface Foo...\n                case GroovyTokenTypes.BAND: // 1 & 2\n                case GroovyTokenTypes.BOR: // 1 | 2\n                case GroovyTokenTypes.BSR: // 1 >>> 2\n                case GroovyTokenTypes.BXOR: // 1 ^ 2\n                case GroovyTokenTypes.CLASS_DEF: // class Foo...\n                case GroovyTokenTypes.CTOR_IDENT: // private Foo() {...\n                case GroovyTokenTypes.DIV: //  3/4\n                case GroovyTokenTypes.DOT: // foo.bar\n                case GroovyTokenTypes.ENUM_DEF: // enum Foo...\n                case GroovyTokenTypes.GE: // a >= b\n                case GroovyTokenTypes.GT: // a > b\n                case GroovyTokenTypes.INTERFACE_DEF: // interface Foo...\n                case GroovyTokenTypes.LABELED_ARG: // myMethod(name:\"Jez\")\n                case GroovyTokenTypes.LABELED_STAT: // foo:x=1                        \n                case GroovyTokenTypes.LAND: // true && false\n                case GroovyTokenTypes.LE: // a <= b\n                case GroovyTokenTypes.LITERAL_as: // foo as Bar\n                case GroovyTokenTypes.LITERAL_in: // if (i in myList) ...\n                case GroovyTokenTypes.LOR: // true && false\n                case GroovyTokenTypes.LT: // a < b\n                case GroovyTokenTypes.MEMBER_POINTER: // this.&foo()\n                case GroovyTokenTypes.MOD: //  4 % 3\n                case GroovyTokenTypes.MINUS: // 1 - 1\n                case GroovyTokenTypes.OPTIONAL_DOT: // foo?.bar\n                case GroovyTokenTypes.PACKAGE_DEF:\n                case GroovyTokenTypes.PLUS: // 1 + 1\n                case GroovyTokenTypes.RANGE_EXCLUSIVE: // [1..<10]\n                case GroovyTokenTypes.RANGE_INCLUSIVE: // [1..10]\n                case GroovyTokenTypes.SL: // a << b\n                case GroovyTokenTypes.SPREAD_DOT: // foo*.bar\n                case GroovyTokenTypes.SR: // a >> b\n                case GroovyTokenTypes.STAR: // a * b   or    import foo.*\n                case GroovyTokenTypes.STAR_STAR: // x ** 3\n                case GroovyTokenTypes.TRAIT_DEF: // trait Foo...\n                    accept_FirstChild_v_RestOfTheChildren(t);\n                    break;\n\n                case GroovyTokenTypes.CTOR_CALL:\n                case GroovyTokenTypes.METHOD_CALL:\n                    if (t.getNumberOfChildren() == 2 && t.childAt(1) != null && t.childAt(1).getType() == GroovyTokenTypes.CLOSABLE_BLOCK) {\n                        // myMethod {...\n                        accept_FirstChild_v_SecondChild(t);\n                    } else {\n                        GroovySourceAST lastChild = t.childAt(t.getNumberOfChildren() -1);\n                        if (lastChild != null && lastChild.getType() == GroovyTokenTypes.CLOSABLE_BLOCK) {\n                            // myMethod(a,b) {...\n                            accept_FirstChild_v_RestOfTheChildren_v_LastChild(t);\n                        } else {\n                            // myMethod(a,b)\n                            accept_FirstChild_v_RestOfTheChildren_v(t);\n                        }\n                    }\n                    break;\n\n                case GroovyTokenTypes.LITERAL_while:\n//deprecated                case GroovyTokenTypes.LITERAL_with:\n                case GroovyTokenTypes.TYPECAST: // (String)itr.next()\n                    accept_v_FirstChildsFirstChild_v_RestOfTheChildren(t);\n                    break;\n\n                case GroovyTokenTypes.LITERAL_if: // if (grandchild) {child1} else {child2} ...\n                    accept_v_FirstChildsFirstChild_v_Child2_Child3_v_Child4_v___v_LastChild(t);\n                    break;\n\n                case GroovyTokenTypes.CLOSABLE_BLOCK: // [1,2,3].each {foo(it)}  <-- Closure\n                    if (t.childAt(0) != null && t.childAt(0).getType() == GroovyTokenTypes.IMPLICIT_PARAMETERS) {\n                        accept_v_AllChildren_v(t);\n                    } else {\n                        accept_v_FirstChild_v_RestOfTheChildren_v(t);\n                    }\n                    break;\n\n                case GroovyTokenTypes.FOR_IN_ITERABLE:\n                case GroovyTokenTypes.LITERAL_for:\n                case GroovyTokenTypes.LITERAL_new:\n                case GroovyTokenTypes.LITERAL_switch:\n                    accept_v_FirstChild_v_RestOfTheChildren_v(t);\n                    break;\n \n                case GroovyTokenTypes.ANNOTATIONS: // just like modifiers but for package/enum declarations\n                case GroovyTokenTypes.LITERAL_assert:\n                case GroovyTokenTypes.LITERAL_catch:\n                case GroovyTokenTypes.LITERAL_synchronized:\n                case GroovyTokenTypes.LITERAL_try:\n                case GroovyTokenTypes.MODIFIERS:\n                    accept_v_FirstChild_v_RestOfTheChildren(t);\n                    break;\n                    \n                case GroovyTokenTypes.WILDCARD_TYPE:\n                    accept_v_Siblings_v(t);\n                    break;\n\n                default:\n                    accept_v_FirstChild_v(t);\n                    break;\n            }\n            pop();\n        }\n    }",
            "  75  \n  76 +\n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  ",
            "    protected void accept(GroovySourceAST currentNode) {\n        if (currentNode != null && unvisitedNodes != null && !unvisitedNodes.isEmpty()) {\n            GroovySourceAST t = currentNode;\n\n            if (!(unvisitedNodes.contains(currentNode))) {\n                return;\n            }\n            push(t);\n            switch (t.getType()) {\n                case GroovyTokenTypes.QUESTION: // expr?foo:bar\n                    accept_FirstChild_v_SecondChild_v_ThirdChild_v(t);\n                    break;\n\n                case GroovyTokenTypes.CASE_GROUP: //\n                case GroovyTokenTypes.LITERAL_instanceof: // foo instanceof MyType\n                    accept_FirstChild_v_SecondChildsChildren_v(t);\n                    break;\n\n                case GroovyTokenTypes.ANNOTATION:\n                    accept_v_FirstChild_2ndv_SecondChild_v___LastChild_v(t);\n                    break;\n\n                case GroovyTokenTypes.CLOSURE_LIST: // (a=1; a<10; a++)\n                case GroovyTokenTypes.ELIST: // a,b,c\n                case GroovyTokenTypes.PARAMETERS: // a,b,c\n                case GroovyTokenTypes.TYPE_ARGUMENTS: // <String, Object>\n                case GroovyTokenTypes.STRING_CONSTRUCTOR: // \"foo${bar}wibble\"\n                case GroovyTokenTypes.TYPE_PARAMETER: // class Foo<T extends F>\n                case GroovyTokenTypes.TYPE_PARAMETERS: // class Foo<T>\n                case GroovyTokenTypes.TYPE_UPPER_BOUNDS: // class Foo<T extends F>\n                    accept_v_FirstChild_v_SecondChild_v___LastChild_v(t);\n                    // todo : confirm that TYPE_LOWER_BOUNDS does not have multiple children\n                    break;\n\n                case GroovyTokenTypes.VARIABLE_PARAMETER_DEF: // void f(String ... others) {}\n                    accept_v_FirstChild_SecondChild_v_ThirdChild_v(t);\n                    break;\n\n                case GroovyTokenTypes.INDEX_OP:\n                    //accept_FirstChild_v_SecondChild_v(t);\n                    accept_SecondChild_v_ThirdChild_v(t);\n                    break;\n\n                case GroovyTokenTypes.ENUM_CONSTANT_DEF: // enum Foo(THESE,ARE,THEY)\n                case GroovyTokenTypes.EXPR:\n                case GroovyTokenTypes.IMPORT:\n                case GroovyTokenTypes.STATIC_IMPORT:\n                case GroovyTokenTypes.VARIABLE_DEF:\n                case GroovyTokenTypes.METHOD_DEF:\n                case GroovyTokenTypes.OBJBLOCK: //class Foo {def bar()}  <-- this block\n                case GroovyTokenTypes.PARAMETER_DEF: // void f(String me) {}\n                case GroovyTokenTypes.SLIST: // list of expressions, variable defs etc\n                    accept_v_AllChildren_v(t);\n                    break;\n\n                case GroovyTokenTypes.ANNOTATION_MEMBER_VALUE_PAIR: // @Blue(foo=123)\n                case GroovyTokenTypes.ASSIGN: // a = b\n                case GroovyTokenTypes.BAND_ASSIGN: // a &= b\n                case GroovyTokenTypes.BOR_ASSIGN: // a |= b\n                case GroovyTokenTypes.BSR_ASSIGN: // a >>>= b\n                case GroovyTokenTypes.BXOR_ASSIGN: // a ^= b\n                case GroovyTokenTypes.COMPARE_TO: // a <=> b\n                case GroovyTokenTypes.DIV_ASSIGN: // a /= b\n                case GroovyTokenTypes.EQUAL: // a == b\n                case GroovyTokenTypes.MINUS_ASSIGN: // a -= b\n                case GroovyTokenTypes.MOD_ASSIGN: // a %= b\n                case GroovyTokenTypes.NOT_EQUAL: // a != b\n                case GroovyTokenTypes.PLUS_ASSIGN: // a += b\n                case GroovyTokenTypes.REGEX_FIND: // a =~ b\n                case GroovyTokenTypes.REGEX_MATCH: // a ==~ b\n                case GroovyTokenTypes.SL_ASSIGN: // a <<= b\n                case GroovyTokenTypes.SR_ASSIGN: // a >>= b\n                case GroovyTokenTypes.STAR_ASSIGN: // a *= b\n                case GroovyTokenTypes.STAR_STAR_ASSIGN: // x **= 3\n                    if (t.childAt(1) != null) {\n                        accept_FirstChild_v_RestOfTheChildren(t);\n                    } else {\n                        accept_v_FirstChild_v_RestOfTheChildren(t);\n                    }\n                    break;\n\n                case GroovyTokenTypes.ANNOTATION_FIELD_DEF: // @interface Foo{ int bar()...\n                    accept_FirstSecondAndThirdChild_v_v_ForthChild(t);\n                    break;\n                    \n                case GroovyTokenTypes.ANNOTATION_DEF: // @interface Foo...\n                case GroovyTokenTypes.BAND: // 1 & 2\n                case GroovyTokenTypes.BOR: // 1 | 2\n                case GroovyTokenTypes.BSR: // 1 >>> 2\n                case GroovyTokenTypes.BXOR: // 1 ^ 2\n                case GroovyTokenTypes.CLASS_DEF: // class Foo...\n                case GroovyTokenTypes.CTOR_IDENT: // private Foo() {...\n                case GroovyTokenTypes.DIV: //  3/4\n                case GroovyTokenTypes.DOT: // foo.bar\n                case GroovyTokenTypes.ENUM_DEF: // enum Foo...\n                case GroovyTokenTypes.GE: // a >= b\n                case GroovyTokenTypes.GT: // a > b\n                case GroovyTokenTypes.INTERFACE_DEF: // interface Foo...\n                case GroovyTokenTypes.LABELED_ARG: // myMethod(name:\"Jez\")\n                case GroovyTokenTypes.LABELED_STAT: // foo:x=1                        \n                case GroovyTokenTypes.LAND: // true && false\n                case GroovyTokenTypes.LE: // a <= b\n                case GroovyTokenTypes.LITERAL_as: // foo as Bar\n                case GroovyTokenTypes.LITERAL_in: // if (i in myList) ...\n                case GroovyTokenTypes.LOR: // true && false\n                case GroovyTokenTypes.LT: // a < b\n                case GroovyTokenTypes.MEMBER_POINTER: // this.&foo()\n                case GroovyTokenTypes.MOD: //  4 % 3\n                case GroovyTokenTypes.MINUS: // 1 - 1\n                case GroovyTokenTypes.OPTIONAL_DOT: // foo?.bar\n                case GroovyTokenTypes.PACKAGE_DEF:\n                case GroovyTokenTypes.PLUS: // 1 + 1\n                case GroovyTokenTypes.RANGE_EXCLUSIVE: // [1..<10]\n                case GroovyTokenTypes.RANGE_INCLUSIVE: // [1..10]\n                case GroovyTokenTypes.SL: // a << b\n                case GroovyTokenTypes.SPREAD_DOT: // foo*.bar\n                case GroovyTokenTypes.SR: // a >> b\n                case GroovyTokenTypes.STAR: // a * b   or    import foo.*\n                case GroovyTokenTypes.STAR_STAR: // x ** 3\n                case GroovyTokenTypes.TRAIT_DEF: // trait Foo...\n                    accept_FirstChild_v_RestOfTheChildren(t);\n                    break;\n\n                case GroovyTokenTypes.CTOR_CALL:\n                case GroovyTokenTypes.METHOD_CALL:\n                    if (t.getNumberOfChildren() == 2 && t.childAt(1) != null && t.childAt(1).getType() == GroovyTokenTypes.CLOSABLE_BLOCK) {\n                        // myMethod {...\n                        accept_FirstChild_v_SecondChild(t);\n                    } else {\n                        GroovySourceAST lastChild = t.childAt(t.getNumberOfChildren() -1);\n                        if (lastChild != null && lastChild.getType() == GroovyTokenTypes.CLOSABLE_BLOCK) {\n                            // myMethod(a,b) {...\n                            accept_FirstChild_v_RestOfTheChildren_v_LastChild(t);\n                        } else {\n                            // myMethod(a,b)\n                            accept_FirstChild_v_RestOfTheChildren_v(t);\n                        }\n                    }\n                    break;\n\n                case GroovyTokenTypes.LITERAL_while:\n//deprecated                case GroovyTokenTypes.LITERAL_with:\n                case GroovyTokenTypes.TYPECAST: // (String)itr.next()\n                    accept_v_FirstChildsFirstChild_v_RestOfTheChildren(t);\n                    break;\n\n                case GroovyTokenTypes.LITERAL_if: // if (grandchild) {child1} else {child2} ...\n                    accept_v_FirstChildsFirstChild_v_Child2_Child3_v_Child4_v___v_LastChild(t);\n                    break;\n\n                case GroovyTokenTypes.CLOSABLE_BLOCK: // [1,2,3].each {foo(it)}  <-- Closure\n                    if (t.childAt(0) != null && t.childAt(0).getType() == GroovyTokenTypes.IMPLICIT_PARAMETERS) {\n                        accept_v_AllChildren_v(t);\n                    } else {\n                        accept_v_FirstChild_v_RestOfTheChildren_v(t);\n                    }\n                    break;\n\n                case GroovyTokenTypes.FOR_IN_ITERABLE:\n                case GroovyTokenTypes.LITERAL_for:\n                case GroovyTokenTypes.LITERAL_new:\n                case GroovyTokenTypes.LITERAL_switch:\n                    accept_v_FirstChild_v_RestOfTheChildren_v(t);\n                    break;\n \n                case GroovyTokenTypes.ANNOTATIONS: // just like modifiers but for package/enum declarations\n                case GroovyTokenTypes.LITERAL_assert:\n                case GroovyTokenTypes.LITERAL_catch:\n                case GroovyTokenTypes.LITERAL_synchronized:\n                case GroovyTokenTypes.LITERAL_try:\n                case GroovyTokenTypes.MODIFIERS:\n                    accept_v_FirstChild_v_RestOfTheChildren(t);\n                    break;\n                    \n                case GroovyTokenTypes.WILDCARD_TYPE:\n                    accept_v_Siblings_v(t);\n                    break;\n\n                default:\n                    accept_v_FirstChild_v(t);\n                    break;\n            }\n            pop();\n        }\n    }"
        ],
        [
            "DefaultGroovyMethods::collate(Iterable,int,int,boolean)",
            "3033  \n3034  \n3035  \n3036  \n3037  \n3038  \n3039  \n3040  \n3041  \n3042  \n3043  \n3044  \n3045  \n3046  \n3047  \n3048  \n3049  \n3050  \n3051  \n3052  \n3053  \n3054  \n3055 -\n3056  \n3057  \n3058  \n3059  \n3060  \n3061  \n3062  \n3063  \n3064  \n3065  \n3066  \n3067  \n3068  \n3069  \n3070  ",
            "    /**\n     * Collates this iterable into sub-lists of length <code>size</code> stepping through the code <code>step</code>\n     * elements for each sub-list.  Any remaining elements in the iterable after the subdivision will be dropped if\n     * <code>keepRemainder</code> is false.\n     * Example:\n     * <pre class=\"groovyTestCase\">\n     * def list = [ 1, 2, 3, 4 ]\n     * assert list.collate( 2, 2, true  ) == [ [ 1, 2 ], [ 3, 4 ] ]\n     * assert list.collate( 3, 1, true  ) == [ [ 1, 2, 3 ], [ 2, 3, 4 ], [ 3, 4 ], [ 4 ] ]\n     * assert list.collate( 3, 1, false ) == [ [ 1, 2, 3 ], [ 2, 3, 4 ] ]\n     * </pre>\n     *\n     * @param self          an Iterable\n     * @param size          the length of each sub-list in the returned list\n     * @param step          the number of elements to step through for each sub-list\n     * @param keepRemainder if true, any remaining elements are returned as sub-lists.  Otherwise they are discarded\n     * @return a List containing the data collated into sub-lists\n     * @since 2.4.0\n     */\n    public static <T> List<List<T>> collate(Iterable<T> self, int size, int step, boolean keepRemainder) {\n        List<T> selfList = asList(self);\n        List<List<T>> answer = new ArrayList<List<T>>();\n        if (size <= 0 || selfList.size() == 0) {\n            answer.add(selfList);\n        } else {\n            for (int pos = 0; pos < selfList.size() && pos > -1; pos += step) {\n                if (!keepRemainder && pos > selfList.size() - size) {\n                    break ;\n                }\n                List<T> element = new ArrayList<T>() ;\n                for (int offs = pos; offs < pos + size && offs < selfList.size(); offs++) {\n                    element.add(selfList.get(offs));\n                }\n                answer.add( element ) ;\n            }\n        }\n        return answer ;\n    }",
            "3033  \n3034  \n3035  \n3036  \n3037  \n3038  \n3039  \n3040  \n3041  \n3042  \n3043  \n3044  \n3045  \n3046  \n3047  \n3048  \n3049  \n3050  \n3051  \n3052  \n3053  \n3054  \n3055 +\n3056  \n3057  \n3058  \n3059  \n3060  \n3061  \n3062  \n3063  \n3064  \n3065  \n3066  \n3067  \n3068  \n3069  \n3070  ",
            "    /**\n     * Collates this iterable into sub-lists of length <code>size</code> stepping through the code <code>step</code>\n     * elements for each sub-list.  Any remaining elements in the iterable after the subdivision will be dropped if\n     * <code>keepRemainder</code> is false.\n     * Example:\n     * <pre class=\"groovyTestCase\">\n     * def list = [ 1, 2, 3, 4 ]\n     * assert list.collate( 2, 2, true  ) == [ [ 1, 2 ], [ 3, 4 ] ]\n     * assert list.collate( 3, 1, true  ) == [ [ 1, 2, 3 ], [ 2, 3, 4 ], [ 3, 4 ], [ 4 ] ]\n     * assert list.collate( 3, 1, false ) == [ [ 1, 2, 3 ], [ 2, 3, 4 ] ]\n     * </pre>\n     *\n     * @param self          an Iterable\n     * @param size          the length of each sub-list in the returned list\n     * @param step          the number of elements to step through for each sub-list\n     * @param keepRemainder if true, any remaining elements are returned as sub-lists.  Otherwise they are discarded\n     * @return a List containing the data collated into sub-lists\n     * @since 2.4.0\n     */\n    public static <T> List<List<T>> collate(Iterable<T> self, int size, int step, boolean keepRemainder) {\n        List<T> selfList = asList(self);\n        List<List<T>> answer = new ArrayList<List<T>>();\n        if (size <= 0 || selfList.isEmpty()) {\n            answer.add(selfList);\n        } else {\n            for (int pos = 0; pos < selfList.size() && pos > -1; pos += step) {\n                if (!keepRemainder && pos > selfList.size() - size) {\n                    break ;\n                }\n                List<T> element = new ArrayList<T>() ;\n                for (int offs = pos; offs < pos + size && offs < selfList.size(); offs++) {\n                    element.add(selfList.get(offs));\n                }\n                answer.add( element ) ;\n            }\n        }\n        return answer ;\n    }"
        ],
        [
            "Groovydoc::parsePackages(List,Path)",
            " 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344 -\n 345  \n 346  \n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  \n 423  \n 424  \n 425  \n 426  \n 427  \n 428  ",
            "    /**\n     * Add the directories matched by the nested dirsets to the resulting\n     * packages list and the base directories of the dirsets to the Path.\n     * It also handles the packages and excludepackages attributes and\n     * elements.\n     *\n     * @param resultantPackages a list to which we add the packages found\n     * @param sourcePath a path to which we add each basedir found\n     * @since 1.5\n     */\n    private void parsePackages(List<String> resultantPackages, Path sourcePath) {\n        List<String> addedPackages = new ArrayList<String>();\n        List<DirSet> dirSets = new ArrayList<DirSet>(packageSets);\n\n        // for each sourcePath entry, add a directoryset with includes\n        // taken from packagenames attribute and nested package\n        // elements and excludes taken from excludepackages attribute\n        // and nested excludepackage elements\n        if (this.sourcePath != null) {\n            PatternSet ps = new PatternSet();\n            if (packageNames.size() > 0) {\n                for (String pn : packageNames) {\n                    String pkg = pn.replace('.', '/');\n                    if (pkg.endsWith(\"*\")) {\n                        pkg += \"*\";\n                    }\n                    ps.createInclude().setName(pkg);\n                }\n            } else {\n                ps.createInclude().setName(\"**\");\n            }\n\n            for (String epn : excludePackageNames) {\n                String pkg = epn.replace('.', '/');\n                if (pkg.endsWith(\"*\")) {\n                    pkg += \"*\";\n                }\n                ps.createExclude().setName(pkg);\n            }\n\n            String[] pathElements = this.sourcePath.list();\n            for (String pathElement : pathElements) {\n                File dir = new File(pathElement);\n                if (dir.isDirectory()) {\n                    DirSet ds = new DirSet();\n                    ds.setDefaultexcludes(useDefaultExcludes);\n                    ds.setDir(dir);\n                    ds.createPatternSet().addConfiguredPatternset(ps);\n                    dirSets.add(ds);\n                } else {\n                    log.warn(\"Skipping \" + pathElement + \" since it is no directory.\");\n                }\n            }\n        }\n\n        for (DirSet ds : dirSets) {\n            File baseDir = ds.getDir(getProject());\n            log.debug(\"scanning \" + baseDir + \" for packages.\");\n            DirectoryScanner dsc = ds.getDirectoryScanner(getProject());\n            String[] dirs = dsc.getIncludedDirectories();\n            boolean containsPackages = false;\n            for (String dir : dirs) {\n                // are there any groovy or java files in this directory?\n                File pd = new File(baseDir, dir);\n                String[] files = pd.list(new FilenameFilter() {\n                    public boolean accept(File dir1, String name) {\n                        if (!includeNoSourcePackages\n                                && name.equals(\"package.html\")) return true;\n                        final StringTokenizer tokenizer = new StringTokenizer(extensions, \":\");\n                        while (tokenizer.hasMoreTokens()) {\n                            String ext = tokenizer.nextToken();\n                            if (name.endsWith(ext)) return true;\n                        }\n                        return false;\n                    }\n                });\n\n                for (String filename : Arrays.asList(files)) {\n                    sourceFilesToDoc.add(dir + File.separator + filename);\n                }\n\n                if (files.length > 0) {\n                    if (\"\".equals(dir)) {\n                        log.warn(baseDir\n                                + \" contains source files in the default package,\"\n                                + \" you must specify them as source files not packages.\");\n                    } else {\n                        containsPackages = true;\n                        String pn = dir.replace(File.separatorChar, '.');\n                        if (!addedPackages.contains(pn)) {\n                            addedPackages.add(pn);\n                            resultantPackages.add(pn);\n                        }\n                    }\n                }\n            }\n            if (containsPackages) {\n                // We don't need to care for duplicates here,\n                // Path.list does it for us.\n                sourcePath.createPathElement().setLocation(baseDir);\n            } else {\n                log.verbose(baseDir + \" doesn't contain any packages, dropping it.\");\n            }\n        }\n    }",
            " 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344 +\n 345  \n 346  \n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  \n 423  \n 424  \n 425  \n 426  \n 427  \n 428  ",
            "    /**\n     * Add the directories matched by the nested dirsets to the resulting\n     * packages list and the base directories of the dirsets to the Path.\n     * It also handles the packages and excludepackages attributes and\n     * elements.\n     *\n     * @param resultantPackages a list to which we add the packages found\n     * @param sourcePath a path to which we add each basedir found\n     * @since 1.5\n     */\n    private void parsePackages(List<String> resultantPackages, Path sourcePath) {\n        List<String> addedPackages = new ArrayList<String>();\n        List<DirSet> dirSets = new ArrayList<DirSet>(packageSets);\n\n        // for each sourcePath entry, add a directoryset with includes\n        // taken from packagenames attribute and nested package\n        // elements and excludes taken from excludepackages attribute\n        // and nested excludepackage elements\n        if (this.sourcePath != null) {\n            PatternSet ps = new PatternSet();\n            if (!packageNames.isEmpty()) {\n                for (String pn : packageNames) {\n                    String pkg = pn.replace('.', '/');\n                    if (pkg.endsWith(\"*\")) {\n                        pkg += \"*\";\n                    }\n                    ps.createInclude().setName(pkg);\n                }\n            } else {\n                ps.createInclude().setName(\"**\");\n            }\n\n            for (String epn : excludePackageNames) {\n                String pkg = epn.replace('.', '/');\n                if (pkg.endsWith(\"*\")) {\n                    pkg += \"*\";\n                }\n                ps.createExclude().setName(pkg);\n            }\n\n            String[] pathElements = this.sourcePath.list();\n            for (String pathElement : pathElements) {\n                File dir = new File(pathElement);\n                if (dir.isDirectory()) {\n                    DirSet ds = new DirSet();\n                    ds.setDefaultexcludes(useDefaultExcludes);\n                    ds.setDir(dir);\n                    ds.createPatternSet().addConfiguredPatternset(ps);\n                    dirSets.add(ds);\n                } else {\n                    log.warn(\"Skipping \" + pathElement + \" since it is no directory.\");\n                }\n            }\n        }\n\n        for (DirSet ds : dirSets) {\n            File baseDir = ds.getDir(getProject());\n            log.debug(\"scanning \" + baseDir + \" for packages.\");\n            DirectoryScanner dsc = ds.getDirectoryScanner(getProject());\n            String[] dirs = dsc.getIncludedDirectories();\n            boolean containsPackages = false;\n            for (String dir : dirs) {\n                // are there any groovy or java files in this directory?\n                File pd = new File(baseDir, dir);\n                String[] files = pd.list(new FilenameFilter() {\n                    public boolean accept(File dir1, String name) {\n                        if (!includeNoSourcePackages\n                                && name.equals(\"package.html\")) return true;\n                        final StringTokenizer tokenizer = new StringTokenizer(extensions, \":\");\n                        while (tokenizer.hasMoreTokens()) {\n                            String ext = tokenizer.nextToken();\n                            if (name.endsWith(ext)) return true;\n                        }\n                        return false;\n                    }\n                });\n\n                for (String filename : Arrays.asList(files)) {\n                    sourceFilesToDoc.add(dir + File.separator + filename);\n                }\n\n                if (files.length > 0) {\n                    if (\"\".equals(dir)) {\n                        log.warn(baseDir\n                                + \" contains source files in the default package,\"\n                                + \" you must specify them as source files not packages.\");\n                    } else {\n                        containsPackages = true;\n                        String pn = dir.replace(File.separatorChar, '.');\n                        if (!addedPackages.contains(pn)) {\n                            addedPackages.add(pn);\n                            resultantPackages.add(pn);\n                        }\n                    }\n                }\n            }\n            if (containsPackages) {\n                // We don't need to care for duplicates here,\n                // Path.list does it for us.\n                sourcePath.createPathElement().setLocation(baseDir);\n            } else {\n                log.verbose(baseDir + \" doesn't contain any packages, dropping it.\");\n            }\n        }\n    }"
        ],
        [
            "AbstractASTTransformation::hasAnnotation(ClassNode,ClassNode)",
            " 249  \n 250  \n 251 -\n 252  ",
            "    public boolean hasAnnotation(ClassNode cNode, ClassNode annotation) {\r\n        List annots = cNode.getAnnotations(annotation);\r\n        return (annots != null && annots.size() > 0);\r\n    }\r",
            " 249  \n 250  \n 251 +\n 252  ",
            "    public boolean hasAnnotation(ClassNode cNode, ClassNode annotation) {\r\n        List annots = cNode.getAnnotations(annotation);\r\n        return (annots != null && !annots.isEmpty());\n    }\r"
        ],
        [
            "AnnotationCollectorTransform::getTargetListFromValue(AnnotationNode,AnnotationNode,SourceUnit)",
            " 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170 -\n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  ",
            "    private List<AnnotationNode> getTargetListFromValue(AnnotationNode collector, AnnotationNode aliasAnnotationUsage, SourceUnit source) {\n        Expression memberValue = collector.getMember(\"value\");\n        if (memberValue == null) return Collections.EMPTY_LIST;\n        if (!(memberValue instanceof ListExpression)) {\n            addError(\"Annotation collector expected a list of classes, but got a \"+memberValue.getClass(), collector, source);\n            return Collections.EMPTY_LIST;\n        }\n        ListExpression memberListExp = (ListExpression) memberValue;\n        List<Expression> memberList = memberListExp.getExpressions();\n        if (memberList.size()==0) return Collections.EMPTY_LIST;\n        List<AnnotationNode> ret = new ArrayList<AnnotationNode>();\n        for (Expression e : memberList) {\n            AnnotationNode toAdd = new AnnotationNode(e.getType());\n            toAdd.setSourcePosition(aliasAnnotationUsage);\n            ret.add(toAdd);\n        }\n        return ret;\n    }",
            " 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170 +\n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  ",
            "    private List<AnnotationNode> getTargetListFromValue(AnnotationNode collector, AnnotationNode aliasAnnotationUsage, SourceUnit source) {\n        Expression memberValue = collector.getMember(\"value\");\n        if (memberValue == null) return Collections.EMPTY_LIST;\n        if (!(memberValue instanceof ListExpression)) {\n            addError(\"Annotation collector expected a list of classes, but got a \"+memberValue.getClass(), collector, source);\n            return Collections.EMPTY_LIST;\n        }\n        ListExpression memberListExp = (ListExpression) memberValue;\n        List<Expression> memberList = memberListExp.getExpressions();\n        if (memberList.isEmpty()) return Collections.EMPTY_LIST;\n        List<AnnotationNode> ret = new ArrayList<AnnotationNode>();\n        for (Expression e : memberList) {\n            AnnotationNode toAdd = new AnnotationNode(e.getType());\n            toAdd.setSourcePosition(aliasAnnotationUsage);\n            ret.add(toAdd);\n        }\n        return ret;\n    }"
        ],
        [
            "AnnotationVisitor::getAttributeType(AnnotationNode,String)",
            " 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172 -\n 173  \n 174  \n 175  \n 176  \n 177  \n 178  ",
            "    private ClassNode getAttributeType(AnnotationNode node, String attrName) {\r\n        ClassNode classNode = node.getClassNode();\r\n        List methods = classNode.getMethods(attrName);\r\n        // if size is >1, then the method was overwritten or something, we ignore that\r\n        // if it is an error, we have to test it at another place. But size==0 is\r\n        // an error, because it means that no such attribute exists.\r\n        if (methods.size() == 0) {\r\n            addError(\"'\" + attrName + \"'is not part of the annotation \" + classNode, node);\r\n            return ClassHelper.OBJECT_TYPE;\r\n        }\r\n        MethodNode method = (MethodNode) methods.get(0);\r\n        return method.getReturnType();\r\n    }\r",
            " 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172 +\n 173  \n 174  \n 175  \n 176  \n 177  \n 178  ",
            "    private ClassNode getAttributeType(AnnotationNode node, String attrName) {\r\n        ClassNode classNode = node.getClassNode();\r\n        List methods = classNode.getMethods(attrName);\r\n        // if size is >1, then the method was overwritten or something, we ignore that\r\n        // if it is an error, we have to test it at another place. But size==0 is\r\n        // an error, because it means that no such attribute exists.\r\n        if (methods.isEmpty()) {\n            addError(\"'\" + attrName + \"'is not part of the annotation \" + classNode, node);\r\n            return ClassHelper.OBJECT_TYPE;\r\n        }\r\n        MethodNode method = (MethodNode) methods.get(0);\r\n        return method.getReturnType();\r\n    }\r"
        ],
        [
            "FactoryBuilderSupport::dispatchNodeCall(Object,Object)",
            " 814  \n 815  \n 816  \n 817  \n 818  \n 819  \n 820  \n 821  \n 822  \n 823  \n 824  \n 825  \n 826  \n 827  \n 828  \n 829  \n 830  \n 831  \n 832  \n 833  \n 834  \n 835  \n 836  \n 837  \n 838  \n 839 -\n 840  \n 841  \n 842  \n 843  \n 844 -\n 845  \n 846  \n 847  \n 848  \n 849  \n 850 -\n 851  \n 852  \n 853  \n 854  \n 855  \n 856  \n 857  \n 858  \n 859  \n 860  \n 861  \n 862  \n 863  \n 864  \n 865  \n 866  \n 867  \n 868  \n 869  \n 870  \n 871  \n 872  \n 873  \n 874  \n 875  \n 876  \n 877  \n 878  \n 879  \n 880  \n 881  \n 882  \n 883  \n 884  \n 885  \n 886  \n 887  \n 888  \n 889  \n 890  \n 891  \n 892  \n 893  \n 894  \n 895  \n 896  \n 897  \n 898  \n 899  \n 900  \n 901  \n 902  \n 903  \n 904  \n 905  ",
            "    protected Object dispatchNodeCall(Object name, Object args) {\n        Object node;\n        Closure closure = null;\n        List list = InvokerHelper.asList(args);\n\n        final boolean needToPopContext;\n        if (getProxyBuilder().getContexts().isEmpty()) {\n            // should be called on first build method only\n            getProxyBuilder().newContext();\n            needToPopContext = true;\n        } else {\n            needToPopContext = false;\n        }\n\n        try {\n            Map namedArgs = Collections.EMPTY_MAP;\n\n            // the arguments come in like [named_args?, args..., closure?]\n            // so peel off a hashmap from the front, and a closure from the\n            // end and presume that is what they meant, since there is\n            // no way to distinguish node(a:b,c,d) {..} from\n            // node([a:b],[c,d], {..}), i.e. the user can deliberately confuse\n            // the builder and there is nothing we can really do to prevent\n            // that\n\n            if ((list.size() > 0)\n                    && (list.get(0) instanceof LinkedHashMap)) {\n                namedArgs = (Map) list.get(0);\n                list = list.subList(1, list.size());\n            }\n            if ((list.size() > 0)\n                    && (list.get(list.size() - 1) instanceof Closure)) {\n                closure = (Closure) list.get(list.size() - 1);\n                list = list.subList(0, list.size() - 1);\n            }\n            Object arg;\n            if (list.size() == 0) {\n                arg = null;\n            } else if (list.size() == 1) {\n                arg = list.get(0);\n            } else {\n                arg = list;\n            }\n            node = getProxyBuilder().createNode(name, namedArgs, arg);\n\n            Object current = getProxyBuilder().getCurrent();\n            if (current != null) {\n                getProxyBuilder().setParent(current, node);\n            }\n\n            if (closure != null) {\n                Factory parentFactory = getProxyBuilder().getCurrentFactory();\n                if (parentFactory.isLeaf()) {\n                    throw new RuntimeException(\"'\" + name + \"' doesn't support nesting.\");\n                }\n                boolean processContent = true;\n                if (parentFactory.isHandlesNodeChildren()) {\n                    processContent = parentFactory.onNodeChildren(this, node, closure);\n                }\n                if (processContent) {\n                    // push new node on stack\n                    String parentName = getProxyBuilder().getCurrentName();\n                    Map parentContext = getProxyBuilder().getContext();\n                    getProxyBuilder().newContext();\n                    try {\n                        getProxyBuilder().getContext().put(OWNER, closure.getOwner());\n                        getProxyBuilder().getContext().put(CURRENT_NODE, node);\n                        getProxyBuilder().getContext().put(PARENT_FACTORY, parentFactory);\n                        getProxyBuilder().getContext().put(PARENT_NODE, current);\n                        getProxyBuilder().getContext().put(PARENT_CONTEXT, parentContext);\n                        getProxyBuilder().getContext().put(PARENT_NAME, parentName);\n                        getProxyBuilder().getContext().put(PARENT_BUILDER, parentContext.get(CURRENT_BUILDER));\n                        getProxyBuilder().getContext().put(CURRENT_BUILDER, parentContext.get(CHILD_BUILDER));\n                        // lets register the builder as the delegate\n                        getProxyBuilder().setClosureDelegate(closure, node);\n                        closure.call();\n                    } finally {\n                        getProxyBuilder().popContext();\n                    }\n                }\n            }\n\n            getProxyBuilder().nodeCompleted(current, node);\n            node = getProxyBuilder().postNodeCompletion(current, node);\n        } finally {\n            if (needToPopContext) {\n                // pop the first context\n                getProxyBuilder().popContext();\n            }\n        }\n        return node;\n    }",
            " 814  \n 815  \n 816  \n 817  \n 818  \n 819  \n 820  \n 821  \n 822  \n 823  \n 824  \n 825  \n 826  \n 827  \n 828  \n 829  \n 830  \n 831  \n 832  \n 833  \n 834  \n 835  \n 836  \n 837  \n 838  \n 839 +\n 840  \n 841  \n 842  \n 843  \n 844 +\n 845  \n 846  \n 847  \n 848  \n 849  \n 850 +\n 851  \n 852  \n 853  \n 854  \n 855  \n 856  \n 857  \n 858  \n 859  \n 860  \n 861  \n 862  \n 863  \n 864  \n 865  \n 866  \n 867  \n 868  \n 869  \n 870  \n 871  \n 872  \n 873  \n 874  \n 875  \n 876  \n 877  \n 878  \n 879  \n 880  \n 881  \n 882  \n 883  \n 884  \n 885  \n 886  \n 887  \n 888  \n 889  \n 890  \n 891  \n 892  \n 893  \n 894  \n 895  \n 896  \n 897  \n 898  \n 899  \n 900  \n 901  \n 902  \n 903  \n 904  \n 905  ",
            "    protected Object dispatchNodeCall(Object name, Object args) {\n        Object node;\n        Closure closure = null;\n        List list = InvokerHelper.asList(args);\n\n        final boolean needToPopContext;\n        if (getProxyBuilder().getContexts().isEmpty()) {\n            // should be called on first build method only\n            getProxyBuilder().newContext();\n            needToPopContext = true;\n        } else {\n            needToPopContext = false;\n        }\n\n        try {\n            Map namedArgs = Collections.EMPTY_MAP;\n\n            // the arguments come in like [named_args?, args..., closure?]\n            // so peel off a hashmap from the front, and a closure from the\n            // end and presume that is what they meant, since there is\n            // no way to distinguish node(a:b,c,d) {..} from\n            // node([a:b],[c,d], {..}), i.e. the user can deliberately confuse\n            // the builder and there is nothing we can really do to prevent\n            // that\n\n            if ((!list.isEmpty())\n                    && (list.get(0) instanceof LinkedHashMap)) {\n                namedArgs = (Map) list.get(0);\n                list = list.subList(1, list.size());\n            }\n            if ((!list.isEmpty())\n                    && (list.get(list.size() - 1) instanceof Closure)) {\n                closure = (Closure) list.get(list.size() - 1);\n                list = list.subList(0, list.size() - 1);\n            }\n            Object arg;\n            if (list.isEmpty()) {\n                arg = null;\n            } else if (list.size() == 1) {\n                arg = list.get(0);\n            } else {\n                arg = list;\n            }\n            node = getProxyBuilder().createNode(name, namedArgs, arg);\n\n            Object current = getProxyBuilder().getCurrent();\n            if (current != null) {\n                getProxyBuilder().setParent(current, node);\n            }\n\n            if (closure != null) {\n                Factory parentFactory = getProxyBuilder().getCurrentFactory();\n                if (parentFactory.isLeaf()) {\n                    throw new RuntimeException(\"'\" + name + \"' doesn't support nesting.\");\n                }\n                boolean processContent = true;\n                if (parentFactory.isHandlesNodeChildren()) {\n                    processContent = parentFactory.onNodeChildren(this, node, closure);\n                }\n                if (processContent) {\n                    // push new node on stack\n                    String parentName = getProxyBuilder().getCurrentName();\n                    Map parentContext = getProxyBuilder().getContext();\n                    getProxyBuilder().newContext();\n                    try {\n                        getProxyBuilder().getContext().put(OWNER, closure.getOwner());\n                        getProxyBuilder().getContext().put(CURRENT_NODE, node);\n                        getProxyBuilder().getContext().put(PARENT_FACTORY, parentFactory);\n                        getProxyBuilder().getContext().put(PARENT_NODE, current);\n                        getProxyBuilder().getContext().put(PARENT_CONTEXT, parentContext);\n                        getProxyBuilder().getContext().put(PARENT_NAME, parentName);\n                        getProxyBuilder().getContext().put(PARENT_BUILDER, parentContext.get(CURRENT_BUILDER));\n                        getProxyBuilder().getContext().put(CURRENT_BUILDER, parentContext.get(CHILD_BUILDER));\n                        // lets register the builder as the delegate\n                        getProxyBuilder().setClosureDelegate(closure, node);\n                        closure.call();\n                    } finally {\n                        getProxyBuilder().popContext();\n                    }\n                }\n            }\n\n            getProxyBuilder().nodeCompleted(current, node);\n            node = getProxyBuilder().postNodeCompletion(current, node);\n        } finally {\n            if (needToPopContext) {\n                // pop the first context\n                getProxyBuilder().popContext();\n            }\n        }\n        return node;\n    }"
        ],
        [
            "NotYetImplementedASTTransformation::visit(ASTNode,SourceUnit)",
            "  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69 -\n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  ",
            "    public void visit(ASTNode[] nodes, SourceUnit source) {\n        if (nodes.length != 2 || !(nodes[0] instanceof AnnotationNode) || !(nodes[1] instanceof AnnotatedNode)) {\n            throw new RuntimeException(\"Internal error: expecting [AnnotationNode, AnnotatedNode] but got: \" + Arrays.asList(nodes));\n        }\n\n        AnnotationNode annotationNode = (AnnotationNode) nodes[0];\n        ASTNode node = nodes[1];\n\n        if (!(node instanceof MethodNode))  {\n            addError(\"@NotYetImplemented must only be applied on test methods!\",node);\n            return;\n        }\n\n        MethodNode methodNode = (MethodNode) node;\n\n        ArrayList<Statement> statements = new ArrayList<Statement>();\n        Statement statement = methodNode.getCode();\n        if (statement instanceof BlockStatement)  {\n            statements.addAll(((BlockStatement) statement).getStatements());\n        }\n\n        if (statements.size() == 0) return;\n\n        BlockStatement rewrittenMethodCode = new BlockStatement();\n\n        rewrittenMethodCode.addStatement(tryCatchAssertionFailedError(annotationNode, methodNode, statements));\n        rewrittenMethodCode.addStatement(throwAssertionFailedError(annotationNode));\n\n        methodNode.setCode(rewrittenMethodCode);\n    }",
            "  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69 +\n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  ",
            "    public void visit(ASTNode[] nodes, SourceUnit source) {\n        if (nodes.length != 2 || !(nodes[0] instanceof AnnotationNode) || !(nodes[1] instanceof AnnotatedNode)) {\n            throw new RuntimeException(\"Internal error: expecting [AnnotationNode, AnnotatedNode] but got: \" + Arrays.asList(nodes));\n        }\n\n        AnnotationNode annotationNode = (AnnotationNode) nodes[0];\n        ASTNode node = nodes[1];\n\n        if (!(node instanceof MethodNode))  {\n            addError(\"@NotYetImplemented must only be applied on test methods!\",node);\n            return;\n        }\n\n        MethodNode methodNode = (MethodNode) node;\n\n        ArrayList<Statement> statements = new ArrayList<Statement>();\n        Statement statement = methodNode.getCode();\n        if (statement instanceof BlockStatement)  {\n            statements.addAll(((BlockStatement) statement).getStatements());\n        }\n\n        if (statements.isEmpty()) return;\n\n        BlockStatement rewrittenMethodCode = new BlockStatement();\n\n        rewrittenMethodCode.addStatement(tryCatchAssertionFailedError(annotationNode, methodNode, statements));\n        rewrittenMethodCode.addStatement(throwAssertionFailedError(annotationNode));\n\n        methodNode.setCode(rewrittenMethodCode);\n    }"
        ],
        [
            "MetaClassImpl::chooseMostSpecificParams(String,List,Class)",
            "3198  \n3199  \n3200  \n3201  \n3202  \n3203  \n3204  \n3205  \n3206 -\n3207  \n3208  \n3209  \n3210  \n3211  \n3212  \n3213  \n3214  \n3215  \n3216  \n3217  \n3218  \n3219  \n3220  \n3221 -\n3222  \n3223  \n3224  \n3225  \n3226  \n3227  \n3228  \n3229  \n3230  \n3231  \n3232  \n3233  \n3234  \n3235  \n3236  ",
            "    private Object chooseMostSpecificParams(String name, List matchingMethods, Class[] arguments) {\n\n        long matchesDistance = -1;\n        LinkedList matches = new LinkedList();\n        for (Object method : matchingMethods) {\n            ParameterTypes paramTypes = (ParameterTypes) method;\n            long dist = MetaClassHelper.calculateParameterDistance(arguments, paramTypes);\n            if (dist == 0) return method;\n            if (matches.size() == 0) {\n                matches.add(method);\n                matchesDistance = dist;\n            } else if (dist < matchesDistance) {\n                matchesDistance = dist;\n                matches.clear();\n                matches.add(method);\n            } else if (dist == matchesDistance) {\n                matches.add(method);\n            }\n\n        }\n        if (matches.size() == 1) {\n            return matches.getFirst();\n        }\n        if (matches.size() == 0) {\n            return null;\n        }\n\n        //more than one matching method found --> ambiguous!\n        StringBuilder msg = new StringBuilder(\"Ambiguous method overloading for method \");\n        msg.append(theClass.getName()).append(\"#\").append(name)\n           .append(\".\\nCannot resolve which method to invoke for \")\n           .append(InvokerHelper.toString(arguments))\n           .append(\" due to overlapping prototypes between:\");\n        for (final Object matche : matches) {\n            Class[] types = ((ParameterTypes) matche).getNativeParameterTypes();\n            msg.append(\"\\n\\t\").append(InvokerHelper.toString(types));\n        }\n        throw new GroovyRuntimeException(msg.toString());\n    }",
            "3198  \n3199  \n3200  \n3201  \n3202  \n3203  \n3204  \n3205  \n3206 +\n3207  \n3208  \n3209  \n3210  \n3211  \n3212  \n3213  \n3214  \n3215  \n3216  \n3217  \n3218  \n3219  \n3220  \n3221 +\n3222  \n3223  \n3224  \n3225  \n3226  \n3227  \n3228  \n3229  \n3230  \n3231  \n3232  \n3233  \n3234  \n3235  \n3236  ",
            "    private Object chooseMostSpecificParams(String name, List matchingMethods, Class[] arguments) {\n\n        long matchesDistance = -1;\n        LinkedList matches = new LinkedList();\n        for (Object method : matchingMethods) {\n            ParameterTypes paramTypes = (ParameterTypes) method;\n            long dist = MetaClassHelper.calculateParameterDistance(arguments, paramTypes);\n            if (dist == 0) return method;\n            if (matches.isEmpty()) {\n                matches.add(method);\n                matchesDistance = dist;\n            } else if (dist < matchesDistance) {\n                matchesDistance = dist;\n                matches.clear();\n                matches.add(method);\n            } else if (dist == matchesDistance) {\n                matches.add(method);\n            }\n\n        }\n        if (matches.size() == 1) {\n            return matches.getFirst();\n        }\n        if (matches.isEmpty()) {\n            return null;\n        }\n\n        //more than one matching method found --> ambiguous!\n        StringBuilder msg = new StringBuilder(\"Ambiguous method overloading for method \");\n        msg.append(theClass.getName()).append(\"#\").append(name)\n           .append(\".\\nCannot resolve which method to invoke for \")\n           .append(InvokerHelper.toString(arguments))\n           .append(\" due to overlapping prototypes between:\");\n        for (final Object matche : matches) {\n            Class[] types = ((ParameterTypes) matche).getNativeParameterTypes();\n            msg.append(\"\\n\\t\").append(InvokerHelper.toString(types));\n        }\n        throw new GroovyRuntimeException(msg.toString());\n    }"
        ],
        [
            "CompileStack::popState()",
            " 197  \n 198 -\n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  ",
            "    private void popState() {\n        if (stateStack.size()==0) {\n             throw new GroovyBugError(\"Tried to do a pop on the compile stack without push.\");\n        }\n        StateStackElement element = (StateStackElement) stateStack.removeLast();\n        scope = element.scope;\n        continueLabel = element.continueLabel;\n        breakLabel = element.breakLabel;\n        stackVariables = element.stackVariables;\n        finallyBlocks = element.finallyBlocks;\n        inSpecialConstructallCall = element.inSpecialConstructallCall;\n    }",
            " 197  \n 198 +\n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  ",
            "    private void popState() {\n        if (stateStack.isEmpty()) {\n             throw new GroovyBugError(\"Tried to do a pop on the compile stack without push.\");\n        }\n        StateStackElement element = (StateStackElement) stateStack.removeLast();\n        scope = element.scope;\n        continueLabel = element.continueLabel;\n        breakLabel = element.breakLabel;\n        stackVariables = element.stackVariables;\n        finallyBlocks = element.finallyBlocks;\n        inSpecialConstructallCall = element.inSpecialConstructallCall;\n    }"
        ],
        [
            "VariableScope::copy()",
            "  98  \n  99  \n 100  \n 101 -\n 102  \n 103  \n 104  \n 105  \n 106  \n 107 -\n 108  \n 109  \n 110  \n 111 -\n 112  \n 113  \n 114  \n 115  \n 116  \n 117  ",
            "    public VariableScope copy() {\n        VariableScope copy = new VariableScope();\n        copy.clazzScope = clazzScope;\n        if (declaredVariables.size() > 0) {\n          copy.declaredVariables = new HashMap<String, Variable>();\n          copy.declaredVariables.putAll(declaredVariables);\n        }\n        copy.inStaticContext = inStaticContext;\n        copy.parent = parent;\n        if (referencedClassVariables.size() > 0) {\n            copy.referencedClassVariables = new HashMap<String, Variable>();\n            copy.referencedClassVariables.putAll(referencedClassVariables);\n        }\n        if (referencedLocalVariables.size() > 0) {\n            copy.referencedLocalVariables = new HashMap<String, Variable>();\n            copy.referencedLocalVariables.putAll(referencedLocalVariables);\n        }\n        copy.resolvesDynamic = resolvesDynamic;\n        return copy;\n    }",
            "  98  \n  99  \n 100  \n 101 +\n 102  \n 103  \n 104  \n 105  \n 106  \n 107 +\n 108  \n 109  \n 110  \n 111 +\n 112  \n 113  \n 114  \n 115  \n 116  \n 117  ",
            "    public VariableScope copy() {\n        VariableScope copy = new VariableScope();\n        copy.clazzScope = clazzScope;\n        if (!declaredVariables.isEmpty()) {\n          copy.declaredVariables = new HashMap<String, Variable>();\n          copy.declaredVariables.putAll(declaredVariables);\n        }\n        copy.inStaticContext = inStaticContext;\n        copy.parent = parent;\n        if (!referencedClassVariables.isEmpty()) {\n            copy.referencedClassVariables = new HashMap<String, Variable>();\n            copy.referencedClassVariables.putAll(referencedClassVariables);\n        }\n        if (!referencedLocalVariables.isEmpty()) {\n            copy.referencedLocalVariables = new HashMap<String, Variable>();\n            copy.referencedLocalVariables.putAll(referencedLocalVariables);\n        }\n        copy.resolvesDynamic = resolvesDynamic;\n        return copy;\n    }"
        ],
        [
            "CompileStack::applyBlockRecorder(List)",
            " 764  \n 765 -\n 766  \n 767  \n 768  \n 769  \n 770  \n 771  \n 772  \n 773  \n 774  \n 775  \n 776  \n 777  \n 778  \n 779  \n 780  \n 781  \n 782  \n 783  \n 784  \n 785  \n 786  \n 787  \n 788  ",
            "    private void applyBlockRecorder(List<BlockRecorder> blocks) {\n        if (blocks.size()==0 || blocks.size()==visitedBlocks.size()) return;\n\n        MethodVisitor mv = controller.getMethodVisitor();\n\n        Label end = new Label();\n        mv.visitInsn(NOP);\n        mv.visitLabel(end);\n        Label newStart = new Label();\n\n        for (BlockRecorder fb : blocks) {\n            if (visitedBlocks.contains(fb)) continue;\n\n            fb.closeRange(end);\n\n            // we exclude the finally block from the exception table\n            // here to avoid double visiting of finally statements\n            fb.excludedStatement.run();\n\n            fb.startRange(newStart);\n        }\n\n        mv.visitInsn(NOP);\n        mv.visitLabel(newStart);\n    }",
            " 764  \n 765 +\n 766  \n 767  \n 768  \n 769  \n 770  \n 771  \n 772  \n 773  \n 774  \n 775  \n 776  \n 777  \n 778  \n 779  \n 780  \n 781  \n 782  \n 783  \n 784  \n 785  \n 786  \n 787  \n 788  ",
            "    private void applyBlockRecorder(List<BlockRecorder> blocks) {\n        if (blocks.isEmpty() || blocks.size()==visitedBlocks.size()) return;\n\n        MethodVisitor mv = controller.getMethodVisitor();\n\n        Label end = new Label();\n        mv.visitInsn(NOP);\n        mv.visitLabel(end);\n        Label newStart = new Label();\n\n        for (BlockRecorder fb : blocks) {\n            if (visitedBlocks.contains(fb)) continue;\n\n            fb.closeRange(end);\n\n            // we exclude the finally block from the exception table\n            // here to avoid double visiting of finally statements\n            fb.excludedStatement.run();\n\n            fb.startRange(newStart);\n        }\n\n        mv.visitInsn(NOP);\n        mv.visitLabel(newStart);\n    }"
        ],
        [
            "FileScanner::hasFiles()",
            "  56  \n  57 -\n  58  ",
            "    public boolean hasFiles() {\n        return filesets.size() > 0;\n    }",
            "  56  \n  57 +\n  58  ",
            "    public boolean hasFiles() {\n        return !filesets.isEmpty();\n    }"
        ],
        [
            "AntlrParserPlugin::tryStatement(AST)",
            "1659  \n1660  \n1661  \n1662  \n1663  \n1664  \n1665  \n1666  \n1667  \n1668  \n1669  \n1670  \n1671  \n1672  \n1673  \n1674  \n1675  \n1676  \n1677 -\n1678  \n1679  \n1680  \n1681  \n1682  \n1683  \n1684  \n1685  \n1686  \n1687  ",
            "    protected Statement tryStatement(AST tryStatementNode) {\n        AST tryNode = tryStatementNode.getFirstChild();\n        Statement tryStatement = statement(tryNode);\n        Statement finallyStatement = EmptyStatement.INSTANCE;\n        AST node = tryNode.getNextSibling();\n\n        // let's do the catch nodes\n        List<CatchStatement> catches = new ArrayList<CatchStatement>();\n        for (; node != null && isType(LITERAL_catch, node); node = node.getNextSibling()) {\n            final List<CatchStatement> catchStatements = catchStatement(node);\n            catches.addAll(catchStatements);\n        }\n\n        if (isType(LITERAL_finally, node)) {\n            finallyStatement = statement(node);\n            node = node.getNextSibling();\n        }\n\n        if (finallyStatement instanceof EmptyStatement && catches.size() == 0) {\n            throw new ASTRuntimeException(tryStatementNode, \"A try statement must have at least one catch or finally block.\");\n        }\n\n        TryCatchStatement tryCatchStatement = new TryCatchStatement(tryStatement, finallyStatement);\n        configureAST(tryCatchStatement, tryStatementNode);\n        for (CatchStatement statement : catches) {\n            tryCatchStatement.addCatch(statement);\n        }\n        return tryCatchStatement;\n    }",
            "1659  \n1660  \n1661  \n1662  \n1663  \n1664  \n1665  \n1666  \n1667  \n1668  \n1669  \n1670  \n1671  \n1672  \n1673  \n1674  \n1675  \n1676  \n1677 +\n1678  \n1679  \n1680  \n1681  \n1682  \n1683  \n1684  \n1685  \n1686  \n1687  ",
            "    protected Statement tryStatement(AST tryStatementNode) {\n        AST tryNode = tryStatementNode.getFirstChild();\n        Statement tryStatement = statement(tryNode);\n        Statement finallyStatement = EmptyStatement.INSTANCE;\n        AST node = tryNode.getNextSibling();\n\n        // let's do the catch nodes\n        List<CatchStatement> catches = new ArrayList<CatchStatement>();\n        for (; node != null && isType(LITERAL_catch, node); node = node.getNextSibling()) {\n            final List<CatchStatement> catchStatements = catchStatement(node);\n            catches.addAll(catchStatements);\n        }\n\n        if (isType(LITERAL_finally, node)) {\n            finallyStatement = statement(node);\n            node = node.getNextSibling();\n        }\n\n        if (finallyStatement instanceof EmptyStatement && catches.isEmpty()) {\n            throw new ASTRuntimeException(tryStatementNode, \"A try statement must have at least one catch or finally block.\");\n        }\n\n        TryCatchStatement tryCatchStatement = new TryCatchStatement(tryStatement, finallyStatement);\n        configureAST(tryCatchStatement, tryStatementNode);\n        for (CatchStatement statement : catches) {\n            tryCatchStatement.addCatch(statement);\n        }\n        return tryCatchStatement;\n    }"
        ],
        [
            "JavaStubGenerator::printEnumFields(PrintWriter,List)",
            " 370  \n 371 -\n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  ",
            "    private void printEnumFields(PrintWriter out, List<FieldNode> fields) {\n        if (fields.size() != 0) {\n            boolean first = true;\n            for (FieldNode field : fields) {\n                if (!first) {\n                    out.print(\", \");\n                } else {\n                    first = false;\n                }\n                out.print(field.getName());\n            }\n        }\n        out.println(\";\");\n    }",
            " 370  \n 371 +\n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  ",
            "    private void printEnumFields(PrintWriter out, List<FieldNode> fields) {\n        if (!fields.isEmpty()) {\n            boolean first = true;\n            for (FieldNode field : fields) {\n                if (!first) {\n                    out.print(\", \");\n                } else {\n                    first = false;\n                }\n                out.print(field.getName());\n            }\n        }\n        out.println(\";\");\n    }"
        ],
        [
            "TraitComposer::removeNonPlaceHolders(GenericsType)",
            " 342  \n 343  \n 344  \n 345  \n 346  \n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355 -\n 356  \n 357  ",
            "    private static GenericsType[] removeNonPlaceHolders(GenericsType[] oldTypes) {\n        if (oldTypes==null || oldTypes.length==0) return oldTypes;\n        ArrayList<GenericsType> l = new ArrayList<GenericsType>(Arrays.asList(oldTypes));\n        Iterator<GenericsType> it = l.iterator();\n        boolean modified = false;\n        while (it.hasNext()) {\n            GenericsType gt = it.next();\n            if (!gt.isPlaceholder()) {\n                it.remove();\n                modified = true;\n            }\n        }\n        if (!modified) return oldTypes;\n        if (l.size()==0) return null;\n        return l.toArray(new GenericsType[l.size()]);\n    }",
            " 342  \n 343  \n 344  \n 345  \n 346  \n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355 +\n 356  \n 357  ",
            "    private static GenericsType[] removeNonPlaceHolders(GenericsType[] oldTypes) {\n        if (oldTypes==null || oldTypes.length==0) return oldTypes;\n        ArrayList<GenericsType> l = new ArrayList<GenericsType>(Arrays.asList(oldTypes));\n        Iterator<GenericsType> it = l.iterator();\n        boolean modified = false;\n        while (it.hasNext()) {\n            GenericsType gt = it.next();\n            if (!gt.isPlaceholder()) {\n                it.remove();\n                modified = true;\n            }\n        }\n        if (!modified) return oldTypes;\n        if (l.isEmpty()) return null;\n        return l.toArray(new GenericsType[l.size()]);\n    }"
        ],
        [
            "TupleConstructorASTTransformation::createConstructor(AbstractASTTransformation,ClassNode,boolean,boolean,boolean,boolean,boolean,boolean,List,List,boolean,boolean)",
            " 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184 -\n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  ",
            "    public static void createConstructor(AbstractASTTransformation xform, ClassNode cNode, boolean includeFields, boolean includeProperties, boolean includeSuperFields, boolean includeSuperProperties, boolean callSuper, boolean force, List<String> excludes, List<String> includes, boolean useSetters, boolean defaults) {\r\n        // no processing if existing constructors found\r\n        if (!cNode.getDeclaredConstructors().isEmpty() && !force) return;\r\n\r\n        List<FieldNode> superList = new ArrayList<FieldNode>();\r\n        if (includeSuperProperties) {\r\n            superList.addAll(getSuperPropertyFields(cNode.getSuperClass()));\r\n        }\r\n        if (includeSuperFields) {\r\n            superList.addAll(getSuperNonPropertyFields(cNode.getSuperClass()));\r\n        }\r\n\r\n        List<FieldNode> list = new ArrayList<FieldNode>();\r\n        if (includeProperties) {\r\n            list.addAll(getInstancePropertyFields(cNode));\r\n        }\r\n        if (includeFields) {\r\n            list.addAll(getInstanceNonPropertyFields(cNode));\r\n        }\r\n\r\n        final List<Parameter> params = new ArrayList<Parameter>();\r\n        final List<Expression> superParams = new ArrayList<Expression>();\r\n        final BlockStatement body = new BlockStatement();\r\n        for (FieldNode fNode : superList) {\r\n            String name = fNode.getName();\r\n            if (shouldSkipUndefinedAware(name, excludes, includes)) continue;\r\n            params.add(createParam(fNode, name, defaults, xform));\r\n            boolean hasSetter = cNode.getProperty(name) != null && !fNode.isFinal();\r\n            if (callSuper) {\r\n                superParams.add(varX(name));\r\n            } else {\r\n                if (useSetters && hasSetter) {\r\n                    body.addStatement(stmt(callThisX(getSetterName(name), varX(name))));\r\n                } else {\r\n                    body.addStatement(assignS(propX(varX(\"this\"), name), varX(name)));\r\n                }\r\n            }\r\n        }\r\n        if (callSuper) {\r\n            body.addStatement(stmt(ctorX(ClassNode.SUPER, args(superParams))));\r\n        }\r\n        for (FieldNode fNode : list) {\r\n            String name = fNode.getName();\r\n            if (shouldSkipUndefinedAware(name, excludes, includes)) continue;\r\n            Parameter nextParam = createParam(fNode, name, defaults, xform);\r\n            params.add(nextParam);\r\n            boolean hasSetter = cNode.getProperty(name) != null && !fNode.isFinal();\r\n            if (useSetters && hasSetter) {\r\n                body.addStatement(stmt(callThisX(getSetterName(name), varX(nextParam))));\r\n            } else {\r\n                body.addStatement(assignS(propX(varX(\"this\"), name), varX(nextParam)));\r\n            }\r\n        }\r\n        cNode.addConstructor(new ConstructorNode(ACC_PUBLIC, params.toArray(new Parameter[params.size()]), ClassNode.EMPTY_ARRAY, body));\r\n        // add map constructor if needed, don't do it for LinkedHashMap for now (would lead to duplicate signature)\r\n        // or if there is only one Map property (for backwards compatibility)\r\n        if (params.size() > 0 && defaults) {\r\n            ClassNode firstParam = params.get(0).getType();\r\n            if (params.size() > 1 || firstParam.equals(ClassHelper.OBJECT_TYPE)) {\r\n                String message = \"The class \" + cNode.getName() + \" was incorrectly initialized via the map constructor with null.\";\r\n                if (firstParam.equals(ClassHelper.MAP_TYPE)) {\r\n                    addMapConstructors(cNode, true, message);\r\n                } else {\r\n                    ClassNode candidate = HMAP_TYPE;\r\n                    while (candidate != null) {\r\n                        if (candidate.equals(firstParam)) {\r\n                            addMapConstructors(cNode, true, message);\r\n                            break;\r\n                        }\r\n                        candidate = candidate.getSuperClass();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r",
            " 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184 +\n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  ",
            "    public static void createConstructor(AbstractASTTransformation xform, ClassNode cNode, boolean includeFields, boolean includeProperties, boolean includeSuperFields, boolean includeSuperProperties, boolean callSuper, boolean force, List<String> excludes, List<String> includes, boolean useSetters, boolean defaults) {\r\n        // no processing if existing constructors found\r\n        if (!cNode.getDeclaredConstructors().isEmpty() && !force) return;\r\n\r\n        List<FieldNode> superList = new ArrayList<FieldNode>();\r\n        if (includeSuperProperties) {\r\n            superList.addAll(getSuperPropertyFields(cNode.getSuperClass()));\r\n        }\r\n        if (includeSuperFields) {\r\n            superList.addAll(getSuperNonPropertyFields(cNode.getSuperClass()));\r\n        }\r\n\r\n        List<FieldNode> list = new ArrayList<FieldNode>();\r\n        if (includeProperties) {\r\n            list.addAll(getInstancePropertyFields(cNode));\r\n        }\r\n        if (includeFields) {\r\n            list.addAll(getInstanceNonPropertyFields(cNode));\r\n        }\r\n\r\n        final List<Parameter> params = new ArrayList<Parameter>();\r\n        final List<Expression> superParams = new ArrayList<Expression>();\r\n        final BlockStatement body = new BlockStatement();\r\n        for (FieldNode fNode : superList) {\r\n            String name = fNode.getName();\r\n            if (shouldSkipUndefinedAware(name, excludes, includes)) continue;\r\n            params.add(createParam(fNode, name, defaults, xform));\r\n            boolean hasSetter = cNode.getProperty(name) != null && !fNode.isFinal();\r\n            if (callSuper) {\r\n                superParams.add(varX(name));\r\n            } else {\r\n                if (useSetters && hasSetter) {\r\n                    body.addStatement(stmt(callThisX(getSetterName(name), varX(name))));\r\n                } else {\r\n                    body.addStatement(assignS(propX(varX(\"this\"), name), varX(name)));\r\n                }\r\n            }\r\n        }\r\n        if (callSuper) {\r\n            body.addStatement(stmt(ctorX(ClassNode.SUPER, args(superParams))));\r\n        }\r\n        for (FieldNode fNode : list) {\r\n            String name = fNode.getName();\r\n            if (shouldSkipUndefinedAware(name, excludes, includes)) continue;\r\n            Parameter nextParam = createParam(fNode, name, defaults, xform);\r\n            params.add(nextParam);\r\n            boolean hasSetter = cNode.getProperty(name) != null && !fNode.isFinal();\r\n            if (useSetters && hasSetter) {\r\n                body.addStatement(stmt(callThisX(getSetterName(name), varX(nextParam))));\r\n            } else {\r\n                body.addStatement(assignS(propX(varX(\"this\"), name), varX(nextParam)));\r\n            }\r\n        }\r\n        cNode.addConstructor(new ConstructorNode(ACC_PUBLIC, params.toArray(new Parameter[params.size()]), ClassNode.EMPTY_ARRAY, body));\r\n        // add map constructor if needed, don't do it for LinkedHashMap for now (would lead to duplicate signature)\r\n        // or if there is only one Map property (for backwards compatibility)\r\n        if (!params.isEmpty() && defaults) {\n            ClassNode firstParam = params.get(0).getType();\r\n            if (params.size() > 1 || firstParam.equals(ClassHelper.OBJECT_TYPE)) {\r\n                String message = \"The class \" + cNode.getName() + \" was incorrectly initialized via the map constructor with null.\";\r\n                if (firstParam.equals(ClassHelper.MAP_TYPE)) {\r\n                    addMapConstructors(cNode, true, message);\r\n                } else {\r\n                    ClassNode candidate = HMAP_TYPE;\r\n                    while (candidate != null) {\r\n                        if (candidate.equals(firstParam)) {\r\n                            addMapConstructors(cNode, true, message);\r\n                            break;\r\n                        }\r\n                        candidate = candidate.getSuperClass();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r"
        ],
        [
            "MopWriter::buildCurrentClassSignatureSet(List)",
            "  86  \n  87 -\n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  ",
            "    private Set<MopKey> buildCurrentClassSignatureSet(List<MethodNode> methods) {\n        if (methods.size()==0) return Collections.EMPTY_SET;\n        HashSet<MopKey> result = new HashSet<MopKey>(methods.size());\n        for (MethodNode mn : methods) {\n            MopKey key = new MopKey(mn.getName(), mn.getParameters());\n            result.add(key);\n        }\n        return result;\n    }",
            "  86  \n  87 +\n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  ",
            "    private Set<MopKey> buildCurrentClassSignatureSet(List<MethodNode> methods) {\n        if (methods.isEmpty()) return Collections.EMPTY_SET;\n        HashSet<MopKey> result = new HashSet<MopKey>(methods.size());\n        for (MethodNode mn : methods) {\n            MopKey key = new MopKey(mn.getName(), mn.getParameters());\n            result.add(key);\n        }\n        return result;\n    }"
        ],
        [
            "StaticInvocationWriter::loadArguments(List,Parameter)",
            " 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336 -\n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344  \n 345  \n 346  \n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  ",
            "    protected void loadArguments(List<Expression> argumentList, Parameter[] para) {\n        if (para.length == 0) return;\n        ClassNode lastParaType = para[para.length - 1].getOriginType();\n        AsmClassGenerator acg = controller.getAcg();\n        TypeChooser typeChooser = controller.getTypeChooser();\n        OperandStack operandStack = controller.getOperandStack();\n        ClassNode lastArgType = argumentList.size()>0?\n                typeChooser.resolveType(argumentList.get(argumentList.size()-1), controller.getClassNode()):null;\n        if (lastParaType.isArray()\n                && ((argumentList.size() > para.length)\n                || ((argumentList.size() == (para.length - 1)) && !lastParaType.equals(lastArgType))\n                || ((argumentList.size() == para.length && lastArgType!=null && !lastArgType.isArray())\n                    && (StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(lastArgType,lastParaType.getComponentType())))\n                        || ClassHelper.GSTRING_TYPE.equals(lastArgType) && ClassHelper.STRING_TYPE.equals(lastParaType.getComponentType()))\n                ) {\n            int stackLen = operandStack.getStackLength() + argumentList.size();\n            MethodVisitor mv = controller.getMethodVisitor();\n            MethodVisitor orig = mv;\n            //mv = new org.objectweb.asm.util.TraceMethodVisitor(mv);\n            controller.setMethodVisitor(mv);\n            // varg call\n            // first parameters as usual\n            for (int i = 0; i < para.length - 1; i++) {\n                Expression expression = argumentList.get(i);\n                expression.visit(acg);\n                if (!isNullConstant(expression)) {\n                    operandStack.doGroovyCast(para[i].getType());\n                }\n            }\n            // last parameters wrapped in an array\n            List<Expression> lastParams = new LinkedList<Expression>();\n            for (int i = para.length - 1; i < argumentList.size(); i++) {\n                lastParams.add(argumentList.get(i));\n            }\n            ArrayExpression array = new ArrayExpression(\n                    lastParaType.getComponentType(),\n                    lastParams\n            );\n            array.visit(acg);\n            // adjust stack length\n            while (operandStack.getStackLength() < stackLen) {\n                operandStack.push(ClassHelper.OBJECT_TYPE);\n            }\n            if (argumentList.size() == para.length - 1) {\n                operandStack.remove(1);\n            }\n        } else if (argumentList.size() == para.length) {\n            for (int i = 0; i < argumentList.size(); i++) {\n                Expression expression = argumentList.get(i);\n                expression.visit(acg);\n                if (!isNullConstant(expression)) {\n                    operandStack.doGroovyCast(para[i].getType());\n                }\n            }\n        } else {\n            // method call with default arguments\n            ClassNode classNode = controller.getClassNode();\n            Expression[] arguments = new Expression[para.length];\n            for (int i = 0, j = 0; i < para.length; i++) {\n                Parameter curParam = para[i];\n                ClassNode curParamType = curParam.getType();\n                Expression curArg = j < argumentList.size() ? argumentList.get(j) : null;\n                Expression initialExpression = (Expression) curParam.getNodeMetaData(StaticTypesMarker.INITIAL_EXPRESSION);\n                if (initialExpression == null && curParam.hasInitialExpression())\n                    initialExpression = curParam.getInitialExpression();\n                if (initialExpression == null && curParam.getNodeMetaData(Verifier.INITIAL_EXPRESSION)!=null) {\n                    initialExpression = (Expression) curParam.getNodeMetaData(Verifier.INITIAL_EXPRESSION);\n                }\n                ClassNode curArgType = curArg == null ? null : typeChooser.resolveType(curArg, classNode);\n\n                if (initialExpression != null && !compatibleArgumentType(curArgType, curParamType)) {\n                    // use default expression\n                    arguments[i] = initialExpression;\n                } else {\n                    arguments[i] = curArg;\n                    j++;\n                }\n            }\n            for (int i = 0; i < arguments.length; i++) {\n                Expression expression = arguments[i];\n                expression.visit(acg);\n                if (!isNullConstant(expression)) {\n                    operandStack.doGroovyCast(para[i].getType());\n                }\n            }\n        }\n    }",
            " 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336 +\n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344  \n 345  \n 346  \n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  ",
            "    protected void loadArguments(List<Expression> argumentList, Parameter[] para) {\n        if (para.length == 0) return;\n        ClassNode lastParaType = para[para.length - 1].getOriginType();\n        AsmClassGenerator acg = controller.getAcg();\n        TypeChooser typeChooser = controller.getTypeChooser();\n        OperandStack operandStack = controller.getOperandStack();\n        ClassNode lastArgType = !argumentList.isEmpty() ?\n                typeChooser.resolveType(argumentList.get(argumentList.size()-1), controller.getClassNode()):null;\n        if (lastParaType.isArray()\n                && ((argumentList.size() > para.length)\n                || ((argumentList.size() == (para.length - 1)) && !lastParaType.equals(lastArgType))\n                || ((argumentList.size() == para.length && lastArgType!=null && !lastArgType.isArray())\n                    && (StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(lastArgType,lastParaType.getComponentType())))\n                        || ClassHelper.GSTRING_TYPE.equals(lastArgType) && ClassHelper.STRING_TYPE.equals(lastParaType.getComponentType()))\n                ) {\n            int stackLen = operandStack.getStackLength() + argumentList.size();\n            MethodVisitor mv = controller.getMethodVisitor();\n            MethodVisitor orig = mv;\n            //mv = new org.objectweb.asm.util.TraceMethodVisitor(mv);\n            controller.setMethodVisitor(mv);\n            // varg call\n            // first parameters as usual\n            for (int i = 0; i < para.length - 1; i++) {\n                Expression expression = argumentList.get(i);\n                expression.visit(acg);\n                if (!isNullConstant(expression)) {\n                    operandStack.doGroovyCast(para[i].getType());\n                }\n            }\n            // last parameters wrapped in an array\n            List<Expression> lastParams = new LinkedList<Expression>();\n            for (int i = para.length - 1; i < argumentList.size(); i++) {\n                lastParams.add(argumentList.get(i));\n            }\n            ArrayExpression array = new ArrayExpression(\n                    lastParaType.getComponentType(),\n                    lastParams\n            );\n            array.visit(acg);\n            // adjust stack length\n            while (operandStack.getStackLength() < stackLen) {\n                operandStack.push(ClassHelper.OBJECT_TYPE);\n            }\n            if (argumentList.size() == para.length - 1) {\n                operandStack.remove(1);\n            }\n        } else if (argumentList.size() == para.length) {\n            for (int i = 0; i < argumentList.size(); i++) {\n                Expression expression = argumentList.get(i);\n                expression.visit(acg);\n                if (!isNullConstant(expression)) {\n                    operandStack.doGroovyCast(para[i].getType());\n                }\n            }\n        } else {\n            // method call with default arguments\n            ClassNode classNode = controller.getClassNode();\n            Expression[] arguments = new Expression[para.length];\n            for (int i = 0, j = 0; i < para.length; i++) {\n                Parameter curParam = para[i];\n                ClassNode curParamType = curParam.getType();\n                Expression curArg = j < argumentList.size() ? argumentList.get(j) : null;\n                Expression initialExpression = (Expression) curParam.getNodeMetaData(StaticTypesMarker.INITIAL_EXPRESSION);\n                if (initialExpression == null && curParam.hasInitialExpression())\n                    initialExpression = curParam.getInitialExpression();\n                if (initialExpression == null && curParam.getNodeMetaData(Verifier.INITIAL_EXPRESSION)!=null) {\n                    initialExpression = (Expression) curParam.getNodeMetaData(Verifier.INITIAL_EXPRESSION);\n                }\n                ClassNode curArgType = curArg == null ? null : typeChooser.resolveType(curArg, classNode);\n\n                if (initialExpression != null && !compatibleArgumentType(curArgType, curParamType)) {\n                    // use default expression\n                    arguments[i] = initialExpression;\n                } else {\n                    arguments[i] = curArg;\n                    j++;\n                }\n            }\n            for (int i = 0; i < arguments.length; i++) {\n                Expression expression = arguments[i];\n                expression.visit(acg);\n                if (!isNullConstant(expression)) {\n                    operandStack.doGroovyCast(para[i].getType());\n                }\n            }\n        }\n    }"
        ],
        [
            "StreamingTemplateEngine::StreamingTemplate::mangleMultipleCompilationErrorsException(MultipleCompilationErrorsException,List)",
            " 799  \n 800  \n 801  \n 802  \n 803  \n 804  \n 805 -\n 806  \n 807  \n 808  \n 809  \n 810  \n 811  \n 812  \n 813  \n 814  \n 815  \n 816  \n 817  \n 818  \n 819  \n 820  \n 821  \n 822  \n 823  \n 824  \n 825  \n 826  \n 827  \n 828  \n 829  \n 830  \n 831  \n 832  \n 833  \n 834  \n 835  ",
            "        private RuntimeException mangleMultipleCompilationErrorsException(MultipleCompilationErrorsException e, List<StringSection> sections) {\n            RuntimeException result = e;\n\n            ErrorCollector collector = e.getErrorCollector();\n            @SuppressWarnings({\"unchecked\"})\n            List<Message> errors = (List<Message>) collector.getErrors();\n            if (errors.size() > 0) {\n                Message firstMessage = errors.get(0);\n                if (firstMessage instanceof SyntaxErrorMessage) {\n                    @SuppressWarnings({\"ThrowableResultOfMethodCallIgnored\"})\n                    SyntaxException syntaxException = ((SyntaxErrorMessage) firstMessage).getCause();\n                    Position errorPosition = new Position(syntaxException.getLine(), syntaxException.getStartColumn());\n\n                    //find the string section which precedes the row/col of the thrown exception\n                    StringSection precedingSection = findPrecedingSection(errorPosition, sections);\n\n                    //and now use the string section to mangle the line numbers so that they refer to the\n                    //appropriate line in the source template data\n                    if (precedingSection != null) {\n                        //if the error was thrown on the same row as where the last string section\n                        //ended, fix column value\n                        offsetPositionFromSection(errorPosition, precedingSection);\n                        //the below being true indicates that we had an unterminated ${ or <% sequence and\n                        //the column is thus meaningless, we reset it to where the %{ or <% starts to at\n                        //least give the user a sporting chance\n                        if (sections.get(sections.size() - 1) == precedingSection) {\n                            errorPosition.column = precedingSection.lastSourcePosition.column;\n                        }\n\n                        String message = mangleExceptionMessage(e.getMessage(), errorPosition);\n                        result = new TemplateParseException(message, e, errorPosition.row, errorPosition.column);\n                    }\n                }\n            }\n\n            return result;\n        }",
            " 799  \n 800  \n 801  \n 802  \n 803  \n 804  \n 805 +\n 806  \n 807  \n 808  \n 809  \n 810  \n 811  \n 812  \n 813  \n 814  \n 815  \n 816  \n 817  \n 818  \n 819  \n 820  \n 821  \n 822  \n 823  \n 824  \n 825  \n 826  \n 827  \n 828  \n 829  \n 830  \n 831  \n 832  \n 833  \n 834  \n 835  ",
            "        private RuntimeException mangleMultipleCompilationErrorsException(MultipleCompilationErrorsException e, List<StringSection> sections) {\n            RuntimeException result = e;\n\n            ErrorCollector collector = e.getErrorCollector();\n            @SuppressWarnings({\"unchecked\"})\n            List<Message> errors = (List<Message>) collector.getErrors();\n            if (!errors.isEmpty()) {\n                Message firstMessage = errors.get(0);\n                if (firstMessage instanceof SyntaxErrorMessage) {\n                    @SuppressWarnings({\"ThrowableResultOfMethodCallIgnored\"})\n                    SyntaxException syntaxException = ((SyntaxErrorMessage) firstMessage).getCause();\n                    Position errorPosition = new Position(syntaxException.getLine(), syntaxException.getStartColumn());\n\n                    //find the string section which precedes the row/col of the thrown exception\n                    StringSection precedingSection = findPrecedingSection(errorPosition, sections);\n\n                    //and now use the string section to mangle the line numbers so that they refer to the\n                    //appropriate line in the source template data\n                    if (precedingSection != null) {\n                        //if the error was thrown on the same row as where the last string section\n                        //ended, fix column value\n                        offsetPositionFromSection(errorPosition, precedingSection);\n                        //the below being true indicates that we had an unterminated ${ or <% sequence and\n                        //the column is thus meaningless, we reset it to where the %{ or <% starts to at\n                        //least give the user a sporting chance\n                        if (sections.get(sections.size() - 1) == precedingSection) {\n                            errorPosition.column = precedingSection.lastSourcePosition.column;\n                        }\n\n                        String message = mangleExceptionMessage(e.getMessage(), errorPosition);\n                        result = new TemplateParseException(message, e, errorPosition.row, errorPosition.column);\n                    }\n                }\n            }\n\n            return result;\n        }"
        ],
        [
            "JavaStubGenerator::getConstructorCallExpression(ConstructorNode)",
            " 438  \n 439  \n 440  \n 441  \n 442  \n 443  \n 444  \n 445 -\n 446  \n 447  \n 448  \n 449  \n 450  \n 451  \n 452  \n 453  \n 454  \n 455  \n 456  \n 457  ",
            "    private ConstructorCallExpression getConstructorCallExpression(ConstructorNode constructorNode) {\n        Statement code = constructorNode.getCode();\n        if (!(code instanceof BlockStatement))\n            return null;\n\n        BlockStatement block = (BlockStatement) code;\n        List stats = block.getStatements();\n        if (stats == null || stats.size() == 0)\n            return null;\n\n        Statement stat = (Statement) stats.get(0);\n        if (!(stat instanceof ExpressionStatement))\n            return null;\n\n        Expression expr = ((ExpressionStatement) stat).getExpression();\n        if (!(expr instanceof ConstructorCallExpression))\n            return null;\n\n        return (ConstructorCallExpression) expr;\n    }",
            " 438  \n 439  \n 440  \n 441  \n 442  \n 443  \n 444  \n 445 +\n 446  \n 447  \n 448  \n 449  \n 450  \n 451  \n 452  \n 453  \n 454  \n 455  \n 456  \n 457  ",
            "    private ConstructorCallExpression getConstructorCallExpression(ConstructorNode constructorNode) {\n        Statement code = constructorNode.getCode();\n        if (!(code instanceof BlockStatement))\n            return null;\n\n        BlockStatement block = (BlockStatement) code;\n        List stats = block.getStatements();\n        if (stats == null || stats.isEmpty())\n            return null;\n\n        Statement stat = (Statement) stats.get(0);\n        if (!(stat instanceof ExpressionStatement))\n            return null;\n\n        Expression expr = ((ExpressionStatement) stat).getExpression();\n        if (!(expr instanceof ConstructorCallExpression))\n            return null;\n\n        return (ConstructorCallExpression) expr;\n    }"
        ],
        [
            "GroovyCollections::transpose(List)",
            " 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163 -\n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  ",
            "    /**\n     * Transposes the given lists.\n     * So, <code>transpose([['a', 'b'], [1, 2]])</code>\n     * is <code>[['a', 1], ['b', 2]]</code> and\n     * <code>transpose([['a', 'b', 'c']])</code>\n     * is <code>[['a'], ['b'], ['c']]</code>.\n     *\n     * @param lists the given lists\n     * @return a List of the transposed lists\n     */\n    public static List transpose(List lists) {\n        List result = new ArrayList();\n        if (lists.isEmpty() || lists.size() == 0) return result;\n        int minSize = Integer.MAX_VALUE;\n        for (Object listLike : lists) {\n            List list = (List) DefaultTypeTransformation.castToType(listLike, List.class);\n            if (list.size() < minSize) minSize = list.size();\n        }\n        if (minSize == 0) return result;\n        for (int i = 0; i < minSize; i++) {\n            result.add(new ArrayList());\n        }\n        for (Object listLike : lists) {\n            List list = (List) DefaultTypeTransformation.castToType(listLike, List.class);\n            for (int i = 0; i < minSize; i++) {\n                List resultList = (List) result.get(i);\n                resultList.add(list.get(i));\n            }\n        }\n        return result;\n    }",
            " 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163 +\n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  ",
            "    /**\n     * Transposes the given lists.\n     * So, <code>transpose([['a', 'b'], [1, 2]])</code>\n     * is <code>[['a', 1], ['b', 2]]</code> and\n     * <code>transpose([['a', 'b', 'c']])</code>\n     * is <code>[['a'], ['b'], ['c']]</code>.\n     *\n     * @param lists the given lists\n     * @return a List of the transposed lists\n     */\n    public static List transpose(List lists) {\n        List result = new ArrayList();\n        if (lists.isEmpty() || lists.isEmpty()) return result;\n        int minSize = Integer.MAX_VALUE;\n        for (Object listLike : lists) {\n            List list = (List) DefaultTypeTransformation.castToType(listLike, List.class);\n            if (list.size() < minSize) minSize = list.size();\n        }\n        if (minSize == 0) return result;\n        for (int i = 0; i < minSize; i++) {\n            result.add(new ArrayList());\n        }\n        for (Object listLike : lists) {\n            List list = (List) DefaultTypeTransformation.castToType(listLike, List.class);\n            for (int i = 0; i < minSize; i++) {\n                List resultList = (List) result.get(i);\n                resultList.add(list.get(i));\n            }\n        }\n        return result;\n    }"
        ],
        [
            "SingletonASTTransformation::createConstructor(ClassNode,FieldNode,String,boolean)",
            " 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119 -\n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  ",
            "    private void createConstructor(ClassNode classNode, FieldNode field, String propertyName, boolean isStrict) {\r\n        final List<ConstructorNode> cNodes = classNode.getDeclaredConstructors();\r\n        ConstructorNode foundNoArg = null;\r\n        for (ConstructorNode cNode : cNodes) {\r\n            final Parameter[] parameters = cNode.getParameters();\r\n            if (parameters == null || parameters.length == 0) {\r\n                foundNoArg = cNode;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (isStrict && cNodes.size() != 0) {\r\n            for (ConstructorNode cNode : cNodes) {\r\n                addError(\"@Singleton didn't expect to find one or more additional constructors: remove constructor(s) or set strict=false\", cNode);\r\n            }\r\n        }\r\n\r\n        if (foundNoArg == null) {\r\n            final BlockStatement body = new BlockStatement();\r\n            body.addStatement(ifS(\r\n                    notNullX(varX(field)),\r\n                    new ThrowStatement(\r\n                            ctorX(make(RuntimeException.class),\r\n                                    args(constX(\"Can't instantiate singleton \" + classNode.getName() + \". Use \" + classNode.getName() + \".\" + propertyName))))\r\n            ));\r\n            classNode.addConstructor(new ConstructorNode(ACC_PRIVATE, body));\r\n        }\r\n    }\r",
            " 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119 +\n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  ",
            "    private void createConstructor(ClassNode classNode, FieldNode field, String propertyName, boolean isStrict) {\r\n        final List<ConstructorNode> cNodes = classNode.getDeclaredConstructors();\r\n        ConstructorNode foundNoArg = null;\r\n        for (ConstructorNode cNode : cNodes) {\r\n            final Parameter[] parameters = cNode.getParameters();\r\n            if (parameters == null || parameters.length == 0) {\r\n                foundNoArg = cNode;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (isStrict && !cNodes.isEmpty()) {\n            for (ConstructorNode cNode : cNodes) {\r\n                addError(\"@Singleton didn't expect to find one or more additional constructors: remove constructor(s) or set strict=false\", cNode);\r\n            }\r\n        }\r\n\r\n        if (foundNoArg == null) {\r\n            final BlockStatement body = new BlockStatement();\r\n            body.addStatement(ifS(\r\n                    notNullX(varX(field)),\r\n                    new ThrowStatement(\r\n                            ctorX(make(RuntimeException.class),\r\n                                    args(constX(\"Can't instantiate singleton \" + classNode.getName() + \". Use \" + classNode.getName() + \".\" + propertyName))))\r\n            ));\r\n            classNode.addConstructor(new ConstructorNode(ACC_PRIVATE, body));\r\n        }\r\n    }\r"
        ],
        [
            "GrabAnnotationTransformation::callGrabAsStaticInitIfNeeded(ClassNode,ClassNode,List,List)",
            " 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  \n 423  \n 424  \n 425  \n 426 -\n 427  \n 428  \n 429  \n 430  \n 431  \n 432  \n 433  \n 434  \n 435  \n 436  \n 437  \n 438  \n 439  \n 440  \n 441  \n 442  \n 443  \n 444  ",
            "    private void callGrabAsStaticInitIfNeeded(ClassNode classNode, ClassNode grapeClassNode, List<Map<String,Object>> grabMapsInit, List<Map<String, Object>> grabExcludeMaps) {\n        List<Statement> grabInitializers = new ArrayList<Statement>();\n        MapExpression basicArgs = new MapExpression();\n        if (autoDownload != null)  {\n            basicArgs.addMapEntryExpression(constX(AUTO_DOWNLOAD_SETTING), constX(autoDownload));\n        }\n\n        if (disableChecksums != null)  {\n            basicArgs.addMapEntryExpression(constX(DISABLE_CHECKSUMS_SETTING), constX(disableChecksums));\n        }\n\n        if (systemProperties != null && !systemProperties.isEmpty()) {\n            BlockStatement block = new BlockStatement();\n            for(Map.Entry e : systemProperties.entrySet()) {\n                block.addStatement(stmt(callX(SYSTEM_CLASSNODE, \"setProperty\", args(constX(e.getKey()), constX(e.getValue())))));\n            }\n            StaticMethodCallExpression enabled = callX(SYSTEM_CLASSNODE, \"getProperty\", args(constX(\"groovy.grape.enable\"), constX(\"true\")));\n            grabInitializers.add(ifS(eqX(enabled, constX(\"true\")), block));\n        }\n\n        if (!grabExcludeMaps.isEmpty()) {\n            ListExpression list = new ListExpression();\n            for (Map<String, Object> map : grabExcludeMaps) {\n                Set<Map.Entry<String, Object>> entries = map.entrySet();\n                MapExpression inner = new MapExpression();\n                for (Map.Entry<String, Object> entry : entries) {\n                    inner.addMapEntryExpression(constX(entry.getKey()), constX(entry.getValue()));\n                }\n                list.addExpression(inner);\n            }\n            basicArgs.addMapEntryExpression(constX(\"excludes\"), list);\n        }\n\n        List<Expression> argList = new ArrayList<Expression>();\n        argList.add(basicArgs);\n        if (grabMapsInit.size() == 0) return;\n        for (Map<String, Object> grabMap : grabMapsInit) {\n            // add Grape.grab(excludeArgs, [group:group, module:module, version:version, classifier:classifier])\n            // or Grape.grab([group:group, module:module, version:version, classifier:classifier])\n            MapExpression dependencyArg = new MapExpression();\n            for (String s : GRAB_REQUIRED) {\n                dependencyArg.addMapEntryExpression(constX(s), constX(grabMap.get(s)));\n            }\n            for (String s : GRAB_OPTIONAL) {\n                if (grabMap.containsKey(s))\n                    dependencyArg.addMapEntryExpression(constX(s), constX(grabMap.get(s)));\n            }\n            argList.add(dependencyArg);\n        }\n        grabInitializers.add(stmt(callX(grapeClassNode, \"grab\", args(argList))));\n\n        // insert at beginning so we have the classloader set up before the class is called\n        classNode.addStaticInitializerStatements(grabInitializers, true);\n    }",
            " 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  \n 423  \n 424  \n 425  \n 426 +\n 427  \n 428  \n 429  \n 430  \n 431  \n 432  \n 433  \n 434  \n 435  \n 436  \n 437  \n 438  \n 439  \n 440  \n 441  \n 442  \n 443  \n 444  ",
            "    private void callGrabAsStaticInitIfNeeded(ClassNode classNode, ClassNode grapeClassNode, List<Map<String,Object>> grabMapsInit, List<Map<String, Object>> grabExcludeMaps) {\n        List<Statement> grabInitializers = new ArrayList<Statement>();\n        MapExpression basicArgs = new MapExpression();\n        if (autoDownload != null)  {\n            basicArgs.addMapEntryExpression(constX(AUTO_DOWNLOAD_SETTING), constX(autoDownload));\n        }\n\n        if (disableChecksums != null)  {\n            basicArgs.addMapEntryExpression(constX(DISABLE_CHECKSUMS_SETTING), constX(disableChecksums));\n        }\n\n        if (systemProperties != null && !systemProperties.isEmpty()) {\n            BlockStatement block = new BlockStatement();\n            for(Map.Entry e : systemProperties.entrySet()) {\n                block.addStatement(stmt(callX(SYSTEM_CLASSNODE, \"setProperty\", args(constX(e.getKey()), constX(e.getValue())))));\n            }\n            StaticMethodCallExpression enabled = callX(SYSTEM_CLASSNODE, \"getProperty\", args(constX(\"groovy.grape.enable\"), constX(\"true\")));\n            grabInitializers.add(ifS(eqX(enabled, constX(\"true\")), block));\n        }\n\n        if (!grabExcludeMaps.isEmpty()) {\n            ListExpression list = new ListExpression();\n            for (Map<String, Object> map : grabExcludeMaps) {\n                Set<Map.Entry<String, Object>> entries = map.entrySet();\n                MapExpression inner = new MapExpression();\n                for (Map.Entry<String, Object> entry : entries) {\n                    inner.addMapEntryExpression(constX(entry.getKey()), constX(entry.getValue()));\n                }\n                list.addExpression(inner);\n            }\n            basicArgs.addMapEntryExpression(constX(\"excludes\"), list);\n        }\n\n        List<Expression> argList = new ArrayList<Expression>();\n        argList.add(basicArgs);\n        if (grabMapsInit.isEmpty()) return;\n        for (Map<String, Object> grabMap : grabMapsInit) {\n            // add Grape.grab(excludeArgs, [group:group, module:module, version:version, classifier:classifier])\n            // or Grape.grab([group:group, module:module, version:version, classifier:classifier])\n            MapExpression dependencyArg = new MapExpression();\n            for (String s : GRAB_REQUIRED) {\n                dependencyArg.addMapEntryExpression(constX(s), constX(grabMap.get(s)));\n            }\n            for (String s : GRAB_OPTIONAL) {\n                if (grabMap.containsKey(s))\n                    dependencyArg.addMapEntryExpression(constX(s), constX(grabMap.get(s)));\n            }\n            argList.add(dependencyArg);\n        }\n        grabInitializers.add(stmt(callX(grapeClassNode, \"grab\", args(argList))));\n\n        // insert at beginning so we have the classloader set up before the class is called\n        classNode.addStaticInitializerStatements(grabInitializers, true);\n    }"
        ],
        [
            "ObservableSet::addAll(Collection)",
            " 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239 -\n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  ",
            "    public boolean addAll(Collection<? extends E> c) {\n        Set<E> duplicates = new HashSet<E>();\n        if (null != c) {\n            for (E e : c) {\n                if (!delegate.contains(e)) continue;\n                duplicates.add(e);\n            }\n        }\n\n        int oldSize = size();\n        boolean success = delegate.addAll(c);\n\n        if (success && c != null) {\n            List<E> values = new ArrayList<E>();\n            for (E element : c) {\n                if (test != null) {\n                    Object result = test.call(element);\n                    if (result != null && result instanceof Boolean && (Boolean) result && !duplicates.contains(element)) {\n                        values.add(element);\n                    }\n                } else if (!duplicates.contains(element)) {\n                    values.add(element);\n                }\n            }\n            if (values.size() > 0) {\n                fireMultiElementAddedEvent(values);\n                fireSizeChangedEvent(oldSize, size());\n            }\n        }\n\n        return success;\n    }",
            " 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239 +\n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  ",
            "    public boolean addAll(Collection<? extends E> c) {\n        Set<E> duplicates = new HashSet<E>();\n        if (null != c) {\n            for (E e : c) {\n                if (!delegate.contains(e)) continue;\n                duplicates.add(e);\n            }\n        }\n\n        int oldSize = size();\n        boolean success = delegate.addAll(c);\n\n        if (success && c != null) {\n            List<E> values = new ArrayList<E>();\n            for (E element : c) {\n                if (test != null) {\n                    Object result = test.call(element);\n                    if (result != null && result instanceof Boolean && (Boolean) result && !duplicates.contains(element)) {\n                        values.add(element);\n                    }\n                } else if (!duplicates.contains(element)) {\n                    values.add(element);\n                }\n            }\n            if (!values.isEmpty()) {\n                fireMultiElementAddedEvent(values);\n                fireSizeChangedEvent(oldSize, size());\n            }\n        }\n\n        return success;\n    }"
        ],
        [
            "DefaultGroovyMethods::minus(Map,Map)",
            "11978  \n11979  \n11980  \n11981  \n11982  \n11983  \n11984  \n11985  \n11986  \n11987  \n11988  \n11989  \n11990 -\n11991  \n11992  \n11993  \n11994  \n11995  \n11996  \n11997  \n11998  \n11999  \n12000  ",
            "    /**\n     * Create a Map composed of the entries of the first map minus the\n     * entries of the given map.\n     *\n     * @param self     a map object\n     * @param removeMe the entries to remove from the map\n     * @return the resulting map\n     * @since 1.7.4\n     */\n    public static <K,V> Map<K,V> minus(Map<K,V> self, Map removeMe) {\n        final Map<K,V> ansMap = createSimilarMap(self);\n        ansMap.putAll(self);\n        if (removeMe != null && removeMe.size() > 0) {\n            for (Map.Entry<K, V> e1 : self.entrySet()) {\n                for (Object e2 : removeMe.entrySet()) {\n                    if (DefaultTypeTransformation.compareEqual(e1, e2)) {\n                        ansMap.remove(e1.getKey());\n                    }\n                }\n            }\n        }\n        return ansMap;\n    }",
            "11978  \n11979  \n11980  \n11981  \n11982  \n11983  \n11984  \n11985  \n11986  \n11987  \n11988  \n11989  \n11990 +\n11991  \n11992  \n11993  \n11994  \n11995  \n11996  \n11997  \n11998  \n11999  \n12000  ",
            "    /**\n     * Create a Map composed of the entries of the first map minus the\n     * entries of the given map.\n     *\n     * @param self     a map object\n     * @param removeMe the entries to remove from the map\n     * @return the resulting map\n     * @since 1.7.4\n     */\n    public static <K,V> Map<K,V> minus(Map<K,V> self, Map removeMe) {\n        final Map<K,V> ansMap = createSimilarMap(self);\n        ansMap.putAll(self);\n        if (removeMe != null && !removeMe.isEmpty()) {\n            for (Map.Entry<K, V> e1 : self.entrySet()) {\n                for (Object e2 : removeMe.entrySet()) {\n                    if (DefaultTypeTransformation.compareEqual(e1, e2)) {\n                        ansMap.remove(e1.getKey());\n                    }\n                }\n            }\n        }\n        return ansMap;\n    }"
        ]
    ],
    "38c2a64c72e346e09cc9f9da7ceff5a65aa3da8e": [
        [
            "StaticTypeCheckingVisitor::checkOrMarkPrivateAccess(Expression,MethodNode)",
            " 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372 -\n 373 -\n 374 -\n 375  \n 376  \n 377  ",
            "    /**\n     * Given a method node, checks if we are calling a private method from an inner class.\n     */\n    private void checkOrMarkPrivateAccess(Expression source, MethodNode mn) {\n        if (mn==null) {\n            return;\n        }\n        ClassNode declaringClass = mn.getDeclaringClass();\n        ClassNode enclosingClassNode = typeCheckingContext.getEnclosingClassNode();\n        if (declaringClass != enclosingClassNode || typeCheckingContext.getEnclosingClosure() != null) {\n            int mods = mn.getModifiers();\n            boolean sameModule = declaringClass.getModule() == enclosingClassNode.getModule();\n            String packageName = declaringClass.getPackageName();\n            if (packageName==null) {\n                packageName = \"\";\n            }\n            if ((Modifier.isPrivate(mods) && sameModule)\n                    || (Modifier.isProtected(mods) && !packageName.equals(enclosingClassNode.getPackageName()))) {\n                addPrivateFieldOrMethodAccess(source, sameModule? declaringClass : enclosingClassNode, StaticTypesMarker.PV_METHODS_ACCESS, mn);\n            }\n        }\n    }",
            " 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372 +\n 373 +\n 374 +\n 375 +\n 376 +\n 377 +\n 378 +\n 379 +\n 380 +\n 381 +\n 382 +\n 383  \n 384  \n 385  ",
            "    /**\n     * Given a method node, checks if we are calling a private method from an inner class.\n     */\n    private void checkOrMarkPrivateAccess(Expression source, MethodNode mn) {\n        if (mn==null) {\n            return;\n        }\n        ClassNode declaringClass = mn.getDeclaringClass();\n        ClassNode enclosingClassNode = typeCheckingContext.getEnclosingClassNode();\n        if (declaringClass != enclosingClassNode || typeCheckingContext.getEnclosingClosure() != null) {\n            int mods = mn.getModifiers();\n            boolean sameModule = declaringClass.getModule() == enclosingClassNode.getModule();\n            String packageName = declaringClass.getPackageName();\n            if (packageName==null) {\n                packageName = \"\";\n            }\n            if ((Modifier.isPrivate(mods) && sameModule)) {\n                addPrivateFieldOrMethodAccess(source, declaringClass, StaticTypesMarker.PV_METHODS_ACCESS, mn);\n            } else if (Modifier.isProtected(mods) && !packageName.equals(enclosingClassNode.getPackageName())\n                    && !implementsInterfaceOrIsSubclassOf(enclosingClassNode, declaringClass)) {\n                ClassNode cn = enclosingClassNode;\n                while ((cn = cn.getOuterClass()) != null) {\n                    if (implementsInterfaceOrIsSubclassOf(cn, declaringClass)) {\n                        addPrivateFieldOrMethodAccess(source, cn, StaticTypesMarker.PV_METHODS_ACCESS, mn);\n                        break;\n                    }\n                }\n            }\n        }\n    }"
        ],
        [
            "StaticInvocationWriter::writeDirectMethodCall(MethodNode,boolean,Expression,TupleExpression)",
            " 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  ",
            "    @Override\n    protected boolean writeDirectMethodCall(final MethodNode target, final boolean implicitThis, final Expression receiver, final TupleExpression args) {\n        if (target==null) return false;\n\n        if (target instanceof ExtensionMethodNode) {\n            ExtensionMethodNode emn = (ExtensionMethodNode) target;\n            MethodNode node = emn.getExtensionMethodNode();\n            String methodName = target.getName();\n\n            MethodVisitor mv = controller.getMethodVisitor();\n            int argumentsToRemove = 0;\n            List<Expression> argumentList = new LinkedList<Expression>(args.getExpressions());\n\n            if (emn.isStaticExtension()) {\n                // it's a static extension method\n                argumentList.add(0, ConstantExpression.NULL);\n            } else {\n                argumentList.add(0, receiver);\n            }\n\n            Parameter[] parameters = node.getParameters();\n            loadArguments(argumentList, parameters);\n\n            String owner = BytecodeHelper.getClassInternalName(node.getDeclaringClass());\n            String desc = BytecodeHelper.getMethodDescriptor(target.getReturnType(), parameters);\n            mv.visitMethodInsn(INVOKESTATIC, owner, methodName, desc, false);\n            ClassNode ret = target.getReturnType().redirect();\n            if (ret == ClassHelper.VOID_TYPE) {\n                ret = ClassHelper.OBJECT_TYPE;\n                mv.visitInsn(ACONST_NULL);\n            }\n            argumentsToRemove += argumentList.size();\n            controller.getOperandStack().remove(argumentsToRemove);\n            controller.getOperandStack().push(ret);\n            return true;\n        } else {\n            if (target == StaticTypeCheckingVisitor.CLOSURE_CALL_VARGS) {\n                // wrap arguments into an array\n                ArrayExpression arr = new ArrayExpression(ClassHelper.OBJECT_TYPE, args.getExpressions());\n                return super.writeDirectMethodCall(target, implicitThis, receiver, new ArgumentListExpression(arr));\n            }\n            ClassNode classNode = controller.getClassNode();\n            if (classNode.isDerivedFrom(ClassHelper.CLOSURE_TYPE)\n                    && controller.isInClosure()\n                    && !target.isPublic()\n                    && target.getDeclaringClass() != classNode) {\n                if (!tryBridgeMethod(target, receiver, implicitThis, args)) {\n                    // replace call with an invoker helper call\n                    ArrayExpression arr = new ArrayExpression(ClassHelper.OBJECT_TYPE, args.getExpressions());\n                    MethodCallExpression mce = new MethodCallExpression(\n                            INVOKERHELER_RECEIVER,\n                            target.isStatic() ? \"invokeStaticMethod\" : \"invokeMethodSafe\",\n                            new ArgumentListExpression(\n                                    target.isStatic() ?\n                                            new ClassExpression(target.getDeclaringClass()) :\n                                            receiver,\n                                    new ConstantExpression(target.getName()),\n                                    arr\n                            )\n                    );\n                    mce.setMethodTarget(target.isStatic() ? INVOKERHELPER_INVOKESTATICMETHOD : INVOKERHELPER_INVOKEMETHOD);\n                    mce.visit(controller.getAcg());\n                    return true;\n                }\n                return true;\n            }\n            if (target.isPrivate()) {\n                if (tryPrivateMethod(target, implicitThis, receiver, args, classNode)) return true;\n            } else if (target.isProtected()) {\n                ClassNode node = receiver==null?ClassHelper.OBJECT_TYPE:controller.getTypeChooser().resolveType(receiver, controller.getClassNode());\n                boolean isThisOrSuper = false;\n                if (receiver instanceof VariableExpression) {\n                    isThisOrSuper = ((VariableExpression) receiver).isThisExpression() || ((VariableExpression) receiver).isSuperExpression();\n                }\n                if (!implicitThis && !isThisOrSuper\n                        && StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(node,target.getDeclaringClass())) {\n                    ASTNode src = receiver==null?args:receiver;\n                    controller.getSourceUnit().addError(\n                            new SyntaxException(\"Method \" + target.getName() + \" is protected in \" + target.getDeclaringClass().toString(false),\n                                    src.getLineNumber(), src.getColumnNumber(), src.getLastLineNumber(), src.getLastColumnNumber()));\n                }\n            }\n            if (receiver != null) {\n                if (!(receiver instanceof VariableExpression) || !((VariableExpression) receiver).isSuperExpression()) {\n                    // in order to avoid calls to castToType, which is the dynamic behaviour, we make sure that we call CHECKCAST instead\n                    // then replace the top operand type\n                    Expression checkCastReceiver = new CheckcastReceiverExpression(receiver, target);\n                    return super.writeDirectMethodCall(target, implicitThis, checkCastReceiver, args);\n                }\n            }\n            return super.writeDirectMethodCall(target, implicitThis, receiver, args);\n        }\n    }",
            " 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285 +\n 286 +\n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  ",
            "    @Override\n    protected boolean writeDirectMethodCall(final MethodNode target, final boolean implicitThis, final Expression receiver, final TupleExpression args) {\n        if (target==null) return false;\n\n        if (target instanceof ExtensionMethodNode) {\n            ExtensionMethodNode emn = (ExtensionMethodNode) target;\n            MethodNode node = emn.getExtensionMethodNode();\n            String methodName = target.getName();\n\n            MethodVisitor mv = controller.getMethodVisitor();\n            int argumentsToRemove = 0;\n            List<Expression> argumentList = new LinkedList<Expression>(args.getExpressions());\n\n            if (emn.isStaticExtension()) {\n                // it's a static extension method\n                argumentList.add(0, ConstantExpression.NULL);\n            } else {\n                argumentList.add(0, receiver);\n            }\n\n            Parameter[] parameters = node.getParameters();\n            loadArguments(argumentList, parameters);\n\n            String owner = BytecodeHelper.getClassInternalName(node.getDeclaringClass());\n            String desc = BytecodeHelper.getMethodDescriptor(target.getReturnType(), parameters);\n            mv.visitMethodInsn(INVOKESTATIC, owner, methodName, desc, false);\n            ClassNode ret = target.getReturnType().redirect();\n            if (ret == ClassHelper.VOID_TYPE) {\n                ret = ClassHelper.OBJECT_TYPE;\n                mv.visitInsn(ACONST_NULL);\n            }\n            argumentsToRemove += argumentList.size();\n            controller.getOperandStack().remove(argumentsToRemove);\n            controller.getOperandStack().push(ret);\n            return true;\n        } else {\n            if (target == StaticTypeCheckingVisitor.CLOSURE_CALL_VARGS) {\n                // wrap arguments into an array\n                ArrayExpression arr = new ArrayExpression(ClassHelper.OBJECT_TYPE, args.getExpressions());\n                return super.writeDirectMethodCall(target, implicitThis, receiver, new ArgumentListExpression(arr));\n            }\n            ClassNode classNode = controller.getClassNode();\n            if (classNode.isDerivedFrom(ClassHelper.CLOSURE_TYPE)\n                    && controller.isInClosure()\n                    && !target.isPublic()\n                    && target.getDeclaringClass() != classNode) {\n                if (!tryBridgeMethod(target, receiver, implicitThis, args)) {\n                    // replace call with an invoker helper call\n                    ArrayExpression arr = new ArrayExpression(ClassHelper.OBJECT_TYPE, args.getExpressions());\n                    MethodCallExpression mce = new MethodCallExpression(\n                            INVOKERHELER_RECEIVER,\n                            target.isStatic() ? \"invokeStaticMethod\" : \"invokeMethodSafe\",\n                            new ArgumentListExpression(\n                                    target.isStatic() ?\n                                            new ClassExpression(target.getDeclaringClass()) :\n                                            receiver,\n                                    new ConstantExpression(target.getName()),\n                                    arr\n                            )\n                    );\n                    mce.setMethodTarget(target.isStatic() ? INVOKERHELPER_INVOKESTATICMETHOD : INVOKERHELPER_INVOKEMETHOD);\n                    mce.visit(controller.getAcg());\n                    return true;\n                }\n                return true;\n            }\n            if (target.isPrivate()) {\n                if (tryPrivateMethod(target, implicitThis, receiver, args, classNode)) return true;\n            } else if (target.isProtected()) {\n                ClassNode node = receiver==null?ClassHelper.OBJECT_TYPE:controller.getTypeChooser().resolveType(receiver, controller.getClassNode());\n                boolean isThisOrSuper = false;\n                if (receiver instanceof VariableExpression) {\n                    isThisOrSuper = ((VariableExpression) receiver).isThisExpression() || ((VariableExpression) receiver).isSuperExpression();\n                }\n                if (!implicitThis && !isThisOrSuper\n                        && StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(node,target.getDeclaringClass())) {\n                    ASTNode src = receiver==null?args:receiver;\n                    controller.getSourceUnit().addError(\n                            new SyntaxException(\"Method \" + target.getName() + \" is protected in \" + target.getDeclaringClass().toString(false),\n                                    src.getLineNumber(), src.getColumnNumber(), src.getLastLineNumber(), src.getLastColumnNumber()));\n                } else if (!node.isDerivedFrom(target.getDeclaringClass()) && tryBridgeMethod(target, receiver, implicitThis, args)) {\n                    return true;\n                }\n            }\n            if (receiver != null) {\n                if (!(receiver instanceof VariableExpression) || !((VariableExpression) receiver).isSuperExpression()) {\n                    // in order to avoid calls to castToType, which is the dynamic behaviour, we make sure that we call CHECKCAST instead\n                    // then replace the top operand type\n                    Expression checkCastReceiver = new CheckcastReceiverExpression(receiver, target);\n                    return super.writeDirectMethodCall(target, implicitThis, checkCastReceiver, args);\n                }\n            }\n            return super.writeDirectMethodCall(target, implicitThis, receiver, args);\n        }\n    }"
        ],
        [
            "StaticInvocationWriter::tryBridgeMethod(MethodNode,Expression,boolean,TupleExpression)",
            " 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180 -\n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190 -\n 191  \n 192 -\n 193 -\n 194 -\n 195 -\n 196 -\n 197 -\n 198 -\n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  ",
            "    /**\n     * Attempts to make a direct method call on a bridge method, if it exists.\n     */\n    protected boolean tryBridgeMethod(MethodNode target, Expression receiver, boolean implicitThis, TupleExpression args) {\n        ClassNode lookupClassNode;\n        if (target.isProtected()) {\n            lookupClassNode = controller.getClassNode();\n            if (controller.isInClosure()) {\n                lookupClassNode = lookupClassNode.getOuterClass();\n            }\n        } else {\n            lookupClassNode = target.getDeclaringClass().redirect();\n        }\n        Map<MethodNode, MethodNode> bridges = lookupClassNode.getNodeMetaData(PRIVATE_BRIDGE_METHODS);\n        MethodNode bridge = bridges==null?null:bridges.get(target);\n        if (bridge != null) {\n            Expression fixedReceiver = receiver;\n            ClassNode declaringClass = bridge.getDeclaringClass();\n            if (implicitThis && !controller.isInClosure()) {\n                ClassNode classNode = controller.getClassNode();\n                while (!classNode.isDerivedFrom(declaringClass)\n                        && !classNode.implementsInterface(declaringClass)\n                        && classNode instanceof InnerClassNode) {\n                    classNode = classNode.getOuterClass();\n                }\n                fixedReceiver = new PropertyExpression(new ClassExpression(classNode), \"this\");\n            }\n            ArgumentListExpression newArgs = new ArgumentListExpression(target.isStatic()?new ConstantExpression(null):fixedReceiver);\n            for (Expression expression : args.getExpressions()) {\n                newArgs.addExpression(expression);\n            }\n            return writeDirectMethodCall(bridge, implicitThis, fixedReceiver, newArgs);\n        }\n        return false;\n    }",
            " 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180 +\n 181  \n 182  \n 183 +\n 184 +\n 185 +\n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194 +\n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  ",
            "    /**\n     * Attempts to make a direct method call on a bridge method, if it exists.\n     */\n    protected boolean tryBridgeMethod(MethodNode target, Expression receiver, boolean implicitThis, TupleExpression args) {\n        ClassNode lookupClassNode;\n        if (target.isProtected()) {\n            lookupClassNode = controller.getClassNode();\n            while (lookupClassNode != null && !lookupClassNode.isDerivedFrom(target.getDeclaringClass())) {\n                lookupClassNode = lookupClassNode.getOuterClass();\n            }\n            if (lookupClassNode == null) {\n                return false;\n            }\n        } else {\n            lookupClassNode = target.getDeclaringClass().redirect();\n        }\n        Map<MethodNode, MethodNode> bridges = lookupClassNode.getNodeMetaData(PRIVATE_BRIDGE_METHODS);\n        MethodNode bridge = bridges==null?null:bridges.get(target);\n        if (bridge != null) {\n            Expression fixedReceiver = receiver;\n            if (implicitThis && !controller.isInClosure()) {\n                fixedReceiver = new PropertyExpression(new ClassExpression(lookupClassNode), \"this\");\n            }\n            ArgumentListExpression newArgs = new ArgumentListExpression(target.isStatic()?new ConstantExpression(null):fixedReceiver);\n            for (Expression expression : args.getExpressions()) {\n                newArgs.addExpression(expression);\n            }\n            return writeDirectMethodCall(bridge, implicitThis, fixedReceiver, newArgs);\n        }\n        return false;\n    }"
        ]
    ],
    "2c226838ed69685919ddfb0f1efb72fa92875b76": [
        [
            "MetaClassImpl::setProperty(Class,Object,String,Object,boolean,boolean)",
            "2569  \n2570  \n2571  \n2572  \n2573  \n2574  \n2575  \n2576  \n2577  \n2578  \n2579  \n2580  \n2581  \n2582  \n2583  \n2584  \n2585  \n2586  \n2587  \n2588  \n2589  \n2590  \n2591  \n2592  \n2593  \n2594  \n2595  \n2596  \n2597  \n2598  \n2599  \n2600  \n2601  \n2602  \n2603  \n2604  \n2605  \n2606  \n2607  \n2608  \n2609  \n2610  \n2611  \n2612  \n2613  \n2614  \n2615  \n2616  \n2617  \n2618  \n2619  \n2620  \n2621  \n2622  \n2623  \n2624  \n2625  \n2626  \n2627  \n2628  \n2629  \n2630  \n2631  \n2632  \n2633  \n2634  \n2635  \n2636  \n2637  \n2638  \n2639  \n2640  \n2641  \n2642  \n2643  \n2644  \n2645  \n2646  \n2647  \n2648  \n2649  \n2650  \n2651  \n2652  \n2653  \n2654  \n2655  \n2656  \n2657  \n2658  \n2659  \n2660  \n2661  \n2662  \n2663  \n2664  \n2665  \n2666  \n2667  \n2668  \n2669  \n2670  \n2671  \n2672  \n2673  \n2674  \n2675  \n2676  \n2677  \n2678  \n2679  \n2680  \n2681  \n2682  \n2683  \n2684  \n2685  \n2686  \n2687  \n2688  \n2689  \n2690  \n2691  \n2692  \n2693  \n2694  \n2695  \n2696  \n2697  \n2698  \n2699  \n2700  \n2701  \n2702  \n2703  \n2704  \n2705  \n2706 -\n2707 -\n2708 -\n2709 -\n2710 -\n2711 -\n2712 -\n2713 -\n2714  \n2715  \n2716  \n2717  \n2718  \n2719  \n2720  \n2721  \n2722  \n2723  \n2724  \n2725  ",
            "   /**\n     * <p>Retrieves a property on the given receiver for the specified arguments. The sender is the class that is requesting the property from the object.\n     * The MetaClass will attempt to establish the method to invoke based on the name and arguments provided.\n     *\n     * <p>The useSuper and fromInsideClass help the Groovy runtime perform optimisations on the call to go directly\n     * to the super class if necessary\n     *\n     * @param sender The java.lang.Class instance that is mutating the property\n     * @param object The Object which the property is being set on\n     * @param name The name of the property\n     * @param newValue The new value of the property to set\n     * @param useSuper Whether the call is to a super class property\n     * @param fromInsideClass Whether the call was invoked from the inside or the outside of the class.\n     */\n    public void setProperty(Class sender, Object object, String name, Object newValue, boolean useSuper, boolean fromInsideClass) {\n        checkInitalised();\n\n        //----------------------------------------------------------------------\n        // handling of static\n        //----------------------------------------------------------------------\n        boolean isStatic = theClass != Class.class && object instanceof Class;\n        if (isStatic && object != theClass) {\n            MetaClass mc = registry.getMetaClass((Class) object);\n            mc.getProperty(sender, object, name, useSuper, fromInsideClass);\n            return;\n        }\n\n        //----------------------------------------------------------------------\n        // Unwrap wrapped values fo now - the new MOP will handle them properly\n        //----------------------------------------------------------------------\n        if (newValue instanceof Wrapper) newValue = ((Wrapper) newValue).unwrap();\n\n        MetaMethod method = null;\n        Object[] arguments = null;\n\n        //----------------------------------------------------------------------\n        // setter\n        //----------------------------------------------------------------------\n        MetaProperty mp = getMetaProperty(sender, name, useSuper, isStatic);\n        MetaProperty field = null;\n        if (mp != null) {\n            if (mp instanceof MetaBeanProperty) {\n                MetaBeanProperty mbp = (MetaBeanProperty) mp;\n                method = mbp.getSetter();\n                MetaProperty f = mbp.getField();\n                if (method != null || (f != null && !Modifier.isFinal(f.getModifiers()))) {\n                    arguments = new Object[]{newValue};\n                    field = f;\n                }\n            } else {\n                field = mp;\n            }\n        }\n\n        // check for a category method named like a setter\n        if (!useSuper && !isStatic && GroovyCategorySupport.hasCategoryInCurrentThread()\n                && name.length() > 0) {\n            String getterName = GroovyCategorySupport.getPropertyCategorySetterName(name);\n            if (getterName != null) {\n                MetaMethod categoryMethod = getCategoryMethodSetter(sender, getterName, false);\n                if (categoryMethod != null) {\n                    method = categoryMethod;\n                    arguments = new Object[]{newValue};\n                }\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // listener method\n        //----------------------------------------------------------------------\n        boolean ambiguousListener = false;\n        if (method == null) {\n            method = (MetaMethod) listeners.get(name);\n            ambiguousListener = method == AMBIGUOUS_LISTENER_METHOD;\n            if (method != null &&\n                    !ambiguousListener &&\n                    newValue instanceof Closure) {\n                // let's create a dynamic proxy\n                Object proxy = Proxy.newProxyInstance(\n                        theClass.getClassLoader(),\n                        new Class[]{method.getParameterTypes()[0].getTheClass()},\n                        new ConvertedClosure((Closure) newValue, name));\n                arguments = new Object[]{proxy};\n                newValue = proxy;\n            } else {\n                method = null;\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // field\n        //----------------------------------------------------------------------\n        if (method == null && field != null) {\n            if (Modifier.isFinal(field.getModifiers())) {\n                throw new ReadOnlyPropertyException(name, theClass);\n            }\n            if(!(this.isMap && isPrivateOrPkgPrivate(field.getModifiers()))) {\n                field.setProperty(object, newValue);\n                return;\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // generic set method\n        //----------------------------------------------------------------------\n        // check for a generic get method provided through a category\n        if (method == null && !useSuper && !isStatic && GroovyCategorySupport.hasCategoryInCurrentThread()) {\n            method = getCategoryMethodSetter(sender, \"set\", true);\n            if (method != null) arguments = new Object[]{name, newValue};\n        }\n\n        // the generic method is valid, if available (!=null), if static or\n        // if it is not static and we do no static access\n        if (method == null && genericSetMethod != null && !(!genericSetMethod.isStatic() && isStatic)) {\n            arguments = new Object[]{name, newValue};\n            method = genericSetMethod;\n        }\n\n        //----------------------------------------------------------------------\n        // executing the getter method\n        //----------------------------------------------------------------------\n        if (method != null) {\n            if (arguments.length == 1) {\n                newValue = DefaultTypeTransformation.castToType(\n                        newValue,\n                        method.getParameterTypes()[0].getTheClass());\n                arguments[0] = newValue;\n            } else {\n                newValue = DefaultTypeTransformation.castToType(\n                        newValue,\n                        method.getParameterTypes()[1].getTheClass());\n                arguments[1] = newValue;\n            }\n            method.doMethodInvoke(object, arguments);\n            return;\n        }\n\n        //----------------------------------------------------------------------\n        // turn setProperty on a Map to put on the Map itself\n        //----------------------------------------------------------------------\n        if (!isStatic && this.isMap) {\n            ((Map) object).put(name, newValue);\n            return;\n        }\n\n        //----------------------------------------------------------------------\n        // error due to missing method/field\n        //----------------------------------------------------------------------\n        if (ambiguousListener) {\n            throw new GroovyRuntimeException(\"There are multiple listeners for the property \" + name + \". Please do not use the bean short form to access this listener.\");\n        }\n        if (mp != null) {\n            throw new ReadOnlyPropertyException(name, theClass);\n        }\n\n        invokeMissingProperty(object, name, newValue, false);\n    }",
            "2569  \n2570  \n2571  \n2572  \n2573  \n2574  \n2575  \n2576  \n2577  \n2578  \n2579  \n2580  \n2581  \n2582  \n2583  \n2584  \n2585  \n2586  \n2587  \n2588  \n2589  \n2590  \n2591  \n2592  \n2593  \n2594  \n2595  \n2596  \n2597  \n2598  \n2599  \n2600  \n2601  \n2602  \n2603  \n2604  \n2605  \n2606  \n2607  \n2608  \n2609  \n2610  \n2611  \n2612  \n2613  \n2614  \n2615  \n2616  \n2617  \n2618  \n2619  \n2620  \n2621  \n2622  \n2623  \n2624  \n2625  \n2626  \n2627  \n2628  \n2629  \n2630  \n2631  \n2632  \n2633  \n2634  \n2635  \n2636  \n2637  \n2638  \n2639  \n2640  \n2641  \n2642  \n2643  \n2644  \n2645  \n2646  \n2647  \n2648  \n2649  \n2650  \n2651  \n2652  \n2653  \n2654  \n2655  \n2656  \n2657  \n2658 +\n2659 +\n2660 +\n2661 +\n2662 +\n2663 +\n2664 +\n2665 +\n2666  \n2667  \n2668  \n2669  \n2670  \n2671  \n2672  \n2673  \n2674  \n2675  \n2676  \n2677  \n2678  \n2679  \n2680  \n2681  \n2682  \n2683  \n2684  \n2685  \n2686  \n2687  \n2688  \n2689  \n2690  \n2691  \n2692  \n2693  \n2694  \n2695  \n2696  \n2697  \n2698  \n2699  \n2700  \n2701  \n2702  \n2703  \n2704  \n2705  \n2706  \n2707  \n2708  \n2709  \n2710  \n2711  \n2712  \n2713  \n2714  \n2715  \n2716  \n2717  \n2718  \n2719  \n2720  \n2721  \n2722  \n2723  \n2724  \n2725  ",
            "   /**\n     * <p>Retrieves a property on the given receiver for the specified arguments. The sender is the class that is requesting the property from the object.\n     * The MetaClass will attempt to establish the method to invoke based on the name and arguments provided.\n     *\n     * <p>The useSuper and fromInsideClass help the Groovy runtime perform optimisations on the call to go directly\n     * to the super class if necessary\n     *\n     * @param sender The java.lang.Class instance that is mutating the property\n     * @param object The Object which the property is being set on\n     * @param name The name of the property\n     * @param newValue The new value of the property to set\n     * @param useSuper Whether the call is to a super class property\n     * @param fromInsideClass Whether the call was invoked from the inside or the outside of the class.\n     */\n    public void setProperty(Class sender, Object object, String name, Object newValue, boolean useSuper, boolean fromInsideClass) {\n        checkInitalised();\n\n        //----------------------------------------------------------------------\n        // handling of static\n        //----------------------------------------------------------------------\n        boolean isStatic = theClass != Class.class && object instanceof Class;\n        if (isStatic && object != theClass) {\n            MetaClass mc = registry.getMetaClass((Class) object);\n            mc.getProperty(sender, object, name, useSuper, fromInsideClass);\n            return;\n        }\n\n        //----------------------------------------------------------------------\n        // Unwrap wrapped values fo now - the new MOP will handle them properly\n        //----------------------------------------------------------------------\n        if (newValue instanceof Wrapper) newValue = ((Wrapper) newValue).unwrap();\n\n        MetaMethod method = null;\n        Object[] arguments = null;\n\n        //----------------------------------------------------------------------\n        // setter\n        //----------------------------------------------------------------------\n        MetaProperty mp = getMetaProperty(sender, name, useSuper, isStatic);\n        MetaProperty field = null;\n        if (mp != null) {\n            if (mp instanceof MetaBeanProperty) {\n                MetaBeanProperty mbp = (MetaBeanProperty) mp;\n                method = mbp.getSetter();\n                MetaProperty f = mbp.getField();\n                if (method != null || (f != null && !Modifier.isFinal(f.getModifiers()))) {\n                    arguments = new Object[]{newValue};\n                    field = f;\n                }\n            } else {\n                field = mp;\n            }\n        }\n\n        // check for a category method named like a setter\n        if (!useSuper && !isStatic && GroovyCategorySupport.hasCategoryInCurrentThread()\n                && name.length() > 0) {\n            String getterName = GroovyCategorySupport.getPropertyCategorySetterName(name);\n            if (getterName != null) {\n                MetaMethod categoryMethod = getCategoryMethodSetter(sender, getterName, false);\n                if (categoryMethod != null) {\n                    method = categoryMethod;\n                    arguments = new Object[]{newValue};\n                }\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // listener method\n        //----------------------------------------------------------------------\n        boolean ambiguousListener = false;\n        if (method == null) {\n            method = (MetaMethod) listeners.get(name);\n            ambiguousListener = method == AMBIGUOUS_LISTENER_METHOD;\n            if (method != null &&\n                    !ambiguousListener &&\n                    newValue instanceof Closure) {\n                // let's create a dynamic proxy\n                Object proxy = Proxy.newProxyInstance(\n                        theClass.getClassLoader(),\n                        new Class[]{method.getParameterTypes()[0].getTheClass()},\n                        new ConvertedClosure((Closure) newValue, name));\n                arguments = new Object[]{proxy};\n                newValue = proxy;\n            } else {\n                method = null;\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // turn setProperty on a Map to put on the Map itself\n        //----------------------------------------------------------------------\n        if (method == null && !isStatic && this.isMap) {\n            ((Map) object).put(name, newValue);\n            return;\n        }\n\n        //----------------------------------------------------------------------\n        // field\n        //----------------------------------------------------------------------\n        if (method == null && field != null) {\n            if (Modifier.isFinal(field.getModifiers())) {\n                throw new ReadOnlyPropertyException(name, theClass);\n            }\n            if(!(this.isMap && isPrivateOrPkgPrivate(field.getModifiers()))) {\n                field.setProperty(object, newValue);\n                return;\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // generic set method\n        //----------------------------------------------------------------------\n        // check for a generic get method provided through a category\n        if (method == null && !useSuper && !isStatic && GroovyCategorySupport.hasCategoryInCurrentThread()) {\n            method = getCategoryMethodSetter(sender, \"set\", true);\n            if (method != null) arguments = new Object[]{name, newValue};\n        }\n\n        // the generic method is valid, if available (!=null), if static or\n        // if it is not static and we do no static access\n        if (method == null && genericSetMethod != null && !(!genericSetMethod.isStatic() && isStatic)) {\n            arguments = new Object[]{name, newValue};\n            method = genericSetMethod;\n        }\n\n        //----------------------------------------------------------------------\n        // executing the getter method\n        //----------------------------------------------------------------------\n        if (method != null) {\n            if (arguments.length == 1) {\n                newValue = DefaultTypeTransformation.castToType(\n                        newValue,\n                        method.getParameterTypes()[0].getTheClass());\n                arguments[0] = newValue;\n            } else {\n                newValue = DefaultTypeTransformation.castToType(\n                        newValue,\n                        method.getParameterTypes()[1].getTheClass());\n                arguments[1] = newValue;\n            }\n            method.doMethodInvoke(object, arguments);\n            return;\n        }\n\n        //----------------------------------------------------------------------\n        // error due to missing method/field\n        //----------------------------------------------------------------------\n        if (ambiguousListener) {\n            throw new GroovyRuntimeException(\"There are multiple listeners for the property \" + name + \". Please do not use the bean short form to access this listener.\");\n        }\n        if (mp != null) {\n            throw new ReadOnlyPropertyException(name, theClass);\n        }\n\n        invokeMissingProperty(object, name, newValue, false);\n    }"
        ]
    ],
    "0d86565c503595965ce2ed697e87ddafe7c40491": [
        [
            "DefaultTypeTransformation::compareToWithEqualityCheck(Object,Object,boolean)",
            " 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564  \n 565  \n 566  \n 567  \n 568  \n 569  \n 570  \n 571  \n 572  \n 573  \n 574  \n 575  \n 576  \n 577  \n 578  \n 579  \n 580  \n 581  \n 582  \n 583 -\n 584  \n 585  \n 586  \n 587  \n 588  \n 589  \n 590  \n 591  \n 592  \n 593  \n 594  \n 595  \n 596  \n 597  \n 598  \n 599  \n 600  \n 601  \n 602  \n 603  \n 604  \n 605  ",
            "    private static int compareToWithEqualityCheck(Object left, Object right, boolean equalityCheckOnly) {\n        if (left == right) {\n            return 0;\n        }\n        if (left == null) {\n            return -1;\n        }\n        else if (right == null) {\n            return 1;\n        }\n        if (left instanceof Comparable) {\n            if (left instanceof Number) {\n                if (right instanceof Character || right instanceof Number) {\n                    return DefaultGroovyMethods.compareTo((Number) left, castToNumber(right));\n                }\n                if (isValidCharacterString(right)) {\n                    return DefaultGroovyMethods.compareTo((Number) left, ShortTypeHandling.castToChar(right));\n                }\n            }\n            else if (left instanceof Character) {\n                if (isValidCharacterString(right)) {\n                    return DefaultGroovyMethods.compareTo((Character)left, ShortTypeHandling.castToChar(right));\n                }\n                if (right instanceof Number) {\n                    return DefaultGroovyMethods.compareTo((Character)left,(Number)right);\n                }\n            }\n            else if (right instanceof Number) {\n                if (isValidCharacterString(left)) {\n                    return DefaultGroovyMethods.compareTo(ShortTypeHandling.castToChar(left),(Number) right);\n                }\n            }\n            else if (left instanceof String && right instanceof Character) {\n                return ((String) left).compareTo(right.toString());\n            }\n            else if (left instanceof String && right instanceof GString) {\n                return ((String) left).compareTo(right.toString());\n            }\n            if (!equalityCheckOnly || left.getClass().isAssignableFrom(right.getClass())\n                    || (right.getClass() != Object.class && right.getClass().isAssignableFrom(left.getClass())) //GROOVY-4046\n                    || (left instanceof GString && right instanceof String)) {\n                Comparable comparable = (Comparable) left;\n                // GROOVY-7876: when comparing for equality we try to only call compareTo when an assignable\n                // relationship holds but with a container/holder class and because of erasure, we might still end\n                // up with the prospect of a ClassCastException which we want to ignore but only if testing equality\n                try {\n                    return comparable.compareTo(right);\n                } catch (ClassCastException cce) {\n                    if (!equalityCheckOnly) throw cce;\n                }\n            }\n        }\n\n        if (equalityCheckOnly) {\n            return -1; // anything other than 0\n        }\n        throw new GroovyRuntimeException(\n                MessageFormat.format(\"Cannot compare {0} with value ''{1}'' and {2} with value ''{3}''\",\n                        left.getClass().getName(),\n                        left,\n                        right.getClass().getName(),\n                        right));\n    }",
            " 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564  \n 565  \n 566  \n 567  \n 568  \n 569  \n 570  \n 571  \n 572  \n 573  \n 574  \n 575  \n 576  \n 577  \n 578  \n 579  \n 580  \n 581 +\n 582 +\n 583 +\n 584  \n 585  \n 586 +\n 587  \n 588  \n 589  \n 590  \n 591  \n 592  \n 593  \n 594  \n 595  \n 596  \n 597  \n 598  \n 599  \n 600  \n 601  \n 602  \n 603  \n 604  \n 605  \n 606  \n 607  \n 608  ",
            "    private static int compareToWithEqualityCheck(Object left, Object right, boolean equalityCheckOnly) {\n        if (left == right) {\n            return 0;\n        }\n        if (left == null) {\n            return -1;\n        }\n        else if (right == null) {\n            return 1;\n        }\n        if (left instanceof Comparable) {\n            if (left instanceof Number) {\n                if (right instanceof Character || right instanceof Number) {\n                    return DefaultGroovyMethods.compareTo((Number) left, castToNumber(right));\n                }\n                if (isValidCharacterString(right)) {\n                    return DefaultGroovyMethods.compareTo((Number) left, ShortTypeHandling.castToChar(right));\n                }\n            }\n            else if (left instanceof Character) {\n                if (isValidCharacterString(right)) {\n                    return DefaultGroovyMethods.compareTo((Character)left, ShortTypeHandling.castToChar(right));\n                }\n                if (right instanceof Number) {\n                    return DefaultGroovyMethods.compareTo((Character)left,(Number)right);\n                }\n            }\n            else if (right instanceof Number) {\n                if (isValidCharacterString(left)) {\n                    return DefaultGroovyMethods.compareTo(ShortTypeHandling.castToChar(left),(Number) right);\n                }\n            }\n            else if (left instanceof String && right instanceof Character) {\n                return ((String) left).compareTo(right.toString());\n            }\n            else if (left instanceof String && right instanceof GString) {\n                return ((String) left).compareTo(right.toString());\n            }\n            else if (left instanceof GString && right instanceof String) {\n                return ((GString) left).compareTo(right);\n            }\n            if (!equalityCheckOnly || left.getClass().isAssignableFrom(right.getClass())\n                    || (right.getClass() != Object.class && right.getClass().isAssignableFrom(left.getClass())) //GROOVY-4046\n            ) {\n                Comparable comparable = (Comparable) left;\n                // GROOVY-7876: when comparing for equality we try to only call compareTo when an assignable\n                // relationship holds but with a container/holder class and because of erasure, we might still end\n                // up with the prospect of a ClassCastException which we want to ignore but only if testing equality\n                try {\n                    return comparable.compareTo(right);\n                } catch (ClassCastException cce) {\n                    if (!equalityCheckOnly) throw cce;\n                }\n            }\n        }\n\n        if (equalityCheckOnly) {\n            return -1; // anything other than 0\n        }\n        throw new GroovyRuntimeException(\n                MessageFormat.format(\"Cannot compare {0} with value ''{1}'' and {2} with value ''{3}''\",\n                        left.getClass().getName(),\n                        left,\n                        right.getClass().getName(),\n                        right));\n    }"
        ]
    ],
    "5714ed7f8a4f90ad89a831172f7f2f1a72979d82": [
        [
            "AsmClassGenerator::visitAttributeOrProperty(PropertyExpression,MethodCallerMultiAdapter)",
            " 865  \n 866  \n 867  \n 868  \n 869  \n 870  \n 871  \n 872  \n 873  \n 874  \n 875  \n 876  \n 877  \n 878  \n 879  \n 880  \n 881  \n 882  \n 883  \n 884  \n 885  \n 886  \n 887  \n 888  \n 889  \n 890  \n 891  \n 892  \n 893  \n 894  \n 895  \n 896  \n 897  \n 898  \n 899  \n 900  \n 901  \n 902  \n 903  \n 904  \n 905  \n 906  \n 907  \n 908  \n 909  \n 910  \n 911  \n 912  \n 913  \n 914  \n 915  \n 916  \n 917  \n 918  \n 919  \n 920  \n 921  \n 922  \n 923  \n 924  \n 925  \n 926  \n 927  \n 928  \n 929  \n 930  \n 931  \n 932  \n 933  \n 934  \n 935  \n 936  \n 937  \n 938  \n 939  \n 940  \n 941  \n 942  \n 943  \n 944  \n 945  \n 946  \n 947  \n 948  \n 949  \n 950  \n 951  \n 952  \n 953  \n 954  \n 955  \n 956  \n 957  \n 958  \n 959  \n 960  \n 961  \n 962  \n 963  \n 964 -\n 965 -\n 966  \n 967 -\n 968 -\n 969  \n 970  \n 971  \n 972 -\n 973 -\n 974  \n 975  \n 976  \n 977  \n 978  \n 979  \n 980  \n 981  \n 982  \n 983  \n 984  \n 985  \n 986  \n 987  \n 988  \n 989  \n 990  \n 991  \n 992  ",
            "    private void visitAttributeOrProperty(PropertyExpression expression, MethodCallerMultiAdapter adapter) {\n        MethodVisitor mv = controller.getMethodVisitor();\n\n        Expression objectExpression = expression.getObjectExpression();\n        ClassNode classNode = controller.getClassNode();\n        if (isThisOrSuper(objectExpression)) {\n            // let's use the field expression if it's available\n            String name = expression.getPropertyAsString();\n            if (name != null) {\n                FieldNode field = null;\n                boolean privateSuperField = false;\n                if (isSuperExpression(objectExpression)) {\n                    field = classNode.getSuperClass().getDeclaredField(name);\n                    if (field != null && ((field.getModifiers() & ACC_PRIVATE) != 0)) {\n                        privateSuperField = true;\n                    }\n                } else {\n                \tif (controller.isNotExplicitThisInClosure(expression.isImplicitThis())) {\n                        field = classNode.getDeclaredField(name);\n                        if (field==null && classNode instanceof InnerClassNode) {\n                            ClassNode outer = classNode.getOuterClass();\n                            FieldNode outerClassField;\n                            while (outer!=null) {\n                                outerClassField = outer.getDeclaredField(name);\n                                if (outerClassField!=null && outerClassField.isStatic() && outerClassField.isFinal()) {\n                                    if (outer!=classNode.getOuterClass() && Modifier.isPrivate(outerClassField.getModifiers())) {\n                                        throw new GroovyBugError(\"Trying to access private constant field [\"+outerClassField.getDeclaringClass()+\"#\"+outerClassField.getName()+\"] from inner class\");\n                                    }\n                                    PropertyExpression pexp = new PropertyExpression(\n                                            new ClassExpression(outer),\n                                            expression.getProperty()\n                                    );\n                                    pexp.visit(controller.getAcg());\n                                    return;\n                                }\n                                outer = outer.getSuperClass();\n                            }\n                        }\n                        if (field==null\n                                && expression instanceof AttributeExpression\n                                && isThisExpression(objectExpression)\n                                && controller.isStaticContext()) {\n                            // GROOVY-6183\n                            ClassNode current = classNode.getSuperClass();\n                            while (field==null && current!=null) {\n                                field = current.getDeclaredField(name);\n                                current = current.getSuperClass();\n                            }\n                            if (field!=null && (field.isProtected() || field.isPublic())) {\n                                visitFieldExpression(new FieldExpression(field));\n                                return;\n                            }\n                        }\n                \t}\n                }\n                if (field != null && !privateSuperField) {//GROOVY-4497: don't visit super field if it is private\n                    visitFieldExpression(new FieldExpression(field));\n                    return;\n                }\n                if (isSuperExpression(objectExpression)) {\n                    String prefix;\n                    if (controller.getCompileStack().isLHS()) {\n                        throw new GroovyBugError(\"Unexpected super property set for:\" + expression.getText());\n                    } else {\n                        prefix = \"get\";\n                    }\n                    String propName = prefix + MetaClassHelper.capitalize(name);\n                    visitMethodCallExpression(new MethodCallExpression(objectExpression, propName, MethodCallExpression.NO_ARGUMENTS));\n                    return;\n                }\n            }\n        }\n\n        final String propName = expression.getPropertyAsString();\n        //TODO: add support for super here too\n        if (expression.getObjectExpression() instanceof ClassExpression &&\n            propName!=null && propName.equals(\"this\"))\n        {\n            // we have something like A.B.this, and need to make it\n            // into this.this$0.this$0, where this.this$0 returns\n            // A.B and this.this$0.this$0 return A.\n            ClassNode type = objectExpression.getType();\n            ClassNode iterType = classNode;\n            if (controller.getCompileStack().isInSpecialConstructorCall() && classNode instanceof InnerClassNode) {\n                boolean staticInnerClass = classNode.isStaticClass();\n                // Outer.this in a special constructor call\n                if (classNode.getOuterClass().equals(type)) {\n                    ConstructorNode ctor = controller.getConstructorNode();\n                    Expression receiver = !staticInnerClass ? new VariableExpression(ctor.getParameters()[0]) : new ClassExpression(type);\n                    receiver.setSourcePosition(expression);\n                    receiver.visit(this);\n                    return;\n                }\n            }\n            mv.visitVarInsn(ALOAD, 0);\n            while (!iterType.equals(type)) {\n                String ownerName = BytecodeHelper.getClassInternalName(iterType);\n                if (iterType.getOuterClass()==null) break;\n                FieldNode thisField = iterType.getField(\"this$0\");\n                if (thisField==null) break;\n                ClassNode thisFieldType = thisField.getType();\n                iterType = iterType.getOuterClass();\n                if (ClassHelper.CLOSURE_TYPE.equals(thisFieldType)) {\n                    mv.visitFieldInsn(GETFIELD, ownerName, \"this$0\", BytecodeHelper.getTypeDescription(ClassHelper.CLOSURE_TYPE));\n                    mv.visitMethodInsn(INVOKEVIRTUAL, BytecodeHelper.getClassInternalName(ClassHelper.CLOSURE_TYPE), \"getThisObject\", \"()Ljava/lang/Object;\", false);\n                    mv.visitTypeInsn(CHECKCAST, BytecodeHelper.getClassInternalName(iterType));\n                } else {\n                    String typeName = BytecodeHelper.getTypeDescription(iterType);\n                    mv.visitFieldInsn(GETFIELD, ownerName, \"this$0\", typeName);\n                }\n            }\n            controller.getOperandStack().push(type);\n            return;\n        }\n\n        if (adapter == getProperty && !expression.isSpreadSafe() && propName != null) {\n            controller.getCallSiteWriter().makeGetPropertySite(objectExpression, propName, expression.isSafe(), expression.isImplicitThis());\n        } else if (adapter == getGroovyObjectProperty && !expression.isSpreadSafe() && propName != null) {\n            controller.getCallSiteWriter().makeGroovyObjectGetPropertySite(objectExpression, propName, expression.isSafe(), expression.isImplicitThis());\n        } else {\n            // todo: for improved modularity and extensibility, this should be moved into a writer\n            if (controller.getCompileStack().isLHS()) controller.getOperandStack().box();\n            controller.getInvocationWriter().makeCall(\n                    expression,\n                    objectExpression, // receiver\n                    new CastExpression(ClassHelper.STRING_TYPE, expression.getProperty()), // messageName\n                    MethodCallExpression.NO_ARGUMENTS, adapter,\n                    expression.isSafe(), expression.isSpreadSafe(), expression.isImplicitThis()",
            " 865  \n 866  \n 867  \n 868  \n 869  \n 870  \n 871  \n 872  \n 873  \n 874  \n 875  \n 876  \n 877  \n 878  \n 879  \n 880  \n 881  \n 882  \n 883  \n 884  \n 885  \n 886  \n 887  \n 888  \n 889  \n 890  \n 891  \n 892  \n 893  \n 894  \n 895  \n 896  \n 897  \n 898  \n 899  \n 900  \n 901  \n 902  \n 903  \n 904  \n 905  \n 906  \n 907  \n 908  \n 909  \n 910  \n 911  \n 912  \n 913  \n 914  \n 915  \n 916  \n 917  \n 918  \n 919  \n 920  \n 921  \n 922  \n 923  \n 924  \n 925  \n 926  \n 927  \n 928  \n 929  \n 930  \n 931  \n 932  \n 933  \n 934  \n 935  \n 936  \n 937  \n 938  \n 939  \n 940  \n 941  \n 942  \n 943  \n 944  \n 945  \n 946  \n 947  \n 948  \n 949  \n 950  \n 951  \n 952  \n 953  \n 954  \n 955  \n 956  \n 957  \n 958  \n 959  \n 960  \n 961  \n 962  \n 963  \n 964  \n 965 +\n 966 +\n 967  \n 968  \n 969  \n 970 +\n 971 +\n 972 +\n 973 +\n 974 +\n 975 +\n 976 +\n 977 +\n 978 +\n 979  \n 980  \n 981  \n 982  \n 983  \n 984  \n 985  \n 986  \n 987  \n 988  \n 989  \n 990  \n 991  \n 992  \n 993  \n 994  \n 995  \n 996  \n 997  ",
            "    private void visitAttributeOrProperty(PropertyExpression expression, MethodCallerMultiAdapter adapter) {\n        MethodVisitor mv = controller.getMethodVisitor();\n\n        Expression objectExpression = expression.getObjectExpression();\n        ClassNode classNode = controller.getClassNode();\n        if (isThisOrSuper(objectExpression)) {\n            // let's use the field expression if it's available\n            String name = expression.getPropertyAsString();\n            if (name != null) {\n                FieldNode field = null;\n                boolean privateSuperField = false;\n                if (isSuperExpression(objectExpression)) {\n                    field = classNode.getSuperClass().getDeclaredField(name);\n                    if (field != null && ((field.getModifiers() & ACC_PRIVATE) != 0)) {\n                        privateSuperField = true;\n                    }\n                } else {\n                \tif (controller.isNotExplicitThisInClosure(expression.isImplicitThis())) {\n                        field = classNode.getDeclaredField(name);\n                        if (field==null && classNode instanceof InnerClassNode) {\n                            ClassNode outer = classNode.getOuterClass();\n                            FieldNode outerClassField;\n                            while (outer!=null) {\n                                outerClassField = outer.getDeclaredField(name);\n                                if (outerClassField!=null && outerClassField.isStatic() && outerClassField.isFinal()) {\n                                    if (outer!=classNode.getOuterClass() && Modifier.isPrivate(outerClassField.getModifiers())) {\n                                        throw new GroovyBugError(\"Trying to access private constant field [\"+outerClassField.getDeclaringClass()+\"#\"+outerClassField.getName()+\"] from inner class\");\n                                    }\n                                    PropertyExpression pexp = new PropertyExpression(\n                                            new ClassExpression(outer),\n                                            expression.getProperty()\n                                    );\n                                    pexp.visit(controller.getAcg());\n                                    return;\n                                }\n                                outer = outer.getSuperClass();\n                            }\n                        }\n                        if (field==null\n                                && expression instanceof AttributeExpression\n                                && isThisExpression(objectExpression)\n                                && controller.isStaticContext()) {\n                            // GROOVY-6183\n                            ClassNode current = classNode.getSuperClass();\n                            while (field==null && current!=null) {\n                                field = current.getDeclaredField(name);\n                                current = current.getSuperClass();\n                            }\n                            if (field!=null && (field.isProtected() || field.isPublic())) {\n                                visitFieldExpression(new FieldExpression(field));\n                                return;\n                            }\n                        }\n                \t}\n                }\n                if (field != null && !privateSuperField) {//GROOVY-4497: don't visit super field if it is private\n                    visitFieldExpression(new FieldExpression(field));\n                    return;\n                }\n                if (isSuperExpression(objectExpression)) {\n                    String prefix;\n                    if (controller.getCompileStack().isLHS()) {\n                        throw new GroovyBugError(\"Unexpected super property set for:\" + expression.getText());\n                    } else {\n                        prefix = \"get\";\n                    }\n                    String propName = prefix + MetaClassHelper.capitalize(name);\n                    visitMethodCallExpression(new MethodCallExpression(objectExpression, propName, MethodCallExpression.NO_ARGUMENTS));\n                    return;\n                }\n            }\n        }\n\n        final String propName = expression.getPropertyAsString();\n        //TODO: add support for super here too\n        if (expression.getObjectExpression() instanceof ClassExpression &&\n            propName!=null && propName.equals(\"this\"))\n        {\n            // we have something like A.B.this, and need to make it\n            // into this.this$0.this$0, where this.this$0 returns\n            // A.B and this.this$0.this$0 return A.\n            ClassNode type = objectExpression.getType();\n            ClassNode iterType = classNode;\n            if (controller.getCompileStack().isInSpecialConstructorCall() && classNode instanceof InnerClassNode) {\n                boolean staticInnerClass = classNode.isStaticClass();\n                // Outer.this in a special constructor call\n                if (classNode.getOuterClass().equals(type)) {\n                    ConstructorNode ctor = controller.getConstructorNode();\n                    Expression receiver = !staticInnerClass ? new VariableExpression(ctor.getParameters()[0]) : new ClassExpression(type);\n                    receiver.setSourcePosition(expression);\n                    receiver.visit(this);\n                    return;\n                }\n            }\n            mv.visitVarInsn(ALOAD, 0);\n            while (!iterType.equals(type)) {\n                String ownerName = BytecodeHelper.getClassInternalName(iterType);\n                if (iterType.getOuterClass()==null) break;\n                FieldNode thisField = iterType.getField(\"this$0\");\n                iterType = iterType.getOuterClass();\n                if (thisField == null) {\n                    // closure within inner class\n                    mv.visitMethodInsn(INVOKEVIRTUAL, BytecodeHelper.getClassInternalName(ClassHelper.CLOSURE_TYPE), \"getThisObject\", \"()Ljava/lang/Object;\", false);\n                    mv.visitTypeInsn(CHECKCAST, BytecodeHelper.getClassInternalName(iterType));\n                } else {\n                    ClassNode thisFieldType = thisField.getType();\n                    if (ClassHelper.CLOSURE_TYPE.equals(thisFieldType)) {\n                        mv.visitFieldInsn(GETFIELD, ownerName, \"this$0\", BytecodeHelper.getTypeDescription(ClassHelper.CLOSURE_TYPE));\n                        mv.visitMethodInsn(INVOKEVIRTUAL, BytecodeHelper.getClassInternalName(ClassHelper.CLOSURE_TYPE), \"getThisObject\", \"()Ljava/lang/Object;\", false);\n                        mv.visitTypeInsn(CHECKCAST, BytecodeHelper.getClassInternalName(iterType));\n                    } else {\n                        String typeName = BytecodeHelper.getTypeDescription(iterType);\n                        mv.visitFieldInsn(GETFIELD, ownerName, \"this$0\", typeName);\n                    }\n                }\n            }\n            controller.getOperandStack().push(type);\n            return;\n        }\n\n        if (adapter == getProperty && !expression.isSpreadSafe() && propName != null) {\n            controller.getCallSiteWriter().makeGetPropertySite(objectExpression, propName, expression.isSafe(), expression.isImplicitThis());\n        } else if (adapter == getGroovyObjectProperty && !expression.isSpreadSafe() && propName != null) {\n            controller.getCallSiteWriter().makeGroovyObjectGetPropertySite(objectExpression, propName, expression.isSafe(), expression.isImplicitThis());\n        } else {\n            // todo: for improved modularity and extensibility, this should be moved into a writer\n            if (controller.getCompileStack().isLHS()) controller.getOperandStack().box();\n            controller.getInvocationWriter().makeCall(\n                    expression,\n                    objectExpression, // receiver\n                    new CastExpression(ClassHelper.STRING_TYPE, expression.getProperty()), // messageName\n                    MethodCallExpression.NO_ARGUMENTS, adapter,\n                    expression.isSafe(), expression.isSpreadSafe(), expression.isImplicitThis()"
        ],
        [
            "StaticTypeCheckingVisitor::existsProperty(PropertyExpression,boolean,ClassCodeVisitorSupport)",
            "1162  \n1163  \n1164  \n1165  \n1166  \n1167  \n1168  \n1169  \n1170  \n1171  \n1172  \n1173  \n1174  \n1175  \n1176  \n1177  \n1178  \n1179  \n1180  \n1181  \n1182 -\n1183  \n1184 -\n1185 -\n1186 -\n1187 -\n1188 -\n1189 -\n1190  \n1191  \n1192  \n1193  \n1194  \n1195  \n1196  \n1197  \n1198  \n1199  \n1200  \n1201  \n1202  \n1203  \n1204  \n1205  \n1206  \n1207  \n1208  \n1209  \n1210  \n1211  \n1212  \n1213  \n1214  \n1215  \n1216  \n1217  \n1218  \n1219  \n1220  \n1221  \n1222  \n1223  \n1224  \n1225  \n1226  \n1227  \n1228  \n1229  \n1230  \n1231  \n1232  \n1233  \n1234  \n1235  \n1236  \n1237  \n1238  \n1239  \n1240  \n1241  \n1242  \n1243  \n1244  \n1245  \n1246  \n1247  \n1248  \n1249  \n1250  \n1251  \n1252  \n1253  \n1254  \n1255  \n1256  \n1257  \n1258  \n1259  \n1260  \n1261  \n1262  \n1263  \n1264  \n1265  \n1266  \n1267  \n1268  \n1269  \n1270  \n1271  \n1272  \n1273  \n1274  \n1275  \n1276  \n1277  \n1278  \n1279  \n1280  \n1281  \n1282  \n1283  \n1284  \n1285  \n1286  \n1287  \n1288  \n1289  \n1290  \n1291  \n1292  \n1293  \n1294  \n1295  \n1296  \n1297  \n1298  \n1299  \n1300  \n1301  \n1302  \n1303  \n1304  \n1305  \n1306  \n1307  \n1308  \n1309  \n1310  \n1311  \n1312  \n1313  \n1314  \n1315  \n1316  \n1317  \n1318  \n1319  \n1320  \n1321  \n1322  \n1323  \n1324  \n1325  \n1326  \n1327  \n1328  \n1329  \n1330  \n1331  \n1332  \n1333  \n1334  \n1335  \n1336  \n1337  \n1338  \n1339  \n1340  \n1341  \n1342  \n1343  \n1344  \n1345  \n1346  \n1347  \n1348  \n1349  \n1350  \n1351  \n1352  \n1353  \n1354  \n1355  \n1356  \n1357  \n1358  \n1359  ",
            "    /**\n     * Checks whether a property exists on the receiver, or on any of the possible receiver classes (found in the\n     * temporary type information table)\n     *\n     * @param pexp             a property expression\n     * @param readMode         if true, look for property read, else for property set\n     * @param visitor          if not null, when the property node is found, visit it with the provided visitor\n     * @return true if the property is defined in any of the possible receiver classes\n     */\n    protected boolean existsProperty(final PropertyExpression pexp, final boolean readMode, final ClassCodeVisitorSupport visitor) {\n        super.visitPropertyExpression(pexp);\n\n        String propertyName = pexp.getPropertyAsString();\n        if (propertyName == null) return false;\n\n        Expression objectExpression = pexp.getObjectExpression();\n        final ClassNode objectExpressionType = getType(objectExpression);\n\n        boolean staticOnlyAccess = isClassClassNodeWrappingConcreteType(objectExpressionType);\n        if (\"this\".equals(propertyName) && staticOnlyAccess) {\n            // Outer.this\n            ClassNode outerNode = objectExpressionType.getGenericsTypes()[0].getType();\n            ClassNode current = typeCheckingContext.getEnclosingClassNode();\n            if (!current.isStaticClass() && current instanceof InnerClassNode) {\n                InnerClassNode icn = (InnerClassNode) current;\n                if (outerNode.equals(icn.getOuterClass())) {\n                    storeType(pexp, outerNode);\n                    return true;\n                }\n            }\n        }\n\n        if (objectExpressionType.isArray() && \"length\".equals(pexp.getPropertyAsString())) {\n            storeType(pexp, int_TYPE);\n            if (visitor != null) {\n                PropertyNode node = new PropertyNode(\"length\", Opcodes.ACC_PUBLIC | Opcodes.ACC_FINAL, int_TYPE, objectExpressionType, null, null, null);\n                visitor.visitProperty(node);\n            }\n            return true;\n        }\n\n        boolean foundGetterOrSetter = false;\n        List<Receiver<String>> receivers = new LinkedList<Receiver<String>>();\n        List<Receiver<String>> owners = makeOwnerList(objectExpression);\n        addReceivers(receivers, owners, pexp.isImplicitThis());\n\n        String capName = MetaClassHelper.capitalize(propertyName);\n        boolean isAttributeExpression = pexp instanceof AttributeExpression;\n        HashSet<ClassNode> handledNodes = new HashSet<ClassNode>();\n        for (Receiver<String> receiver : receivers) {\n            ClassNode testClass = receiver.getType();\n            LinkedList<ClassNode> queue = new LinkedList<ClassNode>();\n            queue.add(testClass);\n            if (isPrimitiveType(testClass)) {\n                queue.add(getWrapper(testClass));\n            }\n            while (!queue.isEmpty()) {\n                ClassNode current = queue.removeFirst();\n                if (handledNodes.contains(current)) continue;\n                handledNodes.add(current);\n                Set<ClassNode> allInterfaces = current.getAllInterfaces();\n                for (ClassNode intf : allInterfaces) {\n                    //TODO: apply right generics here!\n                    queue.add(GenericsUtils.parameterizeType(current, intf));\n                }\n\n                // in case of a lookup on Class we look for instance methods on Class\n                // as well, since in case of a static property access we have the class\n                // itself in the list of receivers already;\n                boolean staticOnly;\n                if (isClassClassNodeWrappingConcreteType(current)) {\n                    staticOnly = false;\n                } else {\n                    staticOnly = staticOnlyAccess;\n                }\n\n                FieldNode field = current.getDeclaredField(propertyName);\n                field = allowStaticAccessToMember(field, staticOnly);\n                if (storeField(field, isAttributeExpression, pexp, current, visitor, receiver.getData(), !readMode)) return true;\n\n                boolean isThisExpression = objectExpression instanceof VariableExpression\n                        && ((VariableExpression) objectExpression).isThisExpression()\n                        && objectExpressionType.equals(current);\n\n                if (storeField(field, isThisExpression, pexp, receiver.getType(), visitor, receiver.getData(), !readMode))\n                    return true;\n\n                MethodNode getter = current.getGetterMethod(\"get\" + capName);\n                getter = allowStaticAccessToMember(getter, staticOnly);\n                if (getter == null) getter = current.getGetterMethod(\"is\" + capName);\n                getter = allowStaticAccessToMember(getter, staticOnly);\n                final String setterName = \"set\" + capName;\n                List<MethodNode> setters = findSetters(current, setterName, false);\n                setters = allowStaticAccessToMember(setters, staticOnly);\n\n                // TODO: remove this visit\n                // need to visit even if we only look for a setters for compatibility\n                if (visitor != null && getter != null) visitor.visitMethod(getter);\n\n                PropertyNode propertyNode = current.getProperty(propertyName);\n                propertyNode = allowStaticAccessToMember(propertyNode, staticOnly);\n                //prefer explicit getter or setter over property if receiver is not 'this'\n                boolean checkGetterOrSetter = !isThisExpression || propertyNode == null;\n\n                if (readMode && checkGetterOrSetter) {\n                    if (getter != null) {\n                        ClassNode cn = inferReturnTypeGenerics(current, getter, ArgumentListExpression.EMPTY_ARGUMENTS);\n                        storeInferredTypeForPropertyExpression(pexp, cn);\n                        pexp.removeNodeMetaData(StaticTypesMarker.READONLY_PROPERTY);\n                        String delegationData = receiver.getData();\n                        if (delegationData != null)\n                            pexp.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER, delegationData);\n                        return true;\n                    }\n                } else if (!readMode && checkGetterOrSetter) {\n                    if (!setters.isEmpty()) {\n                        if (visitor != null) {\n                            if (field != null) {\n                                visitor.visitField(field);\n                            } else {\n                                for (MethodNode setter : setters) {\n                                    ClassNode setterType = setter.getParameters()[0].getOriginType();\n                                    FieldNode virtual = new FieldNode(propertyName, 0, setterType, current, EmptyExpression.INSTANCE);\n                                    visitor.visitField(virtual);\n                                }\n                            }\n                        }\n                        //TODO: apply generics on parameter[0]?\n//                                storeType(pexp, setter.getParameters()[0].getType());\n                        SetterInfo info = new SetterInfo(current, setterName, setters);\n                        BinaryExpression enclosingBinaryExpression = typeCheckingContext.getEnclosingBinaryExpression();\n                        if (enclosingBinaryExpression != null) {\n                            putSetterInfo(enclosingBinaryExpression.getLeftExpression(), info);\n                        }\n                        String delegationData = receiver.getData();\n                        if (delegationData != null) {\n                            pexp.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER, delegationData);\n                        }\n                        return true;\n                    } else if (getter != null && propertyNode == null) {\n                        pexp.putNodeMetaData(StaticTypesMarker.READONLY_PROPERTY, true);\n                    }\n                }\n                foundGetterOrSetter = foundGetterOrSetter || !setters.isEmpty() || getter != null;\n\n                if (storeProperty(propertyNode, pexp, current, visitor, receiver.getData())) return true;\n\n                if (storeField(field, true, pexp, current, visitor, receiver.getData(), !readMode)) return true;\n                // if the property expression is an attribute expression (o.@attr), then\n                // we stop now, otherwise we must check the parent class\n                if (/*!isAttributeExpression && */current.getSuperClass() != null) {\n                    queue.add(current.getUnresolvedSuperClass());\n                }\n            }\n            // GROOVY-5568, the property may be defined by DGM\n            List<ClassNode> dgmReceivers = new ArrayList<ClassNode>(2);\n            dgmReceivers.add(testClass);\n            if (isPrimitiveType(testClass)) dgmReceivers.add(getWrapper(testClass));\n            for (ClassNode dgmReceiver: dgmReceivers) {\n                List<MethodNode> methods = findDGMMethodsByNameAndArguments(getTransformLoader(), dgmReceiver, \"get\" + capName, ClassNode.EMPTY_ARRAY);\n                for (MethodNode m : findDGMMethodsByNameAndArguments(getTransformLoader(), dgmReceiver, \"is\" + capName, ClassNode.EMPTY_ARRAY)) {\n                    if (Boolean_TYPE.equals(getWrapper(m.getReturnType()))) methods.add(m);\n                }\n                if (!methods.isEmpty()) {\n                    List<MethodNode> methodNodes = chooseBestMethod(dgmReceiver, methods, ClassNode.EMPTY_ARRAY);\n                    if (methodNodes.size() == 1) {\n                        MethodNode getter = methodNodes.get(0);\n                        if (visitor != null) {\n                            visitor.visitMethod(getter);\n                        }\n                        ClassNode cn = inferReturnTypeGenerics(dgmReceiver, getter, ArgumentListExpression.EMPTY_ARGUMENTS);\n                        storeInferredTypeForPropertyExpression(pexp, cn);\n\n                        return true;\n                    }\n                }\n            }\n        }\n\n        for (Receiver<String> receiver : receivers) {\n            ClassNode testClass = receiver.getType();\n            ClassNode propertyType = getTypeForMapPropertyExpression(testClass, objectExpressionType, pexp);\n            if (propertyType==null) propertyType = getTypeForListPropertyExpression(testClass, objectExpressionType, pexp);\n            if (propertyType==null) propertyType = getTypeForSpreadExpression(testClass, objectExpressionType, pexp);\n            if (propertyType==null) continue;\n            if (visitor!=null) {\n                // todo : type inference on maps and lists, if possible\n                PropertyNode node = new PropertyNode(propertyName, Opcodes.ACC_PUBLIC, propertyType, receiver.getType(), null, null, null);\n                node.setDeclaringClass(receiver.getType());\n                visitor.visitProperty(node);\n            }\n            storeType(pexp, propertyType);\n            String delegationData = receiver.getData();\n            if (delegationData!=null) pexp.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER, delegationData);\n            return true;\n        }\n        return foundGetterOrSetter;\n    }",
            "1162  \n1163  \n1164  \n1165  \n1166  \n1167  \n1168  \n1169  \n1170  \n1171  \n1172  \n1173  \n1174  \n1175  \n1176  \n1177  \n1178  \n1179  \n1180  \n1181  \n1182 +\n1183  \n1184 +\n1185 +\n1186 +\n1187 +\n1188 +\n1189 +\n1190  \n1191  \n1192 +\n1193 +\n1194 +\n1195 +\n1196  \n1197  \n1198  \n1199  \n1200  \n1201  \n1202  \n1203  \n1204  \n1205  \n1206  \n1207  \n1208  \n1209  \n1210  \n1211  \n1212  \n1213  \n1214  \n1215  \n1216  \n1217  \n1218  \n1219  \n1220  \n1221  \n1222  \n1223  \n1224  \n1225  \n1226  \n1227  \n1228  \n1229  \n1230  \n1231  \n1232  \n1233  \n1234  \n1235  \n1236  \n1237  \n1238  \n1239  \n1240  \n1241  \n1242  \n1243  \n1244  \n1245  \n1246  \n1247  \n1248  \n1249  \n1250  \n1251  \n1252  \n1253  \n1254  \n1255  \n1256  \n1257  \n1258  \n1259  \n1260  \n1261  \n1262  \n1263  \n1264  \n1265  \n1266  \n1267  \n1268  \n1269  \n1270  \n1271  \n1272  \n1273  \n1274  \n1275  \n1276  \n1277  \n1278  \n1279  \n1280  \n1281  \n1282  \n1283  \n1284  \n1285  \n1286  \n1287  \n1288  \n1289  \n1290  \n1291  \n1292  \n1293  \n1294  \n1295  \n1296  \n1297  \n1298  \n1299  \n1300  \n1301  \n1302  \n1303  \n1304  \n1305  \n1306  \n1307  \n1308  \n1309  \n1310  \n1311  \n1312  \n1313  \n1314  \n1315  \n1316  \n1317  \n1318  \n1319  \n1320  \n1321  \n1322  \n1323  \n1324  \n1325  \n1326  \n1327  \n1328  \n1329  \n1330  \n1331  \n1332  \n1333  \n1334  \n1335  \n1336  \n1337  \n1338  \n1339  \n1340  \n1341  \n1342  \n1343  \n1344  \n1345  \n1346  \n1347  \n1348  \n1349  \n1350  \n1351  \n1352  \n1353  \n1354  \n1355  \n1356  \n1357  \n1358  \n1359  \n1360  \n1361  \n1362  \n1363  ",
            "    /**\n     * Checks whether a property exists on the receiver, or on any of the possible receiver classes (found in the\n     * temporary type information table)\n     *\n     * @param pexp             a property expression\n     * @param readMode         if true, look for property read, else for property set\n     * @param visitor          if not null, when the property node is found, visit it with the provided visitor\n     * @return true if the property is defined in any of the possible receiver classes\n     */\n    protected boolean existsProperty(final PropertyExpression pexp, final boolean readMode, final ClassCodeVisitorSupport visitor) {\n        super.visitPropertyExpression(pexp);\n\n        String propertyName = pexp.getPropertyAsString();\n        if (propertyName == null) return false;\n\n        Expression objectExpression = pexp.getObjectExpression();\n        final ClassNode objectExpressionType = getType(objectExpression);\n\n        boolean staticOnlyAccess = isClassClassNodeWrappingConcreteType(objectExpressionType);\n        if (\"this\".equals(propertyName) && staticOnlyAccess) {\n            // Outer.this for any level of nesting\n            ClassNode outerNode = objectExpressionType.getGenericsTypes()[0].getType();\n            List<ClassNode> candidates = typeCheckingContext.getEnclosingClassNodes();\n            ClassNode found = null;\n            for (ClassNode current : candidates) {\n                if (!current.isStaticClass() && current instanceof InnerClassNode && outerNode.equals(current.getOuterClass())) {\n                    found = current;\n                    break;\n                }\n            }\n            if (found != null) {\n                storeType(pexp, outerNode);\n                return true;\n            }\n        }\n\n        if (objectExpressionType.isArray() && \"length\".equals(pexp.getPropertyAsString())) {\n            storeType(pexp, int_TYPE);\n            if (visitor != null) {\n                PropertyNode node = new PropertyNode(\"length\", Opcodes.ACC_PUBLIC | Opcodes.ACC_FINAL, int_TYPE, objectExpressionType, null, null, null);\n                visitor.visitProperty(node);\n            }\n            return true;\n        }\n\n        boolean foundGetterOrSetter = false;\n        List<Receiver<String>> receivers = new LinkedList<Receiver<String>>();\n        List<Receiver<String>> owners = makeOwnerList(objectExpression);\n        addReceivers(receivers, owners, pexp.isImplicitThis());\n\n        String capName = MetaClassHelper.capitalize(propertyName);\n        boolean isAttributeExpression = pexp instanceof AttributeExpression;\n        HashSet<ClassNode> handledNodes = new HashSet<ClassNode>();\n        for (Receiver<String> receiver : receivers) {\n            ClassNode testClass = receiver.getType();\n            LinkedList<ClassNode> queue = new LinkedList<ClassNode>();\n            queue.add(testClass);\n            if (isPrimitiveType(testClass)) {\n                queue.add(getWrapper(testClass));\n            }\n            while (!queue.isEmpty()) {\n                ClassNode current = queue.removeFirst();\n                if (handledNodes.contains(current)) continue;\n                handledNodes.add(current);\n                Set<ClassNode> allInterfaces = current.getAllInterfaces();\n                for (ClassNode intf : allInterfaces) {\n                    //TODO: apply right generics here!\n                    queue.add(GenericsUtils.parameterizeType(current, intf));\n                }\n\n                // in case of a lookup on Class we look for instance methods on Class\n                // as well, since in case of a static property access we have the class\n                // itself in the list of receivers already;\n                boolean staticOnly;\n                if (isClassClassNodeWrappingConcreteType(current)) {\n                    staticOnly = false;\n                } else {\n                    staticOnly = staticOnlyAccess;\n                }\n\n                FieldNode field = current.getDeclaredField(propertyName);\n                field = allowStaticAccessToMember(field, staticOnly);\n                if (storeField(field, isAttributeExpression, pexp, current, visitor, receiver.getData(), !readMode)) return true;\n\n                boolean isThisExpression = objectExpression instanceof VariableExpression\n                        && ((VariableExpression) objectExpression).isThisExpression()\n                        && objectExpressionType.equals(current);\n\n                if (storeField(field, isThisExpression, pexp, receiver.getType(), visitor, receiver.getData(), !readMode))\n                    return true;\n\n                MethodNode getter = current.getGetterMethod(\"get\" + capName);\n                getter = allowStaticAccessToMember(getter, staticOnly);\n                if (getter == null) getter = current.getGetterMethod(\"is\" + capName);\n                getter = allowStaticAccessToMember(getter, staticOnly);\n                final String setterName = \"set\" + capName;\n                List<MethodNode> setters = findSetters(current, setterName, false);\n                setters = allowStaticAccessToMember(setters, staticOnly);\n\n                // TODO: remove this visit\n                // need to visit even if we only look for a setters for compatibility\n                if (visitor != null && getter != null) visitor.visitMethod(getter);\n\n                PropertyNode propertyNode = current.getProperty(propertyName);\n                propertyNode = allowStaticAccessToMember(propertyNode, staticOnly);\n                //prefer explicit getter or setter over property if receiver is not 'this'\n                boolean checkGetterOrSetter = !isThisExpression || propertyNode == null;\n\n                if (readMode && checkGetterOrSetter) {\n                    if (getter != null) {\n                        ClassNode cn = inferReturnTypeGenerics(current, getter, ArgumentListExpression.EMPTY_ARGUMENTS);\n                        storeInferredTypeForPropertyExpression(pexp, cn);\n                        pexp.removeNodeMetaData(StaticTypesMarker.READONLY_PROPERTY);\n                        String delegationData = receiver.getData();\n                        if (delegationData != null)\n                            pexp.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER, delegationData);\n                        return true;\n                    }\n                } else if (!readMode && checkGetterOrSetter) {\n                    if (!setters.isEmpty()) {\n                        if (visitor != null) {\n                            if (field != null) {\n                                visitor.visitField(field);\n                            } else {\n                                for (MethodNode setter : setters) {\n                                    ClassNode setterType = setter.getParameters()[0].getOriginType();\n                                    FieldNode virtual = new FieldNode(propertyName, 0, setterType, current, EmptyExpression.INSTANCE);\n                                    visitor.visitField(virtual);\n                                }\n                            }\n                        }\n                        //TODO: apply generics on parameter[0]?\n//                                storeType(pexp, setter.getParameters()[0].getType());\n                        SetterInfo info = new SetterInfo(current, setterName, setters);\n                        BinaryExpression enclosingBinaryExpression = typeCheckingContext.getEnclosingBinaryExpression();\n                        if (enclosingBinaryExpression != null) {\n                            putSetterInfo(enclosingBinaryExpression.getLeftExpression(), info);\n                        }\n                        String delegationData = receiver.getData();\n                        if (delegationData != null) {\n                            pexp.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER, delegationData);\n                        }\n                        return true;\n                    } else if (getter != null && propertyNode == null) {\n                        pexp.putNodeMetaData(StaticTypesMarker.READONLY_PROPERTY, true);\n                    }\n                }\n                foundGetterOrSetter = foundGetterOrSetter || !setters.isEmpty() || getter != null;\n\n                if (storeProperty(propertyNode, pexp, current, visitor, receiver.getData())) return true;\n\n                if (storeField(field, true, pexp, current, visitor, receiver.getData(), !readMode)) return true;\n                // if the property expression is an attribute expression (o.@attr), then\n                // we stop now, otherwise we must check the parent class\n                if (/*!isAttributeExpression && */current.getSuperClass() != null) {\n                    queue.add(current.getUnresolvedSuperClass());\n                }\n            }\n            // GROOVY-5568, the property may be defined by DGM\n            List<ClassNode> dgmReceivers = new ArrayList<ClassNode>(2);\n            dgmReceivers.add(testClass);\n            if (isPrimitiveType(testClass)) dgmReceivers.add(getWrapper(testClass));\n            for (ClassNode dgmReceiver: dgmReceivers) {\n                List<MethodNode> methods = findDGMMethodsByNameAndArguments(getTransformLoader(), dgmReceiver, \"get\" + capName, ClassNode.EMPTY_ARRAY);\n                for (MethodNode m : findDGMMethodsByNameAndArguments(getTransformLoader(), dgmReceiver, \"is\" + capName, ClassNode.EMPTY_ARRAY)) {\n                    if (Boolean_TYPE.equals(getWrapper(m.getReturnType()))) methods.add(m);\n                }\n                if (!methods.isEmpty()) {\n                    List<MethodNode> methodNodes = chooseBestMethod(dgmReceiver, methods, ClassNode.EMPTY_ARRAY);\n                    if (methodNodes.size() == 1) {\n                        MethodNode getter = methodNodes.get(0);\n                        if (visitor != null) {\n                            visitor.visitMethod(getter);\n                        }\n                        ClassNode cn = inferReturnTypeGenerics(dgmReceiver, getter, ArgumentListExpression.EMPTY_ARGUMENTS);\n                        storeInferredTypeForPropertyExpression(pexp, cn);\n\n                        return true;\n                    }\n                }\n            }\n        }\n\n        for (Receiver<String> receiver : receivers) {\n            ClassNode testClass = receiver.getType();\n            ClassNode propertyType = getTypeForMapPropertyExpression(testClass, objectExpressionType, pexp);\n            if (propertyType==null) propertyType = getTypeForListPropertyExpression(testClass, objectExpressionType, pexp);\n            if (propertyType==null) propertyType = getTypeForSpreadExpression(testClass, objectExpressionType, pexp);\n            if (propertyType==null) continue;\n            if (visitor!=null) {\n                // todo : type inference on maps and lists, if possible\n                PropertyNode node = new PropertyNode(propertyName, Opcodes.ACC_PUBLIC, propertyType, receiver.getType(), null, null, null);\n                node.setDeclaringClass(receiver.getType());\n                visitor.visitProperty(node);\n            }\n            storeType(pexp, propertyType);\n            String delegationData = receiver.getData();\n            if (delegationData!=null) pexp.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER, delegationData);\n            return true;\n        }\n        return foundGetterOrSetter;\n    }"
        ]
    ],
    "01fdb705c4ca0737949c4fd323b62736c27716a8": [
        [
            "Sql::newInstance(Map)",
            " 516  \n 517  \n 518  \n 519  \n 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528  \n 529  \n 530  \n 531  \n 532  \n 533  \n 534  \n 535  \n 536  \n 537  \n 538  \n 539  \n 540  \n 541  \n 542  \n 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564  \n 565  \n 566  \n 567  \n 568  \n 569  \n 570  \n 571  \n 572  \n 573  \n 574  \n 575  \n 576  \n 577  \n 578  \n 579  \n 580  \n 581  \n 582 -\n 583 -\n 584 -\n 585  \n 586  \n 587  \n 588  \n 589  \n 590  \n 591  \n 592  \n 593  \n 594  \n 595  \n 596  \n 597  \n 598  ",
            "    /**\n     * Creates a new Sql instance given parameters in a Map.\n     * Recognized keys for the Map include:\n     * <pre>\n     * driverClassName the fully qualified class name of the driver class\n     * driver          a synonym for driverClassName\n     * url             a database url of the form: <code>jdbc:<em>subprotocol</em>:<em>subname</em></code>\n     * user            the database user on whose behalf the connection is being made\n     * password        the user's password\n     * properties      a list of arbitrary string tag/value pairs as connection arguments;\n     *                 normally at least a \"user\" and \"password\" property should be included\n     * <em>other</em>           any of the public setter methods of this class may be used with property notation\n     *                 e.g. <em>cacheStatements: true, resultSetConcurrency: ResultSet.CONCUR_READ_ONLY</em>\n     * </pre>\n     * Of these, '<code>url</code>' is required. Others may be needed depending on your database.<br>\n     * If '<code>properties</code>' is supplied, neither '<code>user</code>' nor '<code>password</code>' should be supplied.<br>\n     * If one of '<code>user</code>' or '<code>password</code>' is supplied, both should be supplied.\n     *<p>\n     * Example usage:\n     * <pre>\n     * import groovy.sql.Sql\n     * import static java.sql.ResultSet.*\n     *\n     * def sql = Sql.newInstance(\n     *     url:'jdbc:hsqldb:mem:testDB',\n     *     user:'sa',\n     *     password:'',\n     *     driver:'org.hsqldb.jdbc.JDBCDriver',\n     *     cacheStatements: true,\n     *     resultSetConcurrency: CONCUR_READ_ONLY\n     * )\n     * </pre>\n     * \n     * @param args a Map contain further arguments\n     * @return a new Sql instance with a connection\n     * @throws SQLException           if a database access error occurs\n     * @throws ClassNotFoundException if the driver class cannot be found or loaded\n     */\n    public static Sql newInstance(Map<String, Object> args) throws SQLException, ClassNotFoundException {\n        if (!args.containsKey(\"url\"))\n            throw new IllegalArgumentException(\"Argument 'url' is required\");\n\n        if (args.get(\"url\") == null)\n            throw new IllegalArgumentException(\"Argument 'url' must not be null\");\n\n        if (args.containsKey(\"driverClassName\") && args.containsKey(\"driver\"))\n            throw new IllegalArgumentException(\"Only one of 'driverClassName' and 'driver' should be provided\");\n\n        // Make a copy so destructive operations will not affect the caller\n        Map<String, Object> sqlArgs = new HashMap<String, Object>(args);\n\n        Object driverClassName = sqlArgs.remove(\"driverClassName\");\n        if (driverClassName == null) driverClassName = sqlArgs.remove(\"driver\");\n        if (driverClassName != null) loadDriver(driverClassName.toString());\n\n        Properties props = (Properties) sqlArgs.remove(\"properties\");\n        if (props != null && sqlArgs.containsKey(\"user\"))\n            throw new IllegalArgumentException(\"Only one of 'properties' and 'user' should be supplied\");\n        if (props != null && sqlArgs.containsKey(\"password\"))\n            throw new IllegalArgumentException(\"Only one of 'properties' and 'password' should be supplied\");\n        if (sqlArgs.containsKey(\"user\") ^ sqlArgs.containsKey(\"password\"))\n            throw new IllegalArgumentException(\"Found one but not both of 'user' and 'password'\");\n\n        Object url = sqlArgs.remove(\"url\");\n        Connection connection;\n        if (props != null) {\n            System.err.println(\"url = \" + url);\n            System.err.println(\"props = \" + props);\n            connection = DriverManager.getConnection(url.toString(), new Properties(props));\n        } else if (sqlArgs.containsKey(\"user\")) {\n            Object user = sqlArgs.remove(\"user\");\n            Object password = sqlArgs.remove(\"password\");\n            connection = DriverManager.getConnection(url.toString(),\n                    (user == null ? null : user.toString()),\n                    (password == null ? null : password.toString()));\n        } else {\n            connection = DriverManager.getConnection(url.toString());\n        }\n\n        Sql result = (Sql) InvokerHelper.invokeConstructorOf(Sql.class, sqlArgs);\n        result.setConnection(connection);\n        return result;\n    }",
            " 516  \n 517  \n 518  \n 519  \n 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528  \n 529  \n 530  \n 531  \n 532  \n 533  \n 534  \n 535  \n 536  \n 537  \n 538  \n 539  \n 540  \n 541  \n 542  \n 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564  \n 565  \n 566  \n 567  \n 568  \n 569  \n 570  \n 571  \n 572  \n 573  \n 574  \n 575  \n 576  \n 577  \n 578  \n 579  \n 580  \n 581 +\n 582  \n 583 +\n 584 +\n 585 +\n 586 +\n 587 +\n 588 +\n 589 +\n 590 +\n 591  \n 592  \n 593 +\n 594  \n 595 +\n 596  \n 597  \n 598  \n 599  \n 600 +\n 601  \n 602  \n 603  \n 604  \n 605  \n 606  \n 607  ",
            "    /**\n     * Creates a new Sql instance given parameters in a Map.\n     * Recognized keys for the Map include:\n     * <pre>\n     * driverClassName the fully qualified class name of the driver class\n     * driver          a synonym for driverClassName\n     * url             a database url of the form: <code>jdbc:<em>subprotocol</em>:<em>subname</em></code>\n     * user            the database user on whose behalf the connection is being made\n     * password        the user's password\n     * properties      a list of arbitrary string tag/value pairs as connection arguments;\n     *                 normally at least a \"user\" and \"password\" property should be included\n     * <em>other</em>           any of the public setter methods of this class may be used with property notation\n     *                 e.g. <em>cacheStatements: true, resultSetConcurrency: ResultSet.CONCUR_READ_ONLY</em>\n     * </pre>\n     * Of these, '<code>url</code>' is required. Others may be needed depending on your database.<br>\n     * If '<code>properties</code>' is supplied, neither '<code>user</code>' nor '<code>password</code>' should be supplied.<br>\n     * If one of '<code>user</code>' or '<code>password</code>' is supplied, both should be supplied.\n     *<p>\n     * Example usage:\n     * <pre>\n     * import groovy.sql.Sql\n     * import static java.sql.ResultSet.*\n     *\n     * def sql = Sql.newInstance(\n     *     url:'jdbc:hsqldb:mem:testDB',\n     *     user:'sa',\n     *     password:'',\n     *     driver:'org.hsqldb.jdbc.JDBCDriver',\n     *     cacheStatements: true,\n     *     resultSetConcurrency: CONCUR_READ_ONLY\n     * )\n     * </pre>\n     * \n     * @param args a Map contain further arguments\n     * @return a new Sql instance with a connection\n     * @throws SQLException           if a database access error occurs\n     * @throws ClassNotFoundException if the driver class cannot be found or loaded\n     */\n    public static Sql newInstance(Map<String, Object> args) throws SQLException, ClassNotFoundException {\n        if (!args.containsKey(\"url\"))\n            throw new IllegalArgumentException(\"Argument 'url' is required\");\n\n        if (args.get(\"url\") == null)\n            throw new IllegalArgumentException(\"Argument 'url' must not be null\");\n\n        if (args.containsKey(\"driverClassName\") && args.containsKey(\"driver\"))\n            throw new IllegalArgumentException(\"Only one of 'driverClassName' and 'driver' should be provided\");\n\n        // Make a copy so destructive operations will not affect the caller\n        Map<String, Object> sqlArgs = new HashMap<String, Object>(args);\n\n        Object driverClassName = sqlArgs.remove(\"driverClassName\");\n        if (driverClassName == null) driverClassName = sqlArgs.remove(\"driver\");\n        if (driverClassName != null) loadDriver(driverClassName.toString());\n\n        Properties props = (Properties) sqlArgs.remove(\"properties\");\n        if (props != null && sqlArgs.containsKey(\"user\"))\n            throw new IllegalArgumentException(\"Only one of 'properties' and 'user' should be supplied\");\n        if (props != null && sqlArgs.containsKey(\"password\"))\n            throw new IllegalArgumentException(\"Only one of 'properties' and 'password' should be supplied\");\n        if (sqlArgs.containsKey(\"user\") ^ sqlArgs.containsKey(\"password\"))\n            throw new IllegalArgumentException(\"Found one but not both of 'user' and 'password'\");\n\n        Object url = sqlArgs.remove(\"url\");\n        Connection connection;\n        LOG.fine(\"url = \" + url);\n        if (props != null) {\n            Properties propsCopy = new Properties(props);\n            connection = DriverManager.getConnection(url.toString(), propsCopy);\n            if (propsCopy.containsKey(\"password\")) {\n                // don't log the password\n                propsCopy = new Properties(propsCopy);\n                propsCopy.setProperty(\"password\", \"***\");\n            }\n            LOG.fine(\"props = \" + propsCopy);\n        } else if (sqlArgs.containsKey(\"user\")) {\n            Object user = sqlArgs.remove(\"user\");\n            LOG.fine(\"user = \" + user);\n            Object password = sqlArgs.remove(\"password\");\n            LOG.fine(\"password = \" + (password == null ? \"null\" : \"***\"));\n            connection = DriverManager.getConnection(url.toString(),\n                    (user == null ? null : user.toString()),\n                    (password == null ? null : password.toString()));\n        } else {\n            LOG.fine(\"No user/password specified\");\n            connection = DriverManager.getConnection(url.toString());\n        }\n\n        Sql result = (Sql) InvokerHelper.invokeConstructorOf(Sql.class, sqlArgs);\n        result.setConnection(connection);\n        return result;\n    }"
        ]
    ],
    "774415910b4f34eb09e0fa2154be91df3902974d": [
        [
            "AnnotationCollectorTransform::ClassChanger::transformClass(ClassNode)",
            "  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100 -\n 101 -\n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127 -\n 128  \n 129  \n 130  ",
            "        /**\n         * Method to transform the given ClassNode, if it is annotated with \n         * {@link AnnotationCollector}. See class description for what the\n         * transformation includes.\n         */\n        public void transformClass(ClassNode cn) {\n            AnnotationNode collector = null;\n            for (ListIterator<AnnotationNode> it = cn.getAnnotations().listIterator(); it.hasNext();) {\n                AnnotationNode an = it.next();\n                if (an.getClassNode().getName().equals(AnnotationCollector.class.getName())) {\n                    collector = an;\n                    break;\n                }\n            }\n            if (collector==null) return;\n            \n            // force final class, remove interface, annotation, enum and abstract modifiers\n            cn.setModifiers((ACC_FINAL+cn.getModifiers()) & ~(ACC_ENUM|ACC_INTERFACE|ACC_ANNOTATION|ACC_ABSTRACT));\n            // force Object super class\n            cn.setSuperClass(ClassHelper.OBJECT_TYPE);\n            // force no interfaces implemented\n            cn.setInterfaces(ClassNode.EMPTY_ARRAY);\n\n            // add static value():Object[][] method\n            List<AnnotationNode> meta = getMeta(cn); \n            List<Expression> outer = new ArrayList<Expression>(meta.size());\n            for (AnnotationNode an : meta) {\n                Expression serialized = serialize(an);\n                outer.add(serialized);\n            }\n\n            ArrayExpression ae = new ArrayExpression(ClassHelper.OBJECT_TYPE.makeArray(), outer);\n            Statement code = new ReturnStatement(ae);\n            cn.addMethod(   \"value\", ACC_PUBLIC+ACC_STATIC,\n                            ClassHelper.OBJECT_TYPE.makeArray().makeArray(), \n                            Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY,\n                            code);\n\n            // remove annotations\n            for (ListIterator<AnnotationNode> it = cn.getAnnotations().listIterator(); it.hasNext();) {\n                AnnotationNode an = it.next();\n                if (an==collector) continue;\n                it.remove();\n            }\n        }",
            "  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100 +\n 101 +\n 102 +\n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128 +\n 129 +\n 130 +\n 131  \n 132  \n 133  ",
            "        /**\n         * Method to transform the given ClassNode, if it is annotated with \n         * {@link AnnotationCollector}. See class description for what the\n         * transformation includes.\n         */\n        public void transformClass(ClassNode cn) {\n            AnnotationNode collector = null;\n            for (ListIterator<AnnotationNode> it = cn.getAnnotations().listIterator(); it.hasNext();) {\n                AnnotationNode an = it.next();\n                if (an.getClassNode().getName().equals(AnnotationCollector.class.getName())) {\n                    collector = an;\n                    break;\n                }\n            }\n            if (collector == null) {\n                return;\n            }\n            // force final class, remove interface, annotation, enum and abstract modifiers\n            cn.setModifiers((ACC_FINAL+cn.getModifiers()) & ~(ACC_ENUM|ACC_INTERFACE|ACC_ANNOTATION|ACC_ABSTRACT));\n            // force Object super class\n            cn.setSuperClass(ClassHelper.OBJECT_TYPE);\n            // force no interfaces implemented\n            cn.setInterfaces(ClassNode.EMPTY_ARRAY);\n\n            // add static value():Object[][] method\n            List<AnnotationNode> meta = getMeta(cn); \n            List<Expression> outer = new ArrayList<Expression>(meta.size());\n            for (AnnotationNode an : meta) {\n                Expression serialized = serialize(an);\n                outer.add(serialized);\n            }\n\n            ArrayExpression ae = new ArrayExpression(ClassHelper.OBJECT_TYPE.makeArray(), outer);\n            Statement code = new ReturnStatement(ae);\n            cn.addMethod(   \"value\", ACC_PUBLIC+ACC_STATIC,\n                            ClassHelper.OBJECT_TYPE.makeArray().makeArray(), \n                            Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY,\n                            code);\n\n            // remove annotations\n            for (ListIterator<AnnotationNode> it = cn.getAnnotations().listIterator(); it.hasNext();) {\n                AnnotationNode an = it.next();\n                if (an == collector) {\n                    continue;\n                }\n                it.remove();\n            }\n        }"
        ],
        [
            "AnnotationCollectorTransform::makeListOfAnnotations(Object)",
            " 253  \n 254 -\n 255 -\n 256  \n 257  \n 258 -\n 259  \n 260  \n 261  \n 262  \n 263  \n 264 -\n 265  \n 266 -\n 267 -\n 268 -\n 269  \n 270  \n 271  \n 272  \n 273  ",
            "    private static List<AnnotationNode> makeListOfAnnotations(Object[][] data) {\n        if (data.length==0) return Collections.EMPTY_LIST;\n\n        List<AnnotationNode> ret = new ArrayList<AnnotationNode>(data.length);\n        for (Object[] inner : data) {\n            Class anno = (Class) inner[0];\n            AnnotationNode toAdd = new AnnotationNode(ClassHelper.make(anno));\n            ret.add(toAdd);\n\n            @SuppressWarnings(\"unchecked\")\n            Map<String,Object> member = (Map<String, Object>) inner[1];\n            if (member.isEmpty()) continue;\n            Map<String, Expression> generated = new HashMap<String, Expression>(member.size());\n            for (String name : member.keySet()) {\n                Object val = member.get(name);\n                generated.put(name, makeExpression(val));\n            }\n            copyMembers(generated, toAdd);\n        }\n        return ret;\n    }",
            " 260  \n 261 +\n 262 +\n 263 +\n 264  \n 265  \n 266 +\n 267  \n 268  \n 269  \n 270  \n 271  \n 272 +\n 273 +\n 274 +\n 275  \n 276 +\n 277 +\n 278  \n 279  \n 280  \n 281  \n 282  ",
            "    private static List<AnnotationNode> makeListOfAnnotations(Object[][] data) {\n        if (data.length == 0) {\n            return Collections.emptyList();\n        }\n        List<AnnotationNode> ret = new ArrayList<AnnotationNode>(data.length);\n        for (Object[] inner : data) {\n            Class<?> anno = (Class) inner[0];\n            AnnotationNode toAdd = new AnnotationNode(ClassHelper.make(anno));\n            ret.add(toAdd);\n\n            @SuppressWarnings(\"unchecked\")\n            Map<String,Object> member = (Map<String, Object>) inner[1];\n            if (member.isEmpty()) {\n                continue;\n            }\n            Map<String, Expression> generated = new HashMap<String, Expression>(member.size());\n            for (Map.Entry<String, Object> entry : member.entrySet()) {\n                generated.put(entry.getKey(), makeExpression(entry.getValue()));\n            }\n            copyMembers(generated, toAdd);\n        }\n        return ret;\n    }"
        ],
        [
            "Traits::getBridgeMethodTarget(Method)",
            " 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220 -\n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  ",
            "    /**\n     * Reflection API to find the method corresponding to the default implementation of a trait, given a bridge method.\n     * @param someMethod a method node\n     * @return null if it is not a method implemented in a trait. If it is, returns the method from the trait class.\n     */\n    public static Method getBridgeMethodTarget(Method someMethod) {\n        TraitBridge annotation = someMethod.getAnnotation(TraitBridge.class);\n        if (annotation==null) {\n            return null;\n        }\n        Class aClass = annotation.traitClass();\n        String desc = annotation.desc();\n        for (Method method : aClass.getDeclaredMethods()) {\n            String methodDescriptor = BytecodeHelper.getMethodDescriptor(method.getReturnType(), method.getParameterTypes());\n            if (desc.equals(methodDescriptor)) {\n                return method;\n            }\n        }\n        return null;\n    }",
            " 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220 +\n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  ",
            "    /**\n     * Reflection API to find the method corresponding to the default implementation of a trait, given a bridge method.\n     * @param someMethod a method node\n     * @return null if it is not a method implemented in a trait. If it is, returns the method from the trait class.\n     */\n    public static Method getBridgeMethodTarget(Method someMethod) {\n        TraitBridge annotation = someMethod.getAnnotation(TraitBridge.class);\n        if (annotation==null) {\n            return null;\n        }\n        Class<?> aClass = annotation.traitClass();\n        String desc = annotation.desc();\n        for (Method method : aClass.getDeclaredMethods()) {\n            String methodDescriptor = BytecodeHelper.getMethodDescriptor(method.getReturnType(), method.getParameterTypes());\n            if (desc.equals(methodDescriptor)) {\n                return method;\n            }\n        }\n        return null;\n    }"
        ],
        [
            "AnnotationCollectorTransform::getTargetListFromAnnotations(ClassNode)",
            " 215  \n 216  \n 217 -\n 218 -\n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  ",
            "    private static List<AnnotationNode> getTargetListFromAnnotations(ClassNode alias) {\n        List<AnnotationNode> annotations = alias.getAnnotations();\n        if (annotations.size() < 2) return Collections.EMPTY_LIST;\n        \n        List<AnnotationNode> ret = new ArrayList<AnnotationNode>(annotations.size());\n        for (AnnotationNode an : annotations) {\n            ClassNode type = an.getClassNode();\n            if (type.getName().equals(AnnotationCollector.class.getName())) continue;\n            AnnotationNode toAdd = new AnnotationNode(type);\n            copyMembers(an, toAdd);\n            ret.add(toAdd);\n        }\n        return ret;\n    }",
            " 221  \n 222  \n 223 +\n 224 +\n 225 +\n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  ",
            "    private static List<AnnotationNode> getTargetListFromAnnotations(ClassNode alias) {\n        List<AnnotationNode> annotations = alias.getAnnotations();\n        if (annotations.size() < 2) {\n            return Collections.emptyList();\n        }\n        List<AnnotationNode> ret = new ArrayList<AnnotationNode>(annotations.size());\n        for (AnnotationNode an : annotations) {\n            ClassNode type = an.getClassNode();\n            if (type.getName().equals(AnnotationCollector.class.getName())) continue;\n            AnnotationNode toAdd = new AnnotationNode(type);\n            copyMembers(an, toAdd);\n            ret.add(toAdd);\n        }\n        return ret;\n    }"
        ],
        [
            "AnnotationCollectorTransform::getTargetAnnotationList(AnnotationNode,AnnotationNode,SourceUnit)",
            " 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  \n 306  \n 307  \n 308 -\n 309  \n 310  \n 311  \n 312  \n 313  \n 314  ",
            "    /**\n     * Returns a list of AnnotationNodes for the value attribute of the given \n     * AnnotationNode. \n     * \n     * @param collector     the node containing the value member with the list\n     * @param source        the source unit for error reporting\n     * @return              a list of string constants\n     */\n    protected List<AnnotationNode> getTargetAnnotationList(AnnotationNode collector, AnnotationNode aliasAnnotationUsage, SourceUnit source) {\n        List<AnnotationNode> stored     = getStoredTargetList(aliasAnnotationUsage, source);\n        List<AnnotationNode> targetList = getTargetListFromValue(collector, aliasAnnotationUsage, source);\n        int size = targetList.size()+stored.size();\n        if (size==0) return Collections.EMPTY_LIST;\n        List<AnnotationNode> ret = new ArrayList<AnnotationNode>(size);\n        ret.addAll(stored);\n        ret.addAll(targetList);\n\n        return ret;\n    }",
            " 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319 +\n 320 +\n 321 +\n 322  \n 323  \n 324  \n 325  \n 326  \n 327  ",
            "    /**\n     * Returns a list of AnnotationNodes for the value attribute of the given \n     * AnnotationNode. \n     * \n     * @param collector     the node containing the value member with the list\n     * @param source        the source unit for error reporting\n     * @return              a list of string constants\n     */\n    protected List<AnnotationNode> getTargetAnnotationList(AnnotationNode collector, AnnotationNode aliasAnnotationUsage, SourceUnit source) {\n        List<AnnotationNode> stored     = getStoredTargetList(aliasAnnotationUsage, source);\n        List<AnnotationNode> targetList = getTargetListFromValue(collector, aliasAnnotationUsage, source);\n        int size = targetList.size()+stored.size();\n        if (size == 0) {\n            return Collections.emptyList();\n        }\n        List<AnnotationNode> ret = new ArrayList<AnnotationNode>(size);\n        ret.addAll(stored);\n        ret.addAll(targetList);\n\n        return ret;\n    }"
        ],
        [
            "AnnotationCollectorTransform::getTargetListFromValue(AnnotationNode,AnnotationNode,SourceUnit)",
            " 178  \n 179  \n 180 -\n 181  \n 182  \n 183 -\n 184  \n 185  \n 186  \n 187 -\n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  ",
            "    private List<AnnotationNode> getTargetListFromValue(AnnotationNode collector, AnnotationNode aliasAnnotationUsage, SourceUnit source) {\n        Expression memberValue = collector.getMember(\"value\");\n        if (memberValue == null) return Collections.EMPTY_LIST;\n        if (!(memberValue instanceof ListExpression)) {\n            addError(\"Annotation collector expected a list of classes, but got a \"+memberValue.getClass(), collector, source);\n            return Collections.EMPTY_LIST;\n        }\n        ListExpression memberListExp = (ListExpression) memberValue;\n        List<Expression> memberList = memberListExp.getExpressions();\n        if (memberList.isEmpty()) return Collections.EMPTY_LIST;\n        List<AnnotationNode> ret = new ArrayList<AnnotationNode>();\n        for (Expression e : memberList) {\n            AnnotationNode toAdd = new AnnotationNode(e.getType());\n            toAdd.setSourcePosition(aliasAnnotationUsage);\n            ret.add(toAdd);\n        }\n        return ret;\n    }",
            " 180  \n 181  \n 182 +\n 183 +\n 184 +\n 185  \n 186  \n 187 +\n 188  \n 189  \n 190  \n 191 +\n 192 +\n 193 +\n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  ",
            "    private List<AnnotationNode> getTargetListFromValue(AnnotationNode collector, AnnotationNode aliasAnnotationUsage, SourceUnit source) {\n        Expression memberValue = collector.getMember(\"value\");\n        if (memberValue == null) {\n            return Collections.emptyList();\n        }\n        if (!(memberValue instanceof ListExpression)) {\n            addError(\"Annotation collector expected a list of classes, but got a \"+memberValue.getClass(), collector, source);\n            return Collections.emptyList();\n        }\n        ListExpression memberListExp = (ListExpression) memberValue;\n        List<Expression> memberList = memberListExp.getExpressions();\n        if (memberList.isEmpty()) {\n            return Collections.emptyList();\n        }\n        List<AnnotationNode> ret = new ArrayList<AnnotationNode>();\n        for (Expression e : memberList) {\n            AnnotationNode toAdd = new AnnotationNode(e.getType());\n            toAdd.setSourcePosition(aliasAnnotationUsage);\n            ret.add(toAdd);\n        }\n        return ret;\n    }"
        ],
        [
            "AnnotationCollectorTransform::makeExpression(Object)",
            " 275  \n 276 -\n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  ",
            "    private static Expression makeExpression(Object o) {\n        if (o instanceof Class) return new ClassExpression(ClassHelper.make((Class) o));\n        //TODO: value as Annotation here!\n        if (o instanceof Object[][]) {\n            List<AnnotationNode> annotations = makeListOfAnnotations((Object[][])o);\n            ListExpression le = new ListExpression();\n            for (AnnotationNode an : annotations) {\n                le.addExpression(new AnnotationConstantExpression(an));\n            }\n            return le;\n        } else if (o instanceof Object[]) {\n            ListExpression le = new ListExpression();\n            Object[] values = (Object[]) o;\n            for (Object val : values) {\n                le.addExpression(makeExpression(val));\n            }\n            return le;\n        }\n        return new ConstantExpression(o,true);\n    }",
            " 284  \n 285 +\n 286 +\n 287 +\n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  ",
            "    private static Expression makeExpression(Object o) {\n        if (o instanceof Class) {\n            return new ClassExpression(ClassHelper.make((Class) o));\n        }\n        //TODO: value as Annotation here!\n        if (o instanceof Object[][]) {\n            List<AnnotationNode> annotations = makeListOfAnnotations((Object[][])o);\n            ListExpression le = new ListExpression();\n            for (AnnotationNode an : annotations) {\n                le.addExpression(new AnnotationConstantExpression(an));\n            }\n            return le;\n        } else if (o instanceof Object[]) {\n            ListExpression le = new ListExpression();\n            Object[] values = (Object[]) o;\n            for (Object val : values) {\n                le.addExpression(makeExpression(val));\n            }\n            return le;\n        }\n        return new ConstantExpression(o,true);\n    }"
        ],
        [
            "AnnotationCollectorTransform::ClassChanger::serialize(AnnotationNode)",
            " 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160 -\n 161 -\n 162  ",
            "        private Expression serialize(AnnotationNode an) {\n            MapExpression map = new MapExpression();\n            for (String key : an.getMembers().keySet()) {\n                map.addMapEntryExpression(new ConstantExpression(key), serialize(an.getMember(key)));\n            }\n            List<Expression> l = new ArrayList<Expression>(2);\n            l.add(new ClassExpression(an.getClassNode()));\n            l.add(map);\n            ArrayExpression ae = new ArrayExpression(ClassHelper.OBJECT_TYPE, l);\n            return ae;\n        }",
            " 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163 +\n 164  ",
            "        private Expression serialize(AnnotationNode an) {\n            MapExpression map = new MapExpression();\n            for (String key : an.getMembers().keySet()) {\n                map.addMapEntryExpression(new ConstantExpression(key), serialize(an.getMember(key)));\n            }\n            List<Expression> l = new ArrayList<Expression>(2);\n            l.add(new ClassExpression(an.getClassNode()));\n            l.add(map);\n            return new ArrayExpression(ClassHelper.OBJECT_TYPE, l);\n        }"
        ],
        [
            "Traits::isTrait(Class)",
            " 161  \n 162  \n 163  \n 164  \n 165  \n 166 -\n 167  \n 168  ",
            "    /**\n     * Returns true if the specified class is a trait.\n     * @param clazz a class to test\n     * @return true if the classnode represents a trait\n     */\n    public static boolean isTrait(final Class clazz) {\n        return clazz!=null && clazz.getAnnotation(Trait.class)!=null;\n    }",
            " 161  \n 162  \n 163  \n 164  \n 165  \n 166 +\n 167  \n 168  ",
            "    /**\n     * Returns true if the specified class is a trait.\n     * @param clazz a class to test\n     * @return true if the classnode represents a trait\n     */\n    public static boolean isTrait(final Class<?> clazz) {\n        return clazz!=null && clazz.getAnnotation(Trait.class)!=null;\n    }"
        ]
    ],
    "2c79476307ea5bc38b0f7c94a981b2b24eaf33a7": [
        [
            "StaticTypeCheckingVisitor::getResultType(ClassNode,int,ClassNode,BinaryExpression)",
            "3590  \n3591  \n3592  \n3593  \n3594  \n3595  \n3596  \n3597  \n3598  \n3599 -\n3600  \n3601  \n3602  \n3603  \n3604  \n3605  \n3606  \n3607  \n3608  \n3609  \n3610  \n3611  \n3612  \n3613  \n3614  \n3615  \n3616  \n3617  \n3618  \n3619  \n3620  \n3621  \n3622  \n3623  \n3624  \n3625  \n3626  \n3627  \n3628  \n3629  \n3630  \n3631  \n3632  \n3633  \n3634  \n3635  \n3636  \n3637  \n3638  \n3639  \n3640  \n3641  \n3642  \n3643  \n3644  \n3645  \n3646  \n3647  \n3648  \n3649  \n3650  \n3651  \n3652  \n3653  \n3654  \n3655  \n3656  \n3657  \n3658  \n3659  \n3660  \n3661  \n3662  \n3663  \n3664  \n3665  \n3666  \n3667  \n3668  \n3669  \n3670  \n3671  \n3672  \n3673  \n3674  \n3675  \n3676  \n3677  \n3678  \n3679  \n3680  \n3681  \n3682  \n3683  \n3684  \n3685  \n3686  \n3687  \n3688  \n3689  \n3690  \n3691  \n3692  \n3693  \n3694  \n3695  \n3696  \n3697  \n3698  \n3699  \n3700  \n3701  \n3702  \n3703  \n3704  \n3705  \n3706  \n3707  \n3708  \n3709  \n3710  \n3711  \n3712  \n3713  \n3714  \n3715  \n3716  \n3717  \n3718  \n3719  ",
            "    protected ClassNode getResultType(ClassNode left, int op, ClassNode right, BinaryExpression expr) {\n        ClassNode leftRedirect = left.redirect();\n        ClassNode rightRedirect = right.redirect();\n\n        Expression leftExpression = expr.getLeftExpression();\n        Expression rightExpression = expr.getRightExpression();\n        if (op == ASSIGN || op == ASSIGNMENT_OPERATOR || op == ELVIS_EQUAL) {\n            if (leftRedirect.isArray() && implementsInterfaceOrIsSubclassOf(rightRedirect, Collection_TYPE)) return leftRedirect;\n            if (leftRedirect.implementsInterface(Collection_TYPE) && rightRedirect.implementsInterface(Collection_TYPE)) {\n                // because of type inferrence, we must perform an additional check if the right expression\n                // is an empty list expression ([]). In that case and only in that case, the inferred type\n                // will be wrong, so we will prefer the left type\n                if (rightExpression instanceof ListExpression) {\n                    List<Expression> list = ((ListExpression) rightExpression).getExpressions();\n                    if (list.isEmpty()) return left;\n                }\n                return right;\n            }\n            if (rightRedirect.implementsInterface(Collection_TYPE) && rightRedirect.isDerivedFrom(leftRedirect)) {\n                // ex : def foos = ['a','b','c']\n                return right;\n            }\n            if (rightRedirect.isDerivedFrom(CLOSURE_TYPE) && isSAMType(leftRedirect) && rightExpression instanceof ClosureExpression) {\n                return inferSAMTypeGenericsInAssignment(left, findSAM(left),right,(ClosureExpression) rightExpression);\n            }\n\n            if (leftExpression instanceof VariableExpression) {\n                ClassNode initialType = getOriginalDeclarationType(leftExpression).redirect();\n                if (isPrimitiveType(right) && initialType.isDerivedFrom(Number_TYPE)) {\n                    return getWrapper(right);\n                }\n\n                if (isPrimitiveType(initialType) && rightRedirect.isDerivedFrom(Number_TYPE))  {\n                    return getUnwrapper(right);\n                }\n\n                // as anything can be assigned to a String, Class or boolean, return the left type instead\n                if (STRING_TYPE.equals(initialType)\n                        || CLASS_Type.equals(initialType)\n                        || Boolean_TYPE.equals(initialType)\n                        || boolean_TYPE.equals(initialType)) {\n                    return initialType;\n                }\n            }\n            return right;\n        } else if (isBoolIntrinsicOp(op)) {\n            return boolean_TYPE;\n        } else if (isArrayOp(op)) {\n            // using getPNR() to ignore generics at this point\n            // and a different binary expression not to pollute the AST\n            BinaryExpression newExpr = binX(expr.getLeftExpression(), expr.getOperation(), rightExpression);\n            newExpr.setSourcePosition(expr);\n            MethodNode method = findMethodOrFail(newExpr, left.getPlainNodeReference(), \"getAt\", right.getPlainNodeReference());\n            if (method!=null && implementsInterfaceOrIsSubclassOf(right, RANGE_TYPE)) {\n                return inferReturnTypeGenerics(left, method, rightExpression);\n            }\n            return method!=null?inferComponentType(left, right):null;\n        } else if (op == FIND_REGEX) {\n            // this case always succeeds the result is a Matcher\n            return Matcher_TYPE;\n        }\n        // the left operand is determining the result of the operation\n        // for primitives and their wrapper we use a fixed table here\n        else if (isNumberType(leftRedirect) && isNumberType(rightRedirect)) {\n            if (isOperationInGroup(op)) {\n                if (isIntCategory(leftRedirect) && isIntCategory(rightRedirect)) return int_TYPE;\n                if (isLongCategory(leftRedirect) && isLongCategory(rightRedirect)) return long_TYPE;\n                if (isFloat(leftRedirect) && isFloat(rightRedirect)) return float_TYPE;\n                if (isDouble(leftRedirect) && isDouble(rightRedirect)) return double_TYPE;\n            } else if (isPowerOperator(op)) {\n                return Number_TYPE;\n            } else if (isBitOperator(op)) {\n                if (isIntCategory(getUnwrapper(leftRedirect)) && isIntCategory(getUnwrapper(rightRedirect))) return int_TYPE;\n                if (isLongCategory(getUnwrapper(leftRedirect)) && isLongCategory(getUnwrapper(rightRedirect))) return long_TYPE;\n                if (isBigIntCategory(getUnwrapper(leftRedirect)) && isBigIntCategory(getUnwrapper(rightRedirect))) return BigInteger_TYPE;\n            } else if (isCompareToBoolean(op) || op == COMPARE_EQUAL || op == COMPARE_NOT_EQUAL) {\n                return boolean_TYPE;\n            }\n        } else if (char_TYPE.equals(leftRedirect) && char_TYPE.equals(rightRedirect)) {\n            if (isCompareToBoolean(op) || op == COMPARE_EQUAL || op == COMPARE_NOT_EQUAL) {\n                return boolean_TYPE;\n            }\n        }\n\n\n        // try to find a method for the operation\n        String operationName = getOperationName(op);\n        if (isShiftOperation(operationName) && isNumberCategory(leftRedirect) && (isIntCategory(rightRedirect) || isLongCategory(rightRedirect))) {\n            return leftRedirect;\n        }\n\n        // Divisions may produce different results depending on operand types\n        if (isNumberCategory(getWrapper(rightRedirect)) && (isNumberCategory(getWrapper(leftRedirect)) && (DIVIDE == op || DIVIDE_EQUAL == op))) {\n            if (isFloatingCategory(leftRedirect) || isFloatingCategory(rightRedirect)) {\n                if (!isPrimitiveType(leftRedirect) || !isPrimitiveType(rightRedirect)) {\n                    return Double_TYPE;\n                }\n                return double_TYPE;\n            }\n            if (DIVIDE == op) {\n                return BigDecimal_TYPE;\n            }\n            return leftRedirect;\n        } else if (isOperationInGroup(op)) {\n            if (isNumberCategory(getWrapper(leftRedirect)) && isNumberCategory(getWrapper(rightRedirect))) {\n                return getGroupOperationResultType(leftRedirect, rightRedirect);\n            }\n        }\n        if (isNumberCategory(getWrapper(rightRedirect)) && isNumberCategory(getWrapper(leftRedirect)) && (MOD == op || MOD_EQUAL == op)) {\n            return leftRedirect;\n        }\n\n        // GROOVY-5890\n        // do not mix Class<Foo> with Foo\n        if (leftExpression instanceof ClassExpression) {\n            left = CLASS_Type.getPlainNodeReference();\n        }\n\n        MethodNode method = findMethodOrFail(expr, left, operationName, right);\n        if (method != null) {\n            storeTargetMethod(expr, method);\n            typeCheckMethodsWithGenericsOrFail(left, new ClassNode[]{right}, method, expr);\n            if (isAssignment(op)) return left;\n            if (isCompareToBoolean(op)) return boolean_TYPE;\n            if (op == COMPARE_TO) return int_TYPE;\n            return inferReturnTypeGenerics(left, method, args(rightExpression));\n        }\n        //TODO: other cases\n        return null;\n    }",
            "3592  \n3593  \n3594  \n3595  \n3596 +\n3597 +\n3598 +\n3599 +\n3600  \n3601  \n3602  \n3603  \n3604  \n3605 +\n3606  \n3607  \n3608  \n3609  \n3610  \n3611  \n3612  \n3613  \n3614  \n3615  \n3616  \n3617  \n3618  \n3619  \n3620  \n3621  \n3622  \n3623  \n3624  \n3625  \n3626  \n3627  \n3628  \n3629  \n3630  \n3631  \n3632  \n3633  \n3634  \n3635  \n3636  \n3637  \n3638  \n3639  \n3640  \n3641  \n3642  \n3643  \n3644  \n3645  \n3646  \n3647  \n3648  \n3649  \n3650  \n3651  \n3652  \n3653  \n3654  \n3655  \n3656  \n3657  \n3658  \n3659  \n3660  \n3661  \n3662  \n3663  \n3664  \n3665  \n3666  \n3667  \n3668  \n3669  \n3670  \n3671  \n3672  \n3673  \n3674  \n3675  \n3676  \n3677  \n3678  \n3679  \n3680  \n3681  \n3682  \n3683  \n3684  \n3685  \n3686  \n3687  \n3688  \n3689  \n3690  \n3691  \n3692  \n3693  \n3694  \n3695  \n3696  \n3697  \n3698  \n3699  \n3700  \n3701  \n3702  \n3703  \n3704  \n3705  \n3706  \n3707  \n3708  \n3709  \n3710  \n3711  \n3712  \n3713  \n3714  \n3715  \n3716  \n3717  \n3718  \n3719  \n3720  \n3721  \n3722  \n3723  \n3724  \n3725  ",
            "    protected ClassNode getResultType(ClassNode left, int op, ClassNode right, BinaryExpression expr) {\n        ClassNode leftRedirect = left.redirect();\n        ClassNode rightRedirect = right.redirect();\n\n        if (op == COMPARE_NOT_IDENTICAL || op == COMPARE_IDENTICAL) {\n            return boolean_TYPE;\n        }\n\n        Expression leftExpression = expr.getLeftExpression();\n        Expression rightExpression = expr.getRightExpression();\n        if (op == ASSIGN || op == ASSIGNMENT_OPERATOR || op == ELVIS_EQUAL) {\n            if (leftRedirect.isArray() && implementsInterfaceOrIsSubclassOf(rightRedirect, Collection_TYPE)) return leftRedirect;\n            if (leftRedirect.implementsInterface(Collection_TYPE) && rightRedirect.implementsInterface(Collection_TYPE)) {\n                // because of type inference, we must perform an additional check if the right expression\n                // is an empty list expression ([]). In that case and only in that case, the inferred type\n                // will be wrong, so we will prefer the left type\n                if (rightExpression instanceof ListExpression) {\n                    List<Expression> list = ((ListExpression) rightExpression).getExpressions();\n                    if (list.isEmpty()) return left;\n                }\n                return right;\n            }\n            if (rightRedirect.implementsInterface(Collection_TYPE) && rightRedirect.isDerivedFrom(leftRedirect)) {\n                // ex : def foos = ['a','b','c']\n                return right;\n            }\n            if (rightRedirect.isDerivedFrom(CLOSURE_TYPE) && isSAMType(leftRedirect) && rightExpression instanceof ClosureExpression) {\n                return inferSAMTypeGenericsInAssignment(left, findSAM(left),right,(ClosureExpression) rightExpression);\n            }\n\n            if (leftExpression instanceof VariableExpression) {\n                ClassNode initialType = getOriginalDeclarationType(leftExpression).redirect();\n                if (isPrimitiveType(right) && initialType.isDerivedFrom(Number_TYPE)) {\n                    return getWrapper(right);\n                }\n\n                if (isPrimitiveType(initialType) && rightRedirect.isDerivedFrom(Number_TYPE))  {\n                    return getUnwrapper(right);\n                }\n\n                // as anything can be assigned to a String, Class or boolean, return the left type instead\n                if (STRING_TYPE.equals(initialType)\n                        || CLASS_Type.equals(initialType)\n                        || Boolean_TYPE.equals(initialType)\n                        || boolean_TYPE.equals(initialType)) {\n                    return initialType;\n                }\n            }\n            return right;\n        } else if (isBoolIntrinsicOp(op)) {\n            return boolean_TYPE;\n        } else if (isArrayOp(op)) {\n            // using getPNR() to ignore generics at this point\n            // and a different binary expression not to pollute the AST\n            BinaryExpression newExpr = binX(expr.getLeftExpression(), expr.getOperation(), rightExpression);\n            newExpr.setSourcePosition(expr);\n            MethodNode method = findMethodOrFail(newExpr, left.getPlainNodeReference(), \"getAt\", right.getPlainNodeReference());\n            if (method!=null && implementsInterfaceOrIsSubclassOf(right, RANGE_TYPE)) {\n                return inferReturnTypeGenerics(left, method, rightExpression);\n            }\n            return method!=null?inferComponentType(left, right):null;\n        } else if (op == FIND_REGEX) {\n            // this case always succeeds the result is a Matcher\n            return Matcher_TYPE;\n        }\n        // the left operand is determining the result of the operation\n        // for primitives and their wrapper we use a fixed table here\n        else if (isNumberType(leftRedirect) && isNumberType(rightRedirect)) {\n            if (isOperationInGroup(op)) {\n                if (isIntCategory(leftRedirect) && isIntCategory(rightRedirect)) return int_TYPE;\n                if (isLongCategory(leftRedirect) && isLongCategory(rightRedirect)) return long_TYPE;\n                if (isFloat(leftRedirect) && isFloat(rightRedirect)) return float_TYPE;\n                if (isDouble(leftRedirect) && isDouble(rightRedirect)) return double_TYPE;\n            } else if (isPowerOperator(op)) {\n                return Number_TYPE;\n            } else if (isBitOperator(op)) {\n                if (isIntCategory(getUnwrapper(leftRedirect)) && isIntCategory(getUnwrapper(rightRedirect))) return int_TYPE;\n                if (isLongCategory(getUnwrapper(leftRedirect)) && isLongCategory(getUnwrapper(rightRedirect))) return long_TYPE;\n                if (isBigIntCategory(getUnwrapper(leftRedirect)) && isBigIntCategory(getUnwrapper(rightRedirect))) return BigInteger_TYPE;\n            } else if (isCompareToBoolean(op) || op == COMPARE_EQUAL || op == COMPARE_NOT_EQUAL) {\n                return boolean_TYPE;\n            }\n        } else if (char_TYPE.equals(leftRedirect) && char_TYPE.equals(rightRedirect)) {\n            if (isCompareToBoolean(op) || op == COMPARE_EQUAL || op == COMPARE_NOT_EQUAL) {\n                return boolean_TYPE;\n            }\n        }\n\n\n        // try to find a method for the operation\n        String operationName = getOperationName(op);\n        if (isShiftOperation(operationName) && isNumberCategory(leftRedirect) && (isIntCategory(rightRedirect) || isLongCategory(rightRedirect))) {\n            return leftRedirect;\n        }\n\n        // Divisions may produce different results depending on operand types\n        if (isNumberCategory(getWrapper(rightRedirect)) && (isNumberCategory(getWrapper(leftRedirect)) && (DIVIDE == op || DIVIDE_EQUAL == op))) {\n            if (isFloatingCategory(leftRedirect) || isFloatingCategory(rightRedirect)) {\n                if (!isPrimitiveType(leftRedirect) || !isPrimitiveType(rightRedirect)) {\n                    return Double_TYPE;\n                }\n                return double_TYPE;\n            }\n            if (DIVIDE == op) {\n                return BigDecimal_TYPE;\n            }\n            return leftRedirect;\n        } else if (isOperationInGroup(op)) {\n            if (isNumberCategory(getWrapper(leftRedirect)) && isNumberCategory(getWrapper(rightRedirect))) {\n                return getGroupOperationResultType(leftRedirect, rightRedirect);\n            }\n        }\n        if (isNumberCategory(getWrapper(rightRedirect)) && isNumberCategory(getWrapper(leftRedirect)) && (MOD == op || MOD_EQUAL == op)) {\n            return leftRedirect;\n        }\n\n        // GROOVY-5890\n        // do not mix Class<Foo> with Foo\n        if (leftExpression instanceof ClassExpression) {\n            left = CLASS_Type.getPlainNodeReference();\n        }\n\n        MethodNode method = findMethodOrFail(expr, left, operationName, right);\n        if (method != null) {\n            storeTargetMethod(expr, method);\n            typeCheckMethodsWithGenericsOrFail(left, new ClassNode[]{right}, method, expr);\n            if (isAssignment(op)) return left;\n            if (isCompareToBoolean(op)) return boolean_TYPE;\n            if (op == COMPARE_TO) return int_TYPE;\n            return inferReturnTypeGenerics(left, method, args(rightExpression));\n        }\n        //TODO: other cases\n        return null;\n    }"
        ]
    ],
    "802c4d6e58adaefc0c009790ef165bc61f8af3db": [
        [
            "TupleConstructorASTTransformation::createConstructor(ClassNode,boolean,boolean,boolean,boolean,boolean,boolean,List,List)",
            " 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164 -\n 165 -\n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  ",
            "    public static void createConstructor(ClassNode cNode, boolean includeFields, boolean includeProperties, boolean includeSuperFields, boolean includeSuperProperties, boolean callSuper, boolean force, List<String> excludes, List<String> includes) {\r\n        // no processing if existing constructors found\r\n        List<ConstructorNode> constructors = cNode.getDeclaredConstructors();\r\n        if (constructors.size() > 1 && !force) return;\r\n        boolean foundEmpty = constructors.size() == 1 && constructors.get(0).getFirstStatement() == null;\r\n        if (constructors.size() == 1 && !foundEmpty && !force) return;\r\n        // HACK: JavaStubGenerator could have snuck in a constructor we don't want\r\n        if (foundEmpty) constructors.remove(0);\r\n\r\n        List<FieldNode> superList = new ArrayList<FieldNode>();\r\n        if (includeSuperProperties) {\r\n            superList.addAll(getSuperPropertyFields(cNode.getSuperClass()));\r\n        }\r\n        if (includeSuperFields) {\r\n            superList.addAll(getSuperNonPropertyFields(cNode.getSuperClass()));\r\n        }\r\n\r\n        List<FieldNode> list = new ArrayList<FieldNode>();\r\n        if (includeProperties) {\r\n            list.addAll(getInstancePropertyFields(cNode));\r\n        }\r\n        if (includeFields) {\r\n            list.addAll(getInstanceNonPropertyFields(cNode));\r\n        }\r\n\r\n        final List<Parameter> params = new ArrayList<Parameter>();\r\n        final List<Expression> superParams = new ArrayList<Expression>();\r\n        final BlockStatement body = new BlockStatement();\r\n        for (FieldNode fNode : superList) {\r\n            String name = fNode.getName();\r\n            if (shouldSkip(name, excludes, includes)) continue;\r\n            params.add(createParam(fNode, name));\r\n            if (callSuper) {\r\n                superParams.add(varX(name));\r\n            } else {\r\n                body.addStatement(assignS(propX(varX(\"this\"), name), varX(name)));\r\n            }\r\n        }\r\n        if (callSuper) {\r\n            body.addStatement(stmt(ctorX(ClassNode.SUPER, args(superParams))));\r\n        }\r\n        for (FieldNode fNode : list) {\r\n            String name = fNode.getName();\r\n            if (shouldSkip(name, excludes, includes)) continue;\r\n            params.add(createParam(fNode, name));\r\n            body.addStatement(assignS(propX(varX(\"this\"), name), varX(name)));\r\n        }\r\n        cNode.addConstructor(new ConstructorNode(ACC_PUBLIC, params.toArray(new Parameter[params.size()]), ClassNode.EMPTY_ARRAY, body));\r\n        // add map constructor if needed, don't do it for LinkedHashMap for now (would lead to duplicate signature)\r\n        // or if there is only one Map property (for backwards compatibility)\r\n        if (params.size() > 0) {\r\n            ClassNode firstParam = params.get(0).getType();\r\n            if (params.size() > 1 || firstParam.equals(ClassHelper.OBJECT_TYPE)) {\r\n                if (firstParam.equals(ClassHelper.MAP_TYPE)) {\r\n                    addMapConstructors(cNode, true, \"The class \" + cNode.getName() + \" was incorrectly initialized via the map constructor with null.\");\r\n                } else {\r\n                    ClassNode candidate = HMAP_TYPE;\r\n                    while (candidate != null) {\r\n                        if (candidate.equals(firstParam)) {\r\n                            addMapConstructors(cNode, true, \"The class \" + cNode.getName() + \" was incorrectly initialized via the map constructor with null.\");\r\n                            break;\r\n                        }\r\n                        candidate = candidate.getSuperClass();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r",
            " 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164 +\n 165 +\n 166 +\n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  ",
            "    public static void createConstructor(ClassNode cNode, boolean includeFields, boolean includeProperties, boolean includeSuperFields, boolean includeSuperProperties, boolean callSuper, boolean force, List<String> excludes, List<String> includes) {\r\n        // no processing if existing constructors found\r\n        List<ConstructorNode> constructors = cNode.getDeclaredConstructors();\r\n        if (constructors.size() > 1 && !force) return;\r\n        boolean foundEmpty = constructors.size() == 1 && constructors.get(0).getFirstStatement() == null;\r\n        if (constructors.size() == 1 && !foundEmpty && !force) return;\r\n        // HACK: JavaStubGenerator could have snuck in a constructor we don't want\r\n        if (foundEmpty) constructors.remove(0);\r\n\r\n        List<FieldNode> superList = new ArrayList<FieldNode>();\r\n        if (includeSuperProperties) {\r\n            superList.addAll(getSuperPropertyFields(cNode.getSuperClass()));\r\n        }\r\n        if (includeSuperFields) {\r\n            superList.addAll(getSuperNonPropertyFields(cNode.getSuperClass()));\r\n        }\r\n\r\n        List<FieldNode> list = new ArrayList<FieldNode>();\r\n        if (includeProperties) {\r\n            list.addAll(getInstancePropertyFields(cNode));\r\n        }\r\n        if (includeFields) {\r\n            list.addAll(getInstanceNonPropertyFields(cNode));\r\n        }\r\n\r\n        final List<Parameter> params = new ArrayList<Parameter>();\r\n        final List<Expression> superParams = new ArrayList<Expression>();\r\n        final BlockStatement body = new BlockStatement();\r\n        for (FieldNode fNode : superList) {\r\n            String name = fNode.getName();\r\n            if (shouldSkip(name, excludes, includes)) continue;\r\n            params.add(createParam(fNode, name));\r\n            if (callSuper) {\r\n                superParams.add(varX(name));\r\n            } else {\r\n                body.addStatement(assignS(propX(varX(\"this\"), name), varX(name)));\r\n            }\r\n        }\r\n        if (callSuper) {\r\n            body.addStatement(stmt(ctorX(ClassNode.SUPER, args(superParams))));\r\n        }\r\n        for (FieldNode fNode : list) {\r\n            String name = fNode.getName();\r\n            if (shouldSkip(name, excludes, includes)) continue;\r\n            Parameter nextParam = createParam(fNode, name);\r\n            params.add(nextParam);\r\n            body.addStatement(assignS(propX(varX(\"this\"), name), varX(nextParam)));\r\n        }\r\n        cNode.addConstructor(new ConstructorNode(ACC_PUBLIC, params.toArray(new Parameter[params.size()]), ClassNode.EMPTY_ARRAY, body));\r\n        // add map constructor if needed, don't do it for LinkedHashMap for now (would lead to duplicate signature)\r\n        // or if there is only one Map property (for backwards compatibility)\r\n        if (params.size() > 0) {\r\n            ClassNode firstParam = params.get(0).getType();\r\n            if (params.size() > 1 || firstParam.equals(ClassHelper.OBJECT_TYPE)) {\r\n                if (firstParam.equals(ClassHelper.MAP_TYPE)) {\r\n                    addMapConstructors(cNode, true, \"The class \" + cNode.getName() + \" was incorrectly initialized via the map constructor with null.\");\r\n                } else {\r\n                    ClassNode candidate = HMAP_TYPE;\r\n                    while (candidate != null) {\r\n                        if (candidate.equals(firstParam)) {\r\n                            addMapConstructors(cNode, true, \"The class \" + cNode.getName() + \" was incorrectly initialized via the map constructor with null.\");\r\n                            break;\r\n                        }\r\n                        candidate = candidate.getSuperClass();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r"
        ]
    ],
    "de59288028f41460a7d0aaa57e58d32e1ef7327e": [
        [
            "AsmClassGenerator::visitAttributeOrProperty(PropertyExpression,MethodCallerMultiAdapter)",
            " 835  \n 836  \n 837  \n 838  \n 839  \n 840  \n 841  \n 842  \n 843  \n 844  \n 845  \n 846  \n 847  \n 848  \n 849  \n 850  \n 851  \n 852  \n 853  \n 854  \n 855  \n 856  \n 857  \n 858  \n 859  \n 860  \n 861  \n 862  \n 863  \n 864  \n 865  \n 866  \n 867  \n 868  \n 869  \n 870  \n 871  \n 872  \n 873  \n 874  \n 875  \n 876  \n 877  \n 878  \n 879  \n 880  \n 881  \n 882  \n 883  \n 884  \n 885  \n 886  \n 887  \n 888  \n 889  \n 890  \n 891  \n 892  \n 893  \n 894  \n 895  \n 896  \n 897  \n 898  \n 899  \n 900  \n 901  \n 902  \n 903  \n 904  \n 905  \n 906  \n 907  \n 908  \n 909  \n 910  \n 911  \n 912  \n 913  \n 914  \n 915  \n 916  \n 917  \n 918  \n 919  \n 920  \n 921  \n 922  \n 923  \n 924  \n 925  \n 926  \n 927  \n 928  \n 929  \n 930  \n 931  \n 932  \n 933 -\n 934  \n 935  \n 936  \n 937  \n 938  \n 939  \n 940  \n 941  \n 942  \n 943  \n 944  \n 945  \n 946  \n 947  \n 948  \n 949  \n 950  \n 951  \n 952  \n 953  \n 954  \n 955  \n 956  \n 957  \n 958  \n 959  \n 960  ",
            "    private void visitAttributeOrProperty(PropertyExpression expression, MethodCallerMultiAdapter adapter) {\n        MethodVisitor mv = controller.getMethodVisitor();\n\n        Expression objectExpression = expression.getObjectExpression();\n        ClassNode classNode = controller.getClassNode();\n        if (isThisOrSuper(objectExpression)) {\n            // let's use the field expression if it's available\n            String name = expression.getPropertyAsString();\n            if (name != null) {\n                FieldNode field = null;\n                boolean privateSuperField = false;\n                if (isSuperExpression(objectExpression)) {\n                    field = classNode.getSuperClass().getDeclaredField(name);\n                    if (field != null && ((field.getModifiers() & ACC_PRIVATE) != 0)) {\n                        privateSuperField = true;\n                    }\n                } else {\n                \tif (controller.isNotExplicitThisInClosure(expression.isImplicitThis())) {\n                        field = classNode.getDeclaredField(name);\n                        if (field==null && classNode instanceof InnerClassNode) {\n                            ClassNode outer = classNode.getOuterClass();\n                            FieldNode outerClassField;\n                            while (outer!=null) {\n                                outerClassField = outer.getDeclaredField(name);\n                                if (outerClassField!=null && outerClassField.isStatic() && outerClassField.isFinal()) {\n                                    if (outer!=classNode.getOuterClass() && Modifier.isPrivate(outerClassField.getModifiers())) {\n                                        throw new GroovyBugError(\"Trying to access private constant field [\"+outerClassField.getDeclaringClass()+\"#\"+outerClassField.getName()+\"] from inner class\");\n                                    }\n                                    PropertyExpression pexp = new PropertyExpression(\n                                            new ClassExpression(outer),\n                                            expression.getProperty()\n                                    );\n                                    pexp.visit(controller.getAcg());\n                                    return;\n                                }\n                                outer = outer.getSuperClass();\n                            }\n                        }\n                        if (field==null\n                                && expression instanceof AttributeExpression\n                                && isThisExpression(objectExpression)\n                                && controller.isStaticContext()) {\n                            // GROOVY-6183\n                            ClassNode current = classNode.getSuperClass();\n                            while (field==null && current!=null) {\n                                field = current.getDeclaredField(name);\n                                current = current.getSuperClass();\n                            }\n                            if (field!=null && (field.isProtected() || field.isPublic())) {\n                                visitFieldExpression(new FieldExpression(field));\n                                return;\n                            }\n                        }\n                \t}\n                }\n                if (field != null && !privateSuperField) {//GROOVY-4497: don't visit super field if it is private\n                    visitFieldExpression(new FieldExpression(field));\n                    return;\n                }\n            }\n            if (isSuperExpression(objectExpression)) {\n                String prefix;\n                if (controller.getCompileStack().isLHS()) {\n                    prefix = \"set\";\n                } else {\n                    prefix = \"get\";\n                }\n                String propName = prefix + MetaClassHelper.capitalize(name);\n                visitMethodCallExpression(new MethodCallExpression(objectExpression, propName, MethodCallExpression.NO_ARGUMENTS));\n                return;\n            }\n        }\n\n        final String propName = expression.getPropertyAsString();\n        //TODO: add support for super here too\n        if (expression.getObjectExpression() instanceof ClassExpression &&\n            propName!=null && propName.equals(\"this\"))\n        {\n            // we have something like A.B.this, and need to make it\n            // into this.this$0.this$0, where this.this$0 returns\n            // A.B and this.this$0.this$0 return A.\n            ClassNode type = objectExpression.getType();\n            ClassNode iterType = classNode;\n            if (controller.getCompileStack().isInSpecialConstructorCall() && classNode instanceof InnerClassNode) {\n                boolean staticInnerClass = classNode.isStaticClass();\n                // Outer.this in a special constructor call\n                if (classNode.getOuterClass().equals(type)) {\n                    ConstructorNode ctor = controller.getConstructorNode();\n                    Expression receiver = !staticInnerClass ? new VariableExpression(ctor.getParameters()[0]) : new ClassExpression(type);\n                    receiver.setSourcePosition(expression);\n                    receiver.visit(this);\n                    return;\n                }\n            }\n            mv.visitVarInsn(ALOAD, 0);\n            while (!iterType.equals(type)) {\n                String ownerName = BytecodeHelper.getClassInternalName(iterType);\n                if (iterType.getOuterClass()==null) break;\n                ClassNode thisFieldType = iterType.getField(\"this$0\").getType();\n                iterType = iterType.getOuterClass();\n                if (ClassHelper.CLOSURE_TYPE.equals(thisFieldType)) {\n                    mv.visitFieldInsn(GETFIELD, ownerName, \"this$0\", BytecodeHelper.getTypeDescription(ClassHelper.CLOSURE_TYPE));\n                    mv.visitMethodInsn(INVOKEVIRTUAL, BytecodeHelper.getClassInternalName(ClassHelper.CLOSURE_TYPE), \"getThisObject\", \"()Ljava/lang/Object;\", false);\n                    mv.visitTypeInsn(CHECKCAST, BytecodeHelper.getClassInternalName(iterType));\n                } else {\n                    String typeName = BytecodeHelper.getTypeDescription(iterType);\n                    mv.visitFieldInsn(GETFIELD, ownerName, \"this$0\", typeName);\n                }\n            }\n            controller.getOperandStack().push(type);\n            return;\n        }\n\n        if (adapter == getProperty && !expression.isSpreadSafe() && propName != null) {\n            controller.getCallSiteWriter().makeGetPropertySite(objectExpression, propName, expression.isSafe(), expression.isImplicitThis());\n        } else if (adapter == getGroovyObjectProperty && !expression.isSpreadSafe() && propName != null) {\n            controller.getCallSiteWriter().makeGroovyObjectGetPropertySite(objectExpression, propName, expression.isSafe(), expression.isImplicitThis());\n        } else {\n            // todo: for improved modularity and extensibility, this should be moved into a writer\n            if (controller.getCompileStack().isLHS()) controller.getOperandStack().box();\n            controller.getInvocationWriter().makeCall(\n                    expression,\n                    objectExpression, // receiver\n                    new CastExpression(ClassHelper.STRING_TYPE, expression.getProperty()), // messageName\n                    MethodCallExpression.NO_ARGUMENTS, adapter,\n                    expression.isSafe(), expression.isSpreadSafe(), expression.isImplicitThis()",
            " 835  \n 836  \n 837  \n 838  \n 839  \n 840  \n 841  \n 842  \n 843  \n 844  \n 845  \n 846  \n 847  \n 848  \n 849  \n 850  \n 851  \n 852  \n 853  \n 854  \n 855  \n 856  \n 857  \n 858  \n 859  \n 860  \n 861  \n 862  \n 863  \n 864  \n 865  \n 866  \n 867  \n 868  \n 869  \n 870  \n 871  \n 872  \n 873  \n 874  \n 875  \n 876  \n 877  \n 878  \n 879  \n 880  \n 881  \n 882  \n 883  \n 884  \n 885  \n 886  \n 887  \n 888  \n 889  \n 890  \n 891  \n 892  \n 893  \n 894  \n 895  \n 896  \n 897  \n 898  \n 899  \n 900  \n 901  \n 902  \n 903  \n 904  \n 905  \n 906  \n 907  \n 908  \n 909  \n 910  \n 911  \n 912  \n 913  \n 914  \n 915  \n 916  \n 917  \n 918  \n 919  \n 920  \n 921  \n 922  \n 923  \n 924  \n 925  \n 926  \n 927  \n 928  \n 929  \n 930  \n 931  \n 932  \n 933 +\n 934 +\n 935 +\n 936  \n 937  \n 938  \n 939  \n 940  \n 941  \n 942  \n 943  \n 944  \n 945  \n 946  \n 947  \n 948  \n 949  \n 950  \n 951  \n 952  \n 953  \n 954  \n 955  \n 956  \n 957  \n 958  \n 959  \n 960  \n 961  \n 962  ",
            "    private void visitAttributeOrProperty(PropertyExpression expression, MethodCallerMultiAdapter adapter) {\n        MethodVisitor mv = controller.getMethodVisitor();\n\n        Expression objectExpression = expression.getObjectExpression();\n        ClassNode classNode = controller.getClassNode();\n        if (isThisOrSuper(objectExpression)) {\n            // let's use the field expression if it's available\n            String name = expression.getPropertyAsString();\n            if (name != null) {\n                FieldNode field = null;\n                boolean privateSuperField = false;\n                if (isSuperExpression(objectExpression)) {\n                    field = classNode.getSuperClass().getDeclaredField(name);\n                    if (field != null && ((field.getModifiers() & ACC_PRIVATE) != 0)) {\n                        privateSuperField = true;\n                    }\n                } else {\n                \tif (controller.isNotExplicitThisInClosure(expression.isImplicitThis())) {\n                        field = classNode.getDeclaredField(name);\n                        if (field==null && classNode instanceof InnerClassNode) {\n                            ClassNode outer = classNode.getOuterClass();\n                            FieldNode outerClassField;\n                            while (outer!=null) {\n                                outerClassField = outer.getDeclaredField(name);\n                                if (outerClassField!=null && outerClassField.isStatic() && outerClassField.isFinal()) {\n                                    if (outer!=classNode.getOuterClass() && Modifier.isPrivate(outerClassField.getModifiers())) {\n                                        throw new GroovyBugError(\"Trying to access private constant field [\"+outerClassField.getDeclaringClass()+\"#\"+outerClassField.getName()+\"] from inner class\");\n                                    }\n                                    PropertyExpression pexp = new PropertyExpression(\n                                            new ClassExpression(outer),\n                                            expression.getProperty()\n                                    );\n                                    pexp.visit(controller.getAcg());\n                                    return;\n                                }\n                                outer = outer.getSuperClass();\n                            }\n                        }\n                        if (field==null\n                                && expression instanceof AttributeExpression\n                                && isThisExpression(objectExpression)\n                                && controller.isStaticContext()) {\n                            // GROOVY-6183\n                            ClassNode current = classNode.getSuperClass();\n                            while (field==null && current!=null) {\n                                field = current.getDeclaredField(name);\n                                current = current.getSuperClass();\n                            }\n                            if (field!=null && (field.isProtected() || field.isPublic())) {\n                                visitFieldExpression(new FieldExpression(field));\n                                return;\n                            }\n                        }\n                \t}\n                }\n                if (field != null && !privateSuperField) {//GROOVY-4497: don't visit super field if it is private\n                    visitFieldExpression(new FieldExpression(field));\n                    return;\n                }\n            }\n            if (isSuperExpression(objectExpression)) {\n                String prefix;\n                if (controller.getCompileStack().isLHS()) {\n                    prefix = \"set\";\n                } else {\n                    prefix = \"get\";\n                }\n                String propName = prefix + MetaClassHelper.capitalize(name);\n                visitMethodCallExpression(new MethodCallExpression(objectExpression, propName, MethodCallExpression.NO_ARGUMENTS));\n                return;\n            }\n        }\n\n        final String propName = expression.getPropertyAsString();\n        //TODO: add support for super here too\n        if (expression.getObjectExpression() instanceof ClassExpression &&\n            propName!=null && propName.equals(\"this\"))\n        {\n            // we have something like A.B.this, and need to make it\n            // into this.this$0.this$0, where this.this$0 returns\n            // A.B and this.this$0.this$0 return A.\n            ClassNode type = objectExpression.getType();\n            ClassNode iterType = classNode;\n            if (controller.getCompileStack().isInSpecialConstructorCall() && classNode instanceof InnerClassNode) {\n                boolean staticInnerClass = classNode.isStaticClass();\n                // Outer.this in a special constructor call\n                if (classNode.getOuterClass().equals(type)) {\n                    ConstructorNode ctor = controller.getConstructorNode();\n                    Expression receiver = !staticInnerClass ? new VariableExpression(ctor.getParameters()[0]) : new ClassExpression(type);\n                    receiver.setSourcePosition(expression);\n                    receiver.visit(this);\n                    return;\n                }\n            }\n            mv.visitVarInsn(ALOAD, 0);\n            while (!iterType.equals(type)) {\n                String ownerName = BytecodeHelper.getClassInternalName(iterType);\n                if (iterType.getOuterClass()==null) break;\n                FieldNode thisField = iterType.getField(\"this$0\");\n                if (thisField==null) break;\n                ClassNode thisFieldType = thisField.getType();\n                iterType = iterType.getOuterClass();\n                if (ClassHelper.CLOSURE_TYPE.equals(thisFieldType)) {\n                    mv.visitFieldInsn(GETFIELD, ownerName, \"this$0\", BytecodeHelper.getTypeDescription(ClassHelper.CLOSURE_TYPE));\n                    mv.visitMethodInsn(INVOKEVIRTUAL, BytecodeHelper.getClassInternalName(ClassHelper.CLOSURE_TYPE), \"getThisObject\", \"()Ljava/lang/Object;\", false);\n                    mv.visitTypeInsn(CHECKCAST, BytecodeHelper.getClassInternalName(iterType));\n                } else {\n                    String typeName = BytecodeHelper.getTypeDescription(iterType);\n                    mv.visitFieldInsn(GETFIELD, ownerName, \"this$0\", typeName);\n                }\n            }\n            controller.getOperandStack().push(type);\n            return;\n        }\n\n        if (adapter == getProperty && !expression.isSpreadSafe() && propName != null) {\n            controller.getCallSiteWriter().makeGetPropertySite(objectExpression, propName, expression.isSafe(), expression.isImplicitThis());\n        } else if (adapter == getGroovyObjectProperty && !expression.isSpreadSafe() && propName != null) {\n            controller.getCallSiteWriter().makeGroovyObjectGetPropertySite(objectExpression, propName, expression.isSafe(), expression.isImplicitThis());\n        } else {\n            // todo: for improved modularity and extensibility, this should be moved into a writer\n            if (controller.getCompileStack().isLHS()) controller.getOperandStack().box();\n            controller.getInvocationWriter().makeCall(\n                    expression,\n                    objectExpression, // receiver\n                    new CastExpression(ClassHelper.STRING_TYPE, expression.getProperty()), // messageName\n                    MethodCallExpression.NO_ARGUMENTS, adapter,\n                    expression.isSafe(), expression.isSpreadSafe(), expression.isImplicitThis()"
        ]
    ],
    "aa27c6b45b03ba2b591f47b7883b53d85ac68ac9": [
        [
            "SingletonASTTransformation::lazyBody(ClassNode,FieldNode)",
            "  88 -\n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  ",
            "    private Statement lazyBody(ClassNode classNode, FieldNode fieldNode) {\r\n        final Expression instanceExpression = varX(fieldNode);\r\n        return ifElseS(\r\n                notNullX(instanceExpression),\r\n                returnS(instanceExpression),\r\n                new SynchronizedStatement(\r\n                        classX(classNode),\r\n                        ifElseS(\r\n                                notNullX(instanceExpression),\r\n                                returnS(instanceExpression),\r\n                                returnS(assignX(instanceExpression, ctorX(classNode)))\r",
            "  88 +\n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  ",
            "    private static Statement lazyBody(ClassNode classNode, FieldNode fieldNode) {\r\n        final Expression instanceExpression = varX(fieldNode);\r\n        return ifElseS(\r\n                notNullX(instanceExpression),\r\n                returnS(instanceExpression),\r\n                new SynchronizedStatement(\r\n                        classX(classNode),\r\n                        ifElseS(\r\n                                notNullX(instanceExpression),\r\n                                returnS(instanceExpression),\r\n                                returnS(assignX(instanceExpression, ctorX(classNode)))\r"
        ],
        [
            "ImmutableASTTransformation::createGetterBodyArrayOrCloneable(FieldNode)",
            " 615 -\n 616  \n 617  \n 618  \n 619  ",
            "    private Statement createGetterBodyArrayOrCloneable(FieldNode fNode) {\n        final Expression fieldExpr = varX(fNode);\n        final Expression expression = cloneArrayOrCloneableExpr(fieldExpr, fNode.getType());\n        return safeExpression(fieldExpr, expression);\n    }",
            " 615 +\n 616  \n 617  \n 618  \n 619  ",
            "    private static Statement createGetterBodyArrayOrCloneable(FieldNode fNode) {\n        final Expression fieldExpr = varX(fNode);\n        final Expression expression = cloneArrayOrCloneableExpr(fieldExpr, fNode.getType());\n        return safeExpression(fieldExpr, expression);\n    }"
        ],
        [
            "ImmutableASTTransformation::createIfInstanceOfAsImmutableS(Expression,ClassNode,Expression)",
            " 333 -\n 334  \n 335  ",
            "    private Expression createIfInstanceOfAsImmutableS(Expression expr, ClassNode type, Expression elseStatement) {\n        return ternaryX(isInstanceOfX(expr, type), createAsImmutableX(expr, type), elseStatement);\n    }",
            " 333 +\n 334  \n 335  ",
            "    private static Expression createIfInstanceOfAsImmutableS(Expression expr, ClassNode type, Expression elseStatement) {\n        return ternaryX(isInstanceOfX(expr, type), createAsImmutableX(expr, type), elseStatement);\n    }"
        ],
        [
            "AutoCloneASTTransformation::createSimpleClone(ClassNode,List,List)",
            " 201 -\n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  ",
            "    private void createSimpleClone(ClassNode cNode, List<FieldNode> fieldNodes, List<String> excludes) {\r\n        if (cNode.getDeclaredConstructors().isEmpty()) {\n            // add no-arg constructor\r\n            cNode.addConstructor(ACC_PUBLIC, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, block(EmptyStatement.INSTANCE));\r\n        }\r\n        addSimpleCloneHelperMethod(cNode, fieldNodes, excludes);\r\n        final Expression result = varX(\"_result\", cNode);\r\n        ClassNode[] exceptions = {make(CloneNotSupportedException.class)};\r\n        cNode.addMethod(\"clone\", ACC_PUBLIC, GenericsUtils.nonGeneric(cNode), Parameter.EMPTY_ARRAY, exceptions, block(\r\n            declS(result, ctorX(cNode)),\r\n            stmt(callThisX(\"cloneOrCopyMembers\", args(result))),\r\n            returnS(result)));\r\n    }\r",
            " 201 +\n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  ",
            "    private static void createSimpleClone(ClassNode cNode, List<FieldNode> fieldNodes, List<String> excludes) {\r\n        if (cNode.getDeclaredConstructors().isEmpty()) {\n            // add no-arg constructor\r\n            cNode.addConstructor(ACC_PUBLIC, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, block(EmptyStatement.INSTANCE));\r\n        }\r\n        addSimpleCloneHelperMethod(cNode, fieldNodes, excludes);\r\n        final Expression result = varX(\"_result\", cNode);\r\n        ClassNode[] exceptions = {make(CloneNotSupportedException.class)};\r\n        cNode.addMethod(\"clone\", ACC_PUBLIC, GenericsUtils.nonGeneric(cNode), Parameter.EMPTY_ARRAY, exceptions, block(\r\n            declS(result, ctorX(cNode)),\r\n            stmt(callThisX(\"cloneOrCopyMembers\", args(result))),\r\n            returnS(result)));\r\n    }\r"
        ],
        [
            "PackageScopeASTTransformation::revertVisibility(MethodNode)",
            " 157 -\n 158  \n 159  ",
            "    private void revertVisibility(MethodNode mNode) {\n        mNode.setModifiers(mNode.getModifiers() & ~ACC_PUBLIC);\n    }",
            " 157 +\n 158  \n 159  ",
            "    private static void revertVisibility(MethodNode mNode) {\n        mNode.setModifiers(mNode.getModifiers() & ~ACC_PUBLIC);\n    }"
        ],
        [
            "ImmutableASTTransformation::doAddConstructor(ClassNode,ConstructorNode)",
            " 201 -\n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  ",
            "    private void doAddConstructor(final ClassNode cNode, final ConstructorNode constructorNode) {\n        cNode.addConstructor(constructorNode);\n        // GROOVY-5814: Immutable is not compatible with @CompileStatic\n        Parameter argsParam = null;\n        for (Parameter p : constructorNode.getParameters()) {\n            if (\"args\".equals(p.getName())) {\n                argsParam = p;\n                break;\n            }\n        }\n        if (argsParam!=null) {\n            final Parameter arg = argsParam;\n            ClassCodeVisitorSupport variableExpressionFix = new ClassCodeVisitorSupport() {\n                @Override\n                protected SourceUnit getSourceUnit() {\n                    return cNode.getModule().getContext();\n                }\n\n                @Override\n                public void visitVariableExpression(final VariableExpression expression) {\n                    super.visitVariableExpression(expression);\n                    if (\"args\".equals(expression.getName())) {\n                        expression.setAccessedVariable(arg);\n                    }\n                }\n            };\n            variableExpressionFix.visitConstructor(constructorNode);\n        }\n    }",
            " 201 +\n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  ",
            "    private static void doAddConstructor(final ClassNode cNode, final ConstructorNode constructorNode) {\n        cNode.addConstructor(constructorNode);\n        // GROOVY-5814: Immutable is not compatible with @CompileStatic\n        Parameter argsParam = null;\n        for (Parameter p : constructorNode.getParameters()) {\n            if (\"args\".equals(p.getName())) {\n                argsParam = p;\n                break;\n            }\n        }\n        if (argsParam!=null) {\n            final Parameter arg = argsParam;\n            ClassCodeVisitorSupport variableExpressionFix = new ClassCodeVisitorSupport() {\n                @Override\n                protected SourceUnit getSourceUnit() {\n                    return cNode.getModule().getContext();\n                }\n\n                @Override\n                public void visitVariableExpression(final VariableExpression expression) {\n                    super.visitVariableExpression(expression);\n                    if (\"args\".equals(expression.getName())) {\n                        expression.setAccessedVariable(arg);\n                    }\n                }\n            };\n            variableExpressionFix.visitConstructor(constructorNode);\n        }\n    }"
        ],
        [
            "SortableASTTransformation::implementComparable(ClassNode)",
            " 109 -\n 110  \n 111  \n 112  \n 113  ",
            "    private void implementComparable(ClassNode classNode) {\n        if (!classNode.implementsInterface(COMPARABLE_TYPE)) {\n            classNode.addInterface(makeClassSafeWithGenerics(Comparable.class, classNode));\n        }\n    }",
            " 109 +\n 110  \n 111  \n 112  \n 113  ",
            "    private static void implementComparable(ClassNode classNode) {\n        if (!classNode.implementsInterface(COMPARABLE_TYPE)) {\n            classNode.addInterface(makeClassSafeWithGenerics(Comparable.class, classNode));\n        }\n    }"
        ],
        [
            "ASTTransformationCollectorCodeVisitor::mergeParameters(AnnotationNode,AnnotationNode)",
            " 183 -\n 184  \n 185  \n 186  \n 187  \n 188  \n 189  ",
            "    private void mergeParameters(AnnotationNode to, AnnotationNode from) {\n        for (String name : from.getMembers().keySet()) {\n            if (to.getMember(name) == null) {\n                to.setMember(name, from.getMember(name));\n            }\n        }\n    }",
            " 183 +\n 184  \n 185  \n 186  \n 187  \n 188  \n 189  ",
            "    private static void mergeParameters(AnnotationNode to, AnnotationNode from) {\n        for (String name : from.getMembers().keySet()) {\n            if (to.getMember(name) == null) {\n                to.setMember(name, from.getMember(name));\n            }\n        }\n    }"
        ],
        [
            "AutoCloneASTTransformation::addSimpleCloneHelperMethod(ClassNode,List,List)",
            " 215 -\n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  ",
            "    private void addSimpleCloneHelperMethod(ClassNode cNode, List<FieldNode> fieldNodes, List<String> excludes) {\r\n        Parameter methodParam = new Parameter(GenericsUtils.nonGeneric(cNode), \"other\");\r\n        final Expression other = varX(methodParam);\r\n        boolean hasParent = cNode.getSuperClass() != ClassHelper.OBJECT_TYPE;\r\n        BlockStatement methodBody = new BlockStatement();\r\n        if (hasParent) {\r\n            methodBody.addStatement(stmt(callSuperX(\"cloneOrCopyMembers\", args(other))));\r\n        }\r\n        for (FieldNode fieldNode : fieldNodes) {\r\n            String name = fieldNode.getName();\r\n            if (excludes != null && excludes.contains(name)) continue;\r\n            ClassNode fieldType = fieldNode.getType();\r\n            Expression direct = propX(varX(\"this\"), name);\r\n            Expression to = propX(other, name);\r\n            Statement assignDirect = assignS(to, direct);\r\n            Statement assignCloned = assignS(to, castX(fieldType, callCloneDirectX(direct)));\r\n            Statement assignClonedDynamic = assignS(to, castX(fieldType, callCloneDynamicX(direct)));\r\n            if (isCloneableType(fieldType)) {\r\n                methodBody.addStatement(assignCloned);\r\n            } else if (!possiblyCloneable(fieldType)) {\r\n                methodBody.addStatement(assignDirect);\r\n            } else {\r\n                methodBody.addStatement(ifElseS(isInstanceOfX(direct, CLONEABLE_TYPE), assignClonedDynamic, assignDirect));\r\n            }\r\n        }\r\n        ClassNode[] exceptions = {make(CloneNotSupportedException.class)};\r\n        cNode.addMethod(\"cloneOrCopyMembers\", ACC_PROTECTED, ClassHelper.VOID_TYPE, params(methodParam), exceptions, methodBody);\r\n    }\r",
            " 215 +\n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  ",
            "    private static void addSimpleCloneHelperMethod(ClassNode cNode, List<FieldNode> fieldNodes, List<String> excludes) {\r\n        Parameter methodParam = new Parameter(GenericsUtils.nonGeneric(cNode), \"other\");\r\n        final Expression other = varX(methodParam);\r\n        boolean hasParent = cNode.getSuperClass() != ClassHelper.OBJECT_TYPE;\r\n        BlockStatement methodBody = new BlockStatement();\r\n        if (hasParent) {\r\n            methodBody.addStatement(stmt(callSuperX(\"cloneOrCopyMembers\", args(other))));\r\n        }\r\n        for (FieldNode fieldNode : fieldNodes) {\r\n            String name = fieldNode.getName();\r\n            if (excludes != null && excludes.contains(name)) continue;\r\n            ClassNode fieldType = fieldNode.getType();\r\n            Expression direct = propX(varX(\"this\"), name);\r\n            Expression to = propX(other, name);\r\n            Statement assignDirect = assignS(to, direct);\r\n            Statement assignCloned = assignS(to, castX(fieldType, callCloneDirectX(direct)));\r\n            Statement assignClonedDynamic = assignS(to, castX(fieldType, callCloneDynamicX(direct)));\r\n            if (isCloneableType(fieldType)) {\r\n                methodBody.addStatement(assignCloned);\r\n            } else if (!possiblyCloneable(fieldType)) {\r\n                methodBody.addStatement(assignDirect);\r\n            } else {\r\n                methodBody.addStatement(ifElseS(isInstanceOfX(direct, CLONEABLE_TYPE), assignClonedDynamic, assignDirect));\r\n            }\r\n        }\r\n        ClassNode[] exceptions = {make(CloneNotSupportedException.class)};\r\n        cNode.addMethod(\"cloneOrCopyMembers\", ACC_PROTECTED, ClassHelper.VOID_TYPE, params(methodParam), exceptions, methodBody);\r\n    }\r"
        ],
        [
            "IndexedPropertyASTTransformation::addListGetter(FieldNode)",
            "  85 -\n  86  \n  87  ",
            "    private void addListGetter(FieldNode fNode) {\n        addGetter(fNode, getComponentTypeForList(fNode.getType()));\n    }",
            "  85 +\n  86  \n  87  ",
            "    private static void addListGetter(FieldNode fNode) {\n        addGetter(fNode, getComponentTypeForList(fNode.getType()));\n    }"
        ],
        [
            "ImmutableASTTransformation::createCheckForProperty(PropertyNode)",
            " 627 -\n 628  \n 629  \n 630  \n 631  \n 632  \n 633  \n 634  \n 635  \n 636  \n 637  \n 638  \n 639  \n 640  \n 641  \n 642  \n 643  \n 644  \n 645  \n 646  \n 647  \n 648  \n 649  \n 650  \n 651  \n 652  \n 653  \n 654  \n 655  \n 656  \n 657  \n 658  \n 659  \n 660  \n 661  \n 662  \n 663  \n 664  \n 665  \n 666  \n 667  \n 668  \n 669  \n 670  \n 671  \n 672  \n 673  \n 674  \n 675  \n 676  \n 677  \n 678  \n 679  \n 680  \n 681  ",
            "    private Statement createCheckForProperty( final PropertyNode pNode ) {\n        return block(\n                new VariableScope(),\n                ifElseS(\n                        callX(\n                                varX(\"map\", HASHMAP_TYPE),\n                                \"containsKey\",\n                                args(constX(pNode.getName()))\n                        ),\n                        block(\n                                new VariableScope(),\n                                declS(\n                                        varX(\"newValue\", ClassHelper.OBJECT_TYPE),\n                                        callX(\n                                                varX(\"map\", HASHMAP_TYPE),\n                                                \"get\",\n                                                args(constX(pNode.getName()))\n                                        )\n                                ),\n                                declS(\n                                        varX(\"oldValue\", ClassHelper.OBJECT_TYPE),\n                                        callThisX(getGetterName(pNode))\n                                ),\n                                ifS(\n                                        neX(\n                                                varX(\"newValue\", ClassHelper.OBJECT_TYPE),\n                                                varX(\"oldValue\", ClassHelper.OBJECT_TYPE)\n                                        ),\n                                        block(\n                                                new VariableScope(),\n                                                assignS(\n                                                        varX(\"oldValue\", ClassHelper.OBJECT_TYPE),\n                                                        varX(\"newValue\", ClassHelper.OBJECT_TYPE)),\n                                                assignS(\n                                                        varX(\"dirty\", ClassHelper.boolean_TYPE),\n                                                        ConstantExpression.TRUE)\n                                        )\n                                ),\n                                stmt(callX(\n                                        varX(\"construct\", HASHMAP_TYPE),\n                                        \"put\",\n                                        args(\n                                                constX(pNode.getName()),\n                                                varX(\"oldValue\", ClassHelper.OBJECT_TYPE)\n                                        )\n                                ))\n                        ),\n                        block(\n                                new VariableScope(),\n                                stmt(callX(\n                                        varX(\"construct\", HASHMAP_TYPE),\n                                        \"put\",\n                                        args(\n                                                constX(pNode.getName()),\n                                                callThisX(getGetterName(pNode))",
            " 627 +\n 628  \n 629  \n 630  \n 631  \n 632  \n 633  \n 634  \n 635  \n 636  \n 637  \n 638  \n 639  \n 640  \n 641  \n 642  \n 643  \n 644  \n 645  \n 646  \n 647  \n 648  \n 649  \n 650  \n 651  \n 652  \n 653  \n 654  \n 655  \n 656  \n 657  \n 658  \n 659  \n 660  \n 661  \n 662  \n 663  \n 664  \n 665  \n 666  \n 667  \n 668  \n 669  \n 670  \n 671  \n 672  \n 673  \n 674  \n 675  \n 676  \n 677  \n 678  \n 679  \n 680  \n 681  ",
            "    private static Statement createCheckForProperty( final PropertyNode pNode ) {\n        return block(\n                new VariableScope(),\n                ifElseS(\n                        callX(\n                                varX(\"map\", HASHMAP_TYPE),\n                                \"containsKey\",\n                                args(constX(pNode.getName()))\n                        ),\n                        block(\n                                new VariableScope(),\n                                declS(\n                                        varX(\"newValue\", ClassHelper.OBJECT_TYPE),\n                                        callX(\n                                                varX(\"map\", HASHMAP_TYPE),\n                                                \"get\",\n                                                args(constX(pNode.getName()))\n                                        )\n                                ),\n                                declS(\n                                        varX(\"oldValue\", ClassHelper.OBJECT_TYPE),\n                                        callThisX(getGetterName(pNode))\n                                ),\n                                ifS(\n                                        neX(\n                                                varX(\"newValue\", ClassHelper.OBJECT_TYPE),\n                                                varX(\"oldValue\", ClassHelper.OBJECT_TYPE)\n                                        ),\n                                        block(\n                                                new VariableScope(),\n                                                assignS(\n                                                        varX(\"oldValue\", ClassHelper.OBJECT_TYPE),\n                                                        varX(\"newValue\", ClassHelper.OBJECT_TYPE)),\n                                                assignS(\n                                                        varX(\"dirty\", ClassHelper.boolean_TYPE),\n                                                        ConstantExpression.TRUE)\n                                        )\n                                ),\n                                stmt(callX(\n                                        varX(\"construct\", HASHMAP_TYPE),\n                                        \"put\",\n                                        args(\n                                                constX(pNode.getName()),\n                                                varX(\"oldValue\", ClassHelper.OBJECT_TYPE)\n                                        )\n                                ))\n                        ),\n                        block(\n                                new VariableScope(),\n                                stmt(callX(\n                                        varX(\"construct\", HASHMAP_TYPE),\n                                        \"put\",\n                                        args(\n                                                constX(pNode.getName()),\n                                                callThisX(getGetterName(pNode))"
        ],
        [
            "MemoizedASTTransformation::buildDelegatingMethod(MethodNode,ClassNode)",
            " 116 -\n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  ",
            "    private MethodNode buildDelegatingMethod(final MethodNode annotatedMethod, final ClassNode ownerClassNode) {\n        Statement code = annotatedMethod.getCode();\n        int access = ACC_PROTECTED;\n        if (annotatedMethod.isStatic()) {\n            access = ACC_PRIVATE | ACC_STATIC;\n        }\n        MethodNode method = new MethodNode(\n                buildUniqueName(ownerClassNode, METHOD_LABEL, annotatedMethod),\n                access,\n                annotatedMethod.getReturnType(),\n                cloneParams(annotatedMethod.getParameters()),\n                annotatedMethod.getExceptions(),\n                code\n        );\n        List<AnnotationNode> sourceAnnotations = annotatedMethod.getAnnotations();\n        method.addAnnotations(new ArrayList<AnnotationNode>(sourceAnnotations));\n        return method;\n    }",
            " 116 +\n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  ",
            "    private static MethodNode buildDelegatingMethod(final MethodNode annotatedMethod, final ClassNode ownerClassNode) {\n        Statement code = annotatedMethod.getCode();\n        int access = ACC_PROTECTED;\n        if (annotatedMethod.isStatic()) {\n            access = ACC_PRIVATE | ACC_STATIC;\n        }\n        MethodNode method = new MethodNode(\n                buildUniqueName(ownerClassNode, METHOD_LABEL, annotatedMethod),\n                access,\n                annotatedMethod.getReturnType(),\n                cloneParams(annotatedMethod.getParameters()),\n                annotatedMethod.getExceptions(),\n                code\n        );\n        List<AnnotationNode> sourceAnnotations = annotatedMethod.getAnnotations();\n        method.addAnnotations(new ArrayList<AnnotationNode>(sourceAnnotations));\n        return method;\n    }"
        ],
        [
            "ImmutableASTTransformation::createNoArgConstructor(ClassNode)",
            " 374 -\n 375  \n 376  \n 377  ",
            "    private void createNoArgConstructor(ClassNode cNode) {\n        Statement body = stmt(ctorX(ClassNode.THIS, args(new MapExpression())));\n        doAddConstructor(cNode, new ConstructorNode(ACC_PUBLIC, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, body));\n    }",
            " 374 +\n 375  \n 376  \n 377  ",
            "    private static void createNoArgConstructor(ClassNode cNode) {\n        Statement body = stmt(ctorX(ClassNode.THIS, args(new MapExpression())));\n        doAddConstructor(cNode, new ConstructorNode(ACC_PUBLIC, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, body));\n    }"
        ],
        [
            "ImmutableASTTransformation::createConstructorStatementMapSpecial(FieldNode)",
            " 403 -\n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  \n 423  \n 424  \n 425  \n 426  \n 427  ",
            "    private Statement createConstructorStatementMapSpecial(FieldNode fNode) {\n        final Expression fieldExpr = varX(fNode);\n        final ClassNode fieldType = fieldExpr.getType();\n        final Expression initExpr = fNode.getInitialValueExpression();\n        final Statement assignInit;\n        if (initExpr == null || (initExpr instanceof ConstantExpression && ((ConstantExpression)initExpr).isNullExpression())) {\n            assignInit = assignS(fieldExpr, ConstantExpression.EMPTY_EXPRESSION);\n        } else {\n            assignInit = assignS(fieldExpr, cloneCollectionExpr(initExpr, fieldType));\n        }\n        Expression namedArgs = findArg(fNode.getName());\n        Expression baseArgs = varX(\"args\");\n        return ifElseS(\n                equalsNullX(baseArgs),\n                assignInit,\n                ifElseS(\n                        equalsNullX(namedArgs),\n                        ifElseS(\n                                isTrueX(callX(baseArgs, \"containsKey\", constX(fNode.getName()))),\n                                assignS(fieldExpr, namedArgs),\n                                assignS(fieldExpr, cloneCollectionExpr(baseArgs, fieldType))),\n                        ifElseS(\n                                isOneX(callX(baseArgs, \"size\")),\n                                assignS(fieldExpr, cloneCollectionExpr(namedArgs, fieldType)),\n                                assignS(fieldExpr, cloneCollectionExpr(baseArgs, fieldType)))",
            " 403 +\n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  \n 423  \n 424  \n 425  \n 426  \n 427  ",
            "    private static Statement createConstructorStatementMapSpecial(FieldNode fNode) {\n        final Expression fieldExpr = varX(fNode);\n        final ClassNode fieldType = fieldExpr.getType();\n        final Expression initExpr = fNode.getInitialValueExpression();\n        final Statement assignInit;\n        if (initExpr == null || (initExpr instanceof ConstantExpression && ((ConstantExpression)initExpr).isNullExpression())) {\n            assignInit = assignS(fieldExpr, ConstantExpression.EMPTY_EXPRESSION);\n        } else {\n            assignInit = assignS(fieldExpr, cloneCollectionExpr(initExpr, fieldType));\n        }\n        Expression namedArgs = findArg(fNode.getName());\n        Expression baseArgs = varX(\"args\");\n        return ifElseS(\n                equalsNullX(baseArgs),\n                assignInit,\n                ifElseS(\n                        equalsNullX(namedArgs),\n                        ifElseS(\n                                isTrueX(callX(baseArgs, \"containsKey\", constX(fNode.getName()))),\n                                assignS(fieldExpr, namedArgs),\n                                assignS(fieldExpr, cloneCollectionExpr(baseArgs, fieldType))),\n                        ifElseS(\n                                isOneX(callX(baseArgs, \"size\")),\n                                assignS(fieldExpr, cloneCollectionExpr(namedArgs, fieldType)),\n                                assignS(fieldExpr, cloneCollectionExpr(baseArgs, fieldType)))"
        ],
        [
            "CategoryASTTransformation::getTargetClass(SourceUnit,AnnotationNode)",
            " 285 -\n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  ",
            "    private ClassNode getTargetClass(SourceUnit source, AnnotationNode annotation) {\r\n        Expression value = annotation.getMember(\"value\");\r\n        if (value == null || !(value instanceof ClassExpression)) {\r\n            //noinspection ThrowableInstanceNeverThrown\r\n            source.getErrorCollector().addErrorAndContinue(new SyntaxErrorMessage(\r\n                    new SyntaxException(\"@groovy.lang.Category must define 'value' which is the class to apply this category to\",\r\n                            annotation.getLineNumber(), annotation.getColumnNumber(), annotation.getLastLineNumber(), annotation.getLastColumnNumber()),\r\n                    source));\r\n            return null;\r\n        } else {\r\n            ClassExpression ce = (ClassExpression) value;\r\n            return ce.getType();\r\n        }\r\n    }\r",
            " 285 +\n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  ",
            "    private static ClassNode getTargetClass(SourceUnit source, AnnotationNode annotation) {\r\n        Expression value = annotation.getMember(\"value\");\r\n        if (value == null || !(value instanceof ClassExpression)) {\r\n            //noinspection ThrowableInstanceNeverThrown\r\n            source.getErrorCollector().addErrorAndContinue(new SyntaxErrorMessage(\r\n                    new SyntaxException(\"@groovy.lang.Category must define 'value' which is the class to apply this category to\",\r\n                            annotation.getLineNumber(), annotation.getColumnNumber(), annotation.getLastLineNumber(), annotation.getLastColumnNumber()),\r\n                    source));\r\n            return null;\r\n        } else {\r\n            ClassExpression ce = (ClassExpression) value;\r\n            return ce.getType();\r\n        }\r\n    }\r"
        ],
        [
            "NewifyASTTransformation::determineAutoFlag(Expression)",
            " 103 -\n 104  \n 105  ",
            "    private boolean determineAutoFlag(Expression autoExpr) {\n        return !(autoExpr instanceof ConstantExpression && ((ConstantExpression) autoExpr).getValue().equals(false));\n    }",
            " 103 +\n 104  \n 105  ",
            "    private static boolean determineAutoFlag(Expression autoExpr) {\n        return !(autoExpr instanceof ConstantExpression && ((ConstantExpression) autoExpr).getValue().equals(false));\n    }"
        ],
        [
            "SourceURIASTTransformation::getExpression(URI)",
            " 111 -\n 112  \n 113  ",
            "    private Expression getExpression(URI uri) {\n        return callX(URI_TYPE, \"create\", args(constX(uri.toString())));\n    }",
            " 111 +\n 112  \n 113  ",
            "    private static Expression getExpression(URI uri) {\n        return callX(URI_TYPE, \"create\", args(constX(uri.toString())));\n    }"
        ],
        [
            "PackageScopeASTTransformation::determineTargets(Expression)",
            " 165 -\n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  ",
            "    private List<groovy.transform.PackageScopeTarget> determineTargets(Expression expr) {\n        List<groovy.transform.PackageScopeTarget> list = new ArrayList<groovy.transform.PackageScopeTarget>();\n        if (expr instanceof PropertyExpression) {\n            list.add(extractTarget((PropertyExpression) expr));\n        } else if (expr instanceof ListExpression) {\n            final ListExpression expressionList = (ListExpression) expr;\n            final List<Expression> expressions = expressionList.getExpressions();\n            for (Expression ex : expressions) {\n                if (ex instanceof PropertyExpression) {\n                    list.add(extractTarget((PropertyExpression) ex));\n                }\n            }\n        }\n        return list;\n    }",
            " 165 +\n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  ",
            "    private static List<groovy.transform.PackageScopeTarget> determineTargets(Expression expr) {\n        List<groovy.transform.PackageScopeTarget> list = new ArrayList<groovy.transform.PackageScopeTarget>();\n        if (expr instanceof PropertyExpression) {\n            list.add(extractTarget((PropertyExpression) expr));\n        } else if (expr instanceof ListExpression) {\n            final ListExpression expressionList = (ListExpression) expr;\n            final List<Expression> expressions = expressionList.getExpressions();\n            for (Expression ex : expressions) {\n                if (ex instanceof PropertyExpression) {\n                    list.add(extractTarget((PropertyExpression) ex));\n                }\n            }\n        }\n        return list;\n    }"
        ],
        [
            "IndexedPropertyASTTransformation::addListSetter(FieldNode)",
            "  89 -\n  90  \n  91  ",
            "    private void addListSetter(FieldNode fNode) {\n        addSetter(fNode, getComponentTypeForList(fNode.getType()));\n    }",
            "  89 +\n  90  \n  91  ",
            "    private static void addListSetter(FieldNode fNode) {\n        addSetter(fNode, getComponentTypeForList(fNode.getType()));\n    }"
        ],
        [
            "DelegateASTTransformation::shouldSkipPropertyMethod(String,String,List,List)",
            " 186 -\n 187  \n 188  \n 189  \n 190  ",
            "    private boolean shouldSkipPropertyMethod(String propertyName, String methodName, List<String> excludes, List<String> includes) {\n        return (deemedInternalName(propertyName)\n                    || excludes != null && (excludes.contains(propertyName) || excludes.contains(methodName)) \n                    || (includes != null && !includes.isEmpty() && !includes.contains(propertyName) && !includes.contains(methodName)));\n    }",
            " 186 +\n 187  \n 188  \n 189  \n 190  ",
            "    private static boolean shouldSkipPropertyMethod(String propertyName, String methodName, List<String> excludes, List<String> includes) {\n        return (deemedInternalName(propertyName)\n                    || excludes != null && (excludes.contains(propertyName) || excludes.contains(methodName)) \n                    || (includes != null && !includes.isEmpty() && !includes.contains(propertyName) && !includes.contains(methodName)));\n    }"
        ],
        [
            "AnnotationCollectorTransform::copy(List,AnnotationNode)",
            " 186 -\n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  ",
            "    private List<AnnotationNode> copy(List<AnnotationNode> orig, AnnotationNode aliasAnnotationUsage) {\n        if (orig.isEmpty()) return orig;\n        List<AnnotationNode> ret = new ArrayList<AnnotationNode>(orig.size());\n        for (AnnotationNode an : orig) {\n            AnnotationNode newAn = new AnnotationNode(an.getClassNode());\n            newAn.getMembers().putAll(an.getMembers());\n            newAn.setSourcePosition(aliasAnnotationUsage);\n            ret.add(newAn);\n        }\n        return ret;\n    }",
            " 186 +\n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  ",
            "    private static List<AnnotationNode> copy(List<AnnotationNode> orig, AnnotationNode aliasAnnotationUsage) {\n        if (orig.isEmpty()) return orig;\n        List<AnnotationNode> ret = new ArrayList<AnnotationNode>(orig.size());\n        for (AnnotationNode an : orig) {\n            AnnotationNode newAn = new AnnotationNode(an.getClassNode());\n            newAn.getMembers().putAll(an.getMembers());\n            newAn.setSourcePosition(aliasAnnotationUsage);\n            ret.add(newAn);\n        }\n        return ret;\n    }"
        ],
        [
            "ImmutableASTTransformation::adjustPropertyForImmutability(PropertyNode,List)",
            " 574 -\n 575  \n 576  \n 577  \n 578  \n 579  ",
            "    private void adjustPropertyForImmutability(PropertyNode pNode, List<PropertyNode> newNodes) {\n        final FieldNode fNode = pNode.getField();\n        fNode.setModifiers((pNode.getModifiers() & (~ACC_PUBLIC)) | ACC_FINAL | ACC_PRIVATE);\n        adjustPropertyNode(pNode, createGetterBody(fNode));\n        newNodes.add(pNode);\n    }",
            " 574 +\n 575  \n 576  \n 577  \n 578  \n 579  ",
            "    private static void adjustPropertyForImmutability(PropertyNode pNode, List<PropertyNode> newNodes) {\n        final FieldNode fNode = pNode.getField();\n        fNode.setModifiers((pNode.getModifiers() & (~ACC_PUBLIC)) | ACC_FINAL | ACC_PRIVATE);\n        adjustPropertyNode(pNode, createGetterBody(fNode));\n        newNodes.add(pNode);\n    }"
        ],
        [
            "ImmutableASTTransformation::createGetterBody(FieldNode)",
            " 586 -\n 587  \n 588  \n 589  \n 590  \n 591  \n 592  \n 593  \n 594  \n 595  \n 596  \n 597  \n 598  \n 599  ",
            "    private Statement createGetterBody(FieldNode fNode) {\n        BlockStatement body = new BlockStatement();\n        final ClassNode fieldType = fNode.getType();\n        final Statement statement;\n        if (fieldType.isArray() || isOrImplements(fieldType, CLONEABLE_TYPE)) {\n            statement = createGetterBodyArrayOrCloneable(fNode);\n        } else if (fieldType.isDerivedFrom(DATE_TYPE)) {\n            statement = createGetterBodyDate(fNode);\n        } else {\n            statement = createGetterBodyDefault(fNode);\n        }\n        body.addStatement(statement);\n        return body;\n    }",
            " 586 +\n 587  \n 588  \n 589  \n 590  \n 591  \n 592  \n 593  \n 594  \n 595  \n 596  \n 597  \n 598  \n 599  ",
            "    private static Statement createGetterBody(FieldNode fNode) {\n        BlockStatement body = new BlockStatement();\n        final ClassNode fieldType = fNode.getType();\n        final Statement statement;\n        if (fieldType.isArray() || isOrImplements(fieldType, CLONEABLE_TYPE)) {\n            statement = createGetterBodyArrayOrCloneable(fNode);\n        } else if (fieldType.isDerivedFrom(DATE_TYPE)) {\n            statement = createGetterBodyDate(fNode);\n        } else {\n            statement = createGetterBodyDefault(fNode);\n        }\n        body.addStatement(statement);\n        return body;\n    }"
        ],
        [
            "ImmutableASTTransformation::checkUnresolved(FieldNode,Expression)",
            " 499 -\n 500  \n 501  \n 502  ",
            "    private Expression checkUnresolved(FieldNode fNode, Expression value) {\n        Expression args = args(callThisX(\"getClass\"), constX(fNode.getName()), value);\n        return callX(SELF_TYPE, \"checkImmutable\", args);\n    }",
            " 499 +\n 500  \n 501  \n 502  ",
            "    private static Expression checkUnresolved(FieldNode fNode, Expression value) {\n        Expression args = args(callThisX(\"getClass\"), constX(fNode.getName()), value);\n        return callX(SELF_TYPE, \"checkImmutable\", args);\n    }"
        ],
        [
            "ImmutableASTTransformation::cloneDateExpr(Expression)",
            " 570 -\n 571  \n 572  ",
            "    private Expression cloneDateExpr(Expression origDate) {\n        return ctorX(DATE_TYPE, callX(origDate, \"getTime\"));\n    }",
            " 570 +\n 571  \n 572  ",
            "    private static Expression cloneDateExpr(Expression origDate) {\n        return ctorX(DATE_TYPE, callX(origDate, \"getTime\"));\n    }"
        ],
        [
            "ImmutableASTTransformation::createGetterBodyDefault(FieldNode)",
            " 315 -\n 316  \n 317  \n 318  ",
            "    private Statement createGetterBodyDefault(FieldNode fNode) {\n        final Expression fieldExpr = varX(fNode);\n        return stmt(fieldExpr);\n    }",
            " 315 +\n 316  \n 317  \n 318  ",
            "    private static Statement createGetterBodyDefault(FieldNode fNode) {\n        final Expression fieldExpr = varX(fNode);\n        return stmt(fieldExpr);\n    }"
        ],
        [
            "PackageScopeASTTransformation::extractTarget(PropertyExpression)",
            " 181 -\n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  ",
            "    private groovy.transform.PackageScopeTarget extractTarget(PropertyExpression expr) {\n        Expression oe = expr.getObjectExpression();\n        if (oe instanceof ClassExpression) {\n            ClassExpression ce = (ClassExpression) oe;\n            if (ce.getType().getName().equals(\"groovy.transform.PackageScopeTarget\")) {\n                Expression prop = expr.getProperty();\n                if (prop instanceof ConstantExpression) {\n                    String propName = (String) ((ConstantExpression) prop).getValue();\n                    try {\n                        return PackageScopeTarget.valueOf(propName);\n                    } catch(IllegalArgumentException iae) {\n                        /* ignore */\n                    }\n                }\n            }\n        }\n        throw new GroovyBugError(\"Internal error during \" + MY_TYPE_NAME\n                + \" processing. Annotation parameters must be of type: \" + TARGET_CLASS_NAME + \".\");\n    }",
            " 181 +\n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  ",
            "    private static groovy.transform.PackageScopeTarget extractTarget(PropertyExpression expr) {\n        Expression oe = expr.getObjectExpression();\n        if (oe instanceof ClassExpression) {\n            ClassExpression ce = (ClassExpression) oe;\n            if (ce.getType().getName().equals(\"groovy.transform.PackageScopeTarget\")) {\n                Expression prop = expr.getProperty();\n                if (prop instanceof ConstantExpression) {\n                    String propName = (String) ((ConstantExpression) prop).getValue();\n                    try {\n                        return PackageScopeTarget.valueOf(propName);\n                    } catch(IllegalArgumentException iae) {\n                        /* ignore */\n                    }\n                }\n            }\n        }\n        throw new GroovyBugError(\"Internal error during \" + MY_TYPE_NAME\n                + \" processing. Annotation parameters must be of type: \" + TARGET_CLASS_NAME + \".\");\n    }"
        ],
        [
            "FieldASTTransformation::notTransform(ClassNode)",
            " 134 -\n 135  \n 136  ",
            "    private boolean notTransform(ClassNode annotationClassNode) {\r\n        return annotationClassNode.getAnnotations(ASTTRANSFORMCLASS_TYPE).isEmpty();\r\n    }\r",
            " 134 +\n 135  \n 136  ",
            "    private static boolean notTransform(ClassNode annotationClassNode) {\r\n        return annotationClassNode.getAnnotations(ASTTRANSFORMCLASS_TYPE).isEmpty();\r\n    }\r"
        ],
        [
            "ImmutableASTTransformation::createConstructorStatementArrayOrCloneable(FieldNode)",
            " 543 -\n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  ",
            "    private Statement createConstructorStatementArrayOrCloneable(FieldNode fNode) {\n        final Expression fieldExpr = varX(fNode);\n        Expression initExpr = fNode.getInitialValueExpression();\n        ClassNode fieldType = fNode.getType();\n        final Expression array = findArg(fNode.getName());\n        final Statement assignInit;\n        if (initExpr == null || (initExpr instanceof ConstantExpression && ((ConstantExpression)initExpr).isNullExpression())) {\n            assignInit = assignS(fieldExpr, ConstantExpression.EMPTY_EXPRESSION);\n        } else {\n            assignInit = assignS(fieldExpr, cloneArrayOrCloneableExpr(initExpr, fieldType));\n        }\n        return ifElseS(equalsNullX(array), assignInit, assignS(fieldExpr, cloneArrayOrCloneableExpr(array, fieldType)));\n    }",
            " 543 +\n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  ",
            "    private static Statement createConstructorStatementArrayOrCloneable(FieldNode fNode) {\n        final Expression fieldExpr = varX(fNode);\n        Expression initExpr = fNode.getInitialValueExpression();\n        ClassNode fieldType = fNode.getType();\n        final Expression array = findArg(fNode.getName());\n        final Statement assignInit;\n        if (initExpr == null || (initExpr instanceof ConstantExpression && ((ConstantExpression)initExpr).isNullExpression())) {\n            assignInit = assignS(fieldExpr, ConstantExpression.EMPTY_EXPRESSION);\n        } else {\n            assignInit = assignS(fieldExpr, cloneArrayOrCloneableExpr(initExpr, fieldType));\n        }\n        return ifElseS(equalsNullX(array), assignInit, assignS(fieldExpr, cloneArrayOrCloneableExpr(array, fieldType)));\n    }"
        ],
        [
            "FieldASTTransformation::acceptableTransform(AnnotationNode)",
            " 125 -\n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  ",
            "    private boolean acceptableTransform(AnnotationNode annotation) {\r\n        // TODO also check for phase after sourceUnit.getPhase()? but will be ignored anyway?\r\n        // TODO we should only copy those annotations with FIELD_TARGET but haven't visited annotations\r\n        // and gathered target info at this phase, so we can't do this:\r\n        // return annotation.isTargetAllowed(AnnotationNode.FIELD_TARGET);\r\n        // instead just don't copy ourselves for now\r\n        return !annotation.getClassNode().equals(MY_TYPE);\r\n    }\r",
            " 125 +\n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  ",
            "    private static boolean acceptableTransform(AnnotationNode annotation) {\r\n        // TODO also check for phase after sourceUnit.getPhase()? but will be ignored anyway?\r\n        // TODO we should only copy those annotations with FIELD_TARGET but haven't visited annotations\r\n        // and gathered target info at this phase, so we can't do this:\r\n        // return annotation.isTargetAllowed(AnnotationNode.FIELD_TARGET);\r\n        // instead just don't copy ourselves for now\r\n        return !annotation.getClassNode().equals(MY_TYPE);\r\n    }\r"
        ],
        [
            "ImmutableASTTransformation::addProperty(ClassNode,PropertyNode)",
            " 440 -\n 441  \n 442  \n 443  \n 444  \n 445  \n 446  \n 447  \n 448  ",
            "    private void addProperty(ClassNode cNode, PropertyNode pNode) {\n        final FieldNode fn = pNode.getField();\n        cNode.getFields().remove(fn);\n        cNode.addProperty(pNode.getName(), pNode.getModifiers() | ACC_FINAL, pNode.getType(),\n                pNode.getInitialExpression(), pNode.getGetterBlock(), pNode.getSetterBlock());\n        final FieldNode newfn = cNode.getField(fn.getName());\n        cNode.getFields().remove(newfn);\n        cNode.addField(fn);\n    }",
            " 440 +\n 441  \n 442  \n 443  \n 444  \n 445  \n 446  \n 447  \n 448  ",
            "    private static void addProperty(ClassNode cNode, PropertyNode pNode) {\n        final FieldNode fn = pNode.getField();\n        cNode.getFields().remove(fn);\n        cNode.addProperty(pNode.getName(), pNode.getModifiers() | ACC_FINAL, pNode.getType(),\n                pNode.getInitialExpression(), pNode.getGetterBlock(), pNode.getSetterBlock());\n        final FieldNode newfn = cNode.getField(fn.getName());\n        cNode.getFields().remove(newfn);\n        cNode.addField(fn);\n    }"
        ],
        [
            "ImmutableASTTransformation::isKnownImmutable(String,List)",
            " 535 -\n 536  \n 537  ",
            "    private boolean isKnownImmutable(String fieldName, List<String> knownImmutables) {\n        return knownImmutables.contains(fieldName);\n    }",
            " 535 +\n 536  \n 537  ",
            "    private static boolean isKnownImmutable(String fieldName, List<String> knownImmutables) {\n        return knownImmutables.contains(fieldName);\n    }"
        ],
        [
            "AnnotationCollectorTransform::getStoredTargetList(AnnotationNode,SourceUnit)",
            " 180 -\n 181  \n 182  \n 183  \n 184  ",
            "    private List<AnnotationNode> getStoredTargetList(AnnotationNode aliasAnnotationUsage, SourceUnit source) {\n        ClassNode alias = aliasAnnotationUsage.getClassNode().redirect();\n        List<AnnotationNode> ret = getMeta(alias);\n        return copy(ret, aliasAnnotationUsage);\n    }",
            " 180 +\n 181  \n 182  \n 183  \n 184  ",
            "    private static List<AnnotationNode> getStoredTargetList(AnnotationNode aliasAnnotationUsage, SourceUnit source) {\n        ClassNode alias = aliasAnnotationUsage.getClassNode().redirect();\n        List<AnnotationNode> ret = getMeta(alias);\n        return copy(ret, aliasAnnotationUsage);\n    }"
        ],
        [
            "AutoCloneASTTransformation::createClone(ClassNode,List,List)",
            " 244 -\n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  ",
            "    private void createClone(ClassNode cNode, List<FieldNode> fieldNodes, List<String> excludes) {\r\n        final BlockStatement body = new BlockStatement();\r\n        final Expression result = varX(\"_result\", cNode);\r\n        body.addStatement(declS(result, castX(cNode, callSuperX(\"clone\"))));\r\n        for (FieldNode fieldNode : fieldNodes) {\r\n            if (excludes != null && excludes.contains(fieldNode.getName())) continue;\r\n            ClassNode fieldType = fieldNode.getType();\r\n            Expression fieldExpr = varX(fieldNode);\r\n            Expression to = propX(result, fieldNode.getName());\r\n            Statement doClone = assignS(to, castX(fieldType, callCloneDirectX(fieldExpr)));\r\n            Statement doCloneDynamic = assignS(to, castX(fieldType, callCloneDynamicX(fieldExpr)));\r\n            if (isCloneableType(fieldType)) {\r\n                body.addStatement(doClone);\r\n            } else if (possiblyCloneable(fieldType)) {\r\n                body.addStatement(ifS(isInstanceOfX(fieldExpr, CLONEABLE_TYPE), doCloneDynamic));\r\n            }\r\n        }\r\n        body.addStatement(returnS(result));\r\n        ClassNode[] exceptions = {make(CloneNotSupportedException.class)};\r\n        cNode.addMethod(\"clone\", ACC_PUBLIC, GenericsUtils.nonGeneric(cNode), Parameter.EMPTY_ARRAY, exceptions, body);\r\n    }\r",
            " 244 +\n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  ",
            "    private static void createClone(ClassNode cNode, List<FieldNode> fieldNodes, List<String> excludes) {\r\n        final BlockStatement body = new BlockStatement();\r\n        final Expression result = varX(\"_result\", cNode);\r\n        body.addStatement(declS(result, castX(cNode, callSuperX(\"clone\"))));\r\n        for (FieldNode fieldNode : fieldNodes) {\r\n            if (excludes != null && excludes.contains(fieldNode.getName())) continue;\r\n            ClassNode fieldType = fieldNode.getType();\r\n            Expression fieldExpr = varX(fieldNode);\r\n            Expression to = propX(result, fieldNode.getName());\r\n            Statement doClone = assignS(to, castX(fieldType, callCloneDirectX(fieldExpr)));\r\n            Statement doCloneDynamic = assignS(to, castX(fieldType, callCloneDynamicX(fieldExpr)));\r\n            if (isCloneableType(fieldType)) {\r\n                body.addStatement(doClone);\r\n            } else if (possiblyCloneable(fieldType)) {\r\n                body.addStatement(ifS(isInstanceOfX(fieldExpr, CLONEABLE_TYPE), doCloneDynamic));\r\n            }\r\n        }\r\n        body.addStatement(returnS(result));\r\n        ClassNode[] exceptions = {make(CloneNotSupportedException.class)};\r\n        cNode.addMethod(\"clone\", ACC_PUBLIC, GenericsUtils.nonGeneric(cNode), Parameter.EMPTY_ARRAY, exceptions, body);\r\n    }\r"
        ],
        [
            "AutoCloneASTTransformation::getStyle(AnnotationNode,String)",
            " 266 -\n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  ",
            "    private AutoCloneStyle getStyle(AnnotationNode node, String name) {\r\n        final Expression member = node.getMember(name);\r\n        if (member != null && member instanceof PropertyExpression) {\r\n            PropertyExpression prop = (PropertyExpression) member;\r\n            Expression oe = prop.getObjectExpression();\r\n            if (oe instanceof ClassExpression) {\r\n                ClassExpression ce = (ClassExpression) oe;\r\n                if (ce.getType().getName().equals(\"groovy.transform.AutoCloneStyle\")) {\r\n                    return AutoCloneStyle.valueOf(prop.getPropertyAsString());\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r",
            " 266 +\n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  ",
            "    private static AutoCloneStyle getStyle(AnnotationNode node, String name) {\r\n        final Expression member = node.getMember(name);\r\n        if (member != null && member instanceof PropertyExpression) {\r\n            PropertyExpression prop = (PropertyExpression) member;\r\n            Expression oe = prop.getObjectExpression();\r\n            if (oe instanceof ClassExpression) {\r\n                ClassExpression ce = (ClassExpression) oe;\r\n                if (ce.getType().getName().equals(\"groovy.transform.AutoCloneStyle\")) {\r\n                    return AutoCloneStyle.valueOf(prop.getPropertyAsString());\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r"
        ],
        [
            "TraitASTTransformation::createReceiverType(boolean,ClassNode)",
            " 503 -\n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512  \n 513  \n 514  \n 515  \n 516  ",
            "    private ClassNode createReceiverType(final boolean isStatic, final ClassNode rawType) {\n        ClassNode type;\n        if (isStatic) {\n            // Class<TraitClass>\n            type = ClassHelper.CLASS_Type.getPlainNodeReference();\n            type.setGenericsTypes(new GenericsType[]{\n                    new GenericsType(rawType)\n            });\n        } else {\n            // TraitClass\n            type = rawType;\n        }\n        return type;\n    }",
            " 503 +\n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512  \n 513  \n 514  \n 515  \n 516  ",
            "    private static ClassNode createReceiverType(final boolean isStatic, final ClassNode rawType) {\n        ClassNode type;\n        if (isStatic) {\n            // Class<TraitClass>\n            type = ClassHelper.CLASS_Type.getPlainNodeReference();\n            type.setGenericsTypes(new GenericsType[]{\n                    new GenericsType(rawType)\n            });\n        } else {\n            // TraitClass\n            type = rawType;\n        }\n        return type;\n    }"
        ],
        [
            "ImmutableASTTransformation::createConstructorMapCommon(ClassNode,BlockStatement)",
            " 379 -\n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  ",
            "    private void createConstructorMapCommon(ClassNode cNode, BlockStatement body) {\n        final List<FieldNode> fList = cNode.getFields();\n        for (FieldNode fNode : fList) {\n            if (fNode.isPublic()) continue; // public fields will be rejected elsewhere\n            if (cNode.getProperty(fNode.getName()) != null) continue; // a property\n            if (fNode.isFinal() && fNode.isStatic()) continue;\n            if (fNode.getName().contains(\"$\") || fNode.isSynthetic()) continue; // internal field\n            if (fNode.isFinal() && fNode.getInitialExpression() != null)\n                body.addStatement(checkFinalArgNotOverridden(cNode, fNode));\n            body.addStatement(createConstructorStatementDefault(fNode));\n        }\n        doAddConstructor(cNode, new ConstructorNode(ACC_PUBLIC, params(new Parameter(HASHMAP_TYPE, \"args\")), ClassNode.EMPTY_ARRAY, body));\n    }",
            " 379 +\n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  ",
            "    private static void createConstructorMapCommon(ClassNode cNode, BlockStatement body) {\n        final List<FieldNode> fList = cNode.getFields();\n        for (FieldNode fNode : fList) {\n            if (fNode.isPublic()) continue; // public fields will be rejected elsewhere\n            if (cNode.getProperty(fNode.getName()) != null) continue; // a property\n            if (fNode.isFinal() && fNode.isStatic()) continue;\n            if (fNode.getName().contains(\"$\") || fNode.isSynthetic()) continue; // internal field\n            if (fNode.isFinal() && fNode.getInitialExpression() != null)\n                body.addStatement(checkFinalArgNotOverridden(cNode, fNode));\n            body.addStatement(createConstructorStatementDefault(fNode));\n        }\n        doAddConstructor(cNode, new ConstructorNode(ACC_PUBLIC, params(new Parameter(HASHMAP_TYPE, \"args\")), ClassNode.EMPTY_ARRAY, body));\n    }"
        ],
        [
            "ExternalizeMethodsASTTransformation::createReadExternal(ClassNode,List,List)",
            " 103 -\n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  ",
            "    private void createReadExternal(ClassNode cNode, List<String> excludes, List<FieldNode> list) {\n        final BlockStatement body = new BlockStatement();\n        Parameter oin = param(OBJECTINPUT_TYPE, \"oin\");\n        for (FieldNode fNode : list) {\n            if (excludes != null && excludes.contains(fNode.getName())) continue;\n            if ((fNode.getModifiers() & ACC_TRANSIENT) != 0) continue;\n            String suffix = suffixForField(fNode);\n            MethodCallExpression readObject = callX(varX(oin), \"read\" + suffix);\n            readObject.setImplicitThis(false);\n            body.addStatement(assignS(varX(fNode), suffix.equals(\"Object\") ? castX(GenericsUtils.nonGeneric(fNode.getType()), readObject) : readObject));\n        }\n        cNode.addMethod(\"readExternal\", ACC_PUBLIC, ClassHelper.VOID_TYPE, params(oin), ClassNode.EMPTY_ARRAY, body);\n    }",
            " 102 +\n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  ",
            "    private static void createReadExternal(ClassNode cNode, List<String> excludes, List<FieldNode> list) {\n        final BlockStatement body = new BlockStatement();\n        Parameter oin = param(OBJECTINPUT_TYPE, \"oin\");\n        for (FieldNode fNode : list) {\n            if (excludes != null && excludes.contains(fNode.getName())) continue;\n            if ((fNode.getModifiers() & ACC_TRANSIENT) != 0) continue;\n            String suffix = suffixForField(fNode);\n            MethodCallExpression readObject = callX(varX(oin), \"read\" + suffix);\n            readObject.setImplicitThis(false);\n            body.addStatement(assignS(varX(fNode), suffix.equals(\"Object\") ? castX(GenericsUtils.nonGeneric(fNode.getType()), readObject) : readObject));\n        }\n        cNode.addMethod(\"readExternal\", ACC_PUBLIC, ClassHelper.VOID_TYPE, params(oin), ClassNode.EMPTY_ARRAY, body);\n    }"
        ],
        [
            "ImmutableASTTransformation::cloneArrayOrCloneableExpr(Expression,ClassNode)",
            " 341 -\n 342  \n 343  \n 344  \n 345  \n 346  \n 347  \n 348  \n 349  \n 350  \n 351  \n 352  ",
            "    private Expression cloneArrayOrCloneableExpr(Expression fieldExpr, ClassNode type) {\n        Expression smce = callX(\n                REFLECTION_INVOKER_TYPE,\n                \"invoke\",\n                args(\n                        fieldExpr,\n                        constX(\"clone\"),\n                        new ArrayExpression(ClassHelper.OBJECT_TYPE.makeArray(), Collections.<Expression>emptyList())\n                )\n        );\n        return castX(type, smce);\n    }",
            " 341 +\n 342  \n 343  \n 344  \n 345  \n 346  \n 347  \n 348  \n 349  \n 350  \n 351  \n 352  ",
            "    private static Expression cloneArrayOrCloneableExpr(Expression fieldExpr, ClassNode type) {\n        Expression smce = callX(\n                REFLECTION_INVOKER_TYPE,\n                \"invoke\",\n                args(\n                        fieldExpr,\n                        constX(\"clone\"),\n                        new ArrayExpression(ClassHelper.OBJECT_TYPE.makeArray(), Collections.<Expression>emptyList())\n                )\n        );\n        return castX(type, smce);\n    }"
        ],
        [
            "IndexedPropertyASTTransformation::getModifiers(FieldNode)",
            " 128 -\n 129  \n 130  \n 131  \n 132  ",
            "    private int getModifiers(FieldNode fNode) {\n        int mods = ACC_PUBLIC;\n        if (fNode.isStatic()) mods |= ACC_STATIC;\n        return mods;\n    }",
            " 128 +\n 129  \n 130  \n 131  \n 132  ",
            "    private static int getModifiers(FieldNode fNode) {\n        int mods = ACC_PUBLIC;\n        if (fNode.isStatic()) mods |= ACC_STATIC;\n        return mods;\n    }"
        ],
        [
            "ImmutableASTTransformation::createGetterBodyDate(FieldNode)",
            " 621 -\n 622  \n 623  \n 624  \n 625  ",
            "    private Statement createGetterBodyDate(FieldNode fNode) {\n        final Expression fieldExpr = varX(fNode);\n        final Expression expression = cloneDateExpr(fieldExpr);\n        return safeExpression(fieldExpr, expression);\n    }",
            " 621 +\n 622  \n 623  \n 624  \n 625  ",
            "    private static Statement createGetterBodyDate(FieldNode fNode) {\n        final Expression fieldExpr = varX(fNode);\n        final Expression expression = cloneDateExpr(fieldExpr);\n        return safeExpression(fieldExpr, expression);\n    }"
        ],
        [
            "SingletonASTTransformation::nonLazyBody(FieldNode)",
            "  84 -\n  85  \n  86  ",
            "    private Statement nonLazyBody(FieldNode fieldNode) {\r\n        return returnS(varX(fieldNode));\r\n    }\r",
            "  84 +\n  85  \n  86  ",
            "    private static Statement nonLazyBody(FieldNode fieldNode) {\r\n        return returnS(varX(fieldNode));\r\n    }\r"
        ],
        [
            "ImmutableASTTransformation::checkFinalArgNotOverridden(ClassNode,FieldNode)",
            " 393 -\n 394  \n 395  \n 396  \n 397  \n 398  \n 399  ",
            "    private Statement checkFinalArgNotOverridden(ClassNode cNode, FieldNode fNode) {\n        final String name = fNode.getName();\n        Expression value = findArg(name);\n        return ifS(\n                notX(equalsNullX(value)),\n                throwS(ctorX(READONLYEXCEPTION_TYPE,\n                        args(constX(name), constX(cNode.getName()))",
            " 393 +\n 394  \n 395  \n 396  \n 397  \n 398  \n 399  ",
            "    private static Statement checkFinalArgNotOverridden(ClassNode cNode, FieldNode fNode) {\n        final String name = fNode.getName();\n        Expression value = findArg(name);\n        return ifS(\n                notX(equalsNullX(value)),\n                throwS(ctorX(READONLYEXCEPTION_TYPE,\n                        args(constX(name), constX(cNode.getName()))"
        ],
        [
            "AutoCloneASTTransformation::callCloneDynamicX(Expression)",
            " 193 -\n 194  \n 195  ",
            "    private Expression callCloneDynamicX(Expression target) {\r\n        return callX(INVOKER_TYPE, \"invokeMethod\", args(target, constX(\"clone\"), ConstantExpression.NULL));\r\n    }\r",
            " 193 +\n 194  \n 195  ",
            "    private static Expression callCloneDynamicX(Expression target) {\r\n        return callX(INVOKER_TYPE, \"invokeMethod\", args(target, constX(\"clone\"), ConstantExpression.NULL));\r\n    }\r"
        ],
        [
            "ExternalizeVerifierASTTransformation::implementsExternalizable(ClassNode)",
            "  89 -\n  90  \n  91  ",
            "    private boolean implementsExternalizable(ClassNode cNode) {\n        return cNode.implementsInterface(EXTERNALIZABLE_TYPE);\n    }",
            "  89 +\n  90  \n  91  ",
            "    private static boolean implementsExternalizable(ClassNode cNode) {\n        return cNode.implementsInterface(EXTERNALIZABLE_TYPE);\n    }"
        ],
        [
            "InheritConstructorsASTTransformation::isExisting(ClassNode,Parameter)",
            " 119 -\n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  ",
            "    private boolean isExisting(ClassNode classNode, Parameter[] params) {\n        for (ConstructorNode consNode : classNode.getDeclaredConstructors()) {\n            if (matchingTypes(params, consNode.getParameters())) {\n                return true;\n            }\n        }\n        return false;\n    }",
            " 119 +\n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  ",
            "    private static boolean isExisting(ClassNode classNode, Parameter[] params) {\n        for (ConstructorNode consNode : classNode.getDeclaredConstructors()) {\n            if (matchingTypes(params, consNode.getParameters())) {\n                return true;\n            }\n        }\n        return false;\n    }"
        ],
        [
            "TraitASTTransformation::generatePropertyMethods(ClassNode)",
            " 296 -\n 297  \n 298  \n 299  \n 300  ",
            "    private void generatePropertyMethods(final ClassNode cNode) {\n        for (PropertyNode node : cNode.getProperties()) {\n            processProperty(cNode, node);\n        }\n    }",
            " 296 +\n 297  \n 298  \n 299  \n 300  ",
            "    private static void generatePropertyMethods(final ClassNode cNode) {\n        for (PropertyNode node : cNode.getProperties()) {\n            processProperty(cNode, node);\n        }\n    }"
        ],
        [
            "NewifyASTTransformation::internalError(String)",
            " 309 -\n 310  \n 311  ",
            "    private void internalError(String message) {\n        throw new GroovyBugError(\"Internal error: \" + message);\n    }",
            " 309 +\n 310  \n 311  ",
            "    private static void internalError(String message) {\n        throw new GroovyBugError(\"Internal error: \" + message);\n    }"
        ],
        [
            "NewifyASTTransformation::isNewMethodStyle(MethodCallExpression)",
            " 274 -\n 275  \n 276  \n 277  \n 278  \n 279  ",
            "    private boolean isNewMethodStyle(MethodCallExpression mce) {\n        final Expression obj = mce.getObjectExpression();\n        final Expression meth = mce.getMethod();\n        return (obj instanceof ClassExpression && meth instanceof ConstantExpression\n                && ((ConstantExpression) meth).getValue().equals(\"new\"));\n    }",
            " 274 +\n 275  \n 276  \n 277  \n 278  \n 279  ",
            "    private static boolean isNewMethodStyle(MethodCallExpression mce) {\n        final Expression obj = mce.getObjectExpression();\n        final Expression meth = mce.getMethod();\n        return (obj instanceof ClassExpression && meth instanceof ConstantExpression\n                && ((ConstantExpression) meth).getValue().equals(\"new\"));\n    }"
        ],
        [
            "IndexedPropertyASTTransformation::addArrayGetter(FieldNode)",
            "  93 -\n  94  \n  95  ",
            "    private void addArrayGetter(FieldNode fNode) {\n        addGetter(fNode, fNode.getType().getComponentType());\n    }",
            "  93 +\n  94  \n  95  ",
            "    private static void addArrayGetter(FieldNode fNode) {\n        addGetter(fNode, fNode.getType().getComponentType());\n    }"
        ],
        [
            "ExternalizeMethodsASTTransformation::createWriteExternal(ClassNode,List,List)",
            "  89 -\n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  ",
            "    private void createWriteExternal(ClassNode cNode, List<String> excludes, List<FieldNode> list) {\n        final BlockStatement body = new BlockStatement();\n        Parameter out = param(OBJECTOUTPUT_TYPE, \"out\");\n        for (FieldNode fNode : list) {\n            if (excludes != null && excludes.contains(fNode.getName())) continue;\n            if ((fNode.getModifiers() & ACC_TRANSIENT) != 0) continue;\n            MethodCallExpression writeObject = callX(varX(out), \"write\" + suffixForField(fNode), varX(fNode));\n            writeObject.setImplicitThis(false);\n            body.addStatement(stmt(writeObject));\n        }\n        ClassNode[] exceptions = {make(IOException.class)};\n        cNode.addMethod(\"writeExternal\", ACC_PUBLIC, ClassHelper.VOID_TYPE, params(out), exceptions, body);\n    }",
            "  88 +\n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  ",
            "    private static void createWriteExternal(ClassNode cNode, List<String> excludes, List<FieldNode> list) {\n        final BlockStatement body = new BlockStatement();\n        Parameter out = param(OBJECTOUTPUT_TYPE, \"out\");\n        for (FieldNode fNode : list) {\n            if (excludes != null && excludes.contains(fNode.getName())) continue;\n            if ((fNode.getModifiers() & ACC_TRANSIENT) != 0) continue;\n            MethodCallExpression writeObject = callX(varX(out), \"write\" + suffixForField(fNode), varX(fNode));\n            writeObject.setImplicitThis(false);\n            body.addStatement(stmt(writeObject));\n        }\n        ClassNode[] exceptions = {make(IOException.class)};\n        cNode.addMethod(\"writeExternal\", ACC_PUBLIC, ClassHelper.VOID_TYPE, params(out), exceptions, body);\n    }"
        ],
        [
            "InheritConstructorsASTTransformation::matchingTypes(Parameter,Parameter)",
            " 128 -\n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  ",
            "    private boolean matchingTypes(Parameter[] params, Parameter[] existingParams) {\n        if (params.length != existingParams.length) return false;\n        for (int i = 0; i < params.length; i++) {\n            if (!params[i].getType().equals(existingParams[i].getType())) {\n                return false;\n            }\n        }\n        return true;\n    }",
            " 128 +\n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  ",
            "    private static boolean matchingTypes(Parameter[] params, Parameter[] existingParams) {\n        if (params.length != existingParams.length) return false;\n        for (int i = 0; i < params.length; i++) {\n            if (!params[i].getType().equals(existingParams[i].getType())) {\n                return false;\n            }\n        }\n        return true;\n    }"
        ],
        [
            "AutoCloneASTTransformation::possiblyCloneable(ClassNode)",
            " 189 -\n 190  \n 191  ",
            "    private boolean possiblyCloneable(ClassNode type) {\r\n        return !isPrimitiveType(type) && ((isCloneableType(type) || (type.getModifiers() & ACC_FINAL) == 0));\r\n    }\r",
            " 189 +\n 190  \n 191  ",
            "    private static boolean possiblyCloneable(ClassNode type) {\r\n        return !isPrimitiveType(type) && ((isCloneableType(type) || (type.getModifiers() & ACC_FINAL) == 0));\r\n    }\r"
        ],
        [
            "AutoCloneASTTransformation::createCloneCopyConstructor(ClassNode,List,List)",
            " 140 -\n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  ",
            "    private void createCloneCopyConstructor(ClassNode cNode, List<FieldNode> list, List<String> excludes) {\r\n        if (cNode.getDeclaredConstructors().isEmpty()) {\n            // add no-arg constructor\r\n            BlockStatement noArgBody = new BlockStatement();\r\n            noArgBody.addStatement(EmptyStatement.INSTANCE);\r\n            cNode.addConstructor(ACC_PUBLIC, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, noArgBody);\r\n        }\r\n        boolean hasThisCons = false;\r\n        for (ConstructorNode consNode : cNode.getDeclaredConstructors()) {\r\n            Parameter[] parameters = consNode.getParameters();\r\n            if (parameters.length == 1 && parameters[0].getType().equals(cNode)) {\r\n                hasThisCons = true;\r\n            }\r\n        }\r\n        if (!hasThisCons) {\r\n            BlockStatement initBody = new BlockStatement();\r\n            Parameter initParam = param(GenericsUtils.nonGeneric(cNode), \"other\");\r\n            final Expression other = varX(initParam);\r\n            boolean hasParent = cNode.getSuperClass() != ClassHelper.OBJECT_TYPE;\r\n            if (hasParent) {\r\n                initBody.addStatement(stmt(ctorX(ClassNode.SUPER, other)));\r\n            }\r\n            for (FieldNode fieldNode : list) {\r\n                String name = fieldNode.getName();\r\n                if (excludes != null && excludes.contains(name)) continue;\r\n                ClassNode fieldType = fieldNode.getType();\r\n                Expression direct = propX(other, name);\r\n                Expression to = propX(varX(\"this\"), name);\r\n                Statement assignDirect = assignS(to, direct);\r\n                Statement assignCloned = assignS(to, castX(fieldType, callCloneDirectX(direct)));\r\n                Statement assignClonedDynamic = assignS(to, castX(fieldType, callCloneDynamicX(direct)));\r\n                if (isCloneableType(fieldType)) {\r\n                    initBody.addStatement(assignCloned);\r\n                } else if (!possiblyCloneable(fieldType)) {\r\n                    initBody.addStatement(assignDirect);\r\n                } else {\r\n                    initBody.addStatement(ifElseS(isInstanceOfX(direct, CLONEABLE_TYPE), assignClonedDynamic, assignDirect));\r\n                }\r\n            }\r\n            cNode.addConstructor(ACC_PROTECTED, params(initParam), ClassNode.EMPTY_ARRAY, initBody);\r\n        }\r\n        ClassNode[] exceptions = {make(CloneNotSupportedException.class)};\r\n        cNode.addMethod(\"clone\", ACC_PUBLIC, GenericsUtils.nonGeneric(cNode), Parameter.EMPTY_ARRAY, exceptions, block(stmt(ctorX(cNode, args(varX(\"this\"))))));\r\n    }\r",
            " 140 +\n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  ",
            "    private static void createCloneCopyConstructor(ClassNode cNode, List<FieldNode> list, List<String> excludes) {\r\n        if (cNode.getDeclaredConstructors().isEmpty()) {\n            // add no-arg constructor\r\n            BlockStatement noArgBody = new BlockStatement();\r\n            noArgBody.addStatement(EmptyStatement.INSTANCE);\r\n            cNode.addConstructor(ACC_PUBLIC, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, noArgBody);\r\n        }\r\n        boolean hasThisCons = false;\r\n        for (ConstructorNode consNode : cNode.getDeclaredConstructors()) {\r\n            Parameter[] parameters = consNode.getParameters();\r\n            if (parameters.length == 1 && parameters[0].getType().equals(cNode)) {\r\n                hasThisCons = true;\r\n            }\r\n        }\r\n        if (!hasThisCons) {\r\n            BlockStatement initBody = new BlockStatement();\r\n            Parameter initParam = param(GenericsUtils.nonGeneric(cNode), \"other\");\r\n            final Expression other = varX(initParam);\r\n            boolean hasParent = cNode.getSuperClass() != ClassHelper.OBJECT_TYPE;\r\n            if (hasParent) {\r\n                initBody.addStatement(stmt(ctorX(ClassNode.SUPER, other)));\r\n            }\r\n            for (FieldNode fieldNode : list) {\r\n                String name = fieldNode.getName();\r\n                if (excludes != null && excludes.contains(name)) continue;\r\n                ClassNode fieldType = fieldNode.getType();\r\n                Expression direct = propX(other, name);\r\n                Expression to = propX(varX(\"this\"), name);\r\n                Statement assignDirect = assignS(to, direct);\r\n                Statement assignCloned = assignS(to, castX(fieldType, callCloneDirectX(direct)));\r\n                Statement assignClonedDynamic = assignS(to, castX(fieldType, callCloneDynamicX(direct)));\r\n                if (isCloneableType(fieldType)) {\r\n                    initBody.addStatement(assignCloned);\r\n                } else if (!possiblyCloneable(fieldType)) {\r\n                    initBody.addStatement(assignDirect);\r\n                } else {\r\n                    initBody.addStatement(ifElseS(isInstanceOfX(direct, CLONEABLE_TYPE), assignClonedDynamic, assignDirect));\r\n                }\r\n            }\r\n            cNode.addConstructor(ACC_PROTECTED, params(initParam), ClassNode.EMPTY_ARRAY, initBody);\r\n        }\r\n        ClassNode[] exceptions = {make(CloneNotSupportedException.class)};\r\n        cNode.addMethod(\"clone\", ACC_PUBLIC, GenericsUtils.nonGeneric(cNode), Parameter.EMPTY_ARRAY, exceptions, block(stmt(ctorX(cNode, args(varX(\"this\"))))));\r\n    }\r"
        ],
        [
            "IndexedPropertyASTTransformation::makeName(FieldNode,String)",
            " 134 -\n 135  \n 136  ",
            "    private String makeName(FieldNode fNode, String prefix) {\n        return prefix + MetaClassHelper.capitalize(fNode.getName());\n    }",
            " 134 +\n 135  \n 136  ",
            "    private static String makeName(FieldNode fNode, String prefix) {\n        return prefix + MetaClassHelper.capitalize(fNode.getName());\n    }"
        ],
        [
            "ImmutableASTTransformation::createConstructorStatementGuarded(ClassNode,FieldNode)",
            " 486 -\n 487  \n 488  \n 489  \n 490  \n 491  \n 492  \n 493  \n 494  \n 495  \n 496  \n 497  ",
            "    private Statement createConstructorStatementGuarded(ClassNode cNode, FieldNode fNode) {\n        final Expression fieldExpr = varX(fNode);\n        Expression initExpr = fNode.getInitialValueExpression();\n        final Statement assignInit;\n        if (initExpr == null || (initExpr instanceof ConstantExpression && ((ConstantExpression)initExpr).isNullExpression())) {\n            assignInit = assignS(fieldExpr, ConstantExpression.EMPTY_EXPRESSION);\n        } else {\n            assignInit = assignS(fieldExpr, checkUnresolved(fNode, initExpr));\n        }\n        Expression unknown = findArg(fNode.getName());\n        return ifElseS(equalsNullX(unknown), assignInit, assignS(fieldExpr, checkUnresolved(fNode, unknown)));\n    }",
            " 486 +\n 487  \n 488  \n 489  \n 490  \n 491  \n 492  \n 493  \n 494  \n 495  \n 496  \n 497  ",
            "    private static Statement createConstructorStatementGuarded(ClassNode cNode, FieldNode fNode) {\n        final Expression fieldExpr = varX(fNode);\n        Expression initExpr = fNode.getInitialValueExpression();\n        final Statement assignInit;\n        if (initExpr == null || (initExpr instanceof ConstantExpression && ((ConstantExpression)initExpr).isNullExpression())) {\n            assignInit = assignS(fieldExpr, ConstantExpression.EMPTY_EXPRESSION);\n        } else {\n            assignInit = assignS(fieldExpr, checkUnresolved(fNode, initExpr));\n        }\n        Expression unknown = findArg(fNode.getName());\n        return ifElseS(equalsNullX(unknown), assignInit, assignS(fieldExpr, checkUnresolved(fNode, unknown)));\n    }"
        ],
        [
            "TraitASTTransformation::createSelfParameter(ClassNode,boolean)",
            " 497 -\n 498  \n 499  \n 500  \n 501  ",
            "    private Parameter createSelfParameter(final ClassNode traitClass, boolean isStatic) {\n        final ClassNode rawType = traitClass.getPlainNodeReference();\n        ClassNode type = createReceiverType(isStatic, rawType);\n        return new Parameter(type, isStatic?Traits.STATIC_THIS_OBJECT:Traits.THIS_OBJECT);\n    }",
            " 497 +\n 498  \n 499  \n 500  \n 501  ",
            "    private static Parameter createSelfParameter(final ClassNode traitClass, boolean isStatic) {\n        final ClassNode rawType = traitClass.getPlainNodeReference();\n        ClassNode type = createReceiverType(isStatic, rawType);\n        return new Parameter(type, isStatic?Traits.STATIC_THIS_OBJECT:Traits.THIS_OBJECT);\n    }"
        ],
        [
            "ImmutableASTTransformation::createCopyWith(ClassNode,List)",
            " 689 -\n 690  \n 691  \n 692  \n 693  \n 694  \n 695  \n 696  \n 697  \n 698  \n 699  \n 700  \n 701  \n 702  \n 703  \n 704  \n 705  \n 706  \n 707  \n 708  \n 709  \n 710  \n 711  \n 712  \n 713  \n 714  \n 715  \n 716  \n 717  \n 718  \n 719  \n 720  ",
            "    private void createCopyWith(final ClassNode cNode, final List<PropertyNode> pList) {\n        BlockStatement body = new BlockStatement();\n        body.addStatement(ifS(\n                orX(\n                        equalsNullX(varX(\"map\", ClassHelper.MAP_TYPE)),\n                        eqX(callX(varX(\"map\", HASHMAP_TYPE), \"size\"), constX(0))\n                ),\n                returnS(varX(\"this\", cNode))\n        ));\n        body.addStatement(declS(varX(\"dirty\", ClassHelper.boolean_TYPE), ConstantExpression.PRIM_FALSE));\n        body.addStatement(declS(varX(\"construct\", HASHMAP_TYPE), ctorX(HASHMAP_TYPE)));\n\n        // Check for each property\n        for (final PropertyNode pNode : pList) {\n            body.addStatement(createCheckForProperty(pNode));\n        }\n\n        body.addStatement(returnS(ternaryX(\n                isTrueX(varX(\"dirty\", ClassHelper.boolean_TYPE)),\n                ctorX(cNode, args(varX(\"construct\", HASHMAP_TYPE))),\n                varX(\"this\", cNode)\n        )));\n\n        final ClassNode clonedNode = cNode.getPlainNodeReference();\n\n        cNode.addMethod(COPY_WITH_METHOD,\n                ACC_PUBLIC | ACC_FINAL,\n                clonedNode,\n                params(new Parameter(new ClassNode(Map.class), \"map\")),\n                null,\n                body);\n    }",
            " 689 +\n 690  \n 691  \n 692  \n 693  \n 694  \n 695  \n 696  \n 697  \n 698  \n 699  \n 700  \n 701  \n 702  \n 703  \n 704  \n 705  \n 706  \n 707  \n 708  \n 709  \n 710  \n 711  \n 712  \n 713  \n 714  \n 715  \n 716  \n 717  \n 718  \n 719  \n 720  ",
            "    private static void createCopyWith(final ClassNode cNode, final List<PropertyNode> pList) {\n        BlockStatement body = new BlockStatement();\n        body.addStatement(ifS(\n                orX(\n                        equalsNullX(varX(\"map\", ClassHelper.MAP_TYPE)),\n                        eqX(callX(varX(\"map\", HASHMAP_TYPE), \"size\"), constX(0))\n                ),\n                returnS(varX(\"this\", cNode))\n        ));\n        body.addStatement(declS(varX(\"dirty\", ClassHelper.boolean_TYPE), ConstantExpression.PRIM_FALSE));\n        body.addStatement(declS(varX(\"construct\", HASHMAP_TYPE), ctorX(HASHMAP_TYPE)));\n\n        // Check for each property\n        for (final PropertyNode pNode : pList) {\n            body.addStatement(createCheckForProperty(pNode));\n        }\n\n        body.addStatement(returnS(ternaryX(\n                isTrueX(varX(\"dirty\", ClassHelper.boolean_TYPE)),\n                ctorX(cNode, args(varX(\"construct\", HASHMAP_TYPE))),\n                varX(\"this\", cNode)\n        )));\n\n        final ClassNode clonedNode = cNode.getPlainNodeReference();\n\n        cNode.addMethod(COPY_WITH_METHOD,\n                ACC_PUBLIC | ACC_FINAL,\n                clonedNode,\n                params(new Parameter(new ClassNode(Map.class), \"map\")),\n                null,\n                body);\n    }"
        ],
        [
            "IndexedPropertyASTTransformation::addArraySetter(FieldNode)",
            "  97 -\n  98  \n  99  ",
            "    private void addArraySetter(FieldNode fNode) {\n        addSetter(fNode, fNode.getType().getComponentType());\n    }",
            "  97 +\n  98  \n  99  ",
            "    private static void addArraySetter(FieldNode fNode) {\n        addSetter(fNode, fNode.getType().getComponentType());\n    }"
        ],
        [
            "AutoCloneASTTransformation::callCloneDirectX(Expression)",
            " 197 -\n 198  \n 199  ",
            "    private Expression callCloneDirectX(Expression direct) {\r\n        return ternaryX(equalsNullX(direct), ConstantExpression.NULL, callX(direct, \"clone\"));\r\n    }\r",
            " 197 +\n 198  \n 199  ",
            "    private static Expression callCloneDirectX(Expression direct) {\r\n        return ternaryX(equalsNullX(direct), ConstantExpression.NULL, callX(direct, \"clone\"));\r\n    }\r"
        ],
        [
            "ASTTransformationCollectorCodeVisitor::mergeCollectedAnnotations(AnnotationCollectorMode,Map,List)",
            " 124 -\n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  ",
            "    private void mergeCollectedAnnotations(AnnotationCollectorMode mode, Map<Integer, List<AnnotationNode>> existing, List<AnnotationNode> replacements) {\n        switch(mode) {\n            case PREFER_COLLECTOR:\n                deleteExisting(false, existing, replacements);\n                break;\n            case PREFER_COLLECTOR_MERGED:\n                deleteExisting(true, existing, replacements);\n                break;\n            case PREFER_EXPLICIT:\n                deleteReplacement(false, existing, replacements);\n                break;\n            case PREFER_EXPLICIT_MERGED:\n                deleteReplacement(true, existing, replacements);\n                break;",
            " 124 +\n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  ",
            "    private static void mergeCollectedAnnotations(AnnotationCollectorMode mode, Map<Integer, List<AnnotationNode>> existing, List<AnnotationNode> replacements) {\n        switch(mode) {\n            case PREFER_COLLECTOR:\n                deleteExisting(false, existing, replacements);\n                break;\n            case PREFER_COLLECTOR_MERGED:\n                deleteExisting(true, existing, replacements);\n                break;\n            case PREFER_EXPLICIT:\n                deleteReplacement(false, existing, replacements);\n                break;\n            case PREFER_EXPLICIT_MERGED:\n                deleteReplacement(true, existing, replacements);\n                break;"
        ],
        [
            "ImmutableASTTransformation::isKnownImmutableClass(ClassNode,List)",
            " 525 -\n 526  \n 527  \n 528  \n 529  \n 530  \n 531  \n 532  \n 533  ",
            "    private boolean isKnownImmutableClass(ClassNode fieldType, List<String> knownImmutableClasses) {\n        if (inImmutableList(fieldType.getName()) || knownImmutableClasses.contains(fieldType.getName()))\n            return true;\n        if (!fieldType.isResolved())\n            return false;\n        return fieldType.isEnum() ||\n                ClassHelper.isPrimitiveType(fieldType) ||\n                !fieldType.getAnnotations(MY_TYPE).isEmpty();\n    }",
            " 525 +\n 526  \n 527  \n 528  \n 529  \n 530  \n 531  \n 532  \n 533  ",
            "    private static boolean isKnownImmutableClass(ClassNode fieldType, List<String> knownImmutableClasses) {\n        if (inImmutableList(fieldType.getName()) || knownImmutableClasses.contains(fieldType.getName()))\n            return true;\n        if (!fieldType.isResolved())\n            return false;\n        return fieldType.isEnum() ||\n                ClassHelper.isPrimitiveType(fieldType) ||\n                !fieldType.getAnnotations(MY_TYPE).isEmpty();\n    }"
        ],
        [
            "ASTTransformationCollectorCodeVisitor::getMode(AnnotationNode)",
            " 244 -\n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  ",
            "    private AnnotationCollectorMode getMode(AnnotationNode node) {\n        final Expression member = node.getMember(\"mode\");\n        if (member != null && member instanceof PropertyExpression) {\n            PropertyExpression prop = (PropertyExpression) member;\n            Expression oe = prop.getObjectExpression();\n            if (oe instanceof ClassExpression) {\n                ClassExpression ce = (ClassExpression) oe;\n                if (ce.getType().getName().equals(\"groovy.transform.AnnotationCollectorMode\")) {\n                    return AnnotationCollectorMode.valueOf(prop.getPropertyAsString());\n                }\n            }\n        }\n        return null;\n    }",
            " 244 +\n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  ",
            "    private static AnnotationCollectorMode getMode(AnnotationNode node) {\n        final Expression member = node.getMember(\"mode\");\n        if (member != null && member instanceof PropertyExpression) {\n            PropertyExpression prop = (PropertyExpression) member;\n            Expression oe = prop.getObjectExpression();\n            if (oe instanceof ClassExpression) {\n                ClassExpression ce = (ClassExpression) oe;\n                if (ce.getType().getName().equals(\"groovy.transform.AnnotationCollectorMode\")) {\n                    return AnnotationCollectorMode.valueOf(prop.getPropertyAsString());\n                }\n            }\n        }\n        return null;\n    }"
        ],
        [
            "TraitASTTransformation::generateMethodsWithDefaultArgs(ClassNode)",
            " 108 -\n 109  \n 110  \n 111  ",
            "    private void generateMethodsWithDefaultArgs(final ClassNode cNode) {\n        DefaultArgsMethodsAdder adder = new DefaultArgsMethodsAdder();\n        adder.addDefaultParameterMethods(cNode);\n    }",
            " 108 +\n 109  \n 110  \n 111  ",
            "    private static void generateMethodsWithDefaultArgs(final ClassNode cNode) {\n        DefaultArgsMethodsAdder adder = new DefaultArgsMethodsAdder();\n        adder.addDefaultParameterMethods(cNode);\n    }"
        ],
        [
            "ASTTransformationCollectorCodeVisitor::deleteReplacement(boolean,Map,List)",
            " 162 -\n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  ",
            "    private void deleteReplacement(boolean mergeParams, Map<Integer, List<AnnotationNode>> existingMap, List<AnnotationNode> replacements) {\n        Iterator<AnnotationNode> nodeIterator = replacements.iterator();\n        while (nodeIterator.hasNext()) {\n            boolean remove = false;\n            AnnotationNode replacement = nodeIterator.next();\n            for (Integer key : existingMap.keySet()) {\n                for (AnnotationNode existing : existingMap.get(key)) {\n                    if (replacement.getClassNode().getName().equals(existing.getClassNode().getName())) {\n                        if (mergeParams) {\n                            mergeParameters(existing, replacement);\n                        }\n                        remove = true;\n                    }\n                }\n            }\n            if (remove) {\n                nodeIterator.remove();\n            }\n        }\n    }",
            " 162 +\n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  ",
            "    private static void deleteReplacement(boolean mergeParams, Map<Integer, List<AnnotationNode>> existingMap, List<AnnotationNode> replacements) {\n        Iterator<AnnotationNode> nodeIterator = replacements.iterator();\n        while (nodeIterator.hasNext()) {\n            boolean remove = false;\n            AnnotationNode replacement = nodeIterator.next();\n            for (Integer key : existingMap.keySet()) {\n                for (AnnotationNode existing : existingMap.get(key)) {\n                    if (replacement.getClassNode().getName().equals(existing.getClassNode().getName())) {\n                        if (mergeParams) {\n                            mergeParameters(existing, replacement);\n                        }\n                        remove = true;\n                    }\n                }\n            }\n            if (remove) {\n                nodeIterator.remove();\n            }\n        }\n    }"
        ],
        [
            "PackageScopeASTTransformation::visitFieldNode(FieldNode)",
            " 137 -\n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  ",
            "    private void visitFieldNode(FieldNode fNode) {\n        final ClassNode cNode = fNode.getDeclaringClass();\n        final List<PropertyNode> pList = cNode.getProperties();\n        PropertyNode foundProp = null;\n        for (PropertyNode pNode : pList) {\n            if (pNode.getName().equals(fNode.getName())) {\n                foundProp = pNode;\n                break;\n            }\n        }\n        if (foundProp != null) {\n            revertVisibility(fNode);\n            pList.remove(foundProp);\n        }\n    }",
            " 137 +\n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  ",
            "    private static void visitFieldNode(FieldNode fNode) {\n        final ClassNode cNode = fNode.getDeclaringClass();\n        final List<PropertyNode> pList = cNode.getProperties();\n        PropertyNode foundProp = null;\n        for (PropertyNode pNode : pList) {\n            if (pNode.getName().equals(fNode.getName())) {\n                foundProp = pNode;\n                break;\n            }\n        }\n        if (foundProp != null) {\n            revertVisibility(fNode);\n            pList.remove(foundProp);\n        }\n    }"
        ],
        [
            "CategoryASTTransformation::ensureNoInstanceFieldOrProperty(SourceUnit,ClassNode)",
            " 247 -\n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  ",
            "    private boolean ensureNoInstanceFieldOrProperty(final SourceUnit source, final ClassNode parent) {\r\n        boolean valid = true;\r\n        for (FieldNode fieldNode : parent.getFields()) {\r\n            if (!fieldNode.isStatic() && fieldNode.getLineNumber()>0) {\r\n                // if <0, probably an AST transform or internal code (like generated metaclass field, ...)\r\n                addUnsupportedError(fieldNode,  source);\r\n                valid = false;\r\n            }\r\n        }\r\n        for (PropertyNode propertyNode : parent.getProperties()) {\r\n            if (!propertyNode.isStatic() && propertyNode.getLineNumber()>0) {\r\n                // if <0, probably an AST transform or internal code (like generated metaclass field, ...)\r\n                addUnsupportedError(propertyNode, source);\r\n                valid = false;\r\n            }\r\n        }\r\n        return valid;\r\n    }\r",
            " 247 +\n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  ",
            "    private static boolean ensureNoInstanceFieldOrProperty(final SourceUnit source, final ClassNode parent) {\r\n        boolean valid = true;\r\n        for (FieldNode fieldNode : parent.getFields()) {\r\n            if (!fieldNode.isStatic() && fieldNode.getLineNumber()>0) {\r\n                // if <0, probably an AST transform or internal code (like generated metaclass field, ...)\r\n                addUnsupportedError(fieldNode,  source);\r\n                valid = false;\r\n            }\r\n        }\r\n        for (PropertyNode propertyNode : parent.getProperties()) {\r\n            if (!propertyNode.isStatic() && propertyNode.getLineNumber()>0) {\r\n                // if <0, probably an AST transform or internal code (like generated metaclass field, ...)\r\n                addUnsupportedError(propertyNode, source);\r\n                valid = false;\r\n            }\r\n        }\r\n        return valid;\r\n    }\r"
        ],
        [
            "LogASTTransformation::createLoggingStrategy(AnnotationNode,GroovyClassLoader)",
            " 181 -\n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  ",
            "    private LoggingStrategy createLoggingStrategy(AnnotationNode logAnnotation, GroovyClassLoader loader) {\n\n        String annotationName = logAnnotation.getClassNode().getName();\n\n        Class annotationClass;\n        try {\n            annotationClass = Class.forName(annotationName, false, loader);\n        } catch (Throwable e) {\n            throw new RuntimeException(\"Could not resolve class named \" + annotationName);\n        }\n\n        Method annotationMethod;\n        try {\n            annotationMethod = annotationClass.getDeclaredMethod(\"loggingStrategy\", (Class[]) null);\n        } catch (Throwable e) {\n            throw new RuntimeException(\"Could not find method named loggingStrategy on class named \" + annotationName);\n        }\n\n        Object defaultValue;\n        try {\n            defaultValue = annotationMethod.getDefaultValue();\n        } catch (Throwable e) {\n            throw new RuntimeException(\"Could not find default value of method named loggingStrategy on class named \" + annotationName);\n        }\n\n        if (!LoggingStrategy.class.isAssignableFrom((Class) defaultValue)) {\n            throw new RuntimeException(\"Default loggingStrategy value on class named \" + annotationName + \" is not a LoggingStrategy\");\n        }\n\n        try {\n            Class<? extends LoggingStrategy> strategyClass = (Class<? extends LoggingStrategy>) defaultValue;\n            if (AbstractLoggingStrategy.class.isAssignableFrom(strategyClass)) {\n                return DefaultGroovyMethods.newInstance(strategyClass, new Object[]{loader});\n            } else {\n                return strategyClass.newInstance();\n            }\n        } catch (Exception e) {\n            return null;\n        }\n    }",
            " 181 +\n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  ",
            "    private static LoggingStrategy createLoggingStrategy(AnnotationNode logAnnotation, GroovyClassLoader loader) {\n\n        String annotationName = logAnnotation.getClassNode().getName();\n\n        Class annotationClass;\n        try {\n            annotationClass = Class.forName(annotationName, false, loader);\n        } catch (Throwable e) {\n            throw new RuntimeException(\"Could not resolve class named \" + annotationName);\n        }\n\n        Method annotationMethod;\n        try {\n            annotationMethod = annotationClass.getDeclaredMethod(\"loggingStrategy\", (Class[]) null);\n        } catch (Throwable e) {\n            throw new RuntimeException(\"Could not find method named loggingStrategy on class named \" + annotationName);\n        }\n\n        Object defaultValue;\n        try {\n            defaultValue = annotationMethod.getDefaultValue();\n        } catch (Throwable e) {\n            throw new RuntimeException(\"Could not find default value of method named loggingStrategy on class named \" + annotationName);\n        }\n\n        if (!LoggingStrategy.class.isAssignableFrom((Class) defaultValue)) {\n            throw new RuntimeException(\"Default loggingStrategy value on class named \" + annotationName + \" is not a LoggingStrategy\");\n        }\n\n        try {\n            Class<? extends LoggingStrategy> strategyClass = (Class<? extends LoggingStrategy>) defaultValue;\n            if (AbstractLoggingStrategy.class.isAssignableFrom(strategyClass)) {\n                return DefaultGroovyMethods.newInstance(strategyClass, new Object[]{loader});\n            } else {\n                return strategyClass.newInstance();\n            }\n        } catch (Exception e) {\n            return null;\n        }\n    }"
        ],
        [
            "DelegateASTTransformation::clashesWithOtherParams(String,Parameter,int)",
            " 295 -\n 296  \n 297  \n 298  \n 299  \n 300  \n 301  ",
            "    private boolean clashesWithOtherParams(String name, Parameter[] params, int i) {\n        for (int j = 0; j < params.length; j++) {\n            if (i == j) continue;\n            if (params[j].getName().equals(name)) return true;\n        }\n        return false;\n    }",
            " 295 +\n 296  \n 297  \n 298  \n 299  \n 300  \n 301  ",
            "    private static boolean clashesWithOtherParams(String name, Parameter[] params, int i) {\n        for (int j = 0; j < params.length; j++) {\n            if (i == j) continue;\n            if (params[j].getName().equals(name)) return true;\n        }\n        return false;\n    }"
        ],
        [
            "TraitASTTransformation::createInitMethod(boolean,ClassNode,ClassNode)",
            " 236 -\n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  ",
            "    private MethodNode createInitMethod(final boolean isStatic, final ClassNode cNode, final ClassNode helper) {\n        MethodNode initializer = new MethodNode(\n                isStatic?Traits.STATIC_INIT_METHOD:Traits.INIT_METHOD,\n                ACC_STATIC | ACC_PUBLIC | ACC_SYNTHETIC,\n                ClassHelper.VOID_TYPE,\n                new Parameter[]{createSelfParameter(cNode, isStatic)},\n                ClassNode.EMPTY_ARRAY,\n                new BlockStatement()\n        );\n        helper.addMethod(initializer);\n\n        // Cannot add static compilation of init method because of GROOVY-7217, see example 2 of test case\n        //AnnotationNode an = new AnnotationNode(TraitComposer.COMPILESTATIC_CLASSNODE);\n        //initializer.addAnnotation(an);\n        //cNode.addTransform(StaticCompileTransformation.class, an);\n\n        return initializer;\n    }",
            " 236 +\n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  ",
            "    private static MethodNode createInitMethod(final boolean isStatic, final ClassNode cNode, final ClassNode helper) {\n        MethodNode initializer = new MethodNode(\n                isStatic?Traits.STATIC_INIT_METHOD:Traits.INIT_METHOD,\n                ACC_STATIC | ACC_PUBLIC | ACC_SYNTHETIC,\n                ClassHelper.VOID_TYPE,\n                new Parameter[]{createSelfParameter(cNode, isStatic)},\n                ClassNode.EMPTY_ARRAY,\n                new BlockStatement()\n        );\n        helper.addMethod(initializer);\n\n        // Cannot add static compilation of init method because of GROOVY-7217, see example 2 of test case\n        //AnnotationNode an = new AnnotationNode(TraitComposer.COMPILESTATIC_CLASSNODE);\n        //initializer.addAnnotation(an);\n        //cNode.addTransform(StaticCompileTransformation.class, an);\n\n        return initializer;\n    }"
        ],
        [
            "ImmutableASTTransformation::cloneCollectionExpr(Expression,ClassNode)",
            " 320 -\n 321  \n 322  \n 323  \n 324  \n 325  \n 326  ",
            "    private Expression cloneCollectionExpr(Expression fieldExpr, ClassNode type) {\n        return castX(type, createIfInstanceOfAsImmutableS(fieldExpr, SORTEDSET_CLASSNODE,\n                createIfInstanceOfAsImmutableS(fieldExpr, SORTEDMAP_CLASSNODE,\n                        createIfInstanceOfAsImmutableS(fieldExpr, SET_CLASSNODE,\n                                createIfInstanceOfAsImmutableS(fieldExpr, MAP_CLASSNODE,\n                                        createIfInstanceOfAsImmutableS(fieldExpr, ClassHelper.LIST_TYPE,\n                                                createAsImmutableX(fieldExpr, COLLECTION_TYPE))",
            " 320 +\n 321  \n 322  \n 323  \n 324  \n 325  \n 326  ",
            "    private static Expression cloneCollectionExpr(Expression fieldExpr, ClassNode type) {\n        return castX(type, createIfInstanceOfAsImmutableS(fieldExpr, SORTEDSET_CLASSNODE,\n                createIfInstanceOfAsImmutableS(fieldExpr, SORTEDMAP_CLASSNODE,\n                        createIfInstanceOfAsImmutableS(fieldExpr, SET_CLASSNODE,\n                                createIfInstanceOfAsImmutableS(fieldExpr, MAP_CLASSNODE,\n                                        createIfInstanceOfAsImmutableS(fieldExpr, ClassHelper.LIST_TYPE,\n                                                createAsImmutableX(fieldExpr, COLLECTION_TYPE))"
        ],
        [
            "ExternalizeVerifierASTTransformation::implementsSerializable(ClassNode)",
            "  93 -\n  94  \n  95  ",
            "    private boolean implementsSerializable(ClassNode cNode) {\n        return cNode.implementsInterface(SERIALIZABLE_TYPE);\n    }",
            "  93 +\n  94  \n  95  ",
            "    private static boolean implementsSerializable(ClassNode cNode) {\n        return cNode.implementsInterface(SERIALIZABLE_TYPE);\n    }"
        ],
        [
            "ImmutableASTTransformation::createAsImmutableX(Expression,ClassNode)",
            " 337 -\n 338  \n 339  ",
            "    private Expression createAsImmutableX(final Expression expr, final ClassNode type) {\n        return callX(DGM_TYPE, \"asImmutable\", castX(type, expr));\n    }",
            " 337 +\n 338  \n 339  ",
            "    private static Expression createAsImmutableX(final Expression expr, final ClassNode type) {\n        return callX(DGM_TYPE, \"asImmutable\", castX(type, expr));\n    }"
        ],
        [
            "DelegateASTTransformation::addGetterIfNeeded(FieldNode,ClassNode,PropertyNode,String,List,List)",
            " 173 -\n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  ",
            "    private void addGetterIfNeeded(FieldNode fieldNode, ClassNode owner, PropertyNode prop, String name, List<String> includes, List<String> excludes) {\n        String getterName = \"get\" + Verifier.capitalize(name);\n        if (owner.getGetterMethod(getterName) == null\n                && !shouldSkipPropertyMethod(name, getterName, excludes, includes)) {\n            owner.addMethod(getterName,\n                    ACC_PUBLIC,\n                    GenericsUtils.nonGeneric(prop.getType()),\n                    Parameter.EMPTY_ARRAY,\n                    null,\n                    returnS(propX(varX(fieldNode), name)));\n        }\n    }",
            " 173 +\n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  ",
            "    private static void addGetterIfNeeded(FieldNode fieldNode, ClassNode owner, PropertyNode prop, String name, List<String> includes, List<String> excludes) {\n        String getterName = \"get\" + Verifier.capitalize(name);\n        if (owner.getGetterMethod(getterName) == null\n                && !shouldSkipPropertyMethod(name, getterName, excludes, includes)) {\n            owner.addMethod(getterName,\n                    ACC_PUBLIC,\n                    GenericsUtils.nonGeneric(prop.getType()),\n                    Parameter.EMPTY_ARRAY,\n                    null,\n                    returnS(propX(varX(fieldNode), name)));\n        }\n    }"
        ],
        [
            "ExternalizeVerifierASTTransformation::hasNoargConstructor(ClassNode)",
            "  97 -\n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  ",
            "    private boolean hasNoargConstructor(ClassNode cNode) {\n        List<ConstructorNode> constructors = cNode.getDeclaredConstructors();\n        for (ConstructorNode next : constructors) {\n            if (next.getParameters().length == 0) {\n                return true;\n            }\n        }\n        return false;\n    }",
            "  97 +\n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  ",
            "    private static boolean hasNoargConstructor(ClassNode cNode) {\n        List<ConstructorNode> constructors = cNode.getDeclaredConstructors();\n        for (ConstructorNode next : constructors) {\n            if (next.getParameters().length == 0) {\n                return true;\n            }\n        }\n        return false;\n    }"
        ],
        [
            "IndexedPropertyASTTransformation::addGetter(FieldNode,ClassNode)",
            " 101 -\n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  ",
            "    private void addGetter(FieldNode fNode, ClassNode componentType) {\n        ClassNode cNode = fNode.getDeclaringClass();\n        BlockStatement body = new BlockStatement();\n        Parameter[] params = new Parameter[1];\n        params[0] = new Parameter(ClassHelper.int_TYPE, \"index\");\n        body.addStatement(stmt(indexX(varX(fNode), varX(params[0]))));\n        cNode.addMethod(makeName(fNode, \"get\"), getModifiers(fNode), componentType, params, null, body);\n    }",
            " 101 +\n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  ",
            "    private static void addGetter(FieldNode fNode, ClassNode componentType) {\n        ClassNode cNode = fNode.getDeclaringClass();\n        BlockStatement body = new BlockStatement();\n        Parameter[] params = new Parameter[1];\n        params[0] = new Parameter(ClassHelper.int_TYPE, \"index\");\n        body.addStatement(stmt(indexX(varX(fNode), varX(params[0]))));\n        cNode.addMethod(makeName(fNode, \"get\"), getModifiers(fNode), componentType, params, null, body);\n    }"
        ],
        [
            "SingletonASTTransformation::getGetterName(String)",
            " 104 -\n 105  \n 106  ",
            "    private String getGetterName(String propertyName) {\r\n        return \"get\" + Character.toUpperCase(propertyName.charAt(0)) + propertyName.substring(1);\r\n    }\r",
            " 104 +\n 105  \n 106  ",
            "    private static String getGetterName(String propertyName) {\r\n        return \"get\" + Character.toUpperCase(propertyName.charAt(0)) + propertyName.substring(1);\r\n    }\r"
        ],
        [
            "LogASTTransformation::lookupCategoryName(AnnotationNode)",
            " 173 -\n 174  \n 175  \n 176  \n 177  \n 178  \n 179  ",
            "    private String lookupCategoryName(AnnotationNode logAnnotation) {\n        Expression member = logAnnotation.getMember(\"category\");\n        if (member != null && member.getText() != null) {\n            return member.getText();\n        }\n        return DEFAULT_CATEGORY_NAME;\n    }",
            " 173 +\n 174  \n 175  \n 176  \n 177  \n 178  \n 179  ",
            "    private static String lookupCategoryName(AnnotationNode logAnnotation) {\n        Expression member = logAnnotation.getMember(\"category\");\n        if (member != null && member.getText() != null) {\n            return member.getText();\n        }\n        return DEFAULT_CATEGORY_NAME;\n    }"
        ],
        [
            "ImmutableASTTransformation::createConstructorMapSpecial(ClassNode,List)",
            " 354 -\n 355  \n 356  \n 357  \n 358  ",
            "    private void createConstructorMapSpecial(ClassNode cNode, List<PropertyNode> list) {\n        final BlockStatement body = new BlockStatement();\n        body.addStatement(createConstructorStatementMapSpecial(list.get(0).getField()));\n        createConstructorMapCommon(cNode, body);\n    }",
            " 354 +\n 355  \n 356  \n 357  \n 358  ",
            "    private static void createConstructorMapSpecial(ClassNode cNode, List<PropertyNode> list) {\n        final BlockStatement body = new BlockStatement();\n        body.addStatement(createConstructorStatementMapSpecial(list.get(0).getField()));\n        createConstructorMapCommon(cNode, body);\n    }"
        ],
        [
            "ImmutableASTTransformation::adjustPropertyNode(PropertyNode,Statement)",
            " 581 -\n 582  \n 583  \n 584  ",
            "    private void adjustPropertyNode(PropertyNode pNode, Statement getterBody) {\n        pNode.setSetterBlock(null);\n        pNode.setGetterBlock(getterBody);\n    }",
            " 581 +\n 582  \n 583  \n 584  ",
            "    private static void adjustPropertyNode(PropertyNode pNode, Statement getterBody) {\n        pNode.setSetterBlock(null);\n        pNode.setGetterBlock(getterBody);\n    }"
        ],
        [
            "DelegateASTTransformation::genericPlaceholderNames(MethodNode)",
            " 276 -\n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  ",
            "    private List<String> genericPlaceholderNames(MethodNode candidate) {\n        GenericsType[] candidateGenericsTypes = candidate.getGenericsTypes();\n        List<String> names = new ArrayList<String>();\n        if (candidateGenericsTypes != null) {\n            for (GenericsType gt : candidateGenericsTypes) {\n                names.add(gt.getName());\n            }\n        }\n        return names;\n    }",
            " 276 +\n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  ",
            "    private static List<String> genericPlaceholderNames(MethodNode candidate) {\n        GenericsType[] candidateGenericsTypes = candidate.getGenericsTypes();\n        List<String> names = new ArrayList<String>();\n        if (candidateGenericsTypes != null) {\n            for (GenericsType gt : candidateGenericsTypes) {\n                names.add(gt.getName());\n            }\n        }\n        return names;\n    }"
        ],
        [
            "ExternalizeMethodsASTTransformation::suffixForField(FieldNode)",
            " 117 -\n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  ",
            "    private String suffixForField(FieldNode fNode) {\n        // use primitives for efficiency\n        if (fNode.getType() == ClassHelper.int_TYPE) return \"Int\";\n        if (fNode.getType() == ClassHelper.boolean_TYPE) return \"Boolean\";\n//        currently char isn't found due to a bug, so go with Object\n//        if (fNode.getType() == ClassHelper.char_TYPE) return \"Char\";\n        if (fNode.getType() == ClassHelper.long_TYPE) return \"Long\";\n        if (fNode.getType() == ClassHelper.short_TYPE) return \"Short\";\n        if (fNode.getType() == ClassHelper.byte_TYPE) return \"Byte\";\n        if (fNode.getType() == ClassHelper.float_TYPE) return \"Float\";\n        if (fNode.getType() == ClassHelper.double_TYPE) return \"Double\";\n        return \"Object\";\n    }",
            " 116 +\n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  ",
            "    private static String suffixForField(FieldNode fNode) {\n        // use primitives for efficiency\n        if (fNode.getType() == ClassHelper.int_TYPE) return \"Int\";\n        if (fNode.getType() == ClassHelper.boolean_TYPE) return \"Boolean\";\n//        currently char isn't found due to a bug, so go with Object\n//        if (fNode.getType() == ClassHelper.char_TYPE) return \"Char\";\n        if (fNode.getType() == ClassHelper.long_TYPE) return \"Long\";\n        if (fNode.getType() == ClassHelper.short_TYPE) return \"Short\";\n        if (fNode.getType() == ClassHelper.byte_TYPE) return \"Byte\";\n        if (fNode.getType() == ClassHelper.float_TYPE) return \"Float\";\n        if (fNode.getType() == ClassHelper.double_TYPE) return \"Double\";\n        return \"Object\";\n    }"
        ],
        [
            "MemoizedASTTransformation::buildMemoizeClosureCallExpression(MethodNode,int,int)",
            " 140 -\n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  ",
            "    private MethodCallExpression buildMemoizeClosureCallExpression(MethodNode privateMethod,\n                                                                   int protectedCacheSize, int maxCacheSize) {\n        Parameter[] srcParams = privateMethod.getParameters();\n        Parameter[] newParams = cloneParams(srcParams);\n        List<Expression> argList = new ArrayList<Expression>(newParams.length);\n        for (int i = 0; i < srcParams.length; i++) {\n            argList.add(varX(newParams[i]));\n        }\n\n        ClosureExpression expression = new ClosureExpression(\n                newParams,\n                stmt(callThisX(privateMethod.getName(), args(argList)))\n        );\n        MethodCallExpression mce;\n        if (protectedCacheSize == 0 && maxCacheSize == 0) {\n            mce = callX(expression, MEMOIZE_METHOD_NAME);\n        } else if (protectedCacheSize == 0) {\n            mce = callX(expression, MEMOIZE_AT_MOST_METHOD_NAME, args(constX(maxCacheSize)));\n        } else if (maxCacheSize == 0) {\n            mce = callX(expression, MEMOIZE_AT_LEAST_METHOD_NAME, args(constX(protectedCacheSize)));\n        } else {\n            mce = callX(expression, MEMOIZE_BETWEEN_METHOD_NAME, args(constX(protectedCacheSize), constX(maxCacheSize)));\n        }\n        mce.setImplicitThis(false);\n        return mce;\n    }",
            " 140 +\n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  ",
            "    private static MethodCallExpression buildMemoizeClosureCallExpression(MethodNode privateMethod,\n                                                                   int protectedCacheSize, int maxCacheSize) {\n        Parameter[] srcParams = privateMethod.getParameters();\n        Parameter[] newParams = cloneParams(srcParams);\n        List<Expression> argList = new ArrayList<Expression>(newParams.length);\n        for (int i = 0; i < srcParams.length; i++) {\n            argList.add(varX(newParams[i]));\n        }\n\n        ClosureExpression expression = new ClosureExpression(\n                newParams,\n                stmt(callThisX(privateMethod.getName(), args(argList)))\n        );\n        MethodCallExpression mce;\n        if (protectedCacheSize == 0 && maxCacheSize == 0) {\n            mce = callX(expression, MEMOIZE_METHOD_NAME);\n        } else if (protectedCacheSize == 0) {\n            mce = callX(expression, MEMOIZE_AT_MOST_METHOD_NAME, args(constX(maxCacheSize)));\n        } else if (maxCacheSize == 0) {\n            mce = callX(expression, MEMOIZE_AT_LEAST_METHOD_NAME, args(constX(protectedCacheSize)));\n        } else {\n            mce = callX(expression, MEMOIZE_BETWEEN_METHOD_NAME, args(constX(protectedCacheSize), constX(maxCacheSize)));\n        }\n        mce.setImplicitThis(false);\n        return mce;\n    }"
        ],
        [
            "ImmutableASTTransformation::createConstructorStatementCollection(FieldNode)",
            " 504 -\n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512  \n 513  \n 514  \n 515  \n 516  \n 517  \n 518  \n 519  \n 520  \n 521  ",
            "    private Statement createConstructorStatementCollection(FieldNode fNode) {\n        final Expression fieldExpr = varX(fNode);\n        ClassNode fieldType = fieldExpr.getType();\n        Expression initExpr = fNode.getInitialValueExpression();\n        final Statement assignInit;\n        if (initExpr == null || (initExpr instanceof ConstantExpression && ((ConstantExpression)initExpr).isNullExpression())) {\n            assignInit = assignS(fieldExpr, ConstantExpression.EMPTY_EXPRESSION);\n        } else {\n            assignInit = assignS(fieldExpr, cloneCollectionExpr(initExpr, fieldType));\n        }\n        Expression collection = findArg(fNode.getName());\n        return ifElseS(\n                equalsNullX(collection),\n                assignInit,\n                ifElseS(\n                        isInstanceOfX(collection, CLONEABLE_TYPE),\n                        assignS(fieldExpr, cloneCollectionExpr(cloneArrayOrCloneableExpr(collection, fieldType), fieldType)),\n                        assignS(fieldExpr, cloneCollectionExpr(collection, fieldType)))",
            " 504 +\n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512  \n 513  \n 514  \n 515  \n 516  \n 517  \n 518  \n 519  \n 520  \n 521  ",
            "    private static Statement createConstructorStatementCollection(FieldNode fNode) {\n        final Expression fieldExpr = varX(fNode);\n        ClassNode fieldType = fieldExpr.getType();\n        Expression initExpr = fNode.getInitialValueExpression();\n        final Statement assignInit;\n        if (initExpr == null || (initExpr instanceof ConstantExpression && ((ConstantExpression)initExpr).isNullExpression())) {\n            assignInit = assignS(fieldExpr, ConstantExpression.EMPTY_EXPRESSION);\n        } else {\n            assignInit = assignS(fieldExpr, cloneCollectionExpr(initExpr, fieldType));\n        }\n        Expression collection = findArg(fNode.getName());\n        return ifElseS(\n                equalsNullX(collection),\n                assignInit,\n                ifElseS(\n                        isInstanceOfX(collection, CLONEABLE_TYPE),\n                        assignS(fieldExpr, cloneCollectionExpr(cloneArrayOrCloneableExpr(collection, fieldType), fieldType)),\n                        assignS(fieldExpr, cloneCollectionExpr(collection, fieldType)))"
        ],
        [
            "SynchronizedASTTransformation::zeroLengthObjectArray()",
            " 110 -\n 111  \n 112  ",
            "    private Expression zeroLengthObjectArray() {\n        return new ArrayExpression(ClassHelper.OBJECT_TYPE, null, Collections.singletonList((Expression) constX(0)));\n    }",
            " 110 +\n 111  \n 112  ",
            "    private static Expression zeroLengthObjectArray() {\n        return new ArrayExpression(ClassHelper.OBJECT_TYPE, null, Collections.singletonList((Expression) constX(0)));\n    }"
        ],
        [
            "PackageScopeASTTransformation::revertVisibility(ClassNode)",
            " 161 -\n 162  \n 163  ",
            "    private void revertVisibility(ClassNode cNode) {\n        cNode.setModifiers(cNode.getModifiers() & ~ACC_PUBLIC);\n    }",
            " 161 +\n 162  \n 163  ",
            "    private static void revertVisibility(ClassNode cNode) {\n        cNode.setModifiers(cNode.getModifiers() & ~ACC_PUBLIC);\n    }"
        ],
        [
            "IndexedPropertyASTTransformation::getComponentTypeForList(ClassNode)",
            " 120 -\n 121  \n 122  \n 123  \n 124  \n 125  \n 126  ",
            "    private ClassNode getComponentTypeForList(ClassNode fType) {\n        if (fType.isUsingGenerics() && fType.getGenericsTypes().length == 1) {\n            return fType.getGenericsTypes()[0].getType();\n        } else {\n            return ClassHelper.OBJECT_TYPE;\n        }\n    }",
            " 120 +\n 121  \n 122  \n 123  \n 124  \n 125  \n 126  ",
            "    private static ClassNode getComponentTypeForList(ClassNode fType) {\n        if (fType.isUsingGenerics() && fType.getGenericsTypes().length == 1) {\n            return fType.getGenericsTypes()[0].getType();\n        } else {\n            return ClassHelper.OBJECT_TYPE;\n        }\n    }"
        ],
        [
            "DelegateASTTransformation::addSetterIfNeeded(FieldNode,ClassNode,PropertyNode,String,List,List)",
            " 158 -\n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  ",
            "    private void addSetterIfNeeded(FieldNode fieldNode, ClassNode owner, PropertyNode prop, String name, List<String> includes, List<String> excludes) {\n        String setterName = \"set\" + Verifier.capitalize(name);\n        if ((prop.getModifiers() & ACC_FINAL) == 0\n                && owner.getSetterMethod(setterName) == null\n                && !shouldSkipPropertyMethod(name, setterName, excludes, includes)) {\n            owner.addMethod(setterName,\n                    ACC_PUBLIC,\n                    ClassHelper.VOID_TYPE,\n                    params(new Parameter(GenericsUtils.nonGeneric(prop.getType()), \"value\")),\n                    null,\n                    assignS(propX(varX(fieldNode), name), varX(\"value\"))",
            " 158 +\n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  ",
            "    private static void addSetterIfNeeded(FieldNode fieldNode, ClassNode owner, PropertyNode prop, String name, List<String> includes, List<String> excludes) {\n        String setterName = \"set\" + Verifier.capitalize(name);\n        if ((prop.getModifiers() & ACC_FINAL) == 0\n                && owner.getSetterMethod(setterName) == null\n                && !shouldSkipPropertyMethod(name, setterName, excludes, includes)) {\n            owner.addMethod(setterName,\n                    ACC_PUBLIC,\n                    ClassHelper.VOID_TYPE,\n                    params(new Parameter(GenericsUtils.nonGeneric(prop.getType()), \"value\")),\n                    null,\n                    assignS(propX(varX(fieldNode), name), varX(\"value\"))"
        ],
        [
            "BaseScriptASTTransformation::isCustomScriptBodyMethod(MethodNode)",
            " 161 -\n 162  \n 163  \n 164  \n 165  \n 166  ",
            "    private boolean isCustomScriptBodyMethod(MethodNode node) {\r\n        return node != null\r\n            && !(node.getDeclaringClass().equals(ClassHelper.SCRIPT_TYPE)\r\n                && \"run\".equals(node.getName())\r\n                && node.getParameters().length == 0);\r\n    }\r",
            " 161 +\n 162  \n 163  \n 164  \n 165  \n 166  ",
            "    private static boolean isCustomScriptBodyMethod(MethodNode node) {\r\n        return node != null\r\n            && !(node.getDeclaringClass().equals(ClassHelper.SCRIPT_TYPE)\r\n                && \"run\".equals(node.getName())\r\n                && node.getParameters().length == 0);\r\n    }\r"
        ],
        [
            "ImmutableASTTransformation::createConstructorStatementDate(FieldNode)",
            " 557 -\n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564  \n 565  \n 566  \n 567  \n 568  ",
            "    private Statement createConstructorStatementDate(FieldNode fNode) {\n        final Expression fieldExpr = varX(fNode);\n        Expression initExpr = fNode.getInitialValueExpression();\n        final Statement assignInit;\n        if (initExpr == null || (initExpr instanceof ConstantExpression && ((ConstantExpression)initExpr).isNullExpression())) {\n            assignInit = assignS(fieldExpr, ConstantExpression.EMPTY_EXPRESSION);\n        } else {\n            assignInit = assignS(fieldExpr, cloneDateExpr(initExpr));\n        }\n        final Expression date = findArg(fNode.getName());\n        return ifElseS(equalsNullX(date), assignInit, assignS(fieldExpr, cloneDateExpr(date)));\n    }",
            " 557 +\n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564  \n 565  \n 566  \n 567  \n 568  ",
            "    private static Statement createConstructorStatementDate(FieldNode fNode) {\n        final Expression fieldExpr = varX(fNode);\n        Expression initExpr = fNode.getInitialValueExpression();\n        final Statement assignInit;\n        if (initExpr == null || (initExpr instanceof ConstantExpression && ((ConstantExpression)initExpr).isNullExpression())) {\n            assignInit = assignS(fieldExpr, ConstantExpression.EMPTY_EXPRESSION);\n        } else {\n            assignInit = assignS(fieldExpr, cloneDateExpr(initExpr));\n        }\n        final Expression date = findArg(fNode.getName());\n        return ifElseS(equalsNullX(date), assignInit, assignS(fieldExpr, cloneDateExpr(date)));\n    }"
        ],
        [
            "LogASTTransformation::lookupLogFieldName(AnnotationNode)",
            " 164 -\n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  ",
            "    private String lookupLogFieldName(AnnotationNode logAnnotation) {\n        Expression member = logAnnotation.getMember(\"value\");\n        if (member != null && member.getText() != null) {\n            return member.getText();\n        } else {\n            return \"log\";\n        }\n    }",
            " 164 +\n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  ",
            "    private static String lookupLogFieldName(AnnotationNode logAnnotation) {\n        Expression member = logAnnotation.getMember(\"value\");\n        if (member != null && member.getText() != null) {\n            return member.getText();\n        } else {\n            return \"log\";\n        }\n    }"
        ],
        [
            "ReadWriteLockASTTransformation::createLockObject()",
            " 140 -\n 141  \n 142  ",
            "    private Expression createLockObject() {\n        return ctorX(LOCK_TYPE);\n    }",
            " 140 +\n 141  \n 142  ",
            "    private static Expression createLockObject() {\n        return ctorX(LOCK_TYPE);\n    }"
        ],
        [
            "IndexedPropertyASTTransformation::addSetter(FieldNode,ClassNode)",
            " 110 -\n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  ",
            "    private void addSetter(FieldNode fNode, ClassNode componentType) {\n        ClassNode cNode = fNode.getDeclaringClass();\n        BlockStatement body = new BlockStatement();\n        Parameter[] theParams = params(\n                new Parameter(ClassHelper.int_TYPE, \"index\"),\n                new Parameter(componentType, \"value\"));\n        body.addStatement(assignS(indexX(varX(fNode), varX(theParams[0])), varX(theParams[1])));\n        cNode.addMethod(makeName(fNode, \"set\"), getModifiers(fNode), ClassHelper.VOID_TYPE, theParams, null, body);\n    }",
            " 110 +\n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  ",
            "    private static void addSetter(FieldNode fNode, ClassNode componentType) {\n        ClassNode cNode = fNode.getDeclaringClass();\n        BlockStatement body = new BlockStatement();\n        Parameter[] theParams = params(\n                new Parameter(ClassHelper.int_TYPE, \"index\"),\n                new Parameter(componentType, \"value\"));\n        body.addStatement(assignS(indexX(varX(fNode), varX(theParams[0])), varX(theParams[1])));\n        cNode.addMethod(makeName(fNode, \"set\"), getModifiers(fNode), ClassHelper.VOID_TYPE, theParams, null, body);\n    }"
        ],
        [
            "AutoCloneASTTransformation::isCloneableType(ClassNode)",
            " 185 -\n 186  \n 187  ",
            "    private boolean isCloneableType(ClassNode fieldType) {\r\n        return isOrImplements(fieldType, CLONEABLE_TYPE) || !fieldType.getAnnotations(MY_TYPE).isEmpty();\r\n    }\r",
            " 185 +\n 186  \n 187  ",
            "    private static boolean isCloneableType(ClassNode fieldType) {\r\n        return isOrImplements(fieldType, CLONEABLE_TYPE) || !fieldType.getAnnotations(MY_TYPE).isEmpty();\r\n    }\r"
        ],
        [
            "ImmutableASTTransformation::createConstructorOrdered(ClassNode,List)",
            " 301 -\n 302  \n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  ",
            "    private void createConstructorOrdered(ClassNode cNode, List<PropertyNode> list) {\n        final MapExpression argMap = new MapExpression();\n        final Parameter[] orderedParams = new Parameter[list.size()];\n        int index = 0;\n        for (PropertyNode pNode : list) {\n            Parameter param = new Parameter(pNode.getField().getType(), pNode.getField().getName());\n            orderedParams[index++] = param;\n            argMap.addMapEntryExpression(constX(pNode.getName()), varX(pNode.getName()));\n        }\n        final BlockStatement orderedBody = new BlockStatement();\n        orderedBody.addStatement(stmt(ctorX(ClassNode.THIS, args(castX(HASHMAP_TYPE, argMap)))));\n        doAddConstructor(cNode, new ConstructorNode(ACC_PUBLIC, orderedParams, ClassNode.EMPTY_ARRAY, orderedBody));\n    }",
            " 301 +\n 302  \n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  ",
            "    private static void createConstructorOrdered(ClassNode cNode, List<PropertyNode> list) {\n        final MapExpression argMap = new MapExpression();\n        final Parameter[] orderedParams = new Parameter[list.size()];\n        int index = 0;\n        for (PropertyNode pNode : list) {\n            Parameter param = new Parameter(pNode.getField().getType(), pNode.getField().getName());\n            orderedParams[index++] = param;\n            argMap.addMapEntryExpression(constX(pNode.getName()), varX(pNode.getName()));\n        }\n        final BlockStatement orderedBody = new BlockStatement();\n        orderedBody.addStatement(stmt(ctorX(ClassNode.THIS, args(castX(HASHMAP_TYPE, argMap)))));\n        doAddConstructor(cNode, new ConstructorNode(ACC_PUBLIC, orderedParams, ClassNode.EMPTY_ARRAY, orderedBody));\n    }"
        ],
        [
            "TraitASTTransformation::copyClassAnnotations(ClassNode,ClassNode)",
            " 272  \n 273  \n 274  \n 275  \n 276  \n 277 -\n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  ",
            "    /**\n     * Copies annotation from the trait to the helper, excluding the trait annotation itself\n     * @param cNode the trait class node\n     * @param helper the helper class node\n     */\n    private void copyClassAnnotations(final ClassNode cNode, final ClassNode helper) {\n        List<AnnotationNode> annotations = cNode.getAnnotations();\n        for (AnnotationNode annotation : annotations) {\n            if (!annotation.getClassNode().equals(Traits.TRAIT_CLASSNODE)) {\n                helper.addAnnotation(annotation);\n            }\n        }\n    }",
            " 272  \n 273  \n 274  \n 275  \n 276  \n 277 +\n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  ",
            "    /**\n     * Copies annotation from the trait to the helper, excluding the trait annotation itself\n     * @param cNode the trait class node\n     * @param helper the helper class node\n     */\n    private static void copyClassAnnotations(final ClassNode cNode, final ClassNode helper) {\n        List<AnnotationNode> annotations = cNode.getAnnotations();\n        for (AnnotationNode annotation : annotations) {\n            if (!annotation.getClassNode().equals(Traits.TRAIT_CLASSNODE)) {\n                helper.addAnnotation(annotation);\n            }\n        }\n    }"
        ],
        [
            "PackageScopeASTTransformation::revertVisibility(FieldNode)",
            " 153 -\n 154  \n 155  ",
            "    private void revertVisibility(FieldNode fNode) {\n        fNode.setModifiers(fNode.getModifiers() & ~ACC_PRIVATE);\n    }",
            " 153 +\n 154  \n 155  ",
            "    private static void revertVisibility(FieldNode fNode) {\n        fNode.setModifiers(fNode.getModifiers() & ~ACC_PRIVATE);\n    }"
        ],
        [
            "ASTTransformationCollectorCodeVisitor::deleteExisting(boolean,Map,List)",
            " 143 -\n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  ",
            "    private void deleteExisting(boolean mergeParams, Map<Integer, List<AnnotationNode>> existingMap, List<AnnotationNode> replacements) {\n        for (AnnotationNode replacement : replacements) {\n            for (Integer key : existingMap.keySet()) {\n                List<AnnotationNode> annotationNodes = new ArrayList<AnnotationNode>(existingMap.get(key));\n                Iterator<AnnotationNode> iterator = annotationNodes.iterator();\n                while (iterator.hasNext()) {\n                    AnnotationNode existing = iterator.next();\n                    if (replacement.getClassNode().getName().equals(existing.getClassNode().getName())) {\n                        if (mergeParams) {\n                            mergeParameters(replacement, existing);\n                        }\n                        iterator.remove();\n                    }\n                }\n                existingMap.put(key, annotationNodes);\n            }\n        }\n    }",
            " 143 +\n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  ",
            "    private static void deleteExisting(boolean mergeParams, Map<Integer, List<AnnotationNode>> existingMap, List<AnnotationNode> replacements) {\n        for (AnnotationNode replacement : replacements) {\n            for (Integer key : existingMap.keySet()) {\n                List<AnnotationNode> annotationNodes = new ArrayList<AnnotationNode>(existingMap.get(key));\n                Iterator<AnnotationNode> iterator = annotationNodes.iterator();\n                while (iterator.hasNext()) {\n                    AnnotationNode existing = iterator.next();\n                    if (replacement.getClassNode().getName().equals(existing.getClassNode().getName())) {\n                        if (mergeParams) {\n                            mergeParameters(replacement, existing);\n                        }\n                        iterator.remove();\n                    }\n                }\n                existingMap.put(key, annotationNodes);\n            }\n        }\n    }"
        ],
        [
            "ImmutableASTTransformation::makeClassFinal(ClassNode)",
            " 273 -\n 274  \n 275  \n 276  \n 277  ",
            "    private void makeClassFinal(ClassNode cNode) {\n        if ((cNode.getModifiers() & ACC_FINAL) == 0) {\n            cNode.setModifiers(cNode.getModifiers() | ACC_FINAL);\n        }\n    }",
            " 273 +\n 274  \n 275  \n 276  \n 277  ",
            "    private static void makeClassFinal(ClassNode cNode) {\n        if ((cNode.getModifiers() & ACC_FINAL) == 0) {\n            cNode.setModifiers(cNode.getModifiers() | ACC_FINAL);\n        }\n    }"
        ],
        [
            "DelegateASTTransformation::getParamName(Parameter,int,String)",
            " 287 -\n 288  \n 289  \n 290  \n 291  \n 292  \n 293  ",
            "    private String getParamName(Parameter[] params, int i, String fieldName) {\n        String name = params[i].getName();\n        while(name.equals(fieldName) || clashesWithOtherParams(name, params, i)) {\n            name = \"_\" + name;\n        }\n        return name;\n    }",
            " 287 +\n 288  \n 289  \n 290  \n 291  \n 292  \n 293  ",
            "    private static String getParamName(Parameter[] params, int i, String fieldName) {\n        String name = params[i].getName();\n        while(name.equals(fieldName) || clashesWithOtherParams(name, params, i)) {\n            name = \"_\" + name;\n        }\n        return name;\n    }"
        ]
    ],
    "4971552b85e5c12d4ebf49ddac181523c5160baa": [
        [
            "StaticTypesCallSiteWriter::makeSingleArgumentCall(Expression,String,Expression)",
            " 623  \n 624  \n 625  \n 626  \n 627  \n 628  \n 629  \n 630  \n 631  \n 632  \n 633  \n 634  \n 635  \n 636  \n 637  \n 638  \n 639  \n 640  \n 641  \n 642  \n 643  ",
            "    @Override\n    public void makeSingleArgumentCall(final Expression receiver, final String message, final Expression arguments) {\n        TypeChooser typeChooser = controller.getTypeChooser();\n        ClassNode classNode = controller.getClassNode();\n        ClassNode rType = typeChooser.resolveType(receiver, classNode);\n        ClassNode aType = typeChooser.resolveType(arguments, classNode);\n        if (trySubscript(receiver, message, arguments, rType, aType)) {\n            return;\n        }\n        // now try with flow type instead of declaration type\n        rType = receiver.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);\n        if (rType!=null && trySubscript(receiver, message, arguments, rType, aType)) {\n            return;\n        }\n        // todo: more cases\n        throw new GroovyBugError(\n                \"At line \" + receiver.getLineNumber() + \" column \" + receiver.getColumnNumber() + \"\\n\" +\n                \"On receiver: \" + receiver.getText() + \" with message: \" + message + \" and arguments: \" + arguments.getText() + \"\\n\" +\n                \"This method should not have been called. Please try to create a simple example reproducing\\n\" +\n                \"this error and file a bug report at https://issues.apache.org/jira/browse/GROOVY\");\n    }",
            " 623  \n 624  \n 625  \n 626  \n 627  \n 628  \n 629  \n 630  \n 631  \n 632  \n 633  \n 634 +\n 635 +\n 636 +\n 637 +\n 638 +\n 639  \n 640  \n 641  \n 642  \n 643  \n 644  \n 645  \n 646  \n 647  \n 648  ",
            "    @Override\n    public void makeSingleArgumentCall(final Expression receiver, final String message, final Expression arguments) {\n        TypeChooser typeChooser = controller.getTypeChooser();\n        ClassNode classNode = controller.getClassNode();\n        ClassNode rType = typeChooser.resolveType(receiver, classNode);\n        ClassNode aType = typeChooser.resolveType(arguments, classNode);\n        if (trySubscript(receiver, message, arguments, rType, aType)) {\n            return;\n        }\n        // now try with flow type instead of declaration type\n        rType = receiver.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);\n        if (receiver instanceof VariableExpression && receiver.getNodeMetaData().isEmpty()) {\n            // TODO: can STCV be made smarter to avoid this check?\n            VariableExpression ve = (VariableExpression) ((VariableExpression)receiver).getAccessedVariable();\n            rType = ve.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);\n        }\n        if (rType!=null && trySubscript(receiver, message, arguments, rType, aType)) {\n            return;\n        }\n        // todo: more cases\n        throw new GroovyBugError(\n                \"At line \" + receiver.getLineNumber() + \" column \" + receiver.getColumnNumber() + \"\\n\" +\n                \"On receiver: \" + receiver.getText() + \" with message: \" + message + \" and arguments: \" + arguments.getText() + \"\\n\" +\n                \"This method should not have been called. Please try to create a simple example reproducing\\n\" +\n                \"this error and file a bug report at https://issues.apache.org/jira/browse/GROOVY\");\n    }"
        ]
    ],
    "690d1e4870c4107e78bfb05fc0fa23886c3cddd1": [
        [
            "ASTTransformationCollectorCodeVisitor::deleteReplacement(boolean,Map,List)",
            " 162  \n 163  \n 164  \n 165  \n 166  \n 167 -\n 168 -\n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  ",
            "    private static void deleteReplacement(boolean mergeParams, Map<Integer, List<AnnotationNode>> existingMap, List<AnnotationNode> replacements) {\n        Iterator<AnnotationNode> nodeIterator = replacements.iterator();\n        while (nodeIterator.hasNext()) {\n            boolean remove = false;\n            AnnotationNode replacement = nodeIterator.next();\n            for (Integer key : existingMap.keySet()) {\n                for (AnnotationNode existing : existingMap.get(key)) {\n                    if (replacement.getClassNode().getName().equals(existing.getClassNode().getName())) {\n                        if (mergeParams) {\n                            mergeParameters(existing, replacement);\n                        }\n                        remove = true;\n                    }\n                }\n            }\n            if (remove) {\n                nodeIterator.remove();\n            }\n        }\n    }",
            " 164  \n 165  \n 166  \n 167  \n 168  \n 169 +\n 170 +\n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  ",
            "    private static void deleteReplacement(boolean mergeParams, Map<Integer, List<AnnotationNode>> existingMap, List<AnnotationNode> replacements) {\n        Iterator<AnnotationNode> nodeIterator = replacements.iterator();\n        while (nodeIterator.hasNext()) {\n            boolean remove = false;\n            AnnotationNode replacement = nodeIterator.next();\n            for (Map.Entry<Integer, List<AnnotationNode>> entry : existingMap.entrySet()) {\n                for (AnnotationNode existing : entry.getValue()) {\n                    if (replacement.getClassNode().getName().equals(existing.getClassNode().getName())) {\n                        if (mergeParams) {\n                            mergeParameters(existing, replacement);\n                        }\n                        remove = true;\n                    }\n                }\n            }\n            if (remove) {\n                nodeIterator.remove();\n            }\n        }\n    }"
        ],
        [
            "ASTTransformationCollectorCodeVisitor::visitAnnotations(AnnotatedNode)",
            "  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102 -\n 103 -\n 104 -\n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  ",
            "    /**\n     * If the annotation is annotated with {@link GroovyASTTransformation}\n     * the annotation is added to <code>stageVisitors</code> at the appropriate processor visitor.\n     *\n     * @param node the node to process\n     */\n    public void visitAnnotations(AnnotatedNode node) {\n        super.visitAnnotations(node);\n\n        Map<Integer, List<AnnotationNode>> existing = new TreeMap<Integer, List<AnnotationNode>>();\n        Map<Integer, List<AnnotationNode>> replacements = new LinkedHashMap<Integer, List<AnnotationNode>>();\n        Map<Integer, AnnotationCollectorMode> modes = new LinkedHashMap<Integer, AnnotationCollectorMode>();\n        int index = 0;\n        for (AnnotationNode annotation : node.getAnnotations()) {\n            findCollectedAnnotations(annotation, node, index, modes, existing, replacements);\n            index++;\n        }\n        for (Integer replacementIndex : replacements.keySet()) {\n            mergeCollectedAnnotations(modes.get(replacementIndex), existing, replacements.get(replacementIndex));\n            existing.put(replacementIndex, replacements.get(replacementIndex));\n        }\n        List<AnnotationNode> mergedList = new ArrayList<AnnotationNode>();\n        for (List<AnnotationNode> next : existing.values()) {\n            mergedList.addAll(next);\n        }\n\n        node.getAnnotations().clear();\n        node.getAnnotations().addAll(mergedList);\n\n        for (AnnotationNode annotation : node.getAnnotations()) {\n            Annotation transformClassAnnotation = getTransformClassAnnotation(annotation.getClassNode());\n            if (transformClassAnnotation == null) {\n                // skip if there is no such annotation\n                continue;\n            }\n            addTransformsToClassNode(annotation, transformClassAnnotation);\n        }\n    }",
            "  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102 +\n 103 +\n 104 +\n 105 +\n 106 +\n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  ",
            "    /**\n     * If the annotation is annotated with {@link GroovyASTTransformation}\n     * the annotation is added to <code>stageVisitors</code> at the appropriate processor visitor.\n     *\n     * @param node the node to process\n     */\n    public void visitAnnotations(AnnotatedNode node) {\n        super.visitAnnotations(node);\n\n        Map<Integer, List<AnnotationNode>> existing = new TreeMap<Integer, List<AnnotationNode>>();\n        Map<Integer, List<AnnotationNode>> replacements = new LinkedHashMap<Integer, List<AnnotationNode>>();\n        Map<Integer, AnnotationCollectorMode> modes = new LinkedHashMap<Integer, AnnotationCollectorMode>();\n        int index = 0;\n        for (AnnotationNode annotation : node.getAnnotations()) {\n            findCollectedAnnotations(annotation, node, index, modes, existing, replacements);\n            index++;\n        }\n        for (Map.Entry<Integer, List<AnnotationNode>> entry : replacements.entrySet()) {\n            Integer replacementIndex = entry.getKey();\n            List<AnnotationNode> annotationNodeList = entry.getValue();\n            mergeCollectedAnnotations(modes.get(replacementIndex), existing, annotationNodeList);\n            existing.put(replacementIndex, annotationNodeList);\n        }\n        List<AnnotationNode> mergedList = new ArrayList<AnnotationNode>();\n        for (List<AnnotationNode> next : existing.values()) {\n            mergedList.addAll(next);\n        }\n\n        node.getAnnotations().clear();\n        node.getAnnotations().addAll(mergedList);\n\n        for (AnnotationNode annotation : node.getAnnotations()) {\n            Annotation transformClassAnnotation = getTransformClassAnnotation(annotation.getClassNode());\n            if (transformClassAnnotation == null) {\n                // skip if there is no such annotation\n                continue;\n            }\n            addTransformsToClassNode(annotation, transformClassAnnotation);\n        }\n    }"
        ]
    ],
    "cfbd6d298bf76c00bb37ecc6839b044d393a4ebd": [
        [
            "JavaStubGenerator::printAnnotation(PrintWriter,AnnotationNode)",
            " 847  \n 848  \n 849  \n 850  \n 851 -\n 852  \n 853  \n 854 -\n 855  \n 856  \n 857  ",
            "    private void printAnnotation(PrintWriter out, AnnotationNode annotation) {\n        out.print(\"@\" + annotation.getClassNode().getName().replace('$', '.') + \"(\");\n        boolean first = true;\n        Map<String, Expression> members = annotation.getMembers();\n        for (String key : members.keySet()) {\n            if (first) first = false;\n            else out.print(\", \");\n            out.print(key + \"=\" + getAnnotationValue(members.get(key)).replace('$', '.'));\n        }\n        out.print(\") \");\n    }",
            " 847  \n 848  \n 849  \n 850  \n 851 +\n 852 +\n 853  \n 854  \n 855 +\n 856  \n 857  \n 858  ",
            "    private void printAnnotation(PrintWriter out, AnnotationNode annotation) {\n        out.print(\"@\" + annotation.getClassNode().getName().replace('$', '.') + \"(\");\n        boolean first = true;\n        Map<String, Expression> members = annotation.getMembers();\n        for (Map.Entry<String, Expression> entry : members.entrySet()) {\n            String key = entry.getKey();\n            if (first) first = false;\n            else out.print(\", \");\n            out.print(key + \"=\" + getAnnotationValue(entry.getValue()).replace('$', '.'));\n        }\n        out.print(\") \");\n    }"
        ],
        [
            "SimpleGroovyRootDoc::classNamedExact(String)",
            "  64  \n  65 -\n  66 -\n  67  \n  68  \n  69  ",
            "    public GroovyClassDoc classNamedExact(String name) {\n        for (String key : classDocs.keySet()) {\n            if (key.equals(name)) return classDocs.get(key);\n        }\n        return null;\n    }",
            "  65  \n  66 +\n  67 +\n  68 +\n  69  \n  70  \n  71  ",
            "    public GroovyClassDoc classNamedExact(String name) {\n        for (Map.Entry<String, GroovyClassDoc> entry : classDocs.entrySet()) {\n            String key = entry.getKey();\n            if (key.equals(name)) return entry.getValue();\n        }\n        return null;\n    }"
        ],
        [
            "ASTTransformationCollectorCodeVisitor::deleteExisting(boolean,Map,List)",
            " 145  \n 146  \n 147 -\n 148 -\n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  ",
            "    private static void deleteExisting(boolean mergeParams, Map<Integer, List<AnnotationNode>> existingMap, List<AnnotationNode> replacements) {\n        for (AnnotationNode replacement : replacements) {\n            for (Integer key : existingMap.keySet()) {\n                List<AnnotationNode> annotationNodes = new ArrayList<AnnotationNode>(existingMap.get(key));\n                Iterator<AnnotationNode> iterator = annotationNodes.iterator();\n                while (iterator.hasNext()) {\n                    AnnotationNode existing = iterator.next();\n                    if (replacement.getClassNode().getName().equals(existing.getClassNode().getName())) {\n                        if (mergeParams) {\n                            mergeParameters(replacement, existing);\n                        }\n                        iterator.remove();\n                    }\n                }\n                existingMap.put(key, annotationNodes);\n            }\n        }\n    }",
            " 145  \n 146  \n 147 +\n 148 +\n 149 +\n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  ",
            "    private static void deleteExisting(boolean mergeParams, Map<Integer, List<AnnotationNode>> existingMap, List<AnnotationNode> replacements) {\n        for (AnnotationNode replacement : replacements) {\n            for (Map.Entry<Integer, List<AnnotationNode>> entry : existingMap.entrySet()) {\n                Integer key = entry.getKey();\n                List<AnnotationNode> annotationNodes = new ArrayList<AnnotationNode>(entry.getValue());\n                Iterator<AnnotationNode> iterator = annotationNodes.iterator();\n                while (iterator.hasNext()) {\n                    AnnotationNode existing = iterator.next();\n                    if (replacement.getClassNode().getName().equals(existing.getClassNode().getName())) {\n                        if (mergeParams) {\n                            mergeParameters(replacement, existing);\n                        }\n                        iterator.remove();\n                    }\n                }\n                existingMap.put(key, annotationNodes);\n            }\n        }\n    }"
        ],
        [
            "AntProjectPropertiesDelegate::putAll(Map)",
            " 102  \n 103 -\n 104 -\n 105 -\n 106 -\n 107 -\n 108  \n 109  ",
            "    public synchronized void putAll(Map t) {\n        Set keySet = t.keySet();\n        for (Iterator iterator = keySet.iterator(); iterator.hasNext();) {\n            Object key = iterator.next();\n            Object value = t.get(key);\n            put(key, value);\n        }\n    }",
            " 102  \n 103 +\n 104 +\n 105 +\n 106  \n 107  ",
            "    public synchronized void putAll(Map t) {\n        for (Object e : t.entrySet()) {\n            Map.Entry entry = (Map.Entry) e;\n            put(entry.getKey(), entry.getValue());\n        }\n    }"
        ],
        [
            "ClassNodeUtils::addDeclaredMethodsFromInterfaces(ClassNode,Map)",
            "  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93 -\n  94  \n  95 -\n  96 -\n  97  \n  98  \n  99  \n 100  ",
            "    /**\n     * Add in methods from all interfaces. Existing entries in the methods map take precedence.\n     * Methods from interfaces visited early take precedence over later ones.\n     *\n     * @param cNode The ClassNode\n     * @param methodsMap A map of existing methods to alter\n     */\n    public static void addDeclaredMethodsFromInterfaces(ClassNode cNode, Map<String, MethodNode> methodsMap) {\n        // add in unimplemented abstract methods from the interfaces\n        for (ClassNode iface : cNode.getInterfaces()) {\n            Map<String, MethodNode> ifaceMethodsMap = iface.getDeclaredMethodsMap();\n            for (String methSig : ifaceMethodsMap.keySet()) {\n                if (!methodsMap.containsKey(methSig)) {\n                    MethodNode methNode = ifaceMethodsMap.get(methSig);\n                    methodsMap.put(methSig, methNode);\n                }\n            }\n        }\n    }",
            "  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93 +\n  94 +\n  95  \n  96 +\n  97  \n  98  \n  99  \n 100  ",
            "    /**\n     * Add in methods from all interfaces. Existing entries in the methods map take precedence.\n     * Methods from interfaces visited early take precedence over later ones.\n     *\n     * @param cNode The ClassNode\n     * @param methodsMap A map of existing methods to alter\n     */\n    public static void addDeclaredMethodsFromInterfaces(ClassNode cNode, Map<String, MethodNode> methodsMap) {\n        // add in unimplemented abstract methods from the interfaces\n        for (ClassNode iface : cNode.getInterfaces()) {\n            Map<String, MethodNode> ifaceMethodsMap = iface.getDeclaredMethodsMap();\n            for (Map.Entry<String, MethodNode> entry : ifaceMethodsMap.entrySet()) {\n                String methSig = entry.getKey();\n                if (!methodsMap.containsKey(methSig)) {\n                    methodsMap.put(methSig, entry.getValue());\n                }\n            }\n        }\n    }"
        ],
        [
            "Builder::Builder(Map)",
            "  32  \n  33 -\n  34 -\n  35 -\n  36 -\n  37 -\n  38 -\n  39 -\n  40 -\n  41  \n  42  ",
            "    public Builder(final Map namespaceMethodMap) {\n    final Iterator keyIterator = namespaceMethodMap.keySet().iterator();\n        \n        while (keyIterator.hasNext()) {\n        final Object key = keyIterator.next();\n        final List value = (List)namespaceMethodMap.get(key);\n        final Closure dg = ((Closure)value.get(1)).asWritable();\n        \n            this.namespaceMethodMap.put(key, new Object[]{value.get(0), dg, fettleMethodMap(dg, (Map)value.get(2))});\n        }\n    }",
            "  32  \n  33 +\n  34 +\n  35 +\n  36 +\n  37 +\n  38 +\n  39 +\n  40  \n  41  ",
            "    public Builder(final Map namespaceMethodMap) {\n        for (Object e : namespaceMethodMap.entrySet()) {\n            Map.Entry entry = (Map.Entry) e;\n            final Object key = entry.getKey();\n            final List value = (List) entry.getValue();\n            final Closure dg = ((Closure) value.get(1)).asWritable();\n\n            this.namespaceMethodMap.put(key, new Object[] { value.get(0), dg, fettleMethodMap(dg, (Map) value.get(2)) });\n        }\n    }"
        ],
        [
            "SimpleGroovyRootDoc::getVisibleClasses(List)",
            " 121  \n 122  \n 123 -\n 124  \n 125  \n 126  \n 127 -\n 128  \n 129  \n 130  \n 131  \n 132  ",
            "    public Map<String, GroovyClassDoc> getVisibleClasses(List importedClassesAndPackages) {\n        Map<String, GroovyClassDoc> visibleClasses = new LinkedHashMap<String, GroovyClassDoc>();\n        for (String fullClassName : classDocs.keySet()) {\n            String equivalentPackageImport = fullClassName.replaceAll(\"[^/]+$\", \"*\");\n            if (importedClassesAndPackages.contains(fullClassName) ||\n                    importedClassesAndPackages.contains(equivalentPackageImport)) {\n                GroovyClassDoc classDoc = classDocs.get(fullClassName);\n                visibleClasses.put(classDoc.name(), classDoc);\n            }\n        }\n        return visibleClasses;\n    }",
            " 123  \n 124  \n 125 +\n 126 +\n 127  \n 128  \n 129  \n 130 +\n 131  \n 132  \n 133  \n 134  \n 135  ",
            "    public Map<String, GroovyClassDoc> getVisibleClasses(List importedClassesAndPackages) {\n        Map<String, GroovyClassDoc> visibleClasses = new LinkedHashMap<String, GroovyClassDoc>();\n        for (Map.Entry<String, GroovyClassDoc> entry : classDocs.entrySet()) {\n            String fullClassName = entry.getKey();\n            String equivalentPackageImport = fullClassName.replaceAll(\"[^/]+$\", \"*\");\n            if (importedClassesAndPackages.contains(fullClassName) ||\n                    importedClassesAndPackages.contains(equivalentPackageImport)) {\n                GroovyClassDoc classDoc = entry.getValue();\n                visibleClasses.put(classDoc.name(), classDoc);\n            }\n        }\n        return visibleClasses;\n    }"
        ],
        [
            "SimpleGroovyRootDoc::classNamed(GroovyClassDoc,String)",
            "  44  \n  45  \n  46 -\n  47 -\n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57 -\n  58  \n  59  \n  60  \n  61  \n  62  ",
            "    public GroovyClassDoc classNamed(GroovyClassDoc groovyClassDoc, String name) {\n        // look for full match or match excluding package\n        for (String key : classDocs.keySet()) {\n            if (key.equals(name)) return classDocs.get(key);\n            int lastSlashIdx = key.lastIndexOf('/');\n            if (lastSlashIdx > 0) {\n                String shortKey = key.substring(lastSlashIdx + 1);\n                String fullPathName = groovyClassDoc != null ? groovyClassDoc.getFullPathName() : null;\n\n                boolean hasPackage = (fullPathName != null && fullPathName.lastIndexOf('/') > 0);\n                if (hasPackage) fullPathName = fullPathName.substring(0, fullPathName.lastIndexOf('/'));\n\n                if (shortKey.equals(name) && (!hasPackage || key.startsWith(fullPathName))) {\n                    return classDocs.get(key);\n                }\n            }\n        }\n        return null;\n    }",
            "  44  \n  45  \n  46 +\n  47 +\n  48 +\n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58 +\n  59  \n  60  \n  61  \n  62  \n  63  ",
            "    public GroovyClassDoc classNamed(GroovyClassDoc groovyClassDoc, String name) {\n        // look for full match or match excluding package\n        for (Map.Entry<String, GroovyClassDoc> entry : classDocs.entrySet()) {\n            String key = entry.getKey();\n            if (key.equals(name)) return entry.getValue();\n            int lastSlashIdx = key.lastIndexOf('/');\n            if (lastSlashIdx > 0) {\n                String shortKey = key.substring(lastSlashIdx + 1);\n                String fullPathName = groovyClassDoc != null ? groovyClassDoc.getFullPathName() : null;\n\n                boolean hasPackage = (fullPathName != null && fullPathName.lastIndexOf('/') > 0);\n                if (hasPackage) fullPathName = fullPathName.substring(0, fullPathName.lastIndexOf('/'));\n\n                if (shortKey.equals(name) && (!hasPackage || key.startsWith(fullPathName))) {\n                    return entry.getValue();\n                }\n            }\n        }\n        return null;\n    }"
        ]
    ],
    "75e1e878bf0b07662019f3989f0ebcc82ba9805e": [
        [
            "Tuple::equals(Object)",
            "  65  \n  66  \n  67  \n  68 -\n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  ",
            "    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || !(o instanceof Tuple)) return false;\n\n        Tuple that = (Tuple) o;\n        int size = size();\n        if (size != that.size()) return false;\n        for (int i = 0; i < size; i++) {\n            if (!DefaultTypeTransformation.compareEqual(get(i), that.get(i))) {\n                return false;\n            }\n        }\n        return true;\n    }",
            "  65  \n  66  \n  67  \n  68 +\n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  ",
            "    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof Tuple)) return false;\n\n        Tuple that = (Tuple) o;\n        int size = size();\n        if (size != that.size()) return false;\n        for (int i = 0; i < size; i++) {\n            if (!DefaultTypeTransformation.compareEqual(get(i), that.get(i))) {\n                return false;\n            }\n        }\n        return true;\n    }"
        ],
        [
            "Verifier::getFirstIfSpecialConstructorCall(Statement)",
            "1096  \n1097 -\n1098  \n1099  \n1100  \n1101  \n1102  \n1103  \n1104  ",
            "    private static ConstructorCallExpression getFirstIfSpecialConstructorCall(Statement code) {\n        if (code == null || !(code instanceof ExpressionStatement)) return null;\n\n        Expression expression = ((ExpressionStatement) code).getExpression();\n        if (!(expression instanceof ConstructorCallExpression)) return null;\n        ConstructorCallExpression cce = (ConstructorCallExpression) expression;\n        if (cce.isSpecialCall()) return cce;\n        return null;\n    }",
            "1096  \n1097 +\n1098  \n1099  \n1100  \n1101  \n1102  \n1103  \n1104  ",
            "    private static ConstructorCallExpression getFirstIfSpecialConstructorCall(Statement code) {\n        if (!(code instanceof ExpressionStatement)) return null;\n\n        Expression expression = ((ExpressionStatement) code).getExpression();\n        if (!(expression instanceof ConstructorCallExpression)) return null;\n        ConstructorCallExpression cce = (ConstructorCallExpression) expression;\n        if (cce.isSpecialCall()) return cce;\n        return null;\n    }"
        ],
        [
            "MetaClassImpl::invokeMissingMethod(Object,String,Object,RuntimeException,boolean)",
            " 923  \n 924  \n 925  \n 926  \n 927  \n 928  \n 929  \n 930  \n 931  \n 932  \n 933  \n 934  \n 935  \n 936  \n 937  \n 938  \n 939  \n 940  \n 941  \n 942  \n 943  \n 944  \n 945  \n 946 -\n 947  \n 948  \n 949  \n 950  \n 951  \n 952  \n 953  \n 954  \n 955  \n 956  \n 957  \n 958  \n 959  \n 960  \n 961  \n 962  \n 963  \n 964  \n 965  \n 966  \n 967  \n 968  \n 969  \n 970  \n 971  ",
            "    private Object invokeMissingMethod(Object instance, String methodName, Object[] arguments, RuntimeException original, boolean isCallToSuper) {\n        if (!isCallToSuper) {\n            Class instanceKlazz = instance.getClass();\n            if (theClass != instanceKlazz && theClass.isAssignableFrom(instanceKlazz))\n              instanceKlazz = theClass;\n\n            Class[] argClasses = MetaClassHelper.castArgumentsToClassArray(arguments);\n\n            MetaMethod method = findMixinMethod(methodName, argClasses);\n            if(method != null) {\n                onMixinMethodFound(method);\n                return method.invoke(instance, arguments);\n            }\n\n            method = findMethodInClassHierarchy(instanceKlazz, methodName, argClasses, this);\n            if(method != null) {\n                onSuperMethodFoundInHierarchy(method);\n                return method.invoke(instance, arguments);\n            }\n\n            // still not method here, so see if there is an invokeMethod method up the hierarchy\n            final Class[] invokeMethodArgs = {String.class, Object[].class};\n            method = findMethodInClassHierarchy(instanceKlazz, INVOKE_METHOD_METHOD, invokeMethodArgs, this );\n            if(method != null && method instanceof ClosureMetaMethod) {\n                onInvokeMethodFoundInHierarchy(method);\n                return method.invoke(instance, invokeMethodArgs);\n            }\n        }\n\n        if (methodMissing != null) {\n            try {\n                return methodMissing.invoke(instance, new Object[]{methodName, arguments});\n            } catch (InvokerInvocationException iie) {\n                if (methodMissing instanceof ClosureMetaMethod && iie.getCause() instanceof MissingMethodException) {\n                    MissingMethodException mme =  (MissingMethodException) iie.getCause();\n                    throw new MissingMethodExecutionFailed(mme.getMethod(), mme.getClass(),\n                                                            mme.getArguments(),mme.isStatic(),mme);\n                }\n                throw iie;\n            } catch (MissingMethodException mme) {\n                if (methodMissing instanceof ClosureMetaMethod)\n                    throw new MissingMethodExecutionFailed(mme.getMethod(), mme.getClass(),\n                                                        mme.getArguments(),mme.isStatic(),mme);\n                else\n                    throw mme;\n            }\n        } else if (original != null) throw original;\n        else throw new MissingMethodExceptionNoStack(methodName, theClass, arguments, false);\n    }",
            " 923  \n 924  \n 925  \n 926  \n 927  \n 928  \n 929  \n 930  \n 931  \n 932  \n 933  \n 934  \n 935  \n 936  \n 937  \n 938  \n 939  \n 940  \n 941  \n 942  \n 943  \n 944  \n 945  \n 946 +\n 947  \n 948  \n 949  \n 950  \n 951  \n 952  \n 953  \n 954  \n 955  \n 956  \n 957  \n 958  \n 959  \n 960  \n 961  \n 962  \n 963  \n 964  \n 965  \n 966  \n 967  \n 968  \n 969  \n 970  \n 971  ",
            "    private Object invokeMissingMethod(Object instance, String methodName, Object[] arguments, RuntimeException original, boolean isCallToSuper) {\n        if (!isCallToSuper) {\n            Class instanceKlazz = instance.getClass();\n            if (theClass != instanceKlazz && theClass.isAssignableFrom(instanceKlazz))\n              instanceKlazz = theClass;\n\n            Class[] argClasses = MetaClassHelper.castArgumentsToClassArray(arguments);\n\n            MetaMethod method = findMixinMethod(methodName, argClasses);\n            if(method != null) {\n                onMixinMethodFound(method);\n                return method.invoke(instance, arguments);\n            }\n\n            method = findMethodInClassHierarchy(instanceKlazz, methodName, argClasses, this);\n            if(method != null) {\n                onSuperMethodFoundInHierarchy(method);\n                return method.invoke(instance, arguments);\n            }\n\n            // still not method here, so see if there is an invokeMethod method up the hierarchy\n            final Class[] invokeMethodArgs = {String.class, Object[].class};\n            method = findMethodInClassHierarchy(instanceKlazz, INVOKE_METHOD_METHOD, invokeMethodArgs, this );\n            if(method instanceof ClosureMetaMethod) {\n                onInvokeMethodFoundInHierarchy(method);\n                return method.invoke(instance, invokeMethodArgs);\n            }\n        }\n\n        if (methodMissing != null) {\n            try {\n                return methodMissing.invoke(instance, new Object[]{methodName, arguments});\n            } catch (InvokerInvocationException iie) {\n                if (methodMissing instanceof ClosureMetaMethod && iie.getCause() instanceof MissingMethodException) {\n                    MissingMethodException mme =  (MissingMethodException) iie.getCause();\n                    throw new MissingMethodExecutionFailed(mme.getMethod(), mme.getClass(),\n                                                            mme.getArguments(),mme.isStatic(),mme);\n                }\n                throw iie;\n            } catch (MissingMethodException mme) {\n                if (methodMissing instanceof ClosureMetaMethod)\n                    throw new MissingMethodExecutionFailed(mme.getMethod(), mme.getClass(),\n                                                        mme.getArguments(),mme.isStatic(),mme);\n                else\n                    throw mme;\n            }\n        } else if (original != null) throw original;\n        else throw new MissingMethodExceptionNoStack(methodName, theClass, arguments, false);\n    }"
        ],
        [
            "Node::clone()",
            "  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82 -\n  83  \n  84  \n  85  \n  86  \n  87  ",
            "    /**\n     * Creates a new Node with the same name, no parent, shallow cloned attributes\n     * and if the value is a NodeList, a (deep) clone of those nodes.\n     *\n     * @return the clone\n     */\n    @Override\n    public Object clone() {\n        Object newValue = value;\n        if (value != null && value instanceof NodeList) {\n            NodeList nodes = (NodeList) value;\n            newValue = nodes.clone();\n        }\n        return new Node(null, name, new HashMap(attributes), newValue);\n    }",
            "  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82 +\n  83  \n  84  \n  85  \n  86  \n  87  ",
            "    /**\n     * Creates a new Node with the same name, no parent, shallow cloned attributes\n     * and if the value is a NodeList, a (deep) clone of those nodes.\n     *\n     * @return the clone\n     */\n    @Override\n    public Object clone() {\n        Object newValue = value;\n        if (value instanceof NodeList) {\n            NodeList nodes = (NodeList) value;\n            newValue = nodes.clone();\n        }\n        return new Node(null, name, new HashMap(attributes), newValue);\n    }"
        ],
        [
            "StaticTypeCheckingSupport::checkCompatibleAssignmentTypes(ClassNode,ClassNode,Expression,boolean)",
            " 666  \n 667  \n 668  \n 669  \n 670  \n 671  \n 672  \n 673  \n 674  \n 675  \n 676  \n 677  \n 678  \n 679  \n 680  \n 681  \n 682  \n 683  \n 684  \n 685  \n 686  \n 687  \n 688  \n 689  \n 690  \n 691  \n 692  \n 693  \n 694  \n 695  \n 696  \n 697  \n 698  \n 699  \n 700  \n 701  \n 702  \n 703  \n 704  \n 705 -\n 706  \n 707  \n 708  \n 709  \n 710  \n 711  \n 712  \n 713  \n 714  \n 715  \n 716  \n 717  \n 718  \n 719  \n 720  \n 721  \n 722  \n 723  \n 724  \n 725  \n 726  \n 727  \n 728  \n 729  \n 730  \n 731  \n 732  \n 733  \n 734  \n 735  \n 736  \n 737  \n 738  \n 739  \n 740  \n 741  \n 742  \n 743  \n 744  \n 745  \n 746  \n 747  \n 748  \n 749  \n 750  \n 751  \n 752  \n 753  \n 754  \n 755  \n 756  \n 757  \n 758  \n 759  \n 760  ",
            "    public static boolean checkCompatibleAssignmentTypes(ClassNode left, ClassNode right, Expression rightExpression, boolean allowConstructorCoercion) {\n        ClassNode leftRedirect = left.redirect();\n        ClassNode rightRedirect = right.redirect();\n        if (leftRedirect==rightRedirect) return true;\n\n        if (leftRedirect.isArray() && rightRedirect.isArray()) {\n            return checkCompatibleAssignmentTypes(leftRedirect.getComponentType(), rightRedirect.getComponentType(), rightExpression, false);\n        }\n\n        if (right==VOID_TYPE||right==void_WRAPPER_TYPE) {\n            return left==VOID_TYPE||left==void_WRAPPER_TYPE;\n        }\n\n        if ((isNumberType(rightRedirect)|| WideningCategories.isNumberCategory(rightRedirect))) {\n           if (BigDecimal_TYPE==leftRedirect) {\n               // any number can be assigned to a big decimal\n               return true;\n           }\n            if (BigInteger_TYPE==leftRedirect) {\n                return WideningCategories.isBigIntCategory(getUnwrapper(rightRedirect)) ||\n                        rightRedirect.isDerivedFrom(BigInteger_TYPE);\n            }\n        }\n\n        // if rightExpression is null and leftExpression is not a primitive type, it's ok\n        boolean rightExpressionIsNull = rightExpression instanceof ConstantExpression && ((ConstantExpression) rightExpression).getValue()==null;\n        if (rightExpressionIsNull && !isPrimitiveType(left)) {\n            return true;\n        }\n\n        // on an assignment everything that can be done by a GroovyCast is allowed\n\n        // anything can be assigned to an Object, String, Boolean\n        // or Class typed variable\n        if (isWildcardLeftHandSide(leftRedirect)\n                && !(boolean_TYPE.equals(left) && rightExpressionIsNull)) return true;\n\n        // char as left expression\n        if (leftRedirect == char_TYPE && rightRedirect==STRING_TYPE) {\n            if (rightExpression!=null && rightExpression instanceof ConstantExpression) {\n                String value = rightExpression.getText();\n                return value.length()==1;\n            }\n        }\n        if (leftRedirect == Character_TYPE && (rightRedirect==STRING_TYPE||rightExpressionIsNull)) {\n            return rightExpressionIsNull || (rightExpression instanceof ConstantExpression && rightExpression.getText().length()==1);\n        }\n\n        // if left is Enum and right is String or GString we do valueOf\n        if (leftRedirect.isDerivedFrom(Enum_Type) &&\n                (rightRedirect == GSTRING_TYPE || rightRedirect == STRING_TYPE)) {\n            return true;\n        }\n\n        // if right is array, map or collection we try invoking the\n        // constructor\n        if (allowConstructorCoercion && isGroovyConstructorCompatible(rightExpression)) {\n            //TODO: in case of the array we could maybe make a partial check\n            if (leftRedirect.isArray() && rightRedirect.isArray()) {\n                return checkCompatibleAssignmentTypes(leftRedirect.getComponentType(), rightRedirect.getComponentType());\n            } else if (rightRedirect.isArray() && !leftRedirect.isArray()) {\n                return false;\n            }\n            return true;\n        }\n\n        // simple check on being subclass\n        if (right.isDerivedFrom(left) || (left.isInterface() && right.implementsInterface(left))) return true;\n\n        // if left and right are primitives or numbers allow\n        if (isPrimitiveType(leftRedirect) && isPrimitiveType(rightRedirect)) return true;\n        if (isNumberType(leftRedirect) && isNumberType(rightRedirect)) return true;\n\n        // left is a float/double and right is a BigDecimal\n        if (WideningCategories.isFloatingCategory(leftRedirect) && BigDecimal_TYPE.equals(rightRedirect)) {\n            return true;\n        }\n\n        if (GROOVY_OBJECT_TYPE.equals(leftRedirect) && isBeingCompiled(right)) {\n            return true;\n        }\n\n        if (left.isGenericsPlaceHolder()) {\n            // GROOVY-7307\n            GenericsType[] genericsTypes = left.getGenericsTypes();\n            if (genericsTypes!=null && genericsTypes.length==1) {\n                // should always be the case, but safe guard is better\n                return genericsTypes[0].isCompatibleWith(right);\n            }\n        }\n\n        // GROOVY-7316 : it is an apparently legal thing to allow this. It's not type safe,\n        // but it is allowed...\n        return right.isGenericsPlaceHolder();\n    }",
            " 666  \n 667  \n 668  \n 669  \n 670  \n 671  \n 672  \n 673  \n 674  \n 675  \n 676  \n 677  \n 678  \n 679  \n 680  \n 681  \n 682  \n 683  \n 684  \n 685  \n 686  \n 687  \n 688  \n 689  \n 690  \n 691  \n 692  \n 693  \n 694  \n 695  \n 696  \n 697  \n 698  \n 699  \n 700  \n 701  \n 702  \n 703  \n 704  \n 705 +\n 706  \n 707  \n 708  \n 709  \n 710  \n 711  \n 712  \n 713  \n 714  \n 715  \n 716  \n 717  \n 718  \n 719  \n 720  \n 721  \n 722  \n 723  \n 724  \n 725  \n 726  \n 727  \n 728  \n 729  \n 730  \n 731  \n 732  \n 733  \n 734  \n 735  \n 736  \n 737  \n 738  \n 739  \n 740  \n 741  \n 742  \n 743  \n 744  \n 745  \n 746  \n 747  \n 748  \n 749  \n 750  \n 751  \n 752  \n 753  \n 754  \n 755  \n 756  \n 757  \n 758  \n 759  \n 760  ",
            "    public static boolean checkCompatibleAssignmentTypes(ClassNode left, ClassNode right, Expression rightExpression, boolean allowConstructorCoercion) {\n        ClassNode leftRedirect = left.redirect();\n        ClassNode rightRedirect = right.redirect();\n        if (leftRedirect==rightRedirect) return true;\n\n        if (leftRedirect.isArray() && rightRedirect.isArray()) {\n            return checkCompatibleAssignmentTypes(leftRedirect.getComponentType(), rightRedirect.getComponentType(), rightExpression, false);\n        }\n\n        if (right==VOID_TYPE||right==void_WRAPPER_TYPE) {\n            return left==VOID_TYPE||left==void_WRAPPER_TYPE;\n        }\n\n        if ((isNumberType(rightRedirect)|| WideningCategories.isNumberCategory(rightRedirect))) {\n           if (BigDecimal_TYPE==leftRedirect) {\n               // any number can be assigned to a big decimal\n               return true;\n           }\n            if (BigInteger_TYPE==leftRedirect) {\n                return WideningCategories.isBigIntCategory(getUnwrapper(rightRedirect)) ||\n                        rightRedirect.isDerivedFrom(BigInteger_TYPE);\n            }\n        }\n\n        // if rightExpression is null and leftExpression is not a primitive type, it's ok\n        boolean rightExpressionIsNull = rightExpression instanceof ConstantExpression && ((ConstantExpression) rightExpression).getValue()==null;\n        if (rightExpressionIsNull && !isPrimitiveType(left)) {\n            return true;\n        }\n\n        // on an assignment everything that can be done by a GroovyCast is allowed\n\n        // anything can be assigned to an Object, String, Boolean\n        // or Class typed variable\n        if (isWildcardLeftHandSide(leftRedirect)\n                && !(boolean_TYPE.equals(left) && rightExpressionIsNull)) return true;\n\n        // char as left expression\n        if (leftRedirect == char_TYPE && rightRedirect==STRING_TYPE) {\n            if (rightExpression instanceof ConstantExpression) {\n                String value = rightExpression.getText();\n                return value.length()==1;\n            }\n        }\n        if (leftRedirect == Character_TYPE && (rightRedirect==STRING_TYPE||rightExpressionIsNull)) {\n            return rightExpressionIsNull || (rightExpression instanceof ConstantExpression && rightExpression.getText().length()==1);\n        }\n\n        // if left is Enum and right is String or GString we do valueOf\n        if (leftRedirect.isDerivedFrom(Enum_Type) &&\n                (rightRedirect == GSTRING_TYPE || rightRedirect == STRING_TYPE)) {\n            return true;\n        }\n\n        // if right is array, map or collection we try invoking the\n        // constructor\n        if (allowConstructorCoercion && isGroovyConstructorCompatible(rightExpression)) {\n            //TODO: in case of the array we could maybe make a partial check\n            if (leftRedirect.isArray() && rightRedirect.isArray()) {\n                return checkCompatibleAssignmentTypes(leftRedirect.getComponentType(), rightRedirect.getComponentType());\n            } else if (rightRedirect.isArray() && !leftRedirect.isArray()) {\n                return false;\n            }\n            return true;\n        }\n\n        // simple check on being subclass\n        if (right.isDerivedFrom(left) || (left.isInterface() && right.implementsInterface(left))) return true;\n\n        // if left and right are primitives or numbers allow\n        if (isPrimitiveType(leftRedirect) && isPrimitiveType(rightRedirect)) return true;\n        if (isNumberType(leftRedirect) && isNumberType(rightRedirect)) return true;\n\n        // left is a float/double and right is a BigDecimal\n        if (WideningCategories.isFloatingCategory(leftRedirect) && BigDecimal_TYPE.equals(rightRedirect)) {\n            return true;\n        }\n\n        if (GROOVY_OBJECT_TYPE.equals(leftRedirect) && isBeingCompiled(right)) {\n            return true;\n        }\n\n        if (left.isGenericsPlaceHolder()) {\n            // GROOVY-7307\n            GenericsType[] genericsTypes = left.getGenericsTypes();\n            if (genericsTypes!=null && genericsTypes.length==1) {\n                // should always be the case, but safe guard is better\n                return genericsTypes[0].isCompatibleWith(right);\n            }\n        }\n\n        // GROOVY-7316 : it is an apparently legal thing to allow this. It's not type safe,\n        // but it is allowed...\n        return right.isGenericsPlaceHolder();\n    }"
        ],
        [
            "AbstractASTTransformation::getMemberStringValue(AnnotationNode,String,String)",
            " 106  \n 107  \n 108 -\n 109  \n 110 -\n 111  \n 112  \n 113  \n 114  ",
            "    public static String getMemberStringValue(AnnotationNode node, String name, String defaultValue) {\r\n        final Expression member = node.getMember(name);\r\n        if (member != null && member instanceof ConstantExpression) {\r\n            Object result = ((ConstantExpression) member).getValue();\r\n            if (result != null && result instanceof String && isUndefined((String) result)) result = null;\r\n            if (result != null) return result.toString();\r\n        }\r\n        return defaultValue;\r\n    }\r",
            " 106  \n 107  \n 108 +\n 109  \n 110 +\n 111  \n 112  \n 113  \n 114  ",
            "    public static String getMemberStringValue(AnnotationNode node, String name, String defaultValue) {\r\n        final Expression member = node.getMember(name);\r\n        if (member instanceof ConstantExpression) {\r\n            Object result = ((ConstantExpression) member).getValue();\r\n            if (result instanceof String && isUndefined((String) result)) result = null;\r\n            if (result != null) return result.toString();\r\n        }\r\n        return defaultValue;\r\n    }\r"
        ],
        [
            "ObservableList::addAll(int,Collection)",
            " 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178 -\n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  ",
            "    public boolean addAll(int index, Collection c) {\n        int oldSize = size();\n        boolean success = delegate.addAll(index, c);\n\n        if (success && c != null) {\n            List values = new ArrayList();\n            for (Object element : c) {\n                if (test != null) {\n                    Object result = test.call(element);\n                    if (result != null && result instanceof Boolean && (Boolean) result) {\n                        values.add(element);\n                    }\n                } else {\n                    values.add(element);\n                }\n            }\n            if (!values.isEmpty()) {\n                fireMultiElementAddedEvent(index, values);\n                fireSizeChangedEvent(oldSize, size());\n            }\n        }\n\n        return success;\n    }",
            " 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178 +\n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  ",
            "    public boolean addAll(int index, Collection c) {\n        int oldSize = size();\n        boolean success = delegate.addAll(index, c);\n\n        if (success && c != null) {\n            List values = new ArrayList();\n            for (Object element : c) {\n                if (test != null) {\n                    Object result = test.call(element);\n                    if (result instanceof Boolean && (Boolean) result) {\n                        values.add(element);\n                    }\n                } else {\n                    values.add(element);\n                }\n            }\n            if (!values.isEmpty()) {\n                fireMultiElementAddedEvent(index, values);\n                fireSizeChangedEvent(oldSize, size());\n            }\n        }\n\n        return success;\n    }"
        ],
        [
            "StaticTypeCheckingVisitor::checkClosureWithDelegatesTo(ClassNode,MethodNode,ArgumentListExpression,Parameter,Expression,Parameter)",
            "2842  \n2843  \n2844  \n2845  \n2846  \n2847  \n2848  \n2849  \n2850  \n2851  \n2852  \n2853  \n2854  \n2855  \n2856  \n2857  \n2858  \n2859  \n2860  \n2861  \n2862  \n2863  \n2864  \n2865  \n2866  \n2867  \n2868  \n2869  \n2870  \n2871  \n2872  \n2873  \n2874  \n2875  \n2876  \n2877  \n2878  \n2879  \n2880  \n2881  \n2882  \n2883  \n2884  \n2885  \n2886  \n2887  \n2888 -\n2889  \n2890  \n2891  \n2892  \n2893  \n2894  \n2895  \n2896 -\n2897  \n2898  \n2899  \n2900  \n2901 -\n2902  \n2903  \n2904  \n2905  \n2906  \n2907  \n2908  \n2909  \n2910  \n2911  \n2912  \n2913  \n2914  \n2915  \n2916  \n2917  \n2918  \n2919  \n2920  \n2921  \n2922  \n2923  \n2924  \n2925  \n2926  \n2927  \n2928  \n2929  \n2930  \n2931  \n2932  \n2933  ",
            "    private void checkClosureWithDelegatesTo(final ClassNode receiver,\n                                             final MethodNode mn,\n                                             final ArgumentListExpression arguments,\n                                             final Parameter[] params,\n                                             final Expression expression,\n                                             final Parameter param) {\n        List<AnnotationNode> annotations = param.getAnnotations(DELEGATES_TO);\n        if (annotations!=null && !annotations.isEmpty()) {\n            for (AnnotationNode annotation : annotations) {\n                // in theory, there can only be one annotation of that type\n                Expression value = annotation.getMember(\"value\");\n                Expression strategy = annotation.getMember(\"strategy\");\n                Expression genericTypeIndex = annotation.getMember(\"genericTypeIndex\");\n                Expression type = annotation.getMember(\"type\");\n                Integer stInt = Closure.OWNER_FIRST;\n                if (strategy!=null) {\n                    stInt = (Integer) evaluateExpression(castX(ClassHelper.Integer_TYPE,strategy), typeCheckingContext.source.getConfiguration());\n                }\n                if (value instanceof ClassExpression && !value.getType().equals(DELEGATES_TO_TARGET)) {\n                    if (genericTypeIndex!=null) {\n                        addStaticTypeError(\"Cannot use @DelegatesTo(genericTypeIndex=\"+genericTypeIndex.getText()\n                                +\") without @DelegatesTo.Target because generic argument types are not available at runtime\", value);\n                    }\n                    // temporarily store the delegation strategy and the delegate type\n                    expression.putNodeMetaData(StaticTypesMarker.DELEGATION_METADATA, new DelegationMetadata(value.getType(), stInt, typeCheckingContext.delegationMetadata));\n                } else if (type!=null && !\"\".equals(type.getText()) && type instanceof ConstantExpression) {\n                    String typeString = type.getText();\n                    ClassNode[] resolved = GenericsUtils.parseClassNodesFromString(\n                            typeString,\n                            getSourceUnit(),\n                            typeCheckingContext.compilationUnit,\n                            mn,\n                            type\n                    );\n                    if (resolved!=null) {\n                        if (resolved.length==1) {\n                            resolved = resolveGenericsFromTypeHint(receiver, arguments, mn, resolved );\n                            expression.putNodeMetaData(StaticTypesMarker.DELEGATION_METADATA, new DelegationMetadata(resolved[0], stInt, typeCheckingContext.delegationMetadata));\n                        } else {\n                            addStaticTypeError(\"Incorrect type hint found in method \" + (mn), type);\n                        }\n                    }\n                } else {\n                    final List<Expression> expressions = arguments.getExpressions();\n                    final int expressionsSize = expressions.size();\n                    Expression parameter = annotation.getMember(\"target\");\n                    String parameterName = parameter!=null && parameter instanceof ConstantExpression ?parameter.getText():\"\";\n                    // todo: handle vargs!\n                    for (int j = 0, paramsLength = params.length; j < paramsLength; j++) {\n                        final Parameter methodParam = params[j];\n                        List<AnnotationNode> targets = methodParam.getAnnotations(DELEGATES_TO_TARGET);\n                        if (targets != null && targets.size() == 1) {\n                            AnnotationNode targetAnnotation = targets.get(0); // @DelegatesTo.Target Obj foo\n                            Expression idMember = targetAnnotation.getMember(\"value\");\n                            String id = idMember != null && idMember instanceof ConstantExpression ? idMember.getText() : \"\";\n                            if (id.equals(parameterName)) {\n                                if (j < expressionsSize) {\n                                    Expression actualArgument = expressions.get(j);\n                                    ClassNode actualType = getType(actualArgument);\n                                    if (genericTypeIndex!=null && genericTypeIndex instanceof ConstantExpression) {\n                                        int gti = Integer.parseInt(genericTypeIndex.getText());\n                                        ClassNode paramType = methodParam.getType(); // type annotated with @DelegatesTo.Target\n                                        GenericsType[] genericsTypes = paramType.getGenericsTypes();\n                                        if (genericsTypes==null) {\n                                            addStaticTypeError(\"Cannot use @DelegatesTo(genericTypeIndex=\"+genericTypeIndex.getText()\n                                                + \") with a type that doesn't use generics\", methodParam);\n                                        } else if (gti<0 || gti>=genericsTypes.length) {\n                                            addStaticTypeError(\"Index of generic type @DelegatesTo(genericTypeIndex=\"+genericTypeIndex.getText()\n                                                    + \") \"+(gti<0?\"lower\":\"greater\")+\" than those of the selected type\", methodParam);\n                                        } else {\n                                            ClassNode pType = GenericsUtils.parameterizeType(actualType, paramType);\n                                            GenericsType[] pTypeGenerics = pType.getGenericsTypes();\n                                            if (pTypeGenerics!=null && pTypeGenerics.length>gti) {\n                                                actualType = pTypeGenerics[gti].getType();\n                                            } else {\n                                                addStaticTypeError(\"Unable to map actual type [\"+actualType.toString(false)+\"] onto \"+paramType.toString(false), methodParam);\n                                            }\n                                        }\n                                    }\n                                    expression.putNodeMetaData(StaticTypesMarker.DELEGATION_METADATA, new DelegationMetadata(actualType, stInt, typeCheckingContext.delegationMetadata));\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    if (expression.getNodeMetaData(StaticTypesMarker.DELEGATION_METADATA)==null) {\n                        addError(\"Not enough arguments found for a @DelegatesTo method call. Please check that you either use an explicit class or @DelegatesTo.Target with a correct id\", arguments);\n                    }\n                }\n            }\n        }\n    }",
            "2842  \n2843  \n2844  \n2845  \n2846  \n2847  \n2848  \n2849  \n2850  \n2851  \n2852  \n2853  \n2854  \n2855  \n2856  \n2857  \n2858  \n2859  \n2860  \n2861  \n2862  \n2863  \n2864  \n2865  \n2866  \n2867  \n2868  \n2869  \n2870  \n2871  \n2872  \n2873  \n2874  \n2875  \n2876  \n2877  \n2878  \n2879  \n2880  \n2881  \n2882  \n2883  \n2884  \n2885  \n2886  \n2887  \n2888 +\n2889  \n2890  \n2891  \n2892  \n2893  \n2894  \n2895  \n2896 +\n2897  \n2898  \n2899  \n2900  \n2901 +\n2902  \n2903  \n2904  \n2905  \n2906  \n2907  \n2908  \n2909  \n2910  \n2911  \n2912  \n2913  \n2914  \n2915  \n2916  \n2917  \n2918  \n2919  \n2920  \n2921  \n2922  \n2923  \n2924  \n2925  \n2926  \n2927  \n2928  \n2929  \n2930  \n2931  \n2932  \n2933  ",
            "    private void checkClosureWithDelegatesTo(final ClassNode receiver,\n                                             final MethodNode mn,\n                                             final ArgumentListExpression arguments,\n                                             final Parameter[] params,\n                                             final Expression expression,\n                                             final Parameter param) {\n        List<AnnotationNode> annotations = param.getAnnotations(DELEGATES_TO);\n        if (annotations!=null && !annotations.isEmpty()) {\n            for (AnnotationNode annotation : annotations) {\n                // in theory, there can only be one annotation of that type\n                Expression value = annotation.getMember(\"value\");\n                Expression strategy = annotation.getMember(\"strategy\");\n                Expression genericTypeIndex = annotation.getMember(\"genericTypeIndex\");\n                Expression type = annotation.getMember(\"type\");\n                Integer stInt = Closure.OWNER_FIRST;\n                if (strategy!=null) {\n                    stInt = (Integer) evaluateExpression(castX(ClassHelper.Integer_TYPE,strategy), typeCheckingContext.source.getConfiguration());\n                }\n                if (value instanceof ClassExpression && !value.getType().equals(DELEGATES_TO_TARGET)) {\n                    if (genericTypeIndex!=null) {\n                        addStaticTypeError(\"Cannot use @DelegatesTo(genericTypeIndex=\"+genericTypeIndex.getText()\n                                +\") without @DelegatesTo.Target because generic argument types are not available at runtime\", value);\n                    }\n                    // temporarily store the delegation strategy and the delegate type\n                    expression.putNodeMetaData(StaticTypesMarker.DELEGATION_METADATA, new DelegationMetadata(value.getType(), stInt, typeCheckingContext.delegationMetadata));\n                } else if (type!=null && !\"\".equals(type.getText()) && type instanceof ConstantExpression) {\n                    String typeString = type.getText();\n                    ClassNode[] resolved = GenericsUtils.parseClassNodesFromString(\n                            typeString,\n                            getSourceUnit(),\n                            typeCheckingContext.compilationUnit,\n                            mn,\n                            type\n                    );\n                    if (resolved!=null) {\n                        if (resolved.length==1) {\n                            resolved = resolveGenericsFromTypeHint(receiver, arguments, mn, resolved );\n                            expression.putNodeMetaData(StaticTypesMarker.DELEGATION_METADATA, new DelegationMetadata(resolved[0], stInt, typeCheckingContext.delegationMetadata));\n                        } else {\n                            addStaticTypeError(\"Incorrect type hint found in method \" + (mn), type);\n                        }\n                    }\n                } else {\n                    final List<Expression> expressions = arguments.getExpressions();\n                    final int expressionsSize = expressions.size();\n                    Expression parameter = annotation.getMember(\"target\");\n                    String parameterName = parameter instanceof ConstantExpression ?parameter.getText():\"\";\n                    // todo: handle vargs!\n                    for (int j = 0, paramsLength = params.length; j < paramsLength; j++) {\n                        final Parameter methodParam = params[j];\n                        List<AnnotationNode> targets = methodParam.getAnnotations(DELEGATES_TO_TARGET);\n                        if (targets != null && targets.size() == 1) {\n                            AnnotationNode targetAnnotation = targets.get(0); // @DelegatesTo.Target Obj foo\n                            Expression idMember = targetAnnotation.getMember(\"value\");\n                            String id = idMember instanceof ConstantExpression ? idMember.getText() : \"\";\n                            if (id.equals(parameterName)) {\n                                if (j < expressionsSize) {\n                                    Expression actualArgument = expressions.get(j);\n                                    ClassNode actualType = getType(actualArgument);\n                                    if (genericTypeIndex instanceof ConstantExpression) {\n                                        int gti = Integer.parseInt(genericTypeIndex.getText());\n                                        ClassNode paramType = methodParam.getType(); // type annotated with @DelegatesTo.Target\n                                        GenericsType[] genericsTypes = paramType.getGenericsTypes();\n                                        if (genericsTypes==null) {\n                                            addStaticTypeError(\"Cannot use @DelegatesTo(genericTypeIndex=\"+genericTypeIndex.getText()\n                                                + \") with a type that doesn't use generics\", methodParam);\n                                        } else if (gti<0 || gti>=genericsTypes.length) {\n                                            addStaticTypeError(\"Index of generic type @DelegatesTo(genericTypeIndex=\"+genericTypeIndex.getText()\n                                                    + \") \"+(gti<0?\"lower\":\"greater\")+\" than those of the selected type\", methodParam);\n                                        } else {\n                                            ClassNode pType = GenericsUtils.parameterizeType(actualType, paramType);\n                                            GenericsType[] pTypeGenerics = pType.getGenericsTypes();\n                                            if (pTypeGenerics!=null && pTypeGenerics.length>gti) {\n                                                actualType = pTypeGenerics[gti].getType();\n                                            } else {\n                                                addStaticTypeError(\"Unable to map actual type [\"+actualType.toString(false)+\"] onto \"+paramType.toString(false), methodParam);\n                                            }\n                                        }\n                                    }\n                                    expression.putNodeMetaData(StaticTypesMarker.DELEGATION_METADATA, new DelegationMetadata(actualType, stInt, typeCheckingContext.delegationMetadata));\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    if (expression.getNodeMetaData(StaticTypesMarker.DELEGATION_METADATA)==null) {\n                        addError(\"Not enough arguments found for a @DelegatesTo method call. Please check that you either use an explicit class or @DelegatesTo.Target with a correct id\", arguments);\n                    }\n                }\n            }\n        }\n    }"
        ],
        [
            "AbstractASTTransformation::getClassList(AnnotationNode,String)",
            " 201  \n 202  \n 203  \n 204  \n 205 -\n 206  \n 207  \n 208 -\n 209  \n 210  \n 211  \n 212  \n 213  ",
            "    @Deprecated\r\n    public List<ClassNode> getClassList(AnnotationNode anno, String name) {\r\n        List<ClassNode> list = new ArrayList<ClassNode>();\r\n        Expression expr = anno.getMember(name);\r\n        if (expr != null && expr instanceof ListExpression) {\r\n            final ListExpression listExpression = (ListExpression) expr;\r\n            list = getTypeList(listExpression);\r\n        } else if (expr != null && expr instanceof ClassExpression) {\r\n            ClassNode cn = expr.getType();\r\n            if (cn != null) list.add(cn);\r\n        }\r\n        return list;\r\n    }\r",
            " 201  \n 202  \n 203  \n 204  \n 205 +\n 206  \n 207  \n 208 +\n 209  \n 210  \n 211  \n 212  \n 213  ",
            "    @Deprecated\r\n    public List<ClassNode> getClassList(AnnotationNode anno, String name) {\r\n        List<ClassNode> list = new ArrayList<ClassNode>();\r\n        Expression expr = anno.getMember(name);\r\n        if (expr instanceof ListExpression) {\r\n            final ListExpression listExpression = (ListExpression) expr;\r\n            list = getTypeList(listExpression);\r\n        } else if (expr instanceof ClassExpression) {\r\n            ClassNode cn = expr.getType();\r\n            if (cn != null) list.add(cn);\r\n        }\r\n        return list;\r\n    }\r"
        ],
        [
            "ErrorCollector::getSyntaxError(int)",
            " 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245 -\n 246  \n 247  \n 248  \n 249  ",
            "    /**\n     * Convenience routine to return the specified error's\n     * underlying SyntaxException, or null if it isn't one.\n     */\n    public SyntaxException getSyntaxError(int index) {\n        SyntaxException exception = null;\n\n        Message message = getError(index);\n        if (message != null && message instanceof SyntaxErrorMessage) {\n            exception = ((SyntaxErrorMessage) message).getCause();\n        }\n        return exception;\n    }",
            " 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245 +\n 246  \n 247  \n 248  \n 249  ",
            "    /**\n     * Convenience routine to return the specified error's\n     * underlying SyntaxException, or null if it isn't one.\n     */\n    public SyntaxException getSyntaxError(int index) {\n        SyntaxException exception = null;\n\n        Message message = getError(index);\n        if (message instanceof SyntaxErrorMessage) {\n            exception = ((SyntaxErrorMessage) message).getCause();\n        }\n        return exception;\n    }"
        ],
        [
            "ListExpressionTransformer::transformListExpression(ListExpression)",
            "  42  \n  43  \n  44 -\n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  ",
            "    Expression transformListExpression(final ListExpression expr) {\n        MethodNode target = expr.getNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET);\n        if (target!=null && target instanceof ConstructorNode) {\n            if (target.getDeclaringClass().isArray()) {\n                return transformArrayConstructor(expr, target);\n            }\n            return transformRegularConstructor(expr, target);\n\n        } else {\n            return transformer.superTransform(expr);\n        }\n    }",
            "  42  \n  43  \n  44 +\n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  ",
            "    Expression transformListExpression(final ListExpression expr) {\n        MethodNode target = expr.getNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET);\n        if (target instanceof ConstructorNode) {\n            if (target.getDeclaringClass().isArray()) {\n                return transformArrayConstructor(expr, target);\n            }\n            return transformRegularConstructor(expr, target);\n\n        } else {\n            return transformer.superTransform(expr);\n        }\n    }"
        ],
        [
            "ObservableMap::put(Object,Object)",
            " 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192 -\n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  ",
            "    public Object put(Object key, Object value) {\n        int oldSize = size();\n        Object oldValue = null;\n        boolean newKey = !delegate.containsKey(key);\n        if (test != null) {\n            oldValue = delegate.put(key, value);\n            Object result = null;\n            if (test.getMaximumNumberOfParameters() == 2) {\n                result = test.call(key, value);\n            } else {\n                result = test.call(value);\n            }\n            if (result != null && result instanceof Boolean && (Boolean) result) {\n                if (newKey) {\n                    firePropertyAddedEvent(key, value);\n                    fireSizeChangedEvent(oldSize, size());\n                } else if (oldValue != value) {\n                    firePropertyUpdatedEvent(key, oldValue, value);\n                }\n            }\n        } else {\n            oldValue = delegate.put(key, value);\n            if (newKey) {\n                firePropertyAddedEvent(key, value);\n                fireSizeChangedEvent(oldSize, size());\n            } else if (oldValue != value) {\n                firePropertyUpdatedEvent(key, oldValue, value);\n            }\n        }\n        return oldValue;\n    }",
            " 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192 +\n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  ",
            "    public Object put(Object key, Object value) {\n        int oldSize = size();\n        Object oldValue = null;\n        boolean newKey = !delegate.containsKey(key);\n        if (test != null) {\n            oldValue = delegate.put(key, value);\n            Object result = null;\n            if (test.getMaximumNumberOfParameters() == 2) {\n                result = test.call(key, value);\n            } else {\n                result = test.call(value);\n            }\n            if (result instanceof Boolean && (Boolean) result) {\n                if (newKey) {\n                    firePropertyAddedEvent(key, value);\n                    fireSizeChangedEvent(oldSize, size());\n                } else if (oldValue != value) {\n                    firePropertyUpdatedEvent(key, oldValue, value);\n                }\n            }\n        } else {\n            oldValue = delegate.put(key, value);\n            if (newKey) {\n                firePropertyAddedEvent(key, value);\n                fireSizeChangedEvent(oldSize, size());\n            } else if (oldValue != value) {\n                firePropertyUpdatedEvent(key, oldValue, value);\n            }\n        }\n        return oldValue;\n    }"
        ],
        [
            "TraitTypeCheckingExtension::handleMissingMethod(ClassNode,String,ArgumentListExpression,ClassNode,MethodCall)",
            "  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80 -\n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  ",
            "    @Override\n    public List<MethodNode> handleMissingMethod(final ClassNode receiver, final String name, final ArgumentListExpression argumentList, final ClassNode[] argumentTypes, final MethodCall call) {\n        String[] decomposed = Traits.decomposeSuperCallName(name);\n        if (decomposed != null) {\n            return convertToDynamicCall(call, receiver, decomposed, argumentTypes);\n        }\n        if (call instanceof MethodCallExpression) {\n            MethodCallExpression mce = (MethodCallExpression) call;\n            if (mce.getReceiver() instanceof VariableExpression) {\n                VariableExpression var = (VariableExpression) mce.getReceiver();\n\n                // GROOVY-7322\n                // static method call in trait?\n                ClassNode type = null;\n                if (isStaticTraitReceiver(receiver, var)) {\n                    type = receiver.getGenericsTypes()[0].getType();\n                } else if (isThisTraitReceiver(var)) {\n                    type = receiver;\n                }\n                if (type != null && Traits.isTrait(type) && !(type instanceof UnionTypeClassNode)) {\n                    ClassNode helper = Traits.findHelper(type);\n                    Parameter[] params = new Parameter[argumentTypes.length + 1];\n                    params[0] = new Parameter(ClassHelper.CLASS_Type.getPlainNodeReference(), \"staticSelf\");\n                    for (int i = 1; i < params.length; i++) {\n                        params[i] = new Parameter(argumentTypes[i-1], \"p\" + i);\n                    }\n                    MethodNode method = helper.getDeclaredMethod(name, params);\n                    if (method != null) {\n                        return Collections.singletonList(makeDynamic(call, method.getReturnType()));\n                    }\n                }\n            }\n\n            ClassNode dynamic = mce.getNodeMetaData(TraitASTTransformation.DO_DYNAMIC);\n            if (dynamic!=null) {\n                return Collections.singletonList(makeDynamic(call, dynamic));\n            }\n        }\n        return NOTFOUND;\n    }",
            "  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80 +\n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  ",
            "    @Override\n    public List<MethodNode> handleMissingMethod(final ClassNode receiver, final String name, final ArgumentListExpression argumentList, final ClassNode[] argumentTypes, final MethodCall call) {\n        String[] decomposed = Traits.decomposeSuperCallName(name);\n        if (decomposed != null) {\n            return convertToDynamicCall(call, receiver, decomposed, argumentTypes);\n        }\n        if (call instanceof MethodCallExpression) {\n            MethodCallExpression mce = (MethodCallExpression) call;\n            if (mce.getReceiver() instanceof VariableExpression) {\n                VariableExpression var = (VariableExpression) mce.getReceiver();\n\n                // GROOVY-7322\n                // static method call in trait?\n                ClassNode type = null;\n                if (isStaticTraitReceiver(receiver, var)) {\n                    type = receiver.getGenericsTypes()[0].getType();\n                } else if (isThisTraitReceiver(var)) {\n                    type = receiver;\n                }\n                if (Traits.isTrait(type) && !(type instanceof UnionTypeClassNode)) {\n                    ClassNode helper = Traits.findHelper(type);\n                    Parameter[] params = new Parameter[argumentTypes.length + 1];\n                    params[0] = new Parameter(ClassHelper.CLASS_Type.getPlainNodeReference(), \"staticSelf\");\n                    for (int i = 1; i < params.length; i++) {\n                        params[i] = new Parameter(argumentTypes[i-1], \"p\" + i);\n                    }\n                    MethodNode method = helper.getDeclaredMethod(name, params);\n                    if (method != null) {\n                        return Collections.singletonList(makeDynamic(call, method.getReturnType()));\n                    }\n                }\n            }\n\n            ClassNode dynamic = mce.getNodeMetaData(TraitASTTransformation.DO_DYNAMIC);\n            if (dynamic!=null) {\n                return Collections.singletonList(makeDynamic(call, dynamic));\n            }\n        }\n        return NOTFOUND;\n    }"
        ],
        [
            "Expando::toString()",
            " 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118 -\n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  ",
            "    /**\n     * This allows toString to be overridden by a closure <i>field</i> method attached\n     * to the expando object.\n     *\n     * @see java.lang.Object#toString()\n     */\n    public String toString() {\n        Object method = getProperties().get(\"toString\");\n        if (method != null && method instanceof Closure) {\n            // invoke overridden toString closure method\n            Closure closure = (Closure) method;\n            closure.setDelegate(this);\n            return closure.call().toString();\n        } else {\n            return expandoProperties.toString();\n        }\n    }",
            " 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118 +\n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  ",
            "    /**\n     * This allows toString to be overridden by a closure <i>field</i> method attached\n     * to the expando object.\n     *\n     * @see java.lang.Object#toString()\n     */\n    public String toString() {\n        Object method = getProperties().get(\"toString\");\n        if (method instanceof Closure) {\n            // invoke overridden toString closure method\n            Closure closure = (Closure) method;\n            closure.setDelegate(this);\n            return closure.call().toString();\n        } else {\n            return expandoProperties.toString();\n        }\n    }"
        ],
        [
            "GrabAnnotationTransformation::checkForInitContextClassLoader(AnnotationNode)",
            " 479  \n 480  \n 481 -\n 482  \n 483  \n 484  \n 485  ",
            "    private void checkForInitContextClassLoader(AnnotationNode node) {\n        Object val = node.getMember(\"initContextClassLoader\");\n        if (val == null || !(val instanceof ConstantExpression)) return;\n        Object initContextClassLoaderObject = ((ConstantExpression)val).getValue();\n        if (!(initContextClassLoaderObject instanceof Boolean)) return;\n        initContextClassLoader = (Boolean) initContextClassLoaderObject;\n    }",
            " 479  \n 480  \n 481 +\n 482  \n 483  \n 484  \n 485  ",
            "    private void checkForInitContextClassLoader(AnnotationNode node) {\n        Object val = node.getMember(\"initContextClassLoader\");\n        if (!(val instanceof ConstantExpression)) return;\n        Object initContextClassLoaderObject = ((ConstantExpression)val).getValue();\n        if (!(initContextClassLoaderObject instanceof Boolean)) return;\n        initContextClassLoader = (Boolean) initContextClassLoaderObject;\n    }"
        ],
        [
            "AbstractASTTransformation::memberHasValue(AnnotationNode,String,Object)",
            "  95  \n  96  \n  97 -\n  98  ",
            "    public boolean memberHasValue(AnnotationNode node, String name, Object value) {\r\n        final Expression member = node.getMember(name);\r\n        return member != null && member instanceof ConstantExpression && ((ConstantExpression) member).getValue().equals(value);\r\n    }\r",
            "  95  \n  96  \n  97 +\n  98  ",
            "    public boolean memberHasValue(AnnotationNode node, String name, Object value) {\r\n        final Expression member = node.getMember(name);\r\n        return member instanceof ConstantExpression && ((ConstantExpression) member).getValue().equals(value);\r\n    }\r"
        ],
        [
            "ClassCompletionVerifier::checkNoStaticMethodWithSameSignatureAsNonStatic(ClassNode)",
            " 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152 -\n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  ",
            "    private void checkNoStaticMethodWithSameSignatureAsNonStatic(final ClassNode node) {\n        ClassNode parent = node.getSuperClass();\n        Map<String, MethodNode> result;\n        // start with methods from the parent if any\n        if (parent != null) {\n            result = parent.getDeclaredMethodsMap();\n        } else {\n            result = new HashMap<String, MethodNode>();\n        }\n        // add in unimplemented abstract methods from the interfaces\n        ClassNodeUtils.addDeclaredMethodsFromInterfaces(node, result);\n        for (MethodNode methodNode : node.getMethods()) {\n            MethodNode mn = result.get(methodNode.getTypeDescriptor());\n            if (mn != null && (mn.isStatic() ^ methodNode.isStatic()) && !methodNode.isStaticConstructor()) {\n                if (!mn.isAbstract()) continue;\n                ClassNode declaringClass = mn.getDeclaringClass();\n                ClassNode cn = declaringClass.getOuterClass();\n                if (cn == null && declaringClass.isResolved()) {\n                    // in case of a precompiled class, the outerclass is unknown\n                    Class typeClass = declaringClass.getTypeClass();\n                    typeClass = typeClass.getEnclosingClass();\n                    if (typeClass != null) {\n                        cn = ClassHelper.make(typeClass);\n                    }\n                }\n                if (cn == null || !Traits.isTrait(cn)) {\n                    ASTNode errorNode = methodNode;\n                    String name = mn.getName();\n                    if (errorNode.getLineNumber() == -1) {\n                        // try to get a better error message location based on the property\n                        for (PropertyNode propertyNode : node.getProperties()) {\n                            if (name.startsWith(\"set\") || name.startsWith(\"get\") || name.startsWith(\"is\")) {\n                                String propName = Verifier.capitalize(propertyNode.getField().getName());\n                                String shortName = name.substring(name.startsWith(\"is\") ? 2 : 3);\n                                if (propName.equals(shortName)) {\n                                    errorNode = propertyNode;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    addError(\"The \" + getDescription(methodNode) + \" is already defined in \" + getDescription(node) +\n                            \". You cannot have both a static and an instance method with the same signature\", errorNode);\n                }\n            }\n            result.put(methodNode.getTypeDescriptor(), methodNode);\n        }\n    }",
            " 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152 +\n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  ",
            "    private void checkNoStaticMethodWithSameSignatureAsNonStatic(final ClassNode node) {\n        ClassNode parent = node.getSuperClass();\n        Map<String, MethodNode> result;\n        // start with methods from the parent if any\n        if (parent != null) {\n            result = parent.getDeclaredMethodsMap();\n        } else {\n            result = new HashMap<String, MethodNode>();\n        }\n        // add in unimplemented abstract methods from the interfaces\n        ClassNodeUtils.addDeclaredMethodsFromInterfaces(node, result);\n        for (MethodNode methodNode : node.getMethods()) {\n            MethodNode mn = result.get(methodNode.getTypeDescriptor());\n            if (mn != null && (mn.isStatic() ^ methodNode.isStatic()) && !methodNode.isStaticConstructor()) {\n                if (!mn.isAbstract()) continue;\n                ClassNode declaringClass = mn.getDeclaringClass();\n                ClassNode cn = declaringClass.getOuterClass();\n                if (cn == null && declaringClass.isResolved()) {\n                    // in case of a precompiled class, the outerclass is unknown\n                    Class typeClass = declaringClass.getTypeClass();\n                    typeClass = typeClass.getEnclosingClass();\n                    if (typeClass != null) {\n                        cn = ClassHelper.make(typeClass);\n                    }\n                }\n                if (!Traits.isTrait(cn)) {\n                    ASTNode errorNode = methodNode;\n                    String name = mn.getName();\n                    if (errorNode.getLineNumber() == -1) {\n                        // try to get a better error message location based on the property\n                        for (PropertyNode propertyNode : node.getProperties()) {\n                            if (name.startsWith(\"set\") || name.startsWith(\"get\") || name.startsWith(\"is\")) {\n                                String propName = Verifier.capitalize(propertyNode.getField().getName());\n                                String shortName = name.substring(name.startsWith(\"is\") ? 2 : 3);\n                                if (propName.equals(shortName)) {\n                                    errorNode = propertyNode;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    addError(\"The \" + getDescription(methodNode) + \" is already defined in \" + getDescription(node) +\n                            \". You cannot have both a static and an instance method with the same signature\", errorNode);\n                }\n            }\n            result.put(methodNode.getTypeDescriptor(), methodNode);\n        }\n    }"
        ],
        [
            "ObservableList::set(int,Object)",
            " 320  \n 321  \n 322  \n 323  \n 324 -\n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  ",
            "    public Object set(int index, Object element) {\n        Object oldValue = delegate.set(index, element);\n        if (test != null) {\n            Object result = test.call(element);\n            if (result != null && result instanceof Boolean && ((Boolean) result).booleanValue()) {\n                fireElementUpdatedEvent(index, oldValue, element);\n            }\n        } else {\n            fireElementUpdatedEvent(index, oldValue, element);\n        }\n        return oldValue;\n    }",
            " 320  \n 321  \n 322  \n 323  \n 324 +\n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  ",
            "    public Object set(int index, Object element) {\n        Object oldValue = delegate.set(index, element);\n        if (test != null) {\n            Object result = test.call(element);\n            if (result instanceof Boolean && ((Boolean) result).booleanValue()) {\n                fireElementUpdatedEvent(index, oldValue, element);\n            }\n        } else {\n            fireElementUpdatedEvent(index, oldValue, element);\n        }\n        return oldValue;\n    }"
        ],
        [
            "StaticTypeCheckingVisitor::checkForTargetType(Expression,ClassNode)",
            "3711  \n3712  \n3713 -\n3714  \n3715  \n3716  \n3717  \n3718  \n3719  \n3720  \n3721  \n3722  \n3723  \n3724  \n3725  ",
            "    private ClassNode checkForTargetType(final Expression expr, final ClassNode type) {\n        BinaryExpression enclosingBinaryExpression = typeCheckingContext.getEnclosingBinaryExpression();\n        if (enclosingBinaryExpression != null && enclosingBinaryExpression instanceof DeclarationExpression\n                && isEmptyCollection(expr) && isAssignment(enclosingBinaryExpression.getOperation().getType())) {\n            VariableExpression target = (VariableExpression) enclosingBinaryExpression.getLeftExpression();\n            return adjustForTargetType(target.getType(), type);\n        }\n        if (currentField != null) {\n            return adjustForTargetType(currentField.getType(), type);\n        }\n        if (currentProperty != null) {\n            return adjustForTargetType(currentProperty.getType(), type);\n        }\n        return type;\n    }",
            "3711  \n3712  \n3713 +\n3714  \n3715  \n3716  \n3717  \n3718  \n3719  \n3720  \n3721  \n3722  \n3723  \n3724  \n3725  ",
            "    private ClassNode checkForTargetType(final Expression expr, final ClassNode type) {\n        BinaryExpression enclosingBinaryExpression = typeCheckingContext.getEnclosingBinaryExpression();\n        if (enclosingBinaryExpression instanceof DeclarationExpression\n                && isEmptyCollection(expr) && isAssignment(enclosingBinaryExpression.getOperation().getType())) {\n            VariableExpression target = (VariableExpression) enclosingBinaryExpression.getLeftExpression();\n            return adjustForTargetType(target.getType(), type);\n        }\n        if (currentField != null) {\n            return adjustForTargetType(currentField.getType(), type);\n        }\n        if (currentProperty != null) {\n            return adjustForTargetType(currentProperty.getType(), type);\n        }\n        return type;\n    }"
        ],
        [
            "BuilderASTTransformation::AbstractBuilderStrategy::unsupportedAttribute(BuilderASTTransformation,AnnotationNode,String,String)",
            " 122  \n 123  \n 124 -\n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  ",
            "        protected boolean unsupportedAttribute(BuilderASTTransformation transform, AnnotationNode anno, String memberName, String extraMessage) {\n            Object memberValue = transform.getMemberValue(anno, memberName);\n            if (memberValue != null && memberValue instanceof String && isUndefined((String) memberValue)) return false;\n            if (memberValue == null) {\n                memberValue = transform.getMemberClassValue(anno, memberName);\n                if (memberValue != null && isUndefined((ClassNode) memberValue)) {\n                    memberValue = null;\n                }\n            }\n            if (memberValue != null) {\n                String message = extraMessage.length() == 0 ? \"\" : \" \" + extraMessage;\n                transform.addError(\"Error during \" + MY_TYPE_NAME + \" processing: Annotation attribute '\" + memberName + \"' not supported by \" + getClass().getName() + message, anno);\n                return true;\n            }\n            return false;\n        }",
            " 122  \n 123  \n 124 +\n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  ",
            "        protected boolean unsupportedAttribute(BuilderASTTransformation transform, AnnotationNode anno, String memberName, String extraMessage) {\n            Object memberValue = transform.getMemberValue(anno, memberName);\n            if (memberValue instanceof String && isUndefined((String) memberValue)) return false;\n            if (memberValue == null) {\n                memberValue = transform.getMemberClassValue(anno, memberName);\n                if (memberValue != null && isUndefined((ClassNode) memberValue)) {\n                    memberValue = null;\n                }\n            }\n            if (memberValue != null) {\n                String message = extraMessage.length() == 0 ? \"\" : \" \" + extraMessage;\n                transform.addError(\"Error during \" + MY_TYPE_NAME + \" processing: Annotation attribute '\" + memberName + \"' not supported by \" + getClass().getName() + message, anno);\n                return true;\n            }\n            return false;\n        }"
        ],
        [
            "AbstractASTTransformation::getMemberValue(AnnotationNode,String)",
            " 100  \n 101  \n 102 -\n 103  \n 104  ",
            "    public Object getMemberValue(AnnotationNode node, String name) {\r\n        final Expression member = node.getMember(name);\r\n        if (member != null && member instanceof ConstantExpression) return ((ConstantExpression) member).getValue();\r\n        return null;\r\n    }\r",
            " 100  \n 101  \n 102 +\n 103  \n 104  ",
            "    public Object getMemberValue(AnnotationNode node, String name) {\r\n        final Expression member = node.getMember(name);\r\n        if (member instanceof ConstantExpression) return ((ConstantExpression) member).getValue();\r\n        return null;\r\n    }\r"
        ],
        [
            "ObservableList::fireAddWithTest(Object,int,int)",
            " 152  \n 153  \n 154  \n 155 -\n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  ",
            "    private void fireAddWithTest(Object element, int index, int oldSize) {\n        if (test != null) {\n            Object result = test.call(element);\n            if (result != null && result instanceof Boolean && (Boolean) result) {\n                fireElementAddedEvent(index, element);\n                fireSizeChangedEvent(oldSize, size());\n            }\n        } else {\n            fireElementAddedEvent(index, element);\n            fireSizeChangedEvent(oldSize, size());\n        }\n    }",
            " 152  \n 153  \n 154  \n 155 +\n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  ",
            "    private void fireAddWithTest(Object element, int index, int oldSize) {\n        if (test != null) {\n            Object result = test.call(element);\n            if (result instanceof Boolean && (Boolean) result) {\n                fireElementAddedEvent(index, element);\n                fireSizeChangedEvent(oldSize, size());\n            }\n        } else {\n            fireElementAddedEvent(index, element);\n            fireSizeChangedEvent(oldSize, size());\n        }\n    }"
        ],
        [
            "StaticImportVisitor::transformVariableExpression(VariableExpression)",
            " 200  \n 201  \n 202 -\n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  ",
            "    protected Expression transformVariableExpression(VariableExpression ve) {\r\n        Variable v = ve.getAccessedVariable();\r\n        if (v != null && v instanceof DynamicVariable) {\r\n            Expression result = findStaticFieldOrPropAccessorImportFromModule(v.getName());\r\n            if (result != null) {\r\n                setSourcePosition(result, ve);\r\n                if (inAnnotation) {\r\n                    result = transformInlineConstants(result);\r\n                }\r\n                return result;\r\n            }\r\n        }\r\n        return ve;\r\n    }\r",
            " 200  \n 201  \n 202 +\n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  ",
            "    protected Expression transformVariableExpression(VariableExpression ve) {\r\n        Variable v = ve.getAccessedVariable();\r\n        if (v instanceof DynamicVariable) {\r\n            Expression result = findStaticFieldOrPropAccessorImportFromModule(v.getName());\r\n            if (result != null) {\r\n                setSourcePosition(result, ve);\r\n                if (inAnnotation) {\r\n                    result = transformInlineConstants(result);\r\n                }\r\n                return result;\r\n            }\r\n        }\r\n        return ve;\r\n    }\r"
        ],
        [
            "CategoryASTTransformation::getTargetClass(SourceUnit,AnnotationNode)",
            " 282  \n 283  \n 284 -\n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  ",
            "    private static ClassNode getTargetClass(SourceUnit source, AnnotationNode annotation) {\r\n        Expression value = annotation.getMember(\"value\");\r\n        if (value == null || !(value instanceof ClassExpression)) {\r\n            //noinspection ThrowableInstanceNeverThrown\r\n            source.getErrorCollector().addErrorAndContinue(new SyntaxErrorMessage(\r\n                    new SyntaxException(\"@groovy.lang.Category must define 'value' which is the class to apply this category to\",\r\n                            annotation.getLineNumber(), annotation.getColumnNumber(), annotation.getLastLineNumber(), annotation.getLastColumnNumber()),\r\n                    source));\r\n            return null;\r\n        } else {\r\n            ClassExpression ce = (ClassExpression) value;\r\n            return ce.getType();\r\n        }\r\n    }\r",
            " 282  \n 283  \n 284 +\n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  ",
            "    private static ClassNode getTargetClass(SourceUnit source, AnnotationNode annotation) {\r\n        Expression value = annotation.getMember(\"value\");\r\n        if (!(value instanceof ClassExpression)) {\r\n            //noinspection ThrowableInstanceNeverThrown\r\n            source.getErrorCollector().addErrorAndContinue(new SyntaxErrorMessage(\r\n                    new SyntaxException(\"@groovy.lang.Category must define 'value' which is the class to apply this category to\",\r\n                            annotation.getLineNumber(), annotation.getColumnNumber(), annotation.getLastLineNumber(), annotation.getLastColumnNumber()),\r\n                    source));\r\n            return null;\r\n        } else {\r\n            ClassExpression ce = (ClassExpression) value;\r\n            return ce.getType();\r\n        }\r\n    }\r"
        ],
        [
            "GrabAnnotationTransformation::checkForConvenienceForm(AnnotationNode,boolean)",
            " 516  \n 517  \n 518 -\n 519  \n 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528  \n 529  \n 530  \n 531  \n 532  \n 533  \n 534  \n 535  \n 536  \n 537  \n 538  \n 539  \n 540  \n 541  \n 542  \n 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564  \n 565  \n 566  \n 567  \n 568  \n 569  \n 570  ",
            "    private static void checkForConvenienceForm(AnnotationNode node, boolean exclude) {\n        Object val = node.getMember(\"value\");\n        if (val == null || !(val instanceof ConstantExpression)) return;\n        Object allParts = ((ConstantExpression)val).getValue();\n        if (!(allParts instanceof String)) return;\n        String allstr = (String) allParts;\n\n        // strip off trailing attributes\n        boolean done = false;\n        while (!done) {\n            Matcher attrs = ATTRIBUTES_PATTERN.matcher(allstr);\n            if (attrs.find()) {\n                String attrName = attrs.group(2);\n                String attrValue = attrs.group(3);\n                if (attrName == null || attrValue == null) continue;\n                boolean isBool = GRAB_BOOLEAN.contains(attrName);\n                ConstantExpression value = constX(isBool ? Boolean.valueOf(attrValue) : attrValue);\n                value.setSourcePosition(node);\n                node.addMember(attrName, value);\n                int lastSemi = allstr.lastIndexOf(';');\n                if (lastSemi == -1) {\n                    allstr = \"\";\n                    break;\n                }\n                allstr = allstr.substring(0, lastSemi);\n            } else {\n                done = true;\n            }\n        }\n\n        if (allstr.contains(\"#\")) {\n            // see: http://ant.apache.org/ivy/history/latest-milestone/textual.html\n            Matcher m = IVY_PATTERN.matcher(allstr);\n            if (!m.find()) return;\n            if (m.group(1) == null || m.group(2) == null) return;\n            node.addMember(\"module\", constX(m.group(2)));\n            node.addMember(\"group\", constX(m.group(1)));\n            if (m.group(6) != null) node.addMember(\"conf\", constX(m.group(6)));\n            if (m.group(4) != null) node.addMember(\"version\", constX(m.group(4)));\n            else if (!exclude && node.getMember(\"version\") == null) node.addMember(\"version\", constX(\"*\"));\n            node.getMembers().remove(\"value\");\n        } else if (allstr.contains(\":\")) {\n            // assume gradle syntax\n            // see: http://www.gradle.org/latest/docs/userguide/dependency_management.html#sec:how_to_declare_your_dependencies\n            Map<String, Object> parts = GrapeUtil.getIvyParts(allstr);\n            for (Map.Entry<String, Object> entry : parts.entrySet()) {\n                String key = entry.getKey();\n                String value = entry.getValue().toString();\n                if (!key.equals(\"version\") || !value.equals(\"*\") || !exclude) {\n                    node.addMember(key, constX(value));\n                }\n            }\n            node.getMembers().remove(\"value\");\n        }\n    }",
            " 516  \n 517  \n 518 +\n 519  \n 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528  \n 529  \n 530  \n 531  \n 532  \n 533  \n 534  \n 535  \n 536  \n 537  \n 538  \n 539  \n 540  \n 541  \n 542  \n 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564  \n 565  \n 566  \n 567  \n 568  \n 569  \n 570  ",
            "    private static void checkForConvenienceForm(AnnotationNode node, boolean exclude) {\n        Object val = node.getMember(\"value\");\n        if (!(val instanceof ConstantExpression)) return;\n        Object allParts = ((ConstantExpression)val).getValue();\n        if (!(allParts instanceof String)) return;\n        String allstr = (String) allParts;\n\n        // strip off trailing attributes\n        boolean done = false;\n        while (!done) {\n            Matcher attrs = ATTRIBUTES_PATTERN.matcher(allstr);\n            if (attrs.find()) {\n                String attrName = attrs.group(2);\n                String attrValue = attrs.group(3);\n                if (attrName == null || attrValue == null) continue;\n                boolean isBool = GRAB_BOOLEAN.contains(attrName);\n                ConstantExpression value = constX(isBool ? Boolean.valueOf(attrValue) : attrValue);\n                value.setSourcePosition(node);\n                node.addMember(attrName, value);\n                int lastSemi = allstr.lastIndexOf(';');\n                if (lastSemi == -1) {\n                    allstr = \"\";\n                    break;\n                }\n                allstr = allstr.substring(0, lastSemi);\n            } else {\n                done = true;\n            }\n        }\n\n        if (allstr.contains(\"#\")) {\n            // see: http://ant.apache.org/ivy/history/latest-milestone/textual.html\n            Matcher m = IVY_PATTERN.matcher(allstr);\n            if (!m.find()) return;\n            if (m.group(1) == null || m.group(2) == null) return;\n            node.addMember(\"module\", constX(m.group(2)));\n            node.addMember(\"group\", constX(m.group(1)));\n            if (m.group(6) != null) node.addMember(\"conf\", constX(m.group(6)));\n            if (m.group(4) != null) node.addMember(\"version\", constX(m.group(4)));\n            else if (!exclude && node.getMember(\"version\") == null) node.addMember(\"version\", constX(\"*\"));\n            node.getMembers().remove(\"value\");\n        } else if (allstr.contains(\":\")) {\n            // assume gradle syntax\n            // see: http://www.gradle.org/latest/docs/userguide/dependency_management.html#sec:how_to_declare_your_dependencies\n            Map<String, Object> parts = GrapeUtil.getIvyParts(allstr);\n            for (Map.Entry<String, Object> entry : parts.entrySet()) {\n                String key = entry.getKey();\n                String value = entry.getValue().toString();\n                if (!key.equals(\"version\") || !value.equals(\"*\") || !exclude) {\n                    node.addMember(key, constX(value));\n                }\n            }\n            node.getMembers().remove(\"value\");\n        }\n    }"
        ],
        [
            "Expando::equals(Object)",
            " 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136 -\n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  ",
            "    /**\n     * This allows equals to be overridden by a closure <i>field</i> method attached\n     * to the expando object.\n     *\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    public boolean equals(Object obj) {\n        Object method = getProperties().get(\"equals\");\n        if (method != null && method instanceof Closure) {\n            // invoke overridden equals closure method\n            Closure closure = (Closure) method;\n            closure.setDelegate(this);\n            Boolean ret = (Boolean) closure.call(obj);\n            return ret.booleanValue();\n        } else {\n            return super.equals(obj);\n        }\n    }",
            " 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136 +\n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  ",
            "    /**\n     * This allows equals to be overridden by a closure <i>field</i> method attached\n     * to the expando object.\n     *\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    public boolean equals(Object obj) {\n        Object method = getProperties().get(\"equals\");\n        if (method instanceof Closure) {\n            // invoke overridden equals closure method\n            Closure closure = (Closure) method;\n            closure.setDelegate(this);\n            Boolean ret = (Boolean) closure.call(obj);\n            return ret.booleanValue();\n        } else {\n            return super.equals(obj);\n        }\n    }"
        ],
        [
            "ASTTransformationCollectorCodeVisitor::getMode(AnnotationNode)",
            " 247  \n 248  \n 249 -\n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  ",
            "    private static AnnotationCollectorMode getMode(AnnotationNode node) {\n        final Expression member = node.getMember(\"mode\");\n        if (member != null && member instanceof PropertyExpression) {\n            PropertyExpression prop = (PropertyExpression) member;\n            Expression oe = prop.getObjectExpression();\n            if (oe instanceof ClassExpression) {\n                ClassExpression ce = (ClassExpression) oe;\n                if (ce.getType().getName().equals(\"groovy.transform.AnnotationCollectorMode\")) {\n                    return AnnotationCollectorMode.valueOf(prop.getPropertyAsString());\n                }\n            }\n        }\n        return null;\n    }",
            " 247  \n 248  \n 249 +\n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  ",
            "    private static AnnotationCollectorMode getMode(AnnotationNode node) {\n        final Expression member = node.getMember(\"mode\");\n        if (member instanceof PropertyExpression) {\n            PropertyExpression prop = (PropertyExpression) member;\n            Expression oe = prop.getObjectExpression();\n            if (oe instanceof ClassExpression) {\n                ClassExpression ce = (ClassExpression) oe;\n                if (ce.getType().getName().equals(\"groovy.transform.AnnotationCollectorMode\")) {\n                    return AnnotationCollectorMode.valueOf(prop.getPropertyAsString());\n                }\n            }\n        }\n        return null;\n    }"
        ],
        [
            "MetaClassImpl::invokeMissingProperty(Object,String,Object,boolean)",
            " 844  \n 845  \n 846  \n 847  \n 848  \n 849  \n 850  \n 851  \n 852  \n 853  \n 854  \n 855  \n 856  \n 857  \n 858  \n 859  \n 860  \n 861  \n 862  \n 863  \n 864  \n 865  \n 866  \n 867  \n 868  \n 869  \n 870  \n 871  \n 872  \n 873  \n 874  \n 875 -\n 876  \n 877  \n 878  \n 879  \n 880  \n 881  \n 882  \n 883 -\n 884  \n 885  \n 886  \n 887  \n 888  \n 889  \n 890  \n 891  \n 892  \n 893  \n 894  \n 895  \n 896  \n 897  \n 898  \n 899  \n 900  \n 901  \n 902  \n 903  \n 904  \n 905  \n 906  \n 907  \n 908  \n 909  \n 910  \n 911  \n 912  \n 913  \n 914  \n 915  \n 916  \n 917  \n 918  \n 919  \n 920  \n 921  ",
            "    /**\n     * Invoke a missing property on the given object with the given arguments.\n     *\n     * @param instance The object the method should be invoked on.\n     * @param propertyName The name of the property to invoke.\n     * @param optionalValue The (optional) new value for the property\n     * @param isGetter Wether the method is a getter\n     *\n     * @return The result of the method invocation.\n     */\n    public Object invokeMissingProperty(Object instance, String propertyName, Object optionalValue, boolean isGetter) {\n        Class theClass = instance instanceof Class ? (Class)instance : instance.getClass();\n        CachedClass superClass = theCachedClass;\n        while(superClass != null && superClass != ReflectionCache.OBJECT_CLASS) {\n            final MetaBeanProperty property = findPropertyInClassHierarchy(propertyName, superClass);\n            if(property != null) {\n                onSuperPropertyFoundInHierarchy(property);\n                if(!isGetter) {\n                    property.setProperty(instance, optionalValue);\n                    return null;\n                }\n                else {\n                    return property.getProperty(instance);\n                }\n            }\n            superClass = superClass.getCachedSuperClass();\n        }\n        // got here to property not found, look for getProperty or setProperty overrides\n        if(isGetter) {\n            final Class[] getPropertyArgs = {String.class};\n            final MetaMethod method = findMethodInClassHierarchy(instance.getClass(), GET_PROPERTY_METHOD, getPropertyArgs, this);\n            if(method != null && method instanceof ClosureMetaMethod) {\n                onGetPropertyFoundInHierarchy(method);\n                return method.invoke(instance,new Object[]{propertyName});\n            }\n        }\n        else {\n            final Class[] setPropertyArgs = {String.class, Object.class};\n            final MetaMethod method = findMethodInClassHierarchy(instance.getClass(), SET_PROPERTY_METHOD, setPropertyArgs, this);\n            if(method != null && method instanceof ClosureMetaMethod) {\n                onSetPropertyFoundInHierarchy(method);\n                return method.invoke(instance, new Object[]{propertyName, optionalValue});\n            }\n        }\n\n        try {\n            if (!(instance instanceof Class)) {\n                if (isGetter) {\n                    if (propertyMissingGet != null) {\n                        return propertyMissingGet.invoke(instance, new Object[]{propertyName});\n                    }\n                } else {\n                    if (propertyMissingSet != null) {\n                        return propertyMissingSet.invoke(instance, new Object[]{propertyName, optionalValue});\n                    }\n                }\n            }\n        } catch (InvokerInvocationException iie) {\n            boolean shouldHandle = isGetter && propertyMissingGet != null;\n            if (!shouldHandle) shouldHandle = !isGetter && propertyMissingSet != null;\n            if (shouldHandle &&  iie.getCause() instanceof MissingPropertyException) {\n                throw (MissingPropertyException) iie.getCause();\n            }\n            throw iie;\n        }\n\n        if (instance instanceof Class && theClass != Class.class) {\n           final MetaProperty metaProperty = InvokerHelper.getMetaClass(Class.class).hasProperty(instance, propertyName);\n           if (metaProperty != null)\n             if (isGetter)\n               return metaProperty.getProperty(instance);\n             else {\n               metaProperty.setProperty(instance, optionalValue);\n               return null;\n             }\n        }\n        throw new MissingPropertyExceptionNoStack(propertyName, theClass);\n    }",
            " 844  \n 845  \n 846  \n 847  \n 848  \n 849  \n 850  \n 851  \n 852  \n 853  \n 854  \n 855  \n 856  \n 857  \n 858  \n 859  \n 860  \n 861  \n 862  \n 863  \n 864  \n 865  \n 866  \n 867  \n 868  \n 869  \n 870  \n 871  \n 872  \n 873  \n 874  \n 875 +\n 876  \n 877  \n 878  \n 879  \n 880  \n 881  \n 882  \n 883 +\n 884  \n 885  \n 886  \n 887  \n 888  \n 889  \n 890  \n 891  \n 892  \n 893  \n 894  \n 895  \n 896  \n 897  \n 898  \n 899  \n 900  \n 901  \n 902  \n 903  \n 904  \n 905  \n 906  \n 907  \n 908  \n 909  \n 910  \n 911  \n 912  \n 913  \n 914  \n 915  \n 916  \n 917  \n 918  \n 919  \n 920  \n 921  ",
            "    /**\n     * Invoke a missing property on the given object with the given arguments.\n     *\n     * @param instance The object the method should be invoked on.\n     * @param propertyName The name of the property to invoke.\n     * @param optionalValue The (optional) new value for the property\n     * @param isGetter Wether the method is a getter\n     *\n     * @return The result of the method invocation.\n     */\n    public Object invokeMissingProperty(Object instance, String propertyName, Object optionalValue, boolean isGetter) {\n        Class theClass = instance instanceof Class ? (Class)instance : instance.getClass();\n        CachedClass superClass = theCachedClass;\n        while(superClass != null && superClass != ReflectionCache.OBJECT_CLASS) {\n            final MetaBeanProperty property = findPropertyInClassHierarchy(propertyName, superClass);\n            if(property != null) {\n                onSuperPropertyFoundInHierarchy(property);\n                if(!isGetter) {\n                    property.setProperty(instance, optionalValue);\n                    return null;\n                }\n                else {\n                    return property.getProperty(instance);\n                }\n            }\n            superClass = superClass.getCachedSuperClass();\n        }\n        // got here to property not found, look for getProperty or setProperty overrides\n        if(isGetter) {\n            final Class[] getPropertyArgs = {String.class};\n            final MetaMethod method = findMethodInClassHierarchy(instance.getClass(), GET_PROPERTY_METHOD, getPropertyArgs, this);\n            if(method instanceof ClosureMetaMethod) {\n                onGetPropertyFoundInHierarchy(method);\n                return method.invoke(instance,new Object[]{propertyName});\n            }\n        }\n        else {\n            final Class[] setPropertyArgs = {String.class, Object.class};\n            final MetaMethod method = findMethodInClassHierarchy(instance.getClass(), SET_PROPERTY_METHOD, setPropertyArgs, this);\n            if(method instanceof ClosureMetaMethod) {\n                onSetPropertyFoundInHierarchy(method);\n                return method.invoke(instance, new Object[]{propertyName, optionalValue});\n            }\n        }\n\n        try {\n            if (!(instance instanceof Class)) {\n                if (isGetter) {\n                    if (propertyMissingGet != null) {\n                        return propertyMissingGet.invoke(instance, new Object[]{propertyName});\n                    }\n                } else {\n                    if (propertyMissingSet != null) {\n                        return propertyMissingSet.invoke(instance, new Object[]{propertyName, optionalValue});\n                    }\n                }\n            }\n        } catch (InvokerInvocationException iie) {\n            boolean shouldHandle = isGetter && propertyMissingGet != null;\n            if (!shouldHandle) shouldHandle = !isGetter && propertyMissingSet != null;\n            if (shouldHandle &&  iie.getCause() instanceof MissingPropertyException) {\n                throw (MissingPropertyException) iie.getCause();\n            }\n            throw iie;\n        }\n\n        if (instance instanceof Class && theClass != Class.class) {\n           final MetaProperty metaProperty = InvokerHelper.getMetaClass(Class.class).hasProperty(instance, propertyName);\n           if (metaProperty != null)\n             if (isGetter)\n               return metaProperty.getProperty(instance);\n             else {\n               metaProperty.setProperty(instance, optionalValue);\n               return null;\n             }\n        }\n        throw new MissingPropertyExceptionNoStack(propertyName, theClass);\n    }"
        ],
        [
            "ObservableMap::putAll(Map)",
            " 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232 -\n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  ",
            "    public void putAll(Map map) {\n        int oldSize = size();\n        if (map != null) {\n            List<PropertyEvent> events = new ArrayList<PropertyEvent>();\n            for (Object o : map.entrySet()) {\n                Entry entry = (Entry) o;\n\n                String key = String.valueOf(entry.getKey());\n                Object newValue = entry.getValue();\n                Object oldValue = null;\n\n                boolean newKey = !delegate.containsKey(key);\n                if (test != null) {\n                    oldValue = delegate.put(key, newValue);\n                    Object result = null;\n                    if (test.getMaximumNumberOfParameters() == 2) {\n                        result = test.call(key, newValue);\n                    } else {\n                        result = test.call(newValue);\n                    }\n                    if (result != null && result instanceof Boolean && (Boolean) result) {\n                        if (newKey) {\n                            events.add(new PropertyAddedEvent(this, key, newValue));\n                        } else if (oldValue != newValue) {\n                            events.add(new PropertyUpdatedEvent(this, key, oldValue, newValue));\n                        }\n                    }\n                } else {\n                    oldValue = delegate.put(key, newValue);\n                    if (newKey) {\n                        events.add(new PropertyAddedEvent(this, key, newValue));\n                    } else if (oldValue != newValue) {\n                        events.add(new PropertyUpdatedEvent(this, key, oldValue, newValue));\n                    }\n                }\n            }\n            if (!events.isEmpty()) {\n                fireMultiPropertyEvent(events);\n                fireSizeChangedEvent(oldSize, size());\n            }\n        }\n    }",
            " 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232 +\n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  ",
            "    public void putAll(Map map) {\n        int oldSize = size();\n        if (map != null) {\n            List<PropertyEvent> events = new ArrayList<PropertyEvent>();\n            for (Object o : map.entrySet()) {\n                Entry entry = (Entry) o;\n\n                String key = String.valueOf(entry.getKey());\n                Object newValue = entry.getValue();\n                Object oldValue = null;\n\n                boolean newKey = !delegate.containsKey(key);\n                if (test != null) {\n                    oldValue = delegate.put(key, newValue);\n                    Object result = null;\n                    if (test.getMaximumNumberOfParameters() == 2) {\n                        result = test.call(key, newValue);\n                    } else {\n                        result = test.call(newValue);\n                    }\n                    if (result instanceof Boolean && (Boolean) result) {\n                        if (newKey) {\n                            events.add(new PropertyAddedEvent(this, key, newValue));\n                        } else if (oldValue != newValue) {\n                            events.add(new PropertyUpdatedEvent(this, key, oldValue, newValue));\n                        }\n                    }\n                } else {\n                    oldValue = delegate.put(key, newValue);\n                    if (newKey) {\n                        events.add(new PropertyAddedEvent(this, key, newValue));\n                    } else if (oldValue != newValue) {\n                        events.add(new PropertyUpdatedEvent(this, key, oldValue, newValue));\n                    }\n                }\n            }\n            if (!events.isEmpty()) {\n                fireMultiPropertyEvent(events);\n                fireSizeChangedEvent(oldSize, size());\n            }\n        }\n    }"
        ],
        [
            "Expando::hashCode()",
            " 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155 -\n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  ",
            "    /**\n     * This allows hashCode to be overridden by a closure <i>field</i> method attached\n     * to the expando object.\n     *\n     * @see java.lang.Object#hashCode()\n     */\n    public int hashCode() {\n        Object method = getProperties().get(\"hashCode\");\n        if (method != null && method instanceof Closure) {\n            // invoke overridden hashCode closure method\n            Closure closure = (Closure) method;\n            closure.setDelegate(this);\n            Integer ret = (Integer) closure.call();\n            return ret.intValue();\n        } else {\n            return super.hashCode();\n        }\n    }",
            " 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155 +\n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  ",
            "    /**\n     * This allows hashCode to be overridden by a closure <i>field</i> method attached\n     * to the expando object.\n     *\n     * @see java.lang.Object#hashCode()\n     */\n    public int hashCode() {\n        Object method = getProperties().get(\"hashCode\");\n        if (method instanceof Closure) {\n            // invoke overridden hashCode closure method\n            Closure closure = (Closure) method;\n            closure.setDelegate(this);\n            Integer ret = (Integer) closure.call();\n            return ret.intValue();\n        } else {\n            return super.hashCode();\n        }\n    }"
        ],
        [
            "StaticTypeCheckingVisitor::isSecondPassNeededForControlStructure(Map,Map)",
            "1815  \n1816  \n1817  \n1818  \n1819  \n1820  \n1821  \n1822 -\n1823  \n1824  \n1825  \n1826  \n1827  \n1828  ",
            "    protected boolean isSecondPassNeededForControlStructure(final Map<VariableExpression, ClassNode> varOrigType, final Map<VariableExpression, List<ClassNode>> oldTracker) {\n        Map<VariableExpression, ClassNode> assignedVars = popAssignmentTracking(oldTracker);\n        for (Map.Entry<VariableExpression, ClassNode> entry : assignedVars.entrySet()) {\n            Variable key = findTargetVariable(entry.getKey());\n            if (key instanceof VariableExpression) {\n                ClassNode origType = varOrigType.get(key);\n                ClassNode newType = entry.getValue();\n                if (varOrigType.containsKey(key) && (origType == null || !newType.equals(origType))) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }",
            "1815  \n1816  \n1817  \n1818  \n1819  \n1820  \n1821  \n1822 +\n1823  \n1824  \n1825  \n1826  \n1827  \n1828  ",
            "    protected boolean isSecondPassNeededForControlStructure(final Map<VariableExpression, ClassNode> varOrigType, final Map<VariableExpression, List<ClassNode>> oldTracker) {\n        Map<VariableExpression, ClassNode> assignedVars = popAssignmentTracking(oldTracker);\n        for (Map.Entry<VariableExpression, ClassNode> entry : assignedVars.entrySet()) {\n            Variable key = findTargetVariable(entry.getKey());\n            if (key instanceof VariableExpression) {\n                ClassNode origType = varOrigType.get(key);\n                ClassNode newType = entry.getValue();\n                if (varOrigType.containsKey(key) && (!newType.equals(origType))) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }"
        ],
        [
            "StaticVerifier::visitVariableExpression(VariableExpression)",
            "  59  \n  60  \n  61  \n  62 -\n  63  \n  64  \n  65  ",
            "    @Override\r\n    public void visitVariableExpression(VariableExpression ve) {\r\n        Variable v = ve.getAccessedVariable();\r\n        if (v != null && v instanceof DynamicVariable) {\r\n            if (!inPropertyExpression || inSpecialConstructorCall) addStaticVariableError(ve);\r\n        }\r\n    }\r",
            "  59  \n  60  \n  61  \n  62 +\n  63  \n  64  \n  65  ",
            "    @Override\r\n    public void visitVariableExpression(VariableExpression ve) {\r\n        Variable v = ve.getAccessedVariable();\r\n        if (v instanceof DynamicVariable) {\r\n            if (!inPropertyExpression || inSpecialConstructorCall) addStaticVariableError(ve);\r\n        }\r\n    }\r"
        ],
        [
            "AutoCloneASTTransformation::getStyle(AnnotationNode,String)",
            " 290  \n 291  \n 292 -\n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  ",
            "    private static AutoCloneStyle getStyle(AnnotationNode node, String name) {\r\n        final Expression member = node.getMember(name);\r\n        if (member != null && member instanceof PropertyExpression) {\r\n            PropertyExpression prop = (PropertyExpression) member;\r\n            Expression oe = prop.getObjectExpression();\r\n            if (oe instanceof ClassExpression) {\r\n                ClassExpression ce = (ClassExpression) oe;\r\n                if (ce.getType().getName().equals(\"groovy.transform.AutoCloneStyle\")) {\r\n                    return AutoCloneStyle.valueOf(prop.getPropertyAsString());\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r",
            " 290  \n 291  \n 292 +\n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  ",
            "    private static AutoCloneStyle getStyle(AnnotationNode node, String name) {\r\n        final Expression member = node.getMember(name);\r\n        if (member instanceof PropertyExpression) {\r\n            PropertyExpression prop = (PropertyExpression) member;\r\n            Expression oe = prop.getObjectExpression();\r\n            if (oe instanceof ClassExpression) {\r\n                ClassExpression ce = (ClassExpression) oe;\r\n                if (ce.getType().getName().equals(\"groovy.transform.AutoCloneStyle\")) {\r\n                    return AutoCloneStyle.valueOf(prop.getPropertyAsString());\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r"
        ],
        [
            "Script::invokeMethod(String,Object)",
            "  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88 -\n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  ",
            "    /**\n     * Invoke a method (or closure in the binding) defined.\n     *\n     * @param name method to call\n     * @param args arguments to pass to the method\n     * @return value\n     */\n    public Object invokeMethod(String name, Object args) {\n        try {\n            return super.invokeMethod(name, args);\n        }\n        // if the method was not found in the current scope (the script's methods)\n        // let's try to see if there's a method closure with the same name in the binding\n        catch (MissingMethodException mme) {\n            try {\n                if (name.equals(mme.getMethod())) {\n                    Object boundClosure = getProperty(name);\n                    if (boundClosure != null && boundClosure instanceof Closure) {\n                        return ((Closure) boundClosure).call((Object[])args);\n                    } else {\n                        throw mme;\n                    }\n                } else {\n                    throw mme;\n                }\n            } catch (MissingPropertyException mpe) {\n                throw mme;\n            }\n        }\n    }",
            "  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88 +\n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  ",
            "    /**\n     * Invoke a method (or closure in the binding) defined.\n     *\n     * @param name method to call\n     * @param args arguments to pass to the method\n     * @return value\n     */\n    public Object invokeMethod(String name, Object args) {\n        try {\n            return super.invokeMethod(name, args);\n        }\n        // if the method was not found in the current scope (the script's methods)\n        // let's try to see if there's a method closure with the same name in the binding\n        catch (MissingMethodException mme) {\n            try {\n                if (name.equals(mme.getMethod())) {\n                    Object boundClosure = getProperty(name);\n                    if (boundClosure instanceof Closure) {\n                        return ((Closure) boundClosure).call((Object[])args);\n                    } else {\n                        throw mme;\n                    }\n                } else {\n                    throw mme;\n                }\n            } catch (MissingPropertyException mpe) {\n                throw mme;\n            }\n        }\n    }"
        ],
        [
            "StaticInvocationWriter::writeInvokeConstructor(ConstructorCallExpression)",
            " 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167 -\n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  ",
            "    @Override\n    public void writeInvokeConstructor(final ConstructorCallExpression call) {\n        MethodNode mn = call.getNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET);\n        if (mn == null) {\n            super.writeInvokeConstructor(call);\n            return;\n        }\n        if (writeAICCall(call)) return;\n        ConstructorNode cn;\n        if (mn instanceof ConstructorNode) {\n            cn = (ConstructorNode) mn;\n        } else {\n            cn = new ConstructorNode(mn.getModifiers(), mn.getParameters(), mn.getExceptions(), mn.getCode());\n            cn.setDeclaringClass(mn.getDeclaringClass());\n        }\n        TupleExpression args = makeArgumentList(call.getArguments());\n        if (cn.isPrivate()) {\n            ClassNode classNode = controller.getClassNode();\n            ClassNode declaringClass = cn.getDeclaringClass();\n            if (declaringClass != classNode) {\n                MethodNode bridge = null;\n                if (call.getNodeMetaData(StaticTypesMarker.PV_METHODS_ACCESS) != null) {\n                    Map<MethodNode, MethodNode> bridgeMethods = declaringClass.getNodeMetaData(StaticCompilationMetadataKeys.PRIVATE_BRIDGE_METHODS);\n                    bridge = bridgeMethods != null ? bridgeMethods.get(cn) : null;\n                }\n                if (bridge != null && bridge instanceof ConstructorNode) {\n                    ArgumentListExpression newArgs = new ArgumentListExpression(new ConstantExpression(null));\n                    for (Expression arg: args) {\n                        newArgs.addExpression(arg);\n                    }\n                    cn = (ConstructorNode) bridge;\n                    args = newArgs;\n                } else {\n                    controller.getSourceUnit().addError(new SyntaxException(\"Cannot call private constructor for \" + declaringClass.toString(false) +\n                            \" from class \" + classNode.toString(false), call.getLineNumber(), call.getColumnNumber(), mn.getLastLineNumber(), call.getLastColumnNumber()));\n                }\n            }\n        }\n\n        String ownerDescriptor = prepareConstructorCall(cn);\n        int before = controller.getOperandStack().getStackLength();\n        loadArguments(args.getExpressions(), cn.getParameters());\n        finnishConstructorCall(cn, ownerDescriptor, controller.getOperandStack().getStackLength() - before);\n    }",
            " 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167 +\n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  ",
            "    @Override\n    public void writeInvokeConstructor(final ConstructorCallExpression call) {\n        MethodNode mn = call.getNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET);\n        if (mn == null) {\n            super.writeInvokeConstructor(call);\n            return;\n        }\n        if (writeAICCall(call)) return;\n        ConstructorNode cn;\n        if (mn instanceof ConstructorNode) {\n            cn = (ConstructorNode) mn;\n        } else {\n            cn = new ConstructorNode(mn.getModifiers(), mn.getParameters(), mn.getExceptions(), mn.getCode());\n            cn.setDeclaringClass(mn.getDeclaringClass());\n        }\n        TupleExpression args = makeArgumentList(call.getArguments());\n        if (cn.isPrivate()) {\n            ClassNode classNode = controller.getClassNode();\n            ClassNode declaringClass = cn.getDeclaringClass();\n            if (declaringClass != classNode) {\n                MethodNode bridge = null;\n                if (call.getNodeMetaData(StaticTypesMarker.PV_METHODS_ACCESS) != null) {\n                    Map<MethodNode, MethodNode> bridgeMethods = declaringClass.getNodeMetaData(StaticCompilationMetadataKeys.PRIVATE_BRIDGE_METHODS);\n                    bridge = bridgeMethods != null ? bridgeMethods.get(cn) : null;\n                }\n                if (bridge instanceof ConstructorNode) {\n                    ArgumentListExpression newArgs = new ArgumentListExpression(new ConstantExpression(null));\n                    for (Expression arg: args) {\n                        newArgs.addExpression(arg);\n                    }\n                    cn = (ConstructorNode) bridge;\n                    args = newArgs;\n                } else {\n                    controller.getSourceUnit().addError(new SyntaxException(\"Cannot call private constructor for \" + declaringClass.toString(false) +\n                            \" from class \" + classNode.toString(false), call.getLineNumber(), call.getColumnNumber(), mn.getLastLineNumber(), call.getLastColumnNumber()));\n                }\n            }\n        }\n\n        String ownerDescriptor = prepareConstructorCall(cn);\n        int before = controller.getOperandStack().getStackLength();\n        loadArguments(args.getExpressions(), cn.getParameters());\n        finnishConstructorCall(cn, ownerDescriptor, controller.getOperandStack().getStackLength() - before);\n    }"
        ],
        [
            "AbstractASTTransformation::getMemberIntValue(AnnotationNode,String)",
            " 120  \n 121  \n 122 -\n 123  \n 124  \n 125  \n 126  ",
            "    public int getMemberIntValue(AnnotationNode node, String name) {\r\n        Object value = getMemberValue(node, name);\r\n        if (value != null && value instanceof Integer) {\r\n            return (Integer) value;\r\n        }\r\n        return 0;\r\n    }\r",
            " 120  \n 121  \n 122 +\n 123  \n 124  \n 125  \n 126  ",
            "    public int getMemberIntValue(AnnotationNode node, String name) {\r\n        Object value = getMemberValue(node, name);\r\n        if (value instanceof Integer) {\r\n            return (Integer) value;\r\n        }\r\n        return 0;\r\n    }\r"
        ],
        [
            "StaticTypesCallSiteWriter::isDirectAccessAllowed(FieldNode,ClassNode,boolean)",
            " 635  \n 636  \n 637  \n 638  \n 639  \n 640  \n 641  \n 642 -\n 643  \n 644  \n 645  \n 646  \n 647  \n 648  \n 649  \n 650  ",
            "    private static boolean isDirectAccessAllowed(FieldNode a, ClassNode receiver, boolean isSamePackage) {\n        ClassNode declaringClass = a.getDeclaringClass().redirect();\n        ClassNode receiverType = receiver.redirect();\n\n        // first, direct access from within the class or inner class nodes\n        if (declaringClass.equals(receiverType)) return true;\n        if (receiverType instanceof InnerClassNode) {\n            while (receiverType!=null && receiverType instanceof InnerClassNode) {\n                if (declaringClass.equals(receiverType)) return true;\n                receiverType = receiverType.getOuterClass();\n            }\n        }\n\n        // no getter\n        return a.isPublic() || (a.isProtected() && isSamePackage);\n    }",
            " 635  \n 636  \n 637  \n 638  \n 639  \n 640  \n 641  \n 642 +\n 643  \n 644  \n 645  \n 646  \n 647  \n 648  \n 649  \n 650  ",
            "    private static boolean isDirectAccessAllowed(FieldNode a, ClassNode receiver, boolean isSamePackage) {\n        ClassNode declaringClass = a.getDeclaringClass().redirect();\n        ClassNode receiverType = receiver.redirect();\n\n        // first, direct access from within the class or inner class nodes\n        if (declaringClass.equals(receiverType)) return true;\n        if (receiverType instanceof InnerClassNode) {\n            while (receiverType instanceof InnerClassNode) {\n                if (declaringClass.equals(receiverType)) return true;\n                receiverType = receiverType.getOuterClass();\n            }\n        }\n\n        // no getter\n        return a.isPublic() || (a.isProtected() && isSamePackage);\n    }"
        ],
        [
            "StaticInvocationWriter::writeDirectMethodCall(MethodNode,boolean,Expression,TupleExpression)",
            " 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344  \n 345  \n 346  \n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362 -\n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385  ",
            "    @Override\n    protected boolean writeDirectMethodCall(final MethodNode target, final boolean implicitThis, final Expression receiver, final TupleExpression args) {\n        if (target==null) return false;\n\n        if (target instanceof ExtensionMethodNode) {\n            ExtensionMethodNode emn = (ExtensionMethodNode) target;\n            MethodNode node = emn.getExtensionMethodNode();\n            String methodName = target.getName();\n\n            MethodVisitor mv = controller.getMethodVisitor();\n            int argumentsToRemove = 0;\n            List<Expression> argumentList = new LinkedList<Expression>(args.getExpressions());\n\n            if (emn.isStaticExtension()) {\n                // it's a static extension method\n                argumentList.add(0, ConstantExpression.NULL);\n            } else {\n                argumentList.add(0, receiver);\n            }\n\n            Parameter[] parameters = node.getParameters();\n            loadArguments(argumentList, parameters);\n\n            String owner = BytecodeHelper.getClassInternalName(node.getDeclaringClass());\n            String desc = BytecodeHelper.getMethodDescriptor(target.getReturnType(), parameters);\n            mv.visitMethodInsn(INVOKESTATIC, owner, methodName, desc, false);\n            ClassNode ret = target.getReturnType().redirect();\n            if (ret == ClassHelper.VOID_TYPE) {\n                ret = ClassHelper.OBJECT_TYPE;\n                mv.visitInsn(ACONST_NULL);\n            }\n            argumentsToRemove += argumentList.size();\n            controller.getOperandStack().remove(argumentsToRemove);\n            controller.getOperandStack().push(ret);\n            return true;\n        } else {\n            if (target == StaticTypeCheckingVisitor.CLOSURE_CALL_VARGS) {\n                // wrap arguments into an array\n                ArrayExpression arr = new ArrayExpression(ClassHelper.OBJECT_TYPE, args.getExpressions());\n                return super.writeDirectMethodCall(target, implicitThis, receiver, new ArgumentListExpression(arr));\n            }\n            ClassNode classNode = controller.getClassNode();\n            if (classNode.isDerivedFrom(ClassHelper.CLOSURE_TYPE)\n                    && controller.isInClosure()\n                    && !target.isPublic()\n                    && target.getDeclaringClass() != classNode) {\n                if (!tryBridgeMethod(target, receiver, implicitThis, args, classNode)) {\n                    // replace call with an invoker helper call\n                    ArrayExpression arr = new ArrayExpression(ClassHelper.OBJECT_TYPE, args.getExpressions());\n                    MethodCallExpression mce = new MethodCallExpression(\n                            INVOKERHELPER_RECEIVER,\n                            target.isStatic() ? \"invokeStaticMethod\" : \"invokeMethodSafe\",\n                            new ArgumentListExpression(\n                                    target.isStatic() ?\n                                            new ClassExpression(target.getDeclaringClass()) :\n                                            receiver,\n                                    new ConstantExpression(target.getName()),\n                                    arr\n                            )\n                    );\n                    mce.setMethodTarget(target.isStatic() ? INVOKERHELPER_INVOKESTATICMETHOD : INVOKERHELPER_INVOKEMETHOD);\n                    mce.visit(controller.getAcg());\n                    return true;\n                }\n                return true;\n            }\n            Expression fixedReceiver = null;\n            boolean fixedImplicitThis = implicitThis;\n            if (target.isPrivate()) {\n                if (tryPrivateMethod(target, implicitThis, receiver, args, classNode)) return true;\n            } else if (target.isProtected()) {\n                ClassNode node = receiver==null?ClassHelper.OBJECT_TYPE:controller.getTypeChooser().resolveType(receiver, controller.getClassNode());\n                boolean isThisOrSuper = false;\n                if (receiver instanceof VariableExpression) {\n                    isThisOrSuper = ((VariableExpression) receiver).isThisExpression() || ((VariableExpression) receiver).isSuperExpression();\n                }\n                if (!implicitThis && !isThisOrSuper\n                        && StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(node,target.getDeclaringClass())) {\n                    ASTNode src = receiver==null?args:receiver;\n                    controller.getSourceUnit().addError(\n                            new SyntaxException(\"Method \" + target.getName() + \" is protected in \" + target.getDeclaringClass().toString(false),\n                                    src.getLineNumber(), src.getColumnNumber(), src.getLastLineNumber(), src.getLastColumnNumber()));\n                } else if (!node.isDerivedFrom(target.getDeclaringClass()) && tryBridgeMethod(target, receiver, implicitThis, args, classNode)) {\n                    return true;\n                }\n            } else if (target.isPublic() && receiver != null) {\n                if (implicitThis\n                        && !classNode.isDerivedFrom(target.getDeclaringClass())\n                        && !classNode.implementsInterface(target.getDeclaringClass())\n                        && classNode instanceof InnerClassNode && controller.isInClosure()) {\n                    ClassNode current = classNode.getOuterClass();\n                    fixedReceiver = new VariableExpression(\"thisObject\", current);\n                    // adjust for multiple levels of nesting if needed\n                    while (current != null && current instanceof InnerClassNode && !classNode.equals(current)) {\n                        FieldNode thisField = current.getField(\"this$0\");\n                        current = current.getOuterClass();\n                        if (thisField != null) {\n                            fixedReceiver = new PropertyExpression(fixedReceiver, \"this$0\");\n                            fixedReceiver.setType(current);\n                            fixedImplicitThis = false;\n                        }\n                    }\n                }\n            }\n            if (receiver != null) {\n                boolean callToSuper = receiver instanceof VariableExpression && ((VariableExpression) receiver).isSuperExpression();\n                if (!callToSuper) {\n                    fixedReceiver = fixedReceiver == null ? receiver : fixedReceiver;\n                    // in order to avoid calls to castToType, which is the dynamic behaviour, we make sure that we call CHECKCAST instead\n                    // then replace the top operand type\n                    Expression checkCastReceiver = new CheckcastReceiverExpression(fixedReceiver, target);\n                    return super.writeDirectMethodCall(target, fixedImplicitThis, checkCastReceiver, args);\n                }\n            }\n            return super.writeDirectMethodCall(target, implicitThis, receiver, args);\n        }\n    }",
            " 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344  \n 345  \n 346  \n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362 +\n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385  ",
            "    @Override\n    protected boolean writeDirectMethodCall(final MethodNode target, final boolean implicitThis, final Expression receiver, final TupleExpression args) {\n        if (target==null) return false;\n\n        if (target instanceof ExtensionMethodNode) {\n            ExtensionMethodNode emn = (ExtensionMethodNode) target;\n            MethodNode node = emn.getExtensionMethodNode();\n            String methodName = target.getName();\n\n            MethodVisitor mv = controller.getMethodVisitor();\n            int argumentsToRemove = 0;\n            List<Expression> argumentList = new LinkedList<Expression>(args.getExpressions());\n\n            if (emn.isStaticExtension()) {\n                // it's a static extension method\n                argumentList.add(0, ConstantExpression.NULL);\n            } else {\n                argumentList.add(0, receiver);\n            }\n\n            Parameter[] parameters = node.getParameters();\n            loadArguments(argumentList, parameters);\n\n            String owner = BytecodeHelper.getClassInternalName(node.getDeclaringClass());\n            String desc = BytecodeHelper.getMethodDescriptor(target.getReturnType(), parameters);\n            mv.visitMethodInsn(INVOKESTATIC, owner, methodName, desc, false);\n            ClassNode ret = target.getReturnType().redirect();\n            if (ret == ClassHelper.VOID_TYPE) {\n                ret = ClassHelper.OBJECT_TYPE;\n                mv.visitInsn(ACONST_NULL);\n            }\n            argumentsToRemove += argumentList.size();\n            controller.getOperandStack().remove(argumentsToRemove);\n            controller.getOperandStack().push(ret);\n            return true;\n        } else {\n            if (target == StaticTypeCheckingVisitor.CLOSURE_CALL_VARGS) {\n                // wrap arguments into an array\n                ArrayExpression arr = new ArrayExpression(ClassHelper.OBJECT_TYPE, args.getExpressions());\n                return super.writeDirectMethodCall(target, implicitThis, receiver, new ArgumentListExpression(arr));\n            }\n            ClassNode classNode = controller.getClassNode();\n            if (classNode.isDerivedFrom(ClassHelper.CLOSURE_TYPE)\n                    && controller.isInClosure()\n                    && !target.isPublic()\n                    && target.getDeclaringClass() != classNode) {\n                if (!tryBridgeMethod(target, receiver, implicitThis, args, classNode)) {\n                    // replace call with an invoker helper call\n                    ArrayExpression arr = new ArrayExpression(ClassHelper.OBJECT_TYPE, args.getExpressions());\n                    MethodCallExpression mce = new MethodCallExpression(\n                            INVOKERHELPER_RECEIVER,\n                            target.isStatic() ? \"invokeStaticMethod\" : \"invokeMethodSafe\",\n                            new ArgumentListExpression(\n                                    target.isStatic() ?\n                                            new ClassExpression(target.getDeclaringClass()) :\n                                            receiver,\n                                    new ConstantExpression(target.getName()),\n                                    arr\n                            )\n                    );\n                    mce.setMethodTarget(target.isStatic() ? INVOKERHELPER_INVOKESTATICMETHOD : INVOKERHELPER_INVOKEMETHOD);\n                    mce.visit(controller.getAcg());\n                    return true;\n                }\n                return true;\n            }\n            Expression fixedReceiver = null;\n            boolean fixedImplicitThis = implicitThis;\n            if (target.isPrivate()) {\n                if (tryPrivateMethod(target, implicitThis, receiver, args, classNode)) return true;\n            } else if (target.isProtected()) {\n                ClassNode node = receiver==null?ClassHelper.OBJECT_TYPE:controller.getTypeChooser().resolveType(receiver, controller.getClassNode());\n                boolean isThisOrSuper = false;\n                if (receiver instanceof VariableExpression) {\n                    isThisOrSuper = ((VariableExpression) receiver).isThisExpression() || ((VariableExpression) receiver).isSuperExpression();\n                }\n                if (!implicitThis && !isThisOrSuper\n                        && StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(node,target.getDeclaringClass())) {\n                    ASTNode src = receiver==null?args:receiver;\n                    controller.getSourceUnit().addError(\n                            new SyntaxException(\"Method \" + target.getName() + \" is protected in \" + target.getDeclaringClass().toString(false),\n                                    src.getLineNumber(), src.getColumnNumber(), src.getLastLineNumber(), src.getLastColumnNumber()));\n                } else if (!node.isDerivedFrom(target.getDeclaringClass()) && tryBridgeMethod(target, receiver, implicitThis, args, classNode)) {\n                    return true;\n                }\n            } else if (target.isPublic() && receiver != null) {\n                if (implicitThis\n                        && !classNode.isDerivedFrom(target.getDeclaringClass())\n                        && !classNode.implementsInterface(target.getDeclaringClass())\n                        && classNode instanceof InnerClassNode && controller.isInClosure()) {\n                    ClassNode current = classNode.getOuterClass();\n                    fixedReceiver = new VariableExpression(\"thisObject\", current);\n                    // adjust for multiple levels of nesting if needed\n                    while (current instanceof InnerClassNode && !classNode.equals(current)) {\n                        FieldNode thisField = current.getField(\"this$0\");\n                        current = current.getOuterClass();\n                        if (thisField != null) {\n                            fixedReceiver = new PropertyExpression(fixedReceiver, \"this$0\");\n                            fixedReceiver.setType(current);\n                            fixedImplicitThis = false;\n                        }\n                    }\n                }\n            }\n            if (receiver != null) {\n                boolean callToSuper = receiver instanceof VariableExpression && ((VariableExpression) receiver).isSuperExpression();\n                if (!callToSuper) {\n                    fixedReceiver = fixedReceiver == null ? receiver : fixedReceiver;\n                    // in order to avoid calls to castToType, which is the dynamic behaviour, we make sure that we call CHECKCAST instead\n                    // then replace the top operand type\n                    Expression checkCastReceiver = new CheckcastReceiverExpression(fixedReceiver, target);\n                    return super.writeDirectMethodCall(target, fixedImplicitThis, checkCastReceiver, args);\n                }\n            }\n            return super.writeDirectMethodCall(target, implicitThis, receiver, args);\n        }\n    }"
        ],
        [
            "GrabAnnotationTransformation::checkForAutoDownload(AnnotationNode)",
            " 487  \n 488  \n 489 -\n 490  \n 491  \n 492  \n 493  ",
            "    private void checkForAutoDownload(AnnotationNode node) {\n        Object val = node.getMember(AUTO_DOWNLOAD_SETTING);\n        if (val == null || !(val instanceof ConstantExpression)) return;\n        Object autoDownloadValue = ((ConstantExpression)val).getValue();\n        if (!(autoDownloadValue instanceof Boolean)) return;\n        autoDownload = (Boolean) autoDownloadValue;\n    }",
            " 487  \n 488  \n 489 +\n 490  \n 491  \n 492  \n 493  ",
            "    private void checkForAutoDownload(AnnotationNode node) {\n        Object val = node.getMember(AUTO_DOWNLOAD_SETTING);\n        if (!(val instanceof ConstantExpression)) return;\n        Object autoDownloadValue = ((ConstantExpression)val).getValue();\n        if (!(autoDownloadValue instanceof Boolean)) return;\n        autoDownload = (Boolean) autoDownloadValue;\n    }"
        ],
        [
            "AbstractASTTransformation::getValueStringList(ListExpression)",
            " 190  \n 191  \n 192  \n 193 -\n 194  \n 195  \n 196  \n 197  \n 198  \n 199  ",
            "    private static List<String> getValueStringList(ListExpression listExpression) {\r\n        List<String> list = new ArrayList<String>();\r\n        for (Expression itemExpr : listExpression.getExpressions()) {\r\n            if (itemExpr != null && itemExpr instanceof ConstantExpression) {\r\n                Object value = ((ConstantExpression) itemExpr).getValue();\r\n                if (value != null) list.add(value.toString());\r\n            }\r\n        }\r\n        return list;\r\n    }\r",
            " 190  \n 191  \n 192  \n 193 +\n 194  \n 195  \n 196  \n 197  \n 198  \n 199  ",
            "    private static List<String> getValueStringList(ListExpression listExpression) {\r\n        List<String> list = new ArrayList<String>();\r\n        for (Expression itemExpr : listExpression.getExpressions()) {\r\n            if (itemExpr instanceof ConstantExpression) {\r\n                Object value = ((ConstantExpression) itemExpr).getValue();\r\n                if (value != null) list.add(value.toString());\r\n            }\r\n        }\r\n        return list;\r\n    }\r"
        ],
        [
            "StaticInvocationWriter::tryBridgeMethod(MethodNode,Expression,boolean,TupleExpression,ClassNode)",
            " 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250 -\n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  ",
            "    /**\n     * Attempts to make a direct method call on a bridge method, if it exists.\n     */\n    protected boolean tryBridgeMethod(MethodNode target, Expression receiver, boolean implicitThis,\n                                      TupleExpression args, ClassNode thisClass) {\n        ClassNode lookupClassNode;\n        if (target.isProtected()) {\n            lookupClassNode = controller.getClassNode();\n            while (lookupClassNode != null && !lookupClassNode.isDerivedFrom(target.getDeclaringClass())) {\n                lookupClassNode = lookupClassNode.getOuterClass();\n            }\n            if (lookupClassNode == null) {\n                return false;\n            }\n        } else {\n            lookupClassNode = target.getDeclaringClass().redirect();\n        }\n        Map<MethodNode, MethodNode> bridges = lookupClassNode.getNodeMetaData(PRIVATE_BRIDGE_METHODS);\n        MethodNode bridge = bridges==null?null:bridges.get(target);\n        if (bridge != null) {\n            Expression fixedReceiver = receiver;\n            if (implicitThis) {\n                if (!controller.isInClosure()) {\n                    fixedReceiver = new PropertyExpression(new ClassExpression(lookupClassNode), \"this\");\n                } else if (thisClass != null) {\n                    ClassNode current = thisClass.getOuterClass();\n                    fixedReceiver = new VariableExpression(\"thisObject\", current);\n                    // adjust for multiple levels of nesting if needed\n                    while (current != null && current instanceof InnerClassNode && !lookupClassNode.equals(current)) {\n                        FieldNode thisField = current.getField(\"this$0\");\n                        current = current.getOuterClass();\n                        if (thisField != null) {\n                            fixedReceiver = new PropertyExpression(fixedReceiver, \"this$0\");\n                            fixedReceiver.setType(current);\n                        }\n                    }\n                }\n            }\n            ArgumentListExpression newArgs = new ArgumentListExpression(target.isStatic()?new ConstantExpression(null):fixedReceiver);\n            for (Expression expression : args.getExpressions()) {\n                newArgs.addExpression(expression);\n            }\n            return writeDirectMethodCall(bridge, implicitThis, fixedReceiver, newArgs);\n        }\n        return false;\n    }",
            " 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250 +\n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  ",
            "    /**\n     * Attempts to make a direct method call on a bridge method, if it exists.\n     */\n    protected boolean tryBridgeMethod(MethodNode target, Expression receiver, boolean implicitThis,\n                                      TupleExpression args, ClassNode thisClass) {\n        ClassNode lookupClassNode;\n        if (target.isProtected()) {\n            lookupClassNode = controller.getClassNode();\n            while (lookupClassNode != null && !lookupClassNode.isDerivedFrom(target.getDeclaringClass())) {\n                lookupClassNode = lookupClassNode.getOuterClass();\n            }\n            if (lookupClassNode == null) {\n                return false;\n            }\n        } else {\n            lookupClassNode = target.getDeclaringClass().redirect();\n        }\n        Map<MethodNode, MethodNode> bridges = lookupClassNode.getNodeMetaData(PRIVATE_BRIDGE_METHODS);\n        MethodNode bridge = bridges==null?null:bridges.get(target);\n        if (bridge != null) {\n            Expression fixedReceiver = receiver;\n            if (implicitThis) {\n                if (!controller.isInClosure()) {\n                    fixedReceiver = new PropertyExpression(new ClassExpression(lookupClassNode), \"this\");\n                } else if (thisClass != null) {\n                    ClassNode current = thisClass.getOuterClass();\n                    fixedReceiver = new VariableExpression(\"thisObject\", current);\n                    // adjust for multiple levels of nesting if needed\n                    while (current instanceof InnerClassNode && !lookupClassNode.equals(current)) {\n                        FieldNode thisField = current.getField(\"this$0\");\n                        current = current.getOuterClass();\n                        if (thisField != null) {\n                            fixedReceiver = new PropertyExpression(fixedReceiver, \"this$0\");\n                            fixedReceiver.setType(current);\n                        }\n                    }\n                }\n            }\n            ArgumentListExpression newArgs = new ArgumentListExpression(target.isStatic()?new ConstantExpression(null):fixedReceiver);\n            for (Expression expression : args.getExpressions()) {\n                newArgs.addExpression(expression);\n            }\n            return writeDirectMethodCall(bridge, implicitThis, fixedReceiver, newArgs);\n        }\n        return false;\n    }"
        ],
        [
            "GrabAnnotationTransformation::checkForDisableChecksums(AnnotationNode)",
            " 495  \n 496  \n 497 -\n 498  \n 499  \n 500  \n 501  ",
            "    private void checkForDisableChecksums(AnnotationNode node) {\n        Object val = node.getMember(DISABLE_CHECKSUMS_SETTING);\n        if (val == null || !(val instanceof ConstantExpression)) return;\n        Object disableChecksumsValue = ((ConstantExpression)val).getValue();\n        if (!(disableChecksumsValue instanceof Boolean)) return;\n        disableChecksums = (Boolean) disableChecksumsValue;\n    }",
            " 495  \n 496  \n 497 +\n 498  \n 499  \n 500  \n 501  ",
            "    private void checkForDisableChecksums(AnnotationNode node) {\n        Object val = node.getMember(DISABLE_CHECKSUMS_SETTING);\n        if (!(val instanceof ConstantExpression)) return;\n        Object disableChecksumsValue = ((ConstantExpression)val).getValue();\n        if (!(disableChecksumsValue instanceof Boolean)) return;\n        disableChecksums = (Boolean) disableChecksumsValue;\n    }"
        ],
        [
            "CachedClass::addSubclassExpandos(List,MetaClass)",
            " 407  \n 408 -\n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  \n 423  \n 424  \n 425  \n 426  ",
            "    private void addSubclassExpandos(List<MetaMethod> arr, MetaClass mc) {\n        if (mc != null && mc instanceof ExpandoMetaClass) {\n            ExpandoMetaClass emc = (ExpandoMetaClass) mc;\n            for (Object mm : emc.getExpandoSubclassMethods()) {\n                if (mm instanceof MetaMethod) {\n                    MetaMethod method = (MetaMethod) mm;\n                    if (method.getDeclaringClass() == this)\n                      arr.add(method);\n                }\n                else {\n                    FastArray farr = (FastArray) mm;\n                    for (int i = 0; i != farr.size; ++i) {\n                        MetaMethod method = (MetaMethod) farr.get(i);\n                        if (method.getDeclaringClass() == this)\n                          arr.add(method);\n                    }\n                }\n            }\n        }\n    }",
            " 407  \n 408 +\n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  \n 423  \n 424  \n 425  \n 426  ",
            "    private void addSubclassExpandos(List<MetaMethod> arr, MetaClass mc) {\n        if (mc instanceof ExpandoMetaClass) {\n            ExpandoMetaClass emc = (ExpandoMetaClass) mc;\n            for (Object mm : emc.getExpandoSubclassMethods()) {\n                if (mm instanceof MetaMethod) {\n                    MetaMethod method = (MetaMethod) mm;\n                    if (method.getDeclaringClass() == this)\n                      arr.add(method);\n                }\n                else {\n                    FastArray farr = (FastArray) mm;\n                    for (int i = 0; i != farr.size; ++i) {\n                        MetaMethod method = (MetaMethod) farr.get(i);\n                        if (method.getDeclaringClass() == this)\n                          arr.add(method);\n                    }\n                }\n            }\n        }\n    }"
        ],
        [
            "AntlrParserPlugin::tryStatement(AST)",
            "1718  \n1719  \n1720  \n1721  \n1722  \n1723  \n1724  \n1725  \n1726 -\n1727  \n1728  \n1729  \n1730  \n1731  \n1732  \n1733  \n1734  \n1735  \n1736  \n1737  \n1738  \n1739  \n1740  \n1741  \n1742  \n1743  \n1744  \n1745  \n1746  ",
            "    protected Statement tryStatement(AST tryStatementNode) {\n        AST tryNode = tryStatementNode.getFirstChild();\n        Statement tryStatement = statement(tryNode);\n        Statement finallyStatement = EmptyStatement.INSTANCE;\n        AST node = tryNode.getNextSibling();\n\n        // let's do the catch nodes\n        List<CatchStatement> catches = new ArrayList<CatchStatement>();\n        for (; node != null && isType(LITERAL_catch, node); node = node.getNextSibling()) {\n            final List<CatchStatement> catchStatements = catchStatement(node);\n            catches.addAll(catchStatements);\n        }\n\n        if (isType(LITERAL_finally, node)) {\n            finallyStatement = statement(node);\n            node = node.getNextSibling();\n        }\n\n        if (finallyStatement instanceof EmptyStatement && catches.isEmpty()) {\n            throw new ASTRuntimeException(tryStatementNode, \"A try statement must have at least one catch or finally block.\");\n        }\n\n        TryCatchStatement tryCatchStatement = new TryCatchStatement(tryStatement, finallyStatement);\n        configureAST(tryCatchStatement, tryStatementNode);\n        for (CatchStatement statement : catches) {\n            tryCatchStatement.addCatch(statement);\n        }\n        return tryCatchStatement;\n    }",
            "1718  \n1719  \n1720  \n1721  \n1722  \n1723  \n1724  \n1725  \n1726 +\n1727  \n1728  \n1729  \n1730  \n1731  \n1732  \n1733  \n1734  \n1735  \n1736  \n1737  \n1738  \n1739  \n1740  \n1741  \n1742  \n1743  \n1744  \n1745  \n1746  ",
            "    protected Statement tryStatement(AST tryStatementNode) {\n        AST tryNode = tryStatementNode.getFirstChild();\n        Statement tryStatement = statement(tryNode);\n        Statement finallyStatement = EmptyStatement.INSTANCE;\n        AST node = tryNode.getNextSibling();\n\n        // let's do the catch nodes\n        List<CatchStatement> catches = new ArrayList<CatchStatement>();\n        for (; isType(LITERAL_catch, node); node = node.getNextSibling()) {\n            final List<CatchStatement> catchStatements = catchStatement(node);\n            catches.addAll(catchStatements);\n        }\n\n        if (isType(LITERAL_finally, node)) {\n            finallyStatement = statement(node);\n            node = node.getNextSibling();\n        }\n\n        if (finallyStatement instanceof EmptyStatement && catches.isEmpty()) {\n            throw new ASTRuntimeException(tryStatementNode, \"A try statement must have at least one catch or finally block.\");\n        }\n\n        TryCatchStatement tryCatchStatement = new TryCatchStatement(tryStatement, finallyStatement);\n        configureAST(tryCatchStatement, tryStatementNode);\n        for (CatchStatement statement : catches) {\n            tryCatchStatement.addCatch(statement);\n        }\n        return tryCatchStatement;\n    }"
        ],
        [
            "ObservableSet::add(E)",
            " 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194 -\n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  ",
            "    public boolean add(E e) {\n        int oldSize = size();\n        boolean success = delegate.add(e);\n        if (success) {\n            if (test != null) {\n                Object result = test.call(e);\n                if (result != null && result instanceof Boolean && (Boolean) result) {\n                    fireElementAddedEvent(e);\n                    fireSizeChangedEvent(oldSize, size());\n                }\n            } else {\n                fireElementAddedEvent(e);\n                fireSizeChangedEvent(oldSize, size());\n            }\n        }\n        return success;\n    }",
            " 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194 +\n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  ",
            "    public boolean add(E e) {\n        int oldSize = size();\n        boolean success = delegate.add(e);\n        if (success) {\n            if (test != null) {\n                Object result = test.call(e);\n                if (result instanceof Boolean && (Boolean) result) {\n                    fireElementAddedEvent(e);\n                    fireSizeChangedEvent(oldSize, size());\n                }\n            } else {\n                fireElementAddedEvent(e);\n                fireSizeChangedEvent(oldSize, size());\n            }\n        }\n        return success;\n    }"
        ],
        [
            "GroovyCodeSource::GroovyCodeSource(File,String)",
            " 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152 -\n 153  \n 154  \n 155  \n 156  \n 157  ",
            "    public GroovyCodeSource(final File infile, final String encoding) throws IOException {\n        // avoid files which confuse us like ones with .. in path\n        final File file = new File(infile.getCanonicalPath());\n        if (!file.exists()) {\n            throw new FileNotFoundException(file.toString() + \" (\" + file.getAbsolutePath() + \")\");\n        }\n        if (file.isDirectory()) {\n            throw new IllegalArgumentException(file.toString() + \" (\" + file.getAbsolutePath() + \") is a directory not a Groovy source file.\");\n        }\n        try {\n            if (!file.canRead())\n                throw new RuntimeException(file.toString() + \" can not be read. Check the read permission of the file \\\"\" + file.toString() + \"\\\" (\" + file.getAbsolutePath() + \").\");\n        }\n        catch (SecurityException e) {\n            throw e;\n        }\n\n        this.file = file;\n        this.cachable = true;\n        //The calls below require access to user.dir - allow here since getName() and getCodeSource() are\n        //package private and used only by the GroovyClassLoader.\n        try {\n            Object[] info = AccessController.doPrivileged(new PrivilegedExceptionAction<Object[]>() {\n                public Object[] run() throws IOException {\n                    // retrieve the content of the file using the provided encoding\n                    if (encoding != null) {\n                        scriptText = ResourceGroovyMethods.getText(infile, encoding);\n                    } else {\n                        scriptText = ResourceGroovyMethods.getText(infile);\n                    }\n\n                    Object[] info = new Object[2];\n                    URL url = file.toURI().toURL();\n                    info[0] = url.toExternalForm();\n                    //toURI().toURL() will encode, but toURL() will not.\n                    info[1] = new CodeSource(url, (Certificate[]) null);\n                    return info;\n                }\n            });\n\n            this.name = (String) info[0];\n            this.codeSource = (CodeSource) info[1];\n        } catch (PrivilegedActionException pae) {\n            Throwable cause = pae.getCause();\n            if (cause != null && cause instanceof IOException) {\n                throw (IOException) cause;\n            }\n            throw new RuntimeException(\"Could not construct CodeSource for file: \" + file, cause);\n        }\n    }",
            " 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152 +\n 153  \n 154  \n 155  \n 156  \n 157  ",
            "    public GroovyCodeSource(final File infile, final String encoding) throws IOException {\n        // avoid files which confuse us like ones with .. in path\n        final File file = new File(infile.getCanonicalPath());\n        if (!file.exists()) {\n            throw new FileNotFoundException(file.toString() + \" (\" + file.getAbsolutePath() + \")\");\n        }\n        if (file.isDirectory()) {\n            throw new IllegalArgumentException(file.toString() + \" (\" + file.getAbsolutePath() + \") is a directory not a Groovy source file.\");\n        }\n        try {\n            if (!file.canRead())\n                throw new RuntimeException(file.toString() + \" can not be read. Check the read permission of the file \\\"\" + file.toString() + \"\\\" (\" + file.getAbsolutePath() + \").\");\n        }\n        catch (SecurityException e) {\n            throw e;\n        }\n\n        this.file = file;\n        this.cachable = true;\n        //The calls below require access to user.dir - allow here since getName() and getCodeSource() are\n        //package private and used only by the GroovyClassLoader.\n        try {\n            Object[] info = AccessController.doPrivileged(new PrivilegedExceptionAction<Object[]>() {\n                public Object[] run() throws IOException {\n                    // retrieve the content of the file using the provided encoding\n                    if (encoding != null) {\n                        scriptText = ResourceGroovyMethods.getText(infile, encoding);\n                    } else {\n                        scriptText = ResourceGroovyMethods.getText(infile);\n                    }\n\n                    Object[] info = new Object[2];\n                    URL url = file.toURI().toURL();\n                    info[0] = url.toExternalForm();\n                    //toURI().toURL() will encode, but toURL() will not.\n                    info[1] = new CodeSource(url, (Certificate[]) null);\n                    return info;\n                }\n            });\n\n            this.name = (String) info[0];\n            this.codeSource = (CodeSource) info[1];\n        } catch (PrivilegedActionException pae) {\n            Throwable cause = pae.getCause();\n            if (cause instanceof IOException) {\n                throw (IOException) cause;\n            }\n            throw new RuntimeException(\"Could not construct CodeSource for file: \" + file, cause);\n        }\n    }"
        ],
        [
            "AbstractASTTransformation::getTypeList(ListExpression)",
            " 235  \n 236  \n 237  \n 238 -\n 239  \n 240  \n 241  \n 242  \n 243  \n 244  ",
            "    private static List<ClassNode> getTypeList(ListExpression listExpression) {\r\n        List<ClassNode> list = new ArrayList<ClassNode>();\r\n        for (Expression itemExpr : listExpression.getExpressions()) {\r\n            if (itemExpr != null && itemExpr instanceof ClassExpression) {\r\n                ClassNode cn = itemExpr.getType();\r\n                if (cn != null) list.add(cn);\r\n            }\r\n        }\r\n        return list;\r\n    }\r",
            " 235  \n 236  \n 237  \n 238 +\n 239  \n 240  \n 241  \n 242  \n 243  \n 244  ",
            "    private static List<ClassNode> getTypeList(ListExpression listExpression) {\r\n        List<ClassNode> list = new ArrayList<ClassNode>();\r\n        for (Expression itemExpr : listExpression.getExpressions()) {\r\n            if (itemExpr instanceof ClassExpression) {\r\n                ClassNode cn = itemExpr.getType();\r\n                if (cn != null) list.add(cn);\r\n            }\r\n        }\r\n        return list;\r\n    }\r"
        ],
        [
            "ConstructorNode::firstStatementIsSpecialConstructorCall()",
            "  49  \n  50  \n  51 -\n  52  \n  53  \n  54  \n  55  \n  56  \n  57  ",
            "    public boolean firstStatementIsSpecialConstructorCall() {\n        Statement code = getFirstStatement();\n        if (code == null || !(code instanceof ExpressionStatement)) return false;\n\n        Expression expression = ((ExpressionStatement) code).getExpression();\n        if (!(expression instanceof ConstructorCallExpression)) return false;\n        ConstructorCallExpression cce = (ConstructorCallExpression) expression;\n        return cce.isSpecialCall();\n    }",
            "  49  \n  50  \n  51 +\n  52  \n  53  \n  54  \n  55  \n  56  \n  57  ",
            "    public boolean firstStatementIsSpecialConstructorCall() {\n        Statement code = getFirstStatement();\n        if (!(code instanceof ExpressionStatement)) return false;\n\n        Expression expression = ((ExpressionStatement) code).getExpression();\n        if (!(expression instanceof ConstructorCallExpression)) return false;\n        ConstructorCallExpression cce = (ConstructorCallExpression) expression;\n        return cce.isSpecialCall();\n    }"
        ],
        [
            "AbstractASTTransformation::getMemberList(AnnotationNode,String)",
            " 177  \n 178  \n 179  \n 180  \n 181 -\n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  ",
            "    @Deprecated\r\n    public static List<String> getMemberList(AnnotationNode anno, String name) {\r\n        List<String> list;\r\n        Expression expr = anno.getMember(name);\r\n        if (expr != null && expr instanceof ListExpression) {\r\n            final ListExpression listExpression = (ListExpression) expr;\r\n            list = getValueStringList(listExpression);\r\n        } else {\r\n            list = tokenize(getMemberStringValue(anno, name));\r\n        }\r\n        return list;\r\n    }\r",
            " 177  \n 178  \n 179  \n 180  \n 181 +\n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  ",
            "    @Deprecated\r\n    public static List<String> getMemberList(AnnotationNode anno, String name) {\r\n        List<String> list;\r\n        Expression expr = anno.getMember(name);\r\n        if (expr instanceof ListExpression) {\r\n            final ListExpression listExpression = (ListExpression) expr;\r\n            list = getValueStringList(listExpression);\r\n        } else {\r\n            list = tokenize(getMemberStringValue(anno, name));\r\n        }\r\n        return list;\r\n    }\r"
        ],
        [
            "GrabAnnotationTransformation::checkForClassLoader(AnnotationNode)",
            " 470  \n 471  \n 472 -\n 473  \n 474  \n 475  \n 476  \n 477  ",
            "    private void checkForClassLoader(AnnotationNode node) {\n        Object val = node.getMember(\"systemClassLoader\");\n        if (val == null || !(val instanceof ConstantExpression)) return;\n        Object systemClassLoaderObject = ((ConstantExpression)val).getValue();\n        if (!(systemClassLoaderObject instanceof Boolean)) return;\n        Boolean systemClassLoader = (Boolean) systemClassLoaderObject;\n        if (systemClassLoader) loader = ClassLoader.getSystemClassLoader();\n    }",
            " 470  \n 471  \n 472 +\n 473  \n 474  \n 475  \n 476  \n 477  ",
            "    private void checkForClassLoader(AnnotationNode node) {\n        Object val = node.getMember(\"systemClassLoader\");\n        if (!(val instanceof ConstantExpression)) return;\n        Object systemClassLoaderObject = ((ConstantExpression)val).getValue();\n        if (!(systemClassLoaderObject instanceof Boolean)) return;\n        Boolean systemClassLoader = (Boolean) systemClassLoaderObject;\n        if (systemClassLoader) loader = ClassLoader.getSystemClassLoader();\n    }"
        ],
        [
            "ObservableSet::addAll(Collection)",
            " 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237 -\n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  ",
            "    public boolean addAll(Collection<? extends E> c) {\n        Set<E> duplicates = new HashSet<E>();\n        if (null != c) {\n            for (E e : c) {\n                if (!delegate.contains(e)) continue;\n                duplicates.add(e);\n            }\n        }\n\n        int oldSize = size();\n        boolean success = delegate.addAll(c);\n\n        if (success && c != null) {\n            List<E> values = new ArrayList<E>();\n            for (E element : c) {\n                if (test != null) {\n                    Object result = test.call(element);\n                    if (result != null && result instanceof Boolean && (Boolean) result && !duplicates.contains(element)) {\n                        values.add(element);\n                    }\n                } else if (!duplicates.contains(element)) {\n                    values.add(element);\n                }\n            }\n            if (!values.isEmpty()) {\n                fireMultiElementAddedEvent(values);\n                fireSizeChangedEvent(oldSize, size());\n            }\n        }\n\n        return success;\n    }",
            " 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237 +\n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  ",
            "    public boolean addAll(Collection<? extends E> c) {\n        Set<E> duplicates = new HashSet<E>();\n        if (null != c) {\n            for (E e : c) {\n                if (!delegate.contains(e)) continue;\n                duplicates.add(e);\n            }\n        }\n\n        int oldSize = size();\n        boolean success = delegate.addAll(c);\n\n        if (success && c != null) {\n            List<E> values = new ArrayList<E>();\n            for (E element : c) {\n                if (test != null) {\n                    Object result = test.call(element);\n                    if (result instanceof Boolean && (Boolean) result && !duplicates.contains(element)) {\n                        values.add(element);\n                    }\n                } else if (!duplicates.contains(element)) {\n                    values.add(element);\n                }\n            }\n            if (!values.isEmpty()) {\n                fireMultiElementAddedEvent(values);\n                fireSizeChangedEvent(oldSize, size());\n            }\n        }\n\n        return success;\n    }"
        ],
        [
            "InvokerHelper::setPropertySafe(Object,MetaClass,String,Object)",
            " 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512 -\n 513  \n 514  ",
            "    private static void setPropertySafe(Object object, MetaClass mc, String key, Object value) {\n        try {\n            mc.setProperty(object, key, value);\n        } catch (MissingPropertyException mpe) {\n            // Ignore\n        } catch (InvokerInvocationException iie) {\n            // GROOVY-5802 IAE for missing properties with classes that extend List\n            Throwable cause = iie.getCause();\n            if (cause == null || !(cause instanceof IllegalArgumentException)) throw iie;\n        }\n    }",
            " 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512 +\n 513  \n 514  ",
            "    private static void setPropertySafe(Object object, MetaClass mc, String key, Object value) {\n        try {\n            mc.setProperty(object, key, value);\n        } catch (MissingPropertyException mpe) {\n            // Ignore\n        } catch (InvokerInvocationException iie) {\n            // GROOVY-5802 IAE for missing properties with classes that extend List\n            Throwable cause = iie.getCause();\n            if (!(cause instanceof IllegalArgumentException)) throw iie;\n        }\n    }"
        ]
    ],
    "7e918d1b7f7fa6695e62eea1acd2e6940a764dea": [
        [
            "StaticTypeCheckingVisitor::ensureValidSetter(Expression,Expression,Expression,SetterInfo)",
            " 686  \n 687  \n 688  \n 689  \n 690  \n 691  \n 692  \n 693  \n 694  \n 695  \n 696  \n 697  \n 698  \n 699  \n 700  \n 701  \n 702  \n 703  \n 704  \n 705  \n 706  \n 707  \n 708  \n 709  \n 710  \n 711  \n 712  \n 713  \n 714  \n 715  \n 716  \n 717  \n 718  \n 719  \n 720  \n 721  \n 722  \n 723  ",
            "    /**\n     * Given a binary expression corresponding to an assignment, will check that the type of the RHS matches one\n     * of the possible setters and if not, throw a type checking error.\n     * @param expression the assignment expression\n     * @param leftExpression left expression of the assignment\n     * @param rightExpression right expression of the assignment\n     * @param setterInfo possible setters\n     * @return true if type checking passed\n     */\n    private boolean ensureValidSetter(final Expression expression, final Expression leftExpression, final Expression rightExpression, final SetterInfo setterInfo) {\n        // for expressions like foo = { ... }\n        // we know that the RHS type is a closure\n        // but we must check if the binary expression is an assignment\n        // because we need to check if a setter uses @DelegatesTo\n        VariableExpression ve = new VariableExpression(\"%\", setterInfo.receiverType);\n        MethodCallExpression call = new MethodCallExpression(\n                ve,\n                setterInfo.name,\n                rightExpression\n        );\n        call.setImplicitThis(false);\n        visitMethodCallExpression(call);\n        MethodNode directSetterCandidate = call.getNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET);\n        if (directSetterCandidate != null) {\n            for (MethodNode setter : setterInfo.setters) {\n                if (setter == directSetterCandidate) {\n                    leftExpression.putNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET, directSetterCandidate);\n                    storeType(leftExpression, getType(rightExpression));\n                    break;\n                }\n            }\n        } else {\n            ClassNode firstSetterType = setterInfo.setters.iterator().next().getParameters()[0].getOriginType();\n            addAssignmentError(firstSetterType, getType(rightExpression), expression);\n            return true;\n        }\n        return false;\n    }",
            " 686  \n 687  \n 688  \n 689  \n 690  \n 691  \n 692  \n 693  \n 694  \n 695  \n 696  \n 697  \n 698  \n 699  \n 700  \n 701  \n 702  \n 703  \n 704  \n 705  \n 706  \n 707  \n 708  \n 709 +\n 710 +\n 711 +\n 712 +\n 713 +\n 714 +\n 715 +\n 716 +\n 717 +\n 718 +\n 719 +\n 720 +\n 721 +\n 722 +\n 723 +\n 724 +\n 725 +\n 726 +\n 727 +\n 728 +\n 729  \n 730  \n 731  \n 732  \n 733  \n 734  \n 735  \n 736  \n 737  \n 738  \n 739  \n 740  \n 741  \n 742  \n 743  ",
            "    /**\n     * Given a binary expression corresponding to an assignment, will check that the type of the RHS matches one\n     * of the possible setters and if not, throw a type checking error.\n     * @param expression the assignment expression\n     * @param leftExpression left expression of the assignment\n     * @param rightExpression right expression of the assignment\n     * @param setterInfo possible setters\n     * @return true if type checking passed\n     */\n    private boolean ensureValidSetter(final Expression expression, final Expression leftExpression, final Expression rightExpression, final SetterInfo setterInfo) {\n        // for expressions like foo = { ... }\n        // we know that the RHS type is a closure\n        // but we must check if the binary expression is an assignment\n        // because we need to check if a setter uses @DelegatesTo\n        VariableExpression ve = new VariableExpression(\"%\", setterInfo.receiverType);\n        MethodCallExpression call = new MethodCallExpression(\n                ve,\n                setterInfo.name,\n                rightExpression\n        );\n        call.setImplicitThis(false);\n        visitMethodCallExpression(call);\n        MethodNode directSetterCandidate = call.getNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET);\n        if (directSetterCandidate==null) {\n            // this may happen if there's a setter of type boolean/String/Class, and that we are using the property\n            // notation AND that the RHS is not a boolean/String/Class\n            for (MethodNode setter : setterInfo.setters) {\n                ClassNode type = getWrapper(setter.getParameters()[0].getOriginType());\n                if (Boolean_TYPE.equals(type) || STRING_TYPE.equals(type) || CLASS_Type.equals(type)) {\n                    call = new MethodCallExpression(\n                            ve,\n                            setterInfo.name,\n                            new CastExpression(type,rightExpression)\n                    );\n                    call.setImplicitThis(false);\n                    visitMethodCallExpression(call);\n                    directSetterCandidate = call.getNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET);\n                    if (directSetterCandidate!=null) {\n                        break;\n                    }\n                }\n            }\n        }\n        if (directSetterCandidate != null) {\n            for (MethodNode setter : setterInfo.setters) {\n                if (setter == directSetterCandidate) {\n                    leftExpression.putNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET, directSetterCandidate);\n                    storeType(leftExpression, getType(rightExpression));\n                    break;\n                }\n            }\n        } else {\n            ClassNode firstSetterType = setterInfo.setters.iterator().next().getParameters()[0].getOriginType();\n            addAssignmentError(firstSetterType, getType(rightExpression), expression);\n            return true;\n        }\n        return false;\n    }"
        ]
    ],
    "f59f793ab347046f7f4118d3604163a308ba26f0": [
        [
            "TraitASTTransformation::createInitMethod(boolean,ClassNode,ClassNode)",
            " 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232 -\n 233 -\n 234 -\n 235  \n 236  \n 237  ",
            "    private MethodNode createInitMethod(final boolean isStatic, final ClassNode cNode, final ClassNode helper) {\n        MethodNode initializer = new MethodNode(\n                isStatic?Traits.STATIC_INIT_METHOD:Traits.INIT_METHOD,\n                ACC_STATIC | ACC_PUBLIC | ACC_SYNTHETIC,\n                ClassHelper.VOID_TYPE,\n                new Parameter[]{createSelfParameter(cNode, isStatic)},\n                ClassNode.EMPTY_ARRAY,\n                new BlockStatement()\n        );\n        fixGenerics(initializer, cNode);\n        helper.addMethod(initializer);\n        AnnotationNode an = new AnnotationNode(TraitComposer.COMPILESTATIC_CLASSNODE);\n        initializer.addAnnotation(an);\n        cNode.addTransform(StaticCompileTransformation.class, an);\n\n        return initializer;\n    }",
            " 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232 +\n 233 +\n 234 +\n 235 +\n 236 +\n 237  \n 238  \n 239  ",
            "    private MethodNode createInitMethod(final boolean isStatic, final ClassNode cNode, final ClassNode helper) {\n        MethodNode initializer = new MethodNode(\n                isStatic?Traits.STATIC_INIT_METHOD:Traits.INIT_METHOD,\n                ACC_STATIC | ACC_PUBLIC | ACC_SYNTHETIC,\n                ClassHelper.VOID_TYPE,\n                new Parameter[]{createSelfParameter(cNode, isStatic)},\n                ClassNode.EMPTY_ARRAY,\n                new BlockStatement()\n        );\n        fixGenerics(initializer, cNode);\n        helper.addMethod(initializer);\n\n        // Cannot add static compilation of init method because of GROOVY-7217, see example 2 of test case\n        //AnnotationNode an = new AnnotationNode(TraitComposer.COMPILESTATIC_CLASSNODE);\n        //initializer.addAnnotation(an);\n        //cNode.addTransform(StaticCompileTransformation.class, an);\n\n        return initializer;\n    }"
        ],
        [
            "TraitASTTransformation::processField(FieldNode,MethodNode,MethodNode,ClassNode,ClassNode,Set)",
            " 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388 -\n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  \n 423  \n 424  \n 425  \n 426  \n 427  \n 428  \n 429  \n 430  \n 431  ",
            "    private void processField(final FieldNode field, final MethodNode initializer, final MethodNode staticInitializer, final ClassNode fieldHelper, final ClassNode trait, final Set<String> knownFields) {\n        Expression initialExpression = field.getInitialExpression();\n        MethodNode selectedMethod = field.isStatic()?staticInitializer:initializer;\n        if (initialExpression != null) {\n            VariableExpression thisObject = new VariableExpression(selectedMethod.getParameters()[0]);\n            ExpressionStatement initCode = new ExpressionStatement(initialExpression);\n            processBody(thisObject, selectedMethod, initCode, trait, fieldHelper, knownFields);\n            BlockStatement code = (BlockStatement) selectedMethod.getCode();\n            MethodCallExpression mce;\n            if (field.isStatic()) {\n                mce = new MethodCallExpression(\n                        new ClassExpression(INVOKERHELPER_CLASSNODE),\n                        \"invokeStaticMethod\",\n                        new ArgumentListExpression(\n                                thisObject,\n                                new ConstantExpression(Traits.helperSetterName(field)),\n                                initCode.getExpression()\n                        )\n                );\n            } else {\n                mce = new MethodCallExpression(\n                        new CastExpression(createReceiverType(field.isStatic(), fieldHelper), thisObject),\n                        Traits.helperSetterName(field),\n                        initCode.getExpression()\n                );\n            }\n            mce.setImplicitThis(false);\n            mce.setSourcePosition(initialExpression);\n            code.addStatement(new ExpressionStatement(mce));\n        }\n        // define setter/getter helper methods\n        fieldHelper.addMethod(\n                Traits.helperSetterName(field),\n                ACC_PUBLIC | ACC_ABSTRACT,\n                field.getOriginType(),\n                new Parameter[]{new Parameter(field.getOriginType(), \"val\")},\n                ClassNode.EMPTY_ARRAY,\n                null\n        );\n        fieldHelper.addMethod(\n                Traits.helperGetterName(field),\n                ACC_PUBLIC | ACC_ABSTRACT,\n                field.getOriginType(),\n                Parameter.EMPTY_ARRAY,\n                ClassNode.EMPTY_ARRAY,\n                null\n        );\n\n        // dummy fields are only used to carry annotations if instance field\n        // and to differentiate from static fields otherwise\n        String dummyFieldName = (field.isStatic() ? Traits.STATIC_FIELD_PREFIX : Traits.FIELD_PREFIX) +\n                (field.isPublic()? Traits.PUBLIC_FIELD_PREFIX : Traits.PRIVATE_FIELD_PREFIX)+\n                Traits.remappedFieldName(field.getOwner(), field.getName());\n        FieldNode dummyField = new FieldNode(\n                dummyFieldName,\n                ACC_STATIC | ACC_PUBLIC | ACC_FINAL | ACC_SYNTHETIC,\n                field.getOriginType(),\n                fieldHelper,\n                null\n        );\n        // copy annotations from field to dummy field\n        List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n        List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n        GeneralUtils.copyAnnotatedNodeAnnotations(field, copied, notCopied);\n        dummyField.addAnnotations(copied);\n        fieldHelper.addField(dummyField);\n    }",
            " 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388  \n 389  \n 390 +\n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  \n 423  \n 424  \n 425  \n 426  \n 427  \n 428  \n 429  \n 430  \n 431  \n 432  \n 433  ",
            "    private void processField(final FieldNode field, final MethodNode initializer, final MethodNode staticInitializer, final ClassNode fieldHelper, final ClassNode trait, final Set<String> knownFields) {\n        Expression initialExpression = field.getInitialExpression();\n        MethodNode selectedMethod = field.isStatic()?staticInitializer:initializer;\n        if (initialExpression != null) {\n            VariableExpression thisObject = new VariableExpression(selectedMethod.getParameters()[0]);\n            ExpressionStatement initCode = new ExpressionStatement(initialExpression);\n            processBody(thisObject, selectedMethod, initCode, trait, fieldHelper, knownFields);\n            BlockStatement code = (BlockStatement) selectedMethod.getCode();\n            MethodCallExpression mce;\n            if (field.isStatic()) {\n                mce = new MethodCallExpression(\n                        new ClassExpression(INVOKERHELPER_CLASSNODE),\n                        \"invokeStaticMethod\",\n                        new ArgumentListExpression(\n                                thisObject,\n                                new ConstantExpression(Traits.helperSetterName(field)),\n                                initCode.getExpression()\n                        )\n                );\n            } else {\n                mce = new MethodCallExpression(\n                        new CastExpression(createReceiverType(field.isStatic(), fieldHelper), thisObject),\n                        Traits.helperSetterName(field),\n                        new CastExpression(field.getOriginType(),initCode.getExpression())\n                );\n            }\n            mce.setImplicitThis(false);\n            mce.setSourcePosition(initialExpression);\n            code.addStatement(new ExpressionStatement(mce));\n        }\n        // define setter/getter helper methods\n        fieldHelper.addMethod(\n                Traits.helperSetterName(field),\n                ACC_PUBLIC | ACC_ABSTRACT,\n                field.getOriginType(),\n                new Parameter[]{new Parameter(field.getOriginType(), \"val\")},\n                ClassNode.EMPTY_ARRAY,\n                null\n        );\n        fieldHelper.addMethod(\n                Traits.helperGetterName(field),\n                ACC_PUBLIC | ACC_ABSTRACT,\n                field.getOriginType(),\n                Parameter.EMPTY_ARRAY,\n                ClassNode.EMPTY_ARRAY,\n                null\n        );\n\n        // dummy fields are only used to carry annotations if instance field\n        // and to differentiate from static fields otherwise\n        String dummyFieldName = (field.isStatic() ? Traits.STATIC_FIELD_PREFIX : Traits.FIELD_PREFIX) +\n                (field.isPublic()? Traits.PUBLIC_FIELD_PREFIX : Traits.PRIVATE_FIELD_PREFIX)+\n                Traits.remappedFieldName(field.getOwner(), field.getName());\n        FieldNode dummyField = new FieldNode(\n                dummyFieldName,\n                ACC_STATIC | ACC_PUBLIC | ACC_FINAL | ACC_SYNTHETIC,\n                field.getOriginType(),\n                fieldHelper,\n                null\n        );\n        // copy annotations from field to dummy field\n        List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n        List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n        GeneralUtils.copyAnnotatedNodeAnnotations(field, copied, notCopied);\n        dummyField.addAnnotations(copied);\n        fieldHelper.addField(dummyField);\n    }"
        ]
    ],
    "8ed7f551125cf1aa6b927898f0811a86fe783af2": [
        [
            "DelegateASTTransformation::addGetterIfNeeded(DelegateDescription,PropertyNode,String,boolean)",
            " 202  \n 203 -\n 204 -\n 205 -\n 206 -\n 207 -\n 208 -\n 209 -\n 210 -\n 211 -\n 212  \n 213  ",
            "    private static void addGetterIfNeeded(DelegateDescription delegate, PropertyNode prop, String name, boolean allNames) {\n        String getterName = \"get\" + Verifier.capitalize(name);\n        if (delegate.owner.getGetterMethod(getterName) == null\n                && !shouldSkipPropertyMethod(name, getterName, delegate.excludes, delegate.includes, allNames)) {\n            delegate.owner.addMethod(getterName,\n                    ACC_PUBLIC,\n                    GenericsUtils.nonGeneric(prop.getType()),\n                    Parameter.EMPTY_ARRAY,\n                    null,\n                    returnS(propX(delegate.getOp, name)));\n        }\n    }",
            " 202  \n 203 +\n 204 +\n 205 +\n 206 +\n 207 +\n 208 +\n 209 +\n 210 +\n 211 +\n 212 +\n 213 +\n 214 +\n 215 +\n 216 +\n 217 +\n 218 +\n 219 +\n 220 +\n 221 +\n 222 +\n 223 +\n 224 +\n 225 +\n 226 +\n 227 +\n 228  \n 229  ",
            "    private static void addGetterIfNeeded(DelegateDescription delegate, PropertyNode prop, String name, boolean allNames) {\n        boolean isPrimBool = prop.getOriginType().equals(ClassHelper.boolean_TYPE);\n        // do a little bit of pre-work since Groovy compiler hasn't added property accessors yet\n        boolean willHaveGetAccessor = true;\n        boolean willHaveIsAccessor = isPrimBool;\n        String suffix = Verifier.capitalize(name);\n        if (isPrimBool) {\n            ClassNode cNode = prop.getDeclaringClass();\n            if (cNode.getGetterMethod(\"is\" + suffix) != null && cNode.getGetterMethod(\"get\" + suffix) == null)\n                willHaveGetAccessor = false;\n            if (cNode.getGetterMethod(\"get\" + suffix) != null && cNode.getGetterMethod(\"is\" + suffix) == null)\n                willHaveIsAccessor = false;\n        }\n        for (String prefix : new String[]{\"get\", \"is\"}) {\n            String getterName = prefix + suffix;\n            if (delegate.owner.getGetterMethod(getterName) == null\n                    && !shouldSkipPropertyMethod(name, getterName, delegate.excludes, delegate.includes, allNames)) {\n                if (prefix.equals(\"get\") && willHaveGetAccessor || prefix.equals(\"is\") && willHaveIsAccessor) {\n                    delegate.owner.addMethod(getterName,\n                            ACC_PUBLIC,\n                            GenericsUtils.nonGeneric(prop.getType()),\n                            Parameter.EMPTY_ARRAY,\n                            null,\n                            returnS(propX(delegate.getOp, name)));\n                }\n            }\n        }\n    }"
        ]
    ],
    "14a3a67003beca8cc7f4b2619a3b1af39ec6312b": [
        [
            "ToStringASTTransformation::visit(ASTNode,SourceUnit)",
            "  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  ",
            "    public void visit(ASTNode[] nodes, SourceUnit source) {\n        init(nodes, source);\n        AnnotatedNode parent = (AnnotatedNode) nodes[1];\n        AnnotationNode anno = (AnnotationNode) nodes[0];\n        if (!MY_TYPE.equals(anno.getClassNode())) return;\n\n        if (parent instanceof ClassNode) {\n            ClassNode cNode = (ClassNode) parent;\n            if (!checkNotInterface(cNode, MY_TYPE_NAME)) return;\n            boolean includeSuper = memberHasValue(anno, \"includeSuper\", true);\n            boolean includeSuperProperties = memberHasValue(anno, \"includeSuperProperties\", true);\n            boolean cacheToString = memberHasValue(anno, \"cache\", true);\n            if (includeSuper && cNode.getSuperClass().getName().equals(\"java.lang.Object\")) {\n                addError(\"Error during \" + MY_TYPE_NAME + \" processing: includeSuper=true but '\" + cNode.getName() + \"' has no super class.\", anno);\n            }\n            boolean includeNames = memberHasValue(anno, \"includeNames\", true);\n            boolean includeFields = memberHasValue(anno, \"includeFields\", true);\n            List<String> excludes = getMemberList(anno, \"excludes\");\n            List<String> includes = getMemberList(anno, \"includes\");\n            boolean ignoreNulls = memberHasValue(anno, \"ignoreNulls\", true);\n            boolean includePackage = !memberHasValue(anno, \"includePackage\", false);\n            boolean allProperties = !memberHasValue(anno, \"allProperties\", false);\n\n            if (!checkIncludeExclude(anno, excludes, includes, MY_TYPE_NAME)) return;\n            createToString(cNode, includeSuper, includeFields, excludes, includes, includeNames, ignoreNulls, includePackage, cacheToString, includeSuperProperties, allProperties);\n        }\n    }",
            "  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85 +\n  86 +\n  87  \n  88  \n  89  ",
            "    public void visit(ASTNode[] nodes, SourceUnit source) {\n        init(nodes, source);\n        AnnotatedNode parent = (AnnotatedNode) nodes[1];\n        AnnotationNode anno = (AnnotationNode) nodes[0];\n        if (!MY_TYPE.equals(anno.getClassNode())) return;\n\n        if (parent instanceof ClassNode) {\n            ClassNode cNode = (ClassNode) parent;\n            if (!checkNotInterface(cNode, MY_TYPE_NAME)) return;\n            boolean includeSuper = memberHasValue(anno, \"includeSuper\", true);\n            boolean includeSuperProperties = memberHasValue(anno, \"includeSuperProperties\", true);\n            boolean cacheToString = memberHasValue(anno, \"cache\", true);\n            if (includeSuper && cNode.getSuperClass().getName().equals(\"java.lang.Object\")) {\n                addError(\"Error during \" + MY_TYPE_NAME + \" processing: includeSuper=true but '\" + cNode.getName() + \"' has no super class.\", anno);\n            }\n            boolean includeNames = memberHasValue(anno, \"includeNames\", true);\n            boolean includeFields = memberHasValue(anno, \"includeFields\", true);\n            List<String> excludes = getMemberList(anno, \"excludes\");\n            List<String> includes = getMemberList(anno, \"includes\");\n            boolean ignoreNulls = memberHasValue(anno, \"ignoreNulls\", true);\n            boolean includePackage = !memberHasValue(anno, \"includePackage\", false);\n            boolean allProperties = !memberHasValue(anno, \"allProperties\", false);\n\n            if (!checkIncludeExclude(anno, excludes, includes, MY_TYPE_NAME)) return;\n            if (!checkPropertyList(cNode, includes, \"includes\", anno, MY_TYPE_NAME, includeFields)) return;\n            if (!checkPropertyList(cNode, excludes, \"excludes\", anno, MY_TYPE_NAME, includeFields)) return;\n            createToString(cNode, includeSuper, includeFields, excludes, includes, includeNames, ignoreNulls, includePackage, cacheToString, includeSuperProperties, allProperties);\n        }\n    }"
        ],
        [
            "GeneralUtils::getInstancePropertyNames(ClassNode)",
            " 385  \n 386 -\n 387  \n 388  \n 389  \n 390  \n 391  \n 392  ",
            "    public static List<String> getInstancePropertyNames(ClassNode cNode) {\n        List<PropertyNode> pList = getInstanceProperties(cNode);\n        List<String> result = new ArrayList<String>(pList.size());\n        for (PropertyNode pNode : pList) {\n            result.add(pNode.getName());\n        }\n        return result;\n    }",
            " 385  \n 386 +\n 387  \n 388  \n 389  \n 390  \n 391  \n 392  ",
            "    public static List<String> getInstancePropertyNames(ClassNode cNode) {\n        List<PropertyNode> pList = BeanUtils.getAllProperties(cNode, false, false, true);\n        List<String> result = new ArrayList<String>(pList.size());\n        for (PropertyNode pNode : pList) {\n            result.add(pNode.getName());\n        }\n        return result;\n    }"
        ],
        [
            "TupleConstructorASTTransformation::visit(ASTNode,SourceUnit)",
            "  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  ",
            "    public void visit(ASTNode[] nodes, SourceUnit source) {\r\n        init(nodes, source);\r\n        AnnotatedNode parent = (AnnotatedNode) nodes[1];\r\n        AnnotationNode anno = (AnnotationNode) nodes[0];\r\n        if (!MY_TYPE.equals(anno.getClassNode())) return;\r\n\r\n        if (parent instanceof ClassNode) {\r\n            ClassNode cNode = (ClassNode) parent;\r\n            if (!checkNotInterface(cNode, MY_TYPE_NAME)) return;\r\n            boolean includeFields = memberHasValue(anno, \"includeFields\", true);\r\n            boolean includeProperties = !memberHasValue(anno, \"includeProperties\", false);\r\n            boolean includeSuperFields = memberHasValue(anno, \"includeSuperFields\", true);\r\n            boolean includeSuperProperties = memberHasValue(anno, \"includeSuperProperties\", true);\r\n            boolean callSuper = memberHasValue(anno, \"callSuper\", true);\r\n            boolean force = memberHasValue(anno, \"force\", true);\r\n            boolean defaults = !memberHasValue(anno, \"defaults\", false);\r\n            boolean useSetters = memberHasValue(anno, \"useSetters\", true);\r\n            List<String> excludes = getMemberList(anno, \"excludes\");\r\n            List<String> includes = getMemberList(anno, \"includes\");\r\n            if (!checkIncludeExclude(anno, excludes, includes, MY_TYPE_NAME)) return;\r\n            // if @Immutable is found, let it pick up options and do work so we'll skip\r\n            if (hasAnnotation(cNode, ImmutableASTTransformation.MY_TYPE)) return;\r\n            createConstructor(this, cNode, includeFields, includeProperties, includeSuperFields, includeSuperProperties, callSuper, force, excludes, includes, useSetters, defaults);\r\n        }\r\n    }\r",
            "  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116 +\n 117 +\n 118  \n 119  \n 120  \n 121  \n 122  ",
            "    public void visit(ASTNode[] nodes, SourceUnit source) {\r\n        init(nodes, source);\r\n        AnnotatedNode parent = (AnnotatedNode) nodes[1];\r\n        AnnotationNode anno = (AnnotationNode) nodes[0];\r\n        if (!MY_TYPE.equals(anno.getClassNode())) return;\r\n\r\n        if (parent instanceof ClassNode) {\r\n            ClassNode cNode = (ClassNode) parent;\r\n            if (!checkNotInterface(cNode, MY_TYPE_NAME)) return;\r\n            boolean includeFields = memberHasValue(anno, \"includeFields\", true);\r\n            boolean includeProperties = !memberHasValue(anno, \"includeProperties\", false);\r\n            boolean includeSuperFields = memberHasValue(anno, \"includeSuperFields\", true);\r\n            boolean includeSuperProperties = memberHasValue(anno, \"includeSuperProperties\", true);\r\n            boolean callSuper = memberHasValue(anno, \"callSuper\", true);\r\n            boolean force = memberHasValue(anno, \"force\", true);\r\n            boolean defaults = !memberHasValue(anno, \"defaults\", false);\r\n            boolean useSetters = memberHasValue(anno, \"useSetters\", true);\r\n            List<String> excludes = getMemberList(anno, \"excludes\");\r\n            List<String> includes = getMemberList(anno, \"includes\");\r\n            if (!checkIncludeExclude(anno, excludes, includes, MY_TYPE_NAME)) return;\r\n            if (!checkPropertyList(cNode, includes, \"includes\", anno, MY_TYPE_NAME, includeFields)) return;\r\n            if (!checkPropertyList(cNode, excludes, \"excludes\", anno, MY_TYPE_NAME, includeFields)) return;\r\n            // if @Immutable is found, let it pick up options and do work so we'll skip\r\n            if (hasAnnotation(cNode, ImmutableASTTransformation.MY_TYPE)) return;\r\n            createConstructor(this, cNode, includeFields, includeProperties, includeSuperFields, includeSuperProperties, callSuper, force, excludes, includes, useSetters, defaults);\r\n        }\r\n    }\r"
        ]
    ],
    "9e084981806f26b837ffb0194653f9a9c75e62b0": [
        [
            "JavaStubGenerator::printClassContents(PrintWriter,ClassNode)",
            " 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  ",
            "    private void printClassContents(PrintWriter out, ClassNode classNode) throws FileNotFoundException {\n        if (classNode instanceof InnerClassNode && ((InnerClassNode) classNode).isAnonymous()) {\n            // if it is an anonymous inner class, don't generate the stub code for it.\n            return;\n        }\n        try {\n            Verifier verifier = new Verifier() {\n                @Override\n                public void visitClass(final ClassNode node) {\n                    List<Statement> savedStatements = new ArrayList<Statement>(node.getObjectInitializerStatements());\n                    super.visitClass(node);\n                    node.getObjectInitializerStatements().addAll(savedStatements);\n                }\n\n                @Override\n                protected FinalVariableAnalyzer.VariableNotFinalCallback getFinalVariablesCallback() {\n                    return null;\n                }\n\n                public void addCovariantMethods(ClassNode cn) {}\n                protected void addInitialization(ClassNode node) {}\n                protected void addPropertyMethod(MethodNode method) {\n                    doAddMethod(method);\n                }\n                protected void addReturnIfNeeded(MethodNode node) {}\n                protected MethodNode addMethod(ClassNode node, boolean shouldBeSynthetic, String name, int modifiers, ClassNode returnType, Parameter[] parameters, ClassNode[] exceptions, Statement code) {\n                    return doAddMethod(new MethodNode(name, modifiers, returnType, parameters, exceptions, code));\n                }\n\n                protected void addConstructor(Parameter[] newParams, ConstructorNode ctor, Statement code, ClassNode node) {\n                    if (code instanceof ExpressionStatement) {//GROOVY-4508\n                        Statement temp = code;\n                        code = new BlockStatement();\n                        ((BlockStatement) code).addStatement(temp);\n                    }\n                    ConstructorNode ctrNode = new ConstructorNode(ctor.getModifiers(), newParams, ctor.getExceptions(), code);\n                    ctrNode.setDeclaringClass(node);\n                    constructors.add(ctrNode);\n                }\n\n                protected void addDefaultParameters(DefaultArgsAction action, MethodNode method) {\n                    final Parameter[] parameters = method.getParameters();\n                    final Expression[] saved = new Expression[parameters.length];\n                    for (int i = 0; i < parameters.length; i++) {\n                        if (parameters[i].hasInitialExpression())\n                            saved[i] = parameters[i].getInitialExpression();\n                    }\n                    super.addDefaultParameters(action, method);\n                    for (int i = 0; i < parameters.length; i++) {\n                        if (saved[i] != null)\n                            parameters[i].setInitialExpression(saved[i]);\n                    }\n                }\n\n                private MethodNode doAddMethod(MethodNode method) {\n                    String sig = method.getTypeDescriptor();\n\n                    if (propertyMethodsWithSigs.containsKey(sig)) return method;\n\n                    propertyMethods.add(method);\n                    propertyMethodsWithSigs.put(sig, method);\n\n                    return method;\n                }\n\n                @Override\n                protected void addDefaultConstructor(ClassNode node) {\n                    // not required for stub generation\n                }\n            };\n            int origNumConstructors = classNode.getDeclaredConstructors().size();\n            verifier.visitClass(classNode);\n            // undo unwanted side-effect of verifier\n            if (origNumConstructors == 0 && classNode.getDeclaredConstructors().size() == 1) {\n                classNode.getDeclaredConstructors().clear();\n            }\n            currentModule = classNode.getModule();\n\n            boolean isInterface = isInterfaceOrTrait(classNode);\n            boolean isEnum = classNode.isEnum();\n            boolean isAnnotationDefinition = classNode.isAnnotationDefinition();\n            printAnnotations(out, classNode);\n            printModifiers(out, classNode.getModifiers()\n                    & ~(isInterface ? Opcodes.ACC_ABSTRACT : 0)\n                    & ~(isEnum ? Opcodes.ACC_FINAL | Opcodes.ACC_ABSTRACT : 0));\n\n            if (isInterface) {\n                if (isAnnotationDefinition) {\n                    out.print(\"@\");\n                }\n                out.print(\"interface \");\n            } else if (isEnum) {\n                out.print(\"enum \");\n            } else {\n                out.print(\"class \");\n            }\n\n            String className = classNode.getNameWithoutPackage();\n            if (classNode instanceof InnerClassNode)\n                className = className.substring(className.lastIndexOf(\"$\") + 1);\n            out.println(className);\n            printGenericsBounds(out, classNode, true);\n\n            ClassNode superClass = classNode.getUnresolvedSuperClass(false);\n\n            if (!isInterface && !isEnum) {\n                out.print(\"  extends \");\n                printType(out, superClass);\n            }\n\n            ClassNode[] interfaces = classNode.getInterfaces();\n            if (interfaces != null && interfaces.length > 0 && !isAnnotationDefinition) {\n                if (isInterface) {\n                    out.println(\"  extends\");\n                } else {\n                    out.println(\"  implements\");\n                }\n                for (int i = 0; i < interfaces.length - 1; ++i) {\n                    out.print(\"    \");\n                    printType(out, interfaces[i]);\n                    out.print(\",\");\n                }\n                out.print(\"    \");\n                printType(out, interfaces[interfaces.length - 1]);\n            }\n            out.println(\" {\");\n\n            printFields(out, classNode);\n            printMethods(out, classNode, isEnum);\n\n            for (Iterator<InnerClassNode> inner = classNode.getInnerClasses(); inner.hasNext(); ) {\n                // GROOVY-4004: Clear the methods from the outer class so that they don't get duplicated in inner ones\n                propertyMethods.clear();\n                propertyMethodsWithSigs.clear();\n                constructors.clear();\n                printClassContents(out, inner.next());\n            }\n\n            out.println(\"}\");\n        } finally {\n            propertyMethods.clear();\n            propertyMethodsWithSigs.clear();\n            constructors.clear();\n            currentModule = null;\n        }\n    }",
            " 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161 +\n 162 +\n 163 +\n 164 +\n 165 +\n 166 +\n 167 +\n 168 +\n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  ",
            "    private void printClassContents(PrintWriter out, ClassNode classNode) throws FileNotFoundException {\n        if (classNode instanceof InnerClassNode && ((InnerClassNode) classNode).isAnonymous()) {\n            // if it is an anonymous inner class, don't generate the stub code for it.\n            return;\n        }\n        try {\n            Verifier verifier = new Verifier() {\n                @Override\n                public void visitClass(final ClassNode node) {\n                    List<Statement> savedStatements = new ArrayList<Statement>(node.getObjectInitializerStatements());\n                    super.visitClass(node);\n                    node.getObjectInitializerStatements().addAll(savedStatements);\n                    for (ClassNode inode : node.getAllInterfaces()) {\n                        if (Traits.isTrait(inode)) {\n                            List<PropertyNode> traitProps = inode.getProperties();\n                            for (PropertyNode pn : traitProps) {\n                                visitProperty(pn);\n                            }\n                        }\n                    }\n                }\n\n                @Override\n                protected FinalVariableAnalyzer.VariableNotFinalCallback getFinalVariablesCallback() {\n                    return null;\n                }\n\n                public void addCovariantMethods(ClassNode cn) {}\n                protected void addInitialization(ClassNode node) {}\n                protected void addPropertyMethod(MethodNode method) {\n                    doAddMethod(method);\n                }\n                protected void addReturnIfNeeded(MethodNode node) {}\n                protected MethodNode addMethod(ClassNode node, boolean shouldBeSynthetic, String name, int modifiers, ClassNode returnType, Parameter[] parameters, ClassNode[] exceptions, Statement code) {\n                    return doAddMethod(new MethodNode(name, modifiers, returnType, parameters, exceptions, code));\n                }\n\n                protected void addConstructor(Parameter[] newParams, ConstructorNode ctor, Statement code, ClassNode node) {\n                    if (code instanceof ExpressionStatement) {//GROOVY-4508\n                        Statement temp = code;\n                        code = new BlockStatement();\n                        ((BlockStatement) code).addStatement(temp);\n                    }\n                    ConstructorNode ctrNode = new ConstructorNode(ctor.getModifiers(), newParams, ctor.getExceptions(), code);\n                    ctrNode.setDeclaringClass(node);\n                    constructors.add(ctrNode);\n                }\n\n                protected void addDefaultParameters(DefaultArgsAction action, MethodNode method) {\n                    final Parameter[] parameters = method.getParameters();\n                    final Expression[] saved = new Expression[parameters.length];\n                    for (int i = 0; i < parameters.length; i++) {\n                        if (parameters[i].hasInitialExpression())\n                            saved[i] = parameters[i].getInitialExpression();\n                    }\n                    super.addDefaultParameters(action, method);\n                    for (int i = 0; i < parameters.length; i++) {\n                        if (saved[i] != null)\n                            parameters[i].setInitialExpression(saved[i]);\n                    }\n                }\n\n                private MethodNode doAddMethod(MethodNode method) {\n                    String sig = method.getTypeDescriptor();\n\n                    if (propertyMethodsWithSigs.containsKey(sig)) return method;\n\n                    propertyMethods.add(method);\n                    propertyMethodsWithSigs.put(sig, method);\n\n                    return method;\n                }\n\n                @Override\n                protected void addDefaultConstructor(ClassNode node) {\n                    // not required for stub generation\n                }\n            };\n            int origNumConstructors = classNode.getDeclaredConstructors().size();\n            verifier.visitClass(classNode);\n            // undo unwanted side-effect of verifier\n            if (origNumConstructors == 0 && classNode.getDeclaredConstructors().size() == 1) {\n                classNode.getDeclaredConstructors().clear();\n            }\n            currentModule = classNode.getModule();\n\n            boolean isInterface = isInterfaceOrTrait(classNode);\n            boolean isEnum = classNode.isEnum();\n            boolean isAnnotationDefinition = classNode.isAnnotationDefinition();\n            printAnnotations(out, classNode);\n            printModifiers(out, classNode.getModifiers()\n                    & ~(isInterface ? Opcodes.ACC_ABSTRACT : 0)\n                    & ~(isEnum ? Opcodes.ACC_FINAL | Opcodes.ACC_ABSTRACT : 0));\n\n            if (isInterface) {\n                if (isAnnotationDefinition) {\n                    out.print(\"@\");\n                }\n                out.print(\"interface \");\n            } else if (isEnum) {\n                out.print(\"enum \");\n            } else {\n                out.print(\"class \");\n            }\n\n            String className = classNode.getNameWithoutPackage();\n            if (classNode instanceof InnerClassNode)\n                className = className.substring(className.lastIndexOf(\"$\") + 1);\n            out.println(className);\n            printGenericsBounds(out, classNode, true);\n\n            ClassNode superClass = classNode.getUnresolvedSuperClass(false);\n\n            if (!isInterface && !isEnum) {\n                out.print(\"  extends \");\n                printType(out, superClass);\n            }\n\n            ClassNode[] interfaces = classNode.getInterfaces();\n            if (interfaces != null && interfaces.length > 0 && !isAnnotationDefinition) {\n                if (isInterface) {\n                    out.println(\"  extends\");\n                } else {\n                    out.println(\"  implements\");\n                }\n                for (int i = 0; i < interfaces.length - 1; ++i) {\n                    out.print(\"    \");\n                    printType(out, interfaces[i]);\n                    out.print(\",\");\n                }\n                out.print(\"    \");\n                printType(out, interfaces[interfaces.length - 1]);\n            }\n            out.println(\" {\");\n\n            printFields(out, classNode);\n            printMethods(out, classNode, isEnum);\n\n            for (Iterator<InnerClassNode> inner = classNode.getInnerClasses(); inner.hasNext(); ) {\n                // GROOVY-4004: Clear the methods from the outer class so that they don't get duplicated in inner ones\n                propertyMethods.clear();\n                propertyMethodsWithSigs.clear();\n                constructors.clear();\n                printClassContents(out, inner.next());\n            }\n\n            out.println(\"}\");\n        } finally {\n            propertyMethods.clear();\n            propertyMethodsWithSigs.clear();\n            constructors.clear();\n            currentModule = null;\n        }\n    }"
        ]
    ],
    "02dd6d669d7d5cb4abc376d2c7672f3ac9fe12d9": [
        [
            "AutoImplementASTTransformation::visit(ASTNode,SourceUnit)",
            "  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88 -\n  89  \n  90  \n  91  ",
            "    public void visit(ASTNode[] nodes, SourceUnit source) {\n        init(nodes, source);\n        AnnotatedNode parent = (AnnotatedNode) nodes[1];\n        AnnotationNode anno = (AnnotationNode) nodes[0];\n        if (!MY_TYPE.equals(anno.getClassNode())) return;\n\n        if (parent instanceof ClassNode) {\n            ClassNode cNode = (ClassNode) parent;\n            if (!checkNotInterface(cNode, MY_TYPE_NAME)) return;\n            ClassNode exception = getMemberClassValue(anno, \"exception\");\n            if (exception != null && Undefined.isUndefinedException(exception)) {\n                exception = null;\n            }\n            String message = getMemberStringValue(anno, \"message\");\n            Expression code = anno.getMember(\"code\");\n            if (code != null && !(code instanceof ClosureExpression)) {\n                addError(\"Expected closure value for annotation parameter 'code'. Found \" + code, cNode);\n                return;\n            }\n            createMethods(cNode, exception, message, (ClosureExpression) code);\n            if (code != null) {\n                anno.setMember(\"code\", new ClosureExpression(new Parameter[0], EmptyStatement.INSTANCE));\n            }\n        }\n    }",
            "  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88 +\n  89  \n  90  \n  91  ",
            "    public void visit(ASTNode[] nodes, SourceUnit source) {\n        init(nodes, source);\n        AnnotatedNode parent = (AnnotatedNode) nodes[1];\n        AnnotationNode anno = (AnnotationNode) nodes[0];\n        if (!MY_TYPE.equals(anno.getClassNode())) return;\n\n        if (parent instanceof ClassNode) {\n            ClassNode cNode = (ClassNode) parent;\n            if (!checkNotInterface(cNode, MY_TYPE_NAME)) return;\n            ClassNode exception = getMemberClassValue(anno, \"exception\");\n            if (exception != null && Undefined.isUndefinedException(exception)) {\n                exception = null;\n            }\n            String message = getMemberStringValue(anno, \"message\");\n            Expression code = anno.getMember(\"code\");\n            if (code != null && !(code instanceof ClosureExpression)) {\n                addError(\"Expected closure value for annotation parameter 'code'. Found \" + code, cNode);\n                return;\n            }\n            createMethods(cNode, exception, message, (ClosureExpression) code);\n            if (code != null) {\n                anno.setMember(\"code\", new ClosureExpression(Parameter.EMPTY_ARRAY, EmptyStatement.INSTANCE));\n            }\n        }\n    }"
        ],
        [
            "MapConstructorASTTransformation::visit(ASTNode,SourceUnit)",
            "  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131 -\n 132  \n 133  \n 134  \n 135  \n 136  \n 137  ",
            "    public void visit(ASTNode[] nodes, SourceUnit source) {\n        init(nodes, source);\n        AnnotatedNode parent = (AnnotatedNode) nodes[1];\n        AnnotationNode anno = (AnnotationNode) nodes[0];\n        if (!MY_TYPE.equals(anno.getClassNode())) return;\n\n        if (parent instanceof ClassNode) {\n            ClassNode cNode = (ClassNode) parent;\n            if (!checkNotInterface(cNode, MY_TYPE_NAME)) return;\n            boolean includeFields = memberHasValue(anno, \"includeFields\", true);\n            boolean includeProperties = !memberHasValue(anno, \"includeProperties\", false);\n            boolean includeSuperProperties = memberHasValue(anno, \"includeSuperProperties\", true);\n            boolean includeSuperFields = memberHasValue(anno, \"includeSuperFields\", true);\n            boolean includeStatic = memberHasValue(anno, \"includeStatic\", true);\n            boolean allProperties = memberHasValue(anno, \"allProperties\", true);\n            boolean noArg = memberHasValue(anno, \"noArg\", true);\n            boolean specialNamedArgHandling = !memberHasValue(anno, \"specialNamedArgHandling\", false);\n            List<String> excludes = getMemberStringList(anno, \"excludes\");\n            List<String> includes = getMemberStringList(anno, \"includes\");\n            boolean allNames = memberHasValue(anno, \"allNames\", true);\n            if (!checkIncludeExcludeUndefinedAware(anno, excludes, includes, MY_TYPE_NAME)) return;\n            if (!checkPropertyList(cNode, includes, \"includes\", anno, MY_TYPE_NAME, includeFields, includeSuperProperties, allProperties))\n                return;\n            if (!checkPropertyList(cNode, excludes, \"excludes\", anno, MY_TYPE_NAME, includeFields, includeSuperProperties, allProperties))\n                return;\n            final GroovyClassLoader classLoader = compilationUnit != null ? compilationUnit.getTransformLoader() : source.getClassLoader();\n            final PropertyHandler handler = PropertyHandler.createPropertyHandler(this, classLoader, cNode);\n            if (handler == null) return;\n            if (!handler.validateAttributes(this, anno)) return;\n\n            Expression pre = anno.getMember(\"pre\");\n            if (pre != null && !(pre instanceof ClosureExpression)) {\n                addError(\"Expected closure value for annotation parameter 'pre'. Found \" + pre, cNode);\n                return;\n            }\n            Expression post = anno.getMember(\"post\");\n            if (post != null && !(post instanceof ClosureExpression)) {\n                addError(\"Expected closure value for annotation parameter 'post'. Found \" + post, cNode);\n                return;\n            }\n\n            createConstructors(this, anno, handler, cNode, includeFields, includeProperties, includeSuperProperties, includeSuperFields, noArg, allNames, allProperties, specialNamedArgHandling, includeStatic, excludes, includes, (ClosureExpression) pre, (ClosureExpression) post, source);\n\n            if (pre != null) {\n                anno.setMember(\"pre\", new ClosureExpression(new Parameter[0], EmptyStatement.INSTANCE));\n            }\n            if (post != null) {\n                anno.setMember(\"post\", new ClosureExpression(new Parameter[0], EmptyStatement.INSTANCE));\n            }\n        }\n    }",
            "  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131 +\n 132  \n 133  \n 134  \n 135  \n 136  \n 137  ",
            "    public void visit(ASTNode[] nodes, SourceUnit source) {\n        init(nodes, source);\n        AnnotatedNode parent = (AnnotatedNode) nodes[1];\n        AnnotationNode anno = (AnnotationNode) nodes[0];\n        if (!MY_TYPE.equals(anno.getClassNode())) return;\n\n        if (parent instanceof ClassNode) {\n            ClassNode cNode = (ClassNode) parent;\n            if (!checkNotInterface(cNode, MY_TYPE_NAME)) return;\n            boolean includeFields = memberHasValue(anno, \"includeFields\", true);\n            boolean includeProperties = !memberHasValue(anno, \"includeProperties\", false);\n            boolean includeSuperProperties = memberHasValue(anno, \"includeSuperProperties\", true);\n            boolean includeSuperFields = memberHasValue(anno, \"includeSuperFields\", true);\n            boolean includeStatic = memberHasValue(anno, \"includeStatic\", true);\n            boolean allProperties = memberHasValue(anno, \"allProperties\", true);\n            boolean noArg = memberHasValue(anno, \"noArg\", true);\n            boolean specialNamedArgHandling = !memberHasValue(anno, \"specialNamedArgHandling\", false);\n            List<String> excludes = getMemberStringList(anno, \"excludes\");\n            List<String> includes = getMemberStringList(anno, \"includes\");\n            boolean allNames = memberHasValue(anno, \"allNames\", true);\n            if (!checkIncludeExcludeUndefinedAware(anno, excludes, includes, MY_TYPE_NAME)) return;\n            if (!checkPropertyList(cNode, includes, \"includes\", anno, MY_TYPE_NAME, includeFields, includeSuperProperties, allProperties))\n                return;\n            if (!checkPropertyList(cNode, excludes, \"excludes\", anno, MY_TYPE_NAME, includeFields, includeSuperProperties, allProperties))\n                return;\n            final GroovyClassLoader classLoader = compilationUnit != null ? compilationUnit.getTransformLoader() : source.getClassLoader();\n            final PropertyHandler handler = PropertyHandler.createPropertyHandler(this, classLoader, cNode);\n            if (handler == null) return;\n            if (!handler.validateAttributes(this, anno)) return;\n\n            Expression pre = anno.getMember(\"pre\");\n            if (pre != null && !(pre instanceof ClosureExpression)) {\n                addError(\"Expected closure value for annotation parameter 'pre'. Found \" + pre, cNode);\n                return;\n            }\n            Expression post = anno.getMember(\"post\");\n            if (post != null && !(post instanceof ClosureExpression)) {\n                addError(\"Expected closure value for annotation parameter 'post'. Found \" + post, cNode);\n                return;\n            }\n\n            createConstructors(this, anno, handler, cNode, includeFields, includeProperties, includeSuperProperties, includeSuperFields, noArg, allNames, allProperties, specialNamedArgHandling, includeStatic, excludes, includes, (ClosureExpression) pre, (ClosureExpression) post, source);\n\n            if (pre != null) {\n                anno.setMember(\"pre\", new ClosureExpression(Parameter.EMPTY_ARRAY, EmptyStatement.INSTANCE));\n            }\n            if (post != null) {\n                anno.setMember(\"post\", new ClosureExpression(new Parameter[0], EmptyStatement.INSTANCE));\n            }\n        }\n    }"
        ],
        [
            "TupleConstructorASTTransformation::visit(ASTNode,SourceUnit)",
            " 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159 -\n 160  \n 161  \n 162 -\n 163  \n 164  \n 165  ",
            "    public void visit(ASTNode[] nodes, SourceUnit source) {\r\n        init(nodes, source);\r\n        AnnotatedNode parent = (AnnotatedNode) nodes[1];\r\n        AnnotationNode anno = (AnnotationNode) nodes[0];\r\n        if (!MY_TYPE.equals(anno.getClassNode())) return;\r\n\r\n        if (parent instanceof ClassNode) {\r\n            ClassNode cNode = (ClassNode) parent;\r\n            if (!checkNotInterface(cNode, MY_TYPE_NAME)) return;\r\n            boolean includeFields = memberHasValue(anno, \"includeFields\", true);\r\n            boolean includeProperties = !memberHasValue(anno, \"includeProperties\", false);\r\n            boolean includeSuperFields = memberHasValue(anno, \"includeSuperFields\", true);\r\n            boolean includeSuperProperties = memberHasValue(anno, \"includeSuperProperties\", true);\r\n            boolean allProperties = memberHasValue(anno, \"allProperties\", true);\r\n            List<String> excludes = getMemberStringList(anno, \"excludes\");\r\n            List<String> includes = getMemberStringList(anno, \"includes\");\r\n            boolean allNames = memberHasValue(anno, \"allNames\", true);\r\n            if (!checkIncludeExcludeUndefinedAware(anno, excludes, includes, MY_TYPE_NAME)) return;\r\n            if (!checkPropertyList(cNode, includes, \"includes\", anno, MY_TYPE_NAME, includeFields, includeSuperProperties, allProperties, includeSuperFields, false))\r\n                return;\r\n            if (!checkPropertyList(cNode, excludes, \"excludes\", anno, MY_TYPE_NAME, includeFields, includeSuperProperties, allProperties, includeSuperFields, false))\r\n                return;\r\n            final GroovyClassLoader classLoader = compilationUnit != null ? compilationUnit.getTransformLoader() : source.getClassLoader();\r\n            final PropertyHandler handler = PropertyHandler.createPropertyHandler(this, classLoader, cNode);\r\n            if (handler == null) return;\r\n            if (!handler.validateAttributes(this, anno)) return;\r\n\r\n            Expression pre = anno.getMember(\"pre\");\r\n            if (pre != null && !(pre instanceof ClosureExpression)) {\r\n                addError(\"Expected closure value for annotation parameter 'pre'. Found \" + pre, cNode);\r\n                return;\r\n            }\r\n            Expression post = anno.getMember(\"post\");\r\n            if (post != null && !(post instanceof ClosureExpression)) {\r\n                addError(\"Expected closure value for annotation parameter 'post'. Found \" + post, cNode);\r\n                return;\r\n            }\r\n\r\n            createConstructor(this, anno, cNode, includeFields, includeProperties, includeSuperFields, includeSuperProperties,\r\n                    excludes, includes, allNames, allProperties,\r\n                    sourceUnit, handler, (ClosureExpression) pre, (ClosureExpression) post);\r\n\r\n            if (pre != null) {\r\n                anno.setMember(\"pre\", new ClosureExpression(new Parameter[0], EmptyStatement.INSTANCE));\r\n            }\r\n            if (post != null) {\r\n                anno.setMember(\"post\", new ClosureExpression(new Parameter[0], EmptyStatement.INSTANCE));\r\n            }\r\n        }\r\n    }\r",
            " 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159 +\n 160  \n 161  \n 162 +\n 163  \n 164  \n 165  ",
            "    public void visit(ASTNode[] nodes, SourceUnit source) {\r\n        init(nodes, source);\r\n        AnnotatedNode parent = (AnnotatedNode) nodes[1];\r\n        AnnotationNode anno = (AnnotationNode) nodes[0];\r\n        if (!MY_TYPE.equals(anno.getClassNode())) return;\r\n\r\n        if (parent instanceof ClassNode) {\r\n            ClassNode cNode = (ClassNode) parent;\r\n            if (!checkNotInterface(cNode, MY_TYPE_NAME)) return;\r\n            boolean includeFields = memberHasValue(anno, \"includeFields\", true);\r\n            boolean includeProperties = !memberHasValue(anno, \"includeProperties\", false);\r\n            boolean includeSuperFields = memberHasValue(anno, \"includeSuperFields\", true);\r\n            boolean includeSuperProperties = memberHasValue(anno, \"includeSuperProperties\", true);\r\n            boolean allProperties = memberHasValue(anno, \"allProperties\", true);\r\n            List<String> excludes = getMemberStringList(anno, \"excludes\");\r\n            List<String> includes = getMemberStringList(anno, \"includes\");\r\n            boolean allNames = memberHasValue(anno, \"allNames\", true);\r\n            if (!checkIncludeExcludeUndefinedAware(anno, excludes, includes, MY_TYPE_NAME)) return;\r\n            if (!checkPropertyList(cNode, includes, \"includes\", anno, MY_TYPE_NAME, includeFields, includeSuperProperties, allProperties, includeSuperFields, false))\r\n                return;\r\n            if (!checkPropertyList(cNode, excludes, \"excludes\", anno, MY_TYPE_NAME, includeFields, includeSuperProperties, allProperties, includeSuperFields, false))\r\n                return;\r\n            final GroovyClassLoader classLoader = compilationUnit != null ? compilationUnit.getTransformLoader() : source.getClassLoader();\r\n            final PropertyHandler handler = PropertyHandler.createPropertyHandler(this, classLoader, cNode);\r\n            if (handler == null) return;\r\n            if (!handler.validateAttributes(this, anno)) return;\r\n\r\n            Expression pre = anno.getMember(\"pre\");\r\n            if (pre != null && !(pre instanceof ClosureExpression)) {\r\n                addError(\"Expected closure value for annotation parameter 'pre'. Found \" + pre, cNode);\r\n                return;\r\n            }\r\n            Expression post = anno.getMember(\"post\");\r\n            if (post != null && !(post instanceof ClosureExpression)) {\r\n                addError(\"Expected closure value for annotation parameter 'post'. Found \" + post, cNode);\r\n                return;\r\n            }\r\n\r\n            createConstructor(this, anno, cNode, includeFields, includeProperties, includeSuperFields, includeSuperProperties,\r\n                    excludes, includes, allNames, allProperties,\r\n                    sourceUnit, handler, (ClosureExpression) pre, (ClosureExpression) post);\r\n\r\n            if (pre != null) {\r\n                anno.setMember(\"pre\", new ClosureExpression(Parameter.EMPTY_ARRAY, EmptyStatement.INSTANCE));\r\n            }\r\n            if (post != null) {\r\n                anno.setMember(\"post\", new ClosureExpression(Parameter.EMPTY_ARRAY, EmptyStatement.INSTANCE));\r\n            }\r\n        }\r\n    }\r"
        ]
    ],
    "1363536ea8efa1a4e6261c79a8d187c124cf29d5": [
        [
            "SimpleGroovyClassDoc::constructors()",
            " 117  \n 118  \n 119  \n 120  \n 121  \n 122 -\n 123  ",
            "    /**\n     * returns a sorted array of constructors\n     */\n    public GroovyConstructorDoc[] constructors() {\n        Collections.sort(constructors);\n        return constructors.toArray(new GroovyConstructorDoc[0]);\n    }",
            " 122  \n 123  \n 124  \n 125  \n 126  \n 127 +\n 128  ",
            "    /**\n     * returns a sorted array of constructors\n     */\n    public GroovyConstructorDoc[] constructors() {\n        Collections.sort(constructors);\n        return constructors.toArray(EMPTY_GROOVYCONSTRUCTORDOC_ARRAY);\n    }"
        ],
        [
            "Groovyc::resetFileLists()",
            " 859  \n 860  \n 861  \n 862  \n 863 -\n 864  \n 865  ",
            "    /**\n     * Clear the list of files to be compiled and copied.\n     */\n    protected void resetFileLists() {\n        compileList = new File[0];\n        scriptExtensions = new LinkedHashSet<String>();\n    }",
            " 861  \n 862  \n 863  \n 864  \n 865 +\n 866  \n 867  ",
            "    /**\n     * Clear the list of files to be compiled and copied.\n     */\n    protected void resetFileLists() {\n        compileList = EMPTY_FILE_ARRAY;\n        scriptExtensions = new LinkedHashSet<String>();\n    }"
        ],
        [
            "Grape::listDependencies(ClassLoader)",
            " 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217 -\n 218  \n 219  \n 220  \n 221  \n 222  ",
            "    public static Map[] listDependencies(ClassLoader cl) {\n        Map[] maps = null;\n        if (enableGrapes) {\n            GrapeEngine instance = getInstance();\n            if (instance != null) {\n                maps = instance.listDependencies(cl);\n            }\n        }\n        if (maps == null) {\n            return new Map[0];\n        } else {\n            return maps;\n        }\n\n    }",
            " 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219 +\n 220  \n 221  \n 222  \n 223  \n 224  ",
            "    public static Map[] listDependencies(ClassLoader cl) {\n        Map[] maps = null;\n        if (enableGrapes) {\n            GrapeEngine instance = getInstance();\n            if (instance != null) {\n                maps = instance.listDependencies(cl);\n            }\n        }\n        if (maps == null) {\n            return EMPTY_MAP_ARRAY;\n        } else {\n            return maps;\n        }\n\n    }"
        ],
        [
            "SimpleGroovyClassDoc::fields()",
            " 158  \n 159  \n 160  \n 161  \n 162  \n 163 -\n 164  ",
            "    /**\n     * returns a sorted array of fields\n     */\n    public GroovyFieldDoc[] fields() {\n        Collections.sort(fields);\n        return fields.toArray(new GroovyFieldDoc[0]);\n    }",
            " 163  \n 164  \n 165  \n 166  \n 167  \n 168 +\n 169  ",
            "    /**\n     * returns a sorted array of fields\n     */\n    public GroovyFieldDoc[] fields() {\n        Collections.sort(fields);\n        return fields.toArray(EMPTY_GROOVYFIELDDOC_ARRAY);\n    }"
        ],
        [
            "ExternalGroovyClassDoc::importedClasses()",
            " 129  \n 130 -\n 131  ",
            "    public GroovyClassDoc[] importedClasses() {\n        return new GroovyClassDoc[0];\n    }",
            " 136  \n 137 +\n 138  ",
            "    public GroovyClassDoc[] importedClasses() {\n        return EMPTY_GROOVYCLASSDOC_ARRAY;\n    }"
        ],
        [
            "SimpleGroovyClassDoc::methods()",
            " 194  \n 195  \n 196  \n 197  \n 198  \n 199 -\n 200  ",
            "    /**\n     * returns a sorted array of methods\n     */\n    public GroovyMethodDoc[] methods() {\n        Collections.sort(methods);\n        return methods.toArray(new GroovyMethodDoc[0]);\n    }",
            " 199  \n 200  \n 201  \n 202  \n 203  \n 204 +\n 205  ",
            "    /**\n     * returns a sorted array of methods\n     */\n    public GroovyMethodDoc[] methods() {\n        Collections.sort(methods);\n        return methods.toArray(EMPTY_GROOVYMETHODDOC_ARRAY);\n    }"
        ],
        [
            "ExternalGroovyClassDoc::enumConstants()",
            " 109  \n 110 -\n 111  ",
            "    public GroovyFieldDoc[] enumConstants() {\n        return new GroovyFieldDoc[0];\n    }",
            " 116  \n 117 +\n 118  ",
            "    public GroovyFieldDoc[] enumConstants() {\n        return EMPTY_GROOVYFIELDDOC_ARRAY;\n    }"
        ],
        [
            "SimpleGroovyExecutableMemberDoc::parameters()",
            "  37  \n  38 -\n  39  ",
            "    public GroovyParameter[] parameters() {\n        return (GroovyParameter[]) parameters.toArray(new GroovyParameter[0]);\n    }",
            "  38  \n  39 +\n  40  ",
            "    public GroovyParameter[] parameters() {\n        return (GroovyParameter[]) parameters.toArray(EMPTY_GROOVYPARAMETER_ARRAY);\n    }"
        ],
        [
            "SimpleGroovyPackageDoc::allClasses()",
            "  41  \n  42 -\n  43  ",
            "    public GroovyClassDoc[] allClasses() {\n        return classDocs.values().toArray(new GroovyClassDoc[0]);\n    }",
            "  42  \n  43 +\n  44  ",
            "    public GroovyClassDoc[] allClasses() {\n        return classDocs.values().toArray(EMPTY_GROOVYCLASSDOC_ARRAY);\n    }"
        ],
        [
            "SimpleGroovyClassDoc::interfaces()",
            " 752  \n 753  \n 754 -\n 755  ",
            "    public GroovyClassDoc[] interfaces() {\n        Collections.sort(interfaceClasses);\n        return interfaceClasses.toArray(new GroovyClassDoc[0]);\n    }",
            " 757  \n 758  \n 759 +\n 760  ",
            "    public GroovyClassDoc[] interfaces() {\n        Collections.sort(interfaceClasses);\n        return interfaceClasses.toArray(EMPTY_GROOVYCLASSDOC_ARRAY);\n    }"
        ],
        [
            "Java5::getConstructorParameterAnnotations(Constructor)",
            " 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  \n 423  \n 424  \n 425  \n 426  \n 427  \n 428  \n 429  \n 430  \n 431  \n 432  \n 433  \n 434  \n 435  \n 436  \n 437  \n 438  \n 439  \n 440  \n 441  \n 442  \n 443  \n 444  \n 445  \n 446  \n 447  \n 448 -\n 449  \n 450  \n 451  \n 452  \n 453  ",
            "    /**\r\n     * Synthetic parameters such as those added for inner class constructors may\r\n     * not be included in the parameter annotations array. This is the case when\r\n     * at least one parameter of an inner class constructor has an annotation with\r\n     * a RUNTIME retention (this occurs for JDK8 and below). This method will\r\n     * normalize the annotations array so that it contains the same number of\r\n     * elements as the array returned from {@link Constructor#getParameterTypes()}.\r\n     *\r\n     * If adjustment is required, the adjusted array will be prepended with a\r\n     * zero-length element. If no adjustment is required, the original array\r\n     * from {@link Constructor#getParameterAnnotations()} will be returned.\r\n     *\r\n     * @param constructor the Constructor for which to return parameter annotations\r\n     * @return array of arrays containing the annotations on the parameters of the given Constructor\r\n     */\r\n    private Annotation[][] getConstructorParameterAnnotations(Constructor<?> constructor) {\r\n        /*\r\n         * TODO: Remove after JDK9 is the minimum JDK supported\r\n         *\r\n         * JDK9+ correctly accounts for the synthetic parameter and when it becomes\r\n         * the minimum version this method should no longer be required.\r\n         */\r\n        int parameterCount = constructor.getParameterTypes().length;\r\n        Annotation[][] annotations = constructor.getParameterAnnotations();\r\n        int diff = parameterCount - annotations.length;\r\n        if (diff > 0) {\r\n            // May happen on JDK8 and below, but we only expect to have to\r\n            // add a single element to the front of the array to account\r\n            // for the synthetic outer reference\r\n            if (diff > 1) {\r\n                throw new GroovyBugError(\r\n                        \"Constructor parameter annotations length [\" + annotations.length + \"] \" +\r\n                        \"does not match the parameter length: \" + constructor\r\n                );\r\n            }\r\n            Annotation[][] adjusted = new Annotation[parameterCount][];\r\n            adjusted[0] = new Annotation[0];\r\n            System.arraycopy(annotations, 0, adjusted, 1, annotations.length);\r\n            return adjusted;\r\n        }\r\n        return annotations;\r\n    }\r",
            " 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  \n 423  \n 424  \n 425  \n 426  \n 427  \n 428  \n 429  \n 430  \n 431  \n 432  \n 433  \n 434  \n 435  \n 436  \n 437  \n 438  \n 439  \n 440  \n 441  \n 442  \n 443  \n 444  \n 445  \n 446  \n 447  \n 448  \n 449  \n 450 +\n 451  \n 452  \n 453  \n 454  \n 455  ",
            "    /**\r\n     * Synthetic parameters such as those added for inner class constructors may\r\n     * not be included in the parameter annotations array. This is the case when\r\n     * at least one parameter of an inner class constructor has an annotation with\r\n     * a RUNTIME retention (this occurs for JDK8 and below). This method will\r\n     * normalize the annotations array so that it contains the same number of\r\n     * elements as the array returned from {@link Constructor#getParameterTypes()}.\r\n     *\r\n     * If adjustment is required, the adjusted array will be prepended with a\r\n     * zero-length element. If no adjustment is required, the original array\r\n     * from {@link Constructor#getParameterAnnotations()} will be returned.\r\n     *\r\n     * @param constructor the Constructor for which to return parameter annotations\r\n     * @return array of arrays containing the annotations on the parameters of the given Constructor\r\n     */\r\n    private Annotation[][] getConstructorParameterAnnotations(Constructor<?> constructor) {\r\n        /*\r\n         * TODO: Remove after JDK9 is the minimum JDK supported\r\n         *\r\n         * JDK9+ correctly accounts for the synthetic parameter and when it becomes\r\n         * the minimum version this method should no longer be required.\r\n         */\r\n        int parameterCount = constructor.getParameterTypes().length;\r\n        Annotation[][] annotations = constructor.getParameterAnnotations();\r\n        int diff = parameterCount - annotations.length;\r\n        if (diff > 0) {\r\n            // May happen on JDK8 and below, but we only expect to have to\r\n            // add a single element to the front of the array to account\r\n            // for the synthetic outer reference\r\n            if (diff > 1) {\r\n                throw new GroovyBugError(\r\n                        \"Constructor parameter annotations length [\" + annotations.length + \"] \" +\r\n                        \"does not match the parameter length: \" + constructor\r\n                );\r\n            }\r\n            Annotation[][] adjusted = new Annotation[parameterCount][];\r\n            adjusted[0] = EMPTY_ANNOTATION_ARRAY;\r\n            System.arraycopy(annotations, 0, adjusted, 1, annotations.length);\r\n            return adjusted;\r\n        }\r\n        return annotations;\r\n    }\r"
        ],
        [
            "ExternalGroovyClassDoc::methods()",
            " 165  \n 166 -\n 167  ",
            "    public GroovyMethodDoc[] methods() {\n        return new GroovyMethodDoc[0];\n    }",
            " 172  \n 173 +\n 174  ",
            "    public GroovyMethodDoc[] methods() {\n        return EMPTY_GROOVYMETHODDOC_ARRAY;\n    }"
        ],
        [
            "SimpleGroovyRootDoc::classes()",
            "  78  \n  79  \n  80  \n  81  \n  82  \n  83 -\n  84  ",
            "    public GroovyClassDoc[] classes() {\n        if (classDocValues == null) {\n            classDocValues = new ArrayList<GroovyClassDoc>(classDocs.values());\n            Collections.sort(classDocValues);\n        }\n        return classDocValues.toArray(new GroovyClassDoc[0]);\n    }",
            "  80  \n  81  \n  82  \n  83  \n  84  \n  85 +\n  86  ",
            "    public GroovyClassDoc[] classes() {\n        if (classDocValues == null) {\n            classDocValues = new ArrayList<GroovyClassDoc>(classDocs.values());\n            Collections.sort(classDocValues);\n        }\n        return classDocValues.toArray(EMPTY_GROOVYCLASSDOC_ARRAY);\n    }"
        ],
        [
            "SimpleGroovyClassDoc::innerClasses()",
            " 146  \n 147  \n 148  \n 149  \n 150  \n 151 -\n 152  ",
            "    /**\n     * returns a sorted array of nested classes and interfaces\n     */\n    public GroovyClassDoc[] innerClasses() {\n        Collections.sort(nested);\n        return nested.toArray(new GroovyClassDoc[0]);\n    }",
            " 151  \n 152  \n 153  \n 154  \n 155  \n 156 +\n 157  ",
            "    /**\n     * returns a sorted array of nested classes and interfaces\n     */\n    public GroovyClassDoc[] innerClasses() {\n        Collections.sort(nested);\n        return nested.toArray(EMPTY_GROOVYCLASSDOC_ARRAY);\n    }"
        ],
        [
            "ExternalGroovyClassDoc::fields()",
            " 113  \n 114 -\n 115  ",
            "    public GroovyFieldDoc[] fields() {\n        return new GroovyFieldDoc[0];\n    }",
            " 120  \n 121 +\n 122  ",
            "    public GroovyFieldDoc[] fields() {\n        return EMPTY_GROOVYFIELDDOC_ARRAY;\n    }"
        ],
        [
            "SimpleGroovyPackageDoc::errors()",
            "  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91 -\n  92  ",
            "    public GroovyClassDoc[] errors() {\n        List<GroovyClassDoc> result = new ArrayList<GroovyClassDoc>(classDocs.values().size());\n        for (GroovyClassDoc doc : classDocs.values()) {\n            if (doc.isError()) {\n                result.add(doc);\n            }\n        }\n        return result.toArray(new GroovyClassDoc[0]);\n    }",
            "  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92 +\n  93  ",
            "    public GroovyClassDoc[] errors() {\n        List<GroovyClassDoc> result = new ArrayList<GroovyClassDoc>(classDocs.values().size());\n        for (GroovyClassDoc doc : classDocs.values()) {\n            if (doc.isError()) {\n                result.add(doc);\n            }\n        }\n        return result.toArray(EMPTY_GROOVYCLASSDOC_ARRAY);\n    }"
        ],
        [
            "ExternalGroovyClassDoc::constructors()",
            "  97  \n  98 -\n  99  ",
            "    public GroovyConstructorDoc[] constructors() {\n        return new GroovyConstructorDoc[0];\n    }",
            " 104  \n 105 +\n 106  ",
            "    public GroovyConstructorDoc[] constructors() {\n        return EMPTY_GROOVYCONSTRUCTORDOC_ARRAY;\n    }"
        ],
        [
            "ExternalGroovyClassDoc::innerClasses()",
            " 137  \n 138 -\n 139  ",
            "    public GroovyClassDoc[] innerClasses() {\n        return new GroovyClassDoc[0];\n    }",
            " 144  \n 145 +\n 146  ",
            "    public GroovyClassDoc[] innerClasses() {\n        return EMPTY_GROOVYCLASSDOC_ARRAY;\n    }"
        ],
        [
            "ExternalGroovyClassDoc::fields(boolean)",
            " 121  \n 122 -\n 123  ",
            "    public GroovyFieldDoc[] fields(boolean filter) {\n        return new GroovyFieldDoc[0];\n    }",
            " 128  \n 129 +\n 130  ",
            "    public GroovyFieldDoc[] fields(boolean filter) {\n        return EMPTY_GROOVYFIELDDOC_ARRAY;\n    }"
        ],
        [
            "SimpleGroovyClassDoc::properties()",
            " 170  \n 171  \n 172  \n 173  \n 174  \n 175 -\n 176  ",
            "    /**\n     * returns a sorted array of properties\n     */\n    public GroovyFieldDoc[] properties() {\n        Collections.sort(properties);\n        return properties.toArray(new GroovyFieldDoc[0]);\n    }",
            " 175  \n 176  \n 177  \n 178  \n 179  \n 180 +\n 181  ",
            "    /**\n     * returns a sorted array of properties\n     */\n    public GroovyFieldDoc[] properties() {\n        Collections.sort(properties);\n        return properties.toArray(EMPTY_GROOVYFIELDDOC_ARRAY);\n    }"
        ],
        [
            "SimpleGroovyParameter::annotations()",
            "  64  \n  65 -\n  66  ",
            "    public GroovyAnnotationRef[] annotations() {\n        return annotationRefs.toArray(new GroovyAnnotationRef[0]);\n    }",
            "  65  \n  66 +\n  67  ",
            "    public GroovyAnnotationRef[] annotations() {\n        return annotationRefs.toArray(EMPTY_GROOVYANNOTATIONREF_ARRAY);\n    }"
        ],
        [
            "SimpleGroovyPackageDoc::interfaces()",
            " 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115 -\n 116  ",
            "    public GroovyClassDoc[] interfaces() {\n        List<GroovyClassDoc> result = new ArrayList<GroovyClassDoc>(classDocs.values().size());\n        for (GroovyClassDoc doc : classDocs.values()) {\n            if (doc.isInterface()) {\n                result.add(doc);\n            }\n        }\n        return result.toArray(new GroovyClassDoc[0]);\n    }",
            " 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116 +\n 117  ",
            "    public GroovyClassDoc[] interfaces() {\n        List<GroovyClassDoc> result = new ArrayList<GroovyClassDoc>(classDocs.values().size());\n        for (GroovyClassDoc doc : classDocs.values()) {\n            if (doc.isInterface()) {\n                result.add(doc);\n            }\n        }\n        return result.toArray(EMPTY_GROOVYCLASSDOC_ARRAY);\n    }"
        ],
        [
            "Groovyc::makeCommandLine(List)",
            "1150  \n1151  \n1152 -\n1153  ",
            "    private String[] makeCommandLine(List<String> commandLineList) {\n        log.verbose(\"Compilation arguments:\\n\" + DefaultGroovyMethods.join((Iterable)commandLineList, \"\\n\"));\n        return commandLineList.toArray(new String[0]);\n    }",
            "1152  \n1153  \n1154 +\n1155  ",
            "    private String[] makeCommandLine(List<String> commandLineList) {\n        log.verbose(\"Compilation arguments:\\n\" + DefaultGroovyMethods.join((Iterable)commandLineList, \"\\n\"));\n        return commandLineList.toArray(EMPTY_STRING_ARRAY);\n    }"
        ],
        [
            "StringHelper::tokenizeUnquoted(String)",
            "  28  \n  29  \n  30  \n  31  \n  32  \n  33  \n  34  \n  35  \n  36  \n  37  \n  38  \n  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49 -\n  50  ",
            "    /**\r\n     * This method tokenizes a string by space characters, \r\n     * but ignores spaces in quoted parts,that are parts in \r\n     * '' or \"\". The method does allows the usage of \"\" in '' \r\n     * and '' in \"\". The space character between tokens is not \r\n     * returned. \r\n     * \r\n     * @param s the string to tokenize\r\n     * @return the tokens\r\n     */\r\n    public static String[] tokenizeUnquoted(String s) {\r\n        List tokens = new LinkedList();\r\n        int first = 0;\r\n        while (first < s.length()) {\r\n            first = skipWhitespace(s, first);\r\n            int last = scanToken(s, first);\r\n            if (first < last) {\r\n                tokens.add(s.substring(first, last));\r\n            }\r\n            first = last;\r\n        }\r\n        return (String[])tokens.toArray(new String[0]);\r\n    }\r",
            "  29  \n  30  \n  31  \n  32  \n  33  \n  34  \n  35  \n  36  \n  37  \n  38  \n  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50 +\n  51  ",
            "    /**\r\n     * This method tokenizes a string by space characters, \r\n     * but ignores spaces in quoted parts,that are parts in \r\n     * '' or \"\". The method does allows the usage of \"\" in '' \r\n     * and '' in \"\". The space character between tokens is not \r\n     * returned. \r\n     * \r\n     * @param s the string to tokenize\r\n     * @return the tokens\r\n     */\r\n    public static String[] tokenizeUnquoted(String s) {\r\n        List tokens = new LinkedList();\r\n        int first = 0;\r\n        while (first < s.length()) {\r\n            first = skipWhitespace(s, first);\r\n            int last = scanToken(s, first);\r\n            if (first < last) {\r\n                tokens.add(s.substring(first, last));\r\n            }\r\n            first = last;\r\n        }\r\n        return (String[])tokens.toArray(EMPTY_STRING_ARRAY);\r\n    }\r"
        ],
        [
            "ExternalGroovyClassDoc::innerClasses(boolean)",
            " 141  \n 142 -\n 143  ",
            "    public GroovyClassDoc[] innerClasses(boolean filter) {\n        return new GroovyClassDoc[0];\n    }",
            " 148  \n 149 +\n 150  ",
            "    public GroovyClassDoc[] innerClasses(boolean filter) {\n        return EMPTY_GROOVYCLASSDOC_ARRAY;\n    }"
        ],
        [
            "CustomizersFactory::postCompleteNode(FactoryBuilderSupport,Object,Object)",
            "  51  \n  52  \n  53  \n  54  \n  55 -\n  56  \n  57  \n  58  ",
            "    @SuppressWarnings(\"unchecked\")\n    public Object postCompleteNode(final FactoryBuilderSupport factory, final Object parent, final Object node) {\n        if (node instanceof List) {\n            List col = (List) node;\n            return col.toArray(new CompilationCustomizer[0]);\n        }\n        return node;\n    }",
            "  52  \n  53  \n  54  \n  55  \n  56 +\n  57  \n  58  \n  59  ",
            "    @SuppressWarnings(\"unchecked\")\n    public Object postCompleteNode(final FactoryBuilderSupport factory, final Object parent, final Object node) {\n        if (node instanceof List) {\n            List col = (List) node;\n            return col.toArray(EMPTY_COMPILATIONCUSTOMIZER_ARRAY);\n        }\n        return node;\n    }"
        ],
        [
            "ExternalGroovyClassDoc::constructors(boolean)",
            " 101  \n 102 -\n 103  ",
            "    public GroovyConstructorDoc[] constructors(boolean filter) {\n        return new GroovyConstructorDoc[0];\n    }",
            " 108  \n 109 +\n 110  ",
            "    public GroovyConstructorDoc[] constructors(boolean filter) {\n        return EMPTY_GROOVYCONSTRUCTORDOC_ARRAY;\n    }"
        ],
        [
            "SimpleGroovyPackageDoc::ordinaryClasses()",
            " 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125 -\n 126  ",
            "    public GroovyClassDoc[] ordinaryClasses() {\n        List<GroovyClassDoc> result = new ArrayList<GroovyClassDoc>(classDocs.values().size());\n        for (GroovyClassDoc doc : classDocs.values()) {\n            if (doc.isOrdinaryClass()) {\n                result.add(doc);\n            }\n        }\n        return result.toArray(new GroovyClassDoc[0]);\n    }",
            " 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126 +\n 127  ",
            "    public GroovyClassDoc[] ordinaryClasses() {\n        List<GroovyClassDoc> result = new ArrayList<GroovyClassDoc>(classDocs.values().size());\n        for (GroovyClassDoc doc : classDocs.values()) {\n            if (doc.isOrdinaryClass()) {\n                result.add(doc);\n            }\n        }\n        return result.toArray(EMPTY_GROOVYCLASSDOC_ARRAY);\n    }"
        ],
        [
            "ClosureTriggerBinding::createBindPath(String,BindPathSnooper)",
            "  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58 -\n  59  \n  60  ",
            "    private BindPath createBindPath(String propertyName, BindPathSnooper snooper) {\n        BindPath bp = new BindPath();\n        bp.propertyName = propertyName;\n        bp.updateLocalSyntheticProperties(syntheticBindings);\n        List<BindPath> childPaths = new ArrayList<BindPath>();\n        for (Map.Entry<String, BindPathSnooper> entry : snooper.fields.entrySet()) {\n            childPaths.add(createBindPath(entry.getKey(), entry.getValue()));\n        }\n        bp.children = childPaths.toArray(new BindPath[0]);\n        return bp;\n    }",
            "  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58 +\n  59  \n  60  ",
            "    private BindPath createBindPath(String propertyName, BindPathSnooper snooper) {\n        BindPath bp = new BindPath();\n        bp.propertyName = propertyName;\n        bp.updateLocalSyntheticProperties(syntheticBindings);\n        List<BindPath> childPaths = new ArrayList<BindPath>();\n        for (Map.Entry<String, BindPathSnooper> entry : snooper.fields.entrySet()) {\n            childPaths.add(createBindPath(entry.getKey(), entry.getValue()));\n        }\n        bp.children = childPaths.toArray(EMPTY_BINDPATH_ARRAY);\n        return bp;\n    }"
        ],
        [
            "ExternalGroovyClassDoc::properties()",
            " 117  \n 118 -\n 119  ",
            "    public GroovyFieldDoc[] properties() {\n        return new GroovyFieldDoc[0];\n    }",
            " 124  \n 125 +\n 126  ",
            "    public GroovyFieldDoc[] properties() {\n        return EMPTY_GROOVYFIELDDOC_ARRAY;\n    }"
        ],
        [
            "ExternalGroovyClassDoc::serializationMethods()",
            " 177  \n 178 -\n 179  ",
            "    public GroovyMethodDoc[] serializationMethods() {\n        return new GroovyMethodDoc[0];\n    }",
            " 184  \n 185 +\n 186  ",
            "    public GroovyMethodDoc[] serializationMethods() {\n        return EMPTY_GROOVYMETHODDOC_ARRAY;\n    }"
        ],
        [
            "ExternalGroovyClassDoc::methods(boolean)",
            " 169  \n 170 -\n 171  ",
            "    public GroovyMethodDoc[] methods(boolean filter) {\n        return new GroovyMethodDoc[0];\n    }",
            " 176  \n 177 +\n 178  ",
            "    public GroovyMethodDoc[] methods(boolean filter) {\n        return EMPTY_GROOVYMETHODDOC_ARRAY;\n    }"
        ],
        [
            "SimpleGroovyPackageDoc::allClasses(boolean)",
            "  69  \n  70  \n  71 -\n  72  ",
            "    public GroovyClassDoc[] allClasses(boolean arg0) {\n        List<GroovyClassDoc> classDocValues = new ArrayList<GroovyClassDoc>(classDocs.values());\n        return classDocValues.toArray(new GroovyClassDoc[0]);\n    }",
            "  70  \n  71  \n  72 +\n  73  ",
            "    public GroovyClassDoc[] allClasses(boolean arg0) {\n        List<GroovyClassDoc> classDocValues = new ArrayList<GroovyClassDoc>(classDocs.values());\n        return classDocValues.toArray(EMPTY_GROOVYCLASSDOC_ARRAY);\n    }"
        ],
        [
            "ClosureTriggerBinding::createBinding(SourceBinding,TargetBinding)",
            "  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126 -\n 127  \n 128  ",
            "    public FullBinding createBinding(SourceBinding source, TargetBinding target) {\n        if (source != this) {\n            throw new RuntimeException(\"Source binding must the Trigger Binding as well\");\n        }\n        final BindPathSnooper delegate = new BindPathSnooper();\n        try {\n            // create our own local copy of the closure\n            final Class closureClass = closure.getClass();\n\n            // do in privileged block since we may be looking at private stuff\n            Closure closureLocalCopy = java.security.AccessController.doPrivileged(new PrivilegedAction<Closure>() {\n                public Closure run() {\n                    // assume closures have only 1 constructor, of the form (Object, Reference*)\n                    Constructor constructor = closureClass.getConstructors()[0];\n                    int paramCount = constructor.getParameterTypes().length;\n                    Object[] args = new Object[paramCount];\n                    args[0] = delegate;\n                    for (int i = 1; i < paramCount; i++) {\n                        args[i] = new Reference(new BindPathSnooper());\n                    }\n                    try {\n                        boolean acc = constructor.isAccessible();\n                        constructor.setAccessible(true);\n                        Closure localCopy = (Closure) constructor.newInstance(args);\n                        if (!acc) { constructor.setAccessible(false); }\n                        localCopy.setResolveStrategy(Closure.DELEGATE_ONLY);\n                        for (Field f:closureClass.getDeclaredFields()) {\n                            acc = f.isAccessible();\n                            f.setAccessible(true);\n                            if (f.getType() == Reference.class) {\n                                delegate.fields.put(f.getName(),\n                                        (BindPathSnooper) ((Reference) f.get(localCopy)).get());\n                            }\n                            if (!acc) { f.setAccessible(false); }\n                        }\n                        return localCopy;\n                    } catch (Exception e) {\n                        throw new RuntimeException(\"Error snooping closure\", e);\n                    }\n                }\n            });\n            try {\n                closureLocalCopy.call();\n            } catch (DeadEndException e) {\n                // we want this exception exposed.\n                throw e;\n            } catch (Exception e) {\n                //LOGME\n                // ignore it, likely failing because we are faking out properties\n                // such as a call to Math.min(int, BindPathSnooper)\n            }\n        } catch (Exception e) {\n            e.printStackTrace(System.out);\n            throw new RuntimeException(\"A closure expression binding could not be created because of \" + e.getClass().getName() + \":\\n\\t\" + e.getMessage());\n        }\n        List<BindPath> rootPaths = new ArrayList<BindPath>();\n        for (Map.Entry<String, BindPathSnooper> entry : delegate.fields.entrySet()) {\n            BindPath bp =createBindPath(entry.getKey(), entry.getValue());\n            bp.currentObject = closure;\n            rootPaths.add(bp);\n        }\n        PropertyPathFullBinding fb = new PropertyPathFullBinding();\n        fb.setSourceBinding(new ClosureSourceBinding(closure));\n        fb.setTargetBinding(target);\n        fb.bindPaths = rootPaths.toArray(new BindPath[0]);\n        return fb;\n    }",
            "  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126 +\n 127  \n 128  ",
            "    public FullBinding createBinding(SourceBinding source, TargetBinding target) {\n        if (source != this) {\n            throw new RuntimeException(\"Source binding must the Trigger Binding as well\");\n        }\n        final BindPathSnooper delegate = new BindPathSnooper();\n        try {\n            // create our own local copy of the closure\n            final Class closureClass = closure.getClass();\n\n            // do in privileged block since we may be looking at private stuff\n            Closure closureLocalCopy = java.security.AccessController.doPrivileged(new PrivilegedAction<Closure>() {\n                public Closure run() {\n                    // assume closures have only 1 constructor, of the form (Object, Reference*)\n                    Constructor constructor = closureClass.getConstructors()[0];\n                    int paramCount = constructor.getParameterTypes().length;\n                    Object[] args = new Object[paramCount];\n                    args[0] = delegate;\n                    for (int i = 1; i < paramCount; i++) {\n                        args[i] = new Reference(new BindPathSnooper());\n                    }\n                    try {\n                        boolean acc = constructor.isAccessible();\n                        constructor.setAccessible(true);\n                        Closure localCopy = (Closure) constructor.newInstance(args);\n                        if (!acc) { constructor.setAccessible(false); }\n                        localCopy.setResolveStrategy(Closure.DELEGATE_ONLY);\n                        for (Field f:closureClass.getDeclaredFields()) {\n                            acc = f.isAccessible();\n                            f.setAccessible(true);\n                            if (f.getType() == Reference.class) {\n                                delegate.fields.put(f.getName(),\n                                        (BindPathSnooper) ((Reference) f.get(localCopy)).get());\n                            }\n                            if (!acc) { f.setAccessible(false); }\n                        }\n                        return localCopy;\n                    } catch (Exception e) {\n                        throw new RuntimeException(\"Error snooping closure\", e);\n                    }\n                }\n            });\n            try {\n                closureLocalCopy.call();\n            } catch (DeadEndException e) {\n                // we want this exception exposed.\n                throw e;\n            } catch (Exception e) {\n                //LOGME\n                // ignore it, likely failing because we are faking out properties\n                // such as a call to Math.min(int, BindPathSnooper)\n            }\n        } catch (Exception e) {\n            e.printStackTrace(System.out);\n            throw new RuntimeException(\"A closure expression binding could not be created because of \" + e.getClass().getName() + \":\\n\\t\" + e.getMessage());\n        }\n        List<BindPath> rootPaths = new ArrayList<BindPath>();\n        for (Map.Entry<String, BindPathSnooper> entry : delegate.fields.entrySet()) {\n            BindPath bp =createBindPath(entry.getKey(), entry.getValue());\n            bp.currentObject = closure;\n            rootPaths.add(bp);\n        }\n        PropertyPathFullBinding fb = new PropertyPathFullBinding();\n        fb.setSourceBinding(new ClosureSourceBinding(closure));\n        fb.setTargetBinding(target);\n        fb.bindPaths = rootPaths.toArray(EMPTY_BINDPATH_ARRAY);\n        return fb;\n    }"
        ],
        [
            "SimpleGroovyPackageDoc::enums()",
            "  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81 -\n  82  ",
            "    public GroovyClassDoc[] enums() {\n        List<GroovyClassDoc> result = new ArrayList<GroovyClassDoc>(classDocs.values().size());\n        for (GroovyClassDoc doc : classDocs.values()) {\n            if (doc.isEnum()) {\n                result.add(doc);\n            }\n        }\n        return result.toArray(new GroovyClassDoc[0]);\n    }",
            "  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82 +\n  83  ",
            "    public GroovyClassDoc[] enums() {\n        List<GroovyClassDoc> result = new ArrayList<GroovyClassDoc>(classDocs.values().size());\n        for (GroovyClassDoc doc : classDocs.values()) {\n            if (doc.isEnum()) {\n                result.add(doc);\n            }\n        }\n        return result.toArray(EMPTY_GROOVYCLASSDOC_ARRAY);\n    }"
        ],
        [
            "SimpleGroovyRootDoc::specifiedPackages()",
            " 108  \n 109  \n 110  \n 111  \n 112  \n 113 -\n 114  ",
            "    public GroovyPackageDoc[] specifiedPackages() {\n        if (packageDocValues == null) {\n            packageDocValues = new ArrayList<GroovyPackageDoc>(packageDocs.values());\n            Collections.sort(packageDocValues);\n        }\n        return packageDocValues.toArray(new GroovyPackageDoc[0]);\n    }",
            " 110  \n 111  \n 112  \n 113  \n 114  \n 115 +\n 116  ",
            "    public GroovyPackageDoc[] specifiedPackages() {\n        if (packageDocValues == null) {\n            packageDocValues = new ArrayList<GroovyPackageDoc>(packageDocs.values());\n            Collections.sort(packageDocValues);\n        }\n        return packageDocValues.toArray(EMPTY_GROOVYPACKAGEDOC_ARRAY);\n    }"
        ],
        [
            "JavacJavaCompiler::makeParameters(List,GroovyClassLoader)",
            " 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175 -\n 176  ",
            "    private String[] makeParameters(List<String> files, GroovyClassLoader parentClassLoader) {\n        Map options = config.getJointCompilationOptions();\n        LinkedList<String> paras = new LinkedList<String>();\n\n        File target = config.getTargetDirectory();\n        if (target == null) target = new File(\".\");\n\n        // defaults\n        paras.add(\"-d\");\n        paras.add(target.getAbsolutePath());\n        paras.add(\"-sourcepath\");\n        paras.add(((File) options.get(\"stubDir\")).getAbsolutePath());\n\n        // add flags\n        String[] flags = (String[]) options.get(\"flags\");\n        if (flags != null) {\n            for (String flag : flags) {\n                paras.add('-' + flag);\n            }\n        }\n\n        boolean hadClasspath = false;\n        // add namedValues\n        String[] namedValues = (String[]) options.get(\"namedValues\");\n        if (namedValues != null) {\n            for (int i = 0; i < namedValues.length; i += 2) {\n                String name = namedValues[i];\n                if (name.equals(\"classpath\")) hadClasspath = true;\n                paras.add('-' + name);\n                paras.add(namedValues[i + 1]);\n            }\n        }\n\n        // append classpath if not already defined\n        if (!hadClasspath) {\n            // add all classpaths that compilation unit sees\n            List<String> paths = new ArrayList<String>(config.getClasspath());\n            ClassLoader cl = parentClassLoader;\n            while (cl != null) {\n                if (cl instanceof URLClassLoader) {\n                    for (URL u : ((URLClassLoader) cl).getURLs()) {\n                        try {\n                            paths.add(new File(u.toURI()).getPath());\n                        } catch (URISyntaxException e) {\n                            // ignore it\n                        }\n                    }\n                }\n                cl = cl.getParent();\n            }\n\n            try {\n                CodeSource codeSource =AccessController.doPrivileged(new PrivilegedAction<CodeSource>() {\n                    @Override\n                    public CodeSource run() {\n                        return GroovyObject.class.getProtectionDomain().getCodeSource();\n                    }\n                });\n                if (codeSource != null) {\n                    paths.add(new File(codeSource.getLocation().toURI()).getPath());\n                }\n            } catch (URISyntaxException e) {\n                // ignore it\n            }\n\n            paras.add(\"-classpath\");\n            paras.add(DefaultGroovyMethods.join((Iterable) paths, File.pathSeparator));\n        }\n\n        // files to compile\n        paras.addAll(files);\n\n        return paras.toArray(new String[0]);\n    }",
            " 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176 +\n 177  ",
            "    private String[] makeParameters(List<String> files, GroovyClassLoader parentClassLoader) {\n        Map options = config.getJointCompilationOptions();\n        LinkedList<String> paras = new LinkedList<String>();\n\n        File target = config.getTargetDirectory();\n        if (target == null) target = new File(\".\");\n\n        // defaults\n        paras.add(\"-d\");\n        paras.add(target.getAbsolutePath());\n        paras.add(\"-sourcepath\");\n        paras.add(((File) options.get(\"stubDir\")).getAbsolutePath());\n\n        // add flags\n        String[] flags = (String[]) options.get(\"flags\");\n        if (flags != null) {\n            for (String flag : flags) {\n                paras.add('-' + flag);\n            }\n        }\n\n        boolean hadClasspath = false;\n        // add namedValues\n        String[] namedValues = (String[]) options.get(\"namedValues\");\n        if (namedValues != null) {\n            for (int i = 0; i < namedValues.length; i += 2) {\n                String name = namedValues[i];\n                if (name.equals(\"classpath\")) hadClasspath = true;\n                paras.add('-' + name);\n                paras.add(namedValues[i + 1]);\n            }\n        }\n\n        // append classpath if not already defined\n        if (!hadClasspath) {\n            // add all classpaths that compilation unit sees\n            List<String> paths = new ArrayList<String>(config.getClasspath());\n            ClassLoader cl = parentClassLoader;\n            while (cl != null) {\n                if (cl instanceof URLClassLoader) {\n                    for (URL u : ((URLClassLoader) cl).getURLs()) {\n                        try {\n                            paths.add(new File(u.toURI()).getPath());\n                        } catch (URISyntaxException e) {\n                            // ignore it\n                        }\n                    }\n                }\n                cl = cl.getParent();\n            }\n\n            try {\n                CodeSource codeSource =AccessController.doPrivileged(new PrivilegedAction<CodeSource>() {\n                    @Override\n                    public CodeSource run() {\n                        return GroovyObject.class.getProtectionDomain().getCodeSource();\n                    }\n                });\n                if (codeSource != null) {\n                    paths.add(new File(codeSource.getLocation().toURI()).getPath());\n                }\n            } catch (URISyntaxException e) {\n                // ignore it\n            }\n\n            paras.add(\"-classpath\");\n            paras.add(DefaultGroovyMethods.join((Iterable) paths, File.pathSeparator));\n        }\n\n        // files to compile\n        paras.addAll(files);\n\n        return paras.toArray(EMPTY_STRING_ARRAY);\n    }"
        ],
        [
            "Java5::configureAnnotation(AnnotationNode,Annotation)",
            " 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279 -\n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  ",
            "    private void configureAnnotation(AnnotationNode node, Annotation annotation) {\r\n        Class type = annotation.annotationType();\r\n        if (type == Retention.class) {\r\n            Retention r = (Retention) annotation;\r\n            RetentionPolicy value = r.value();\r\n            setRetentionPolicy(value, node);\r\n            node.setMember(\"value\", new PropertyExpression(\r\n                    new ClassExpression(ClassHelper.makeWithoutCaching(RetentionPolicy.class, false)),\r\n                    value.toString()));\r\n        } else if (type == Target.class) {\r\n            Target t = (Target) annotation;\r\n            ElementType[] elements = t.value();\r\n            ListExpression elementExprs = new ListExpression();\r\n            for (ElementType element : elements) {\r\n                elementExprs.addExpression(new PropertyExpression(\r\n                        new ClassExpression(ClassHelper.ELEMENT_TYPE_TYPE), element.name()));\r\n            }\r\n            node.setMember(\"value\", elementExprs);\r\n        } else {\r\n            Method[] declaredMethods;\r\n            try {\r\n                declaredMethods = type.getDeclaredMethods();\r\n            } catch (SecurityException se) {\r\n                declaredMethods = new Method[0];\r\n            }\r\n            for (Method declaredMethod : declaredMethods) {\r\n                try {\r\n                    Object value = declaredMethod.invoke(annotation);\r\n                    Expression valueExpression = annotationValueToExpression(value);\r\n                    if (valueExpression == null)\r\n                        continue;\r\n                    node.setMember(declaredMethod.getName(), valueExpression);\r\n                } catch (IllegalAccessException | InvocationTargetException e) {\r\n                }\r\n            }\r\n        }\r\n    }\r",
            " 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281 +\n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  ",
            "    private void configureAnnotation(AnnotationNode node, Annotation annotation) {\r\n        Class type = annotation.annotationType();\r\n        if (type == Retention.class) {\r\n            Retention r = (Retention) annotation;\r\n            RetentionPolicy value = r.value();\r\n            setRetentionPolicy(value, node);\r\n            node.setMember(\"value\", new PropertyExpression(\r\n                    new ClassExpression(ClassHelper.makeWithoutCaching(RetentionPolicy.class, false)),\r\n                    value.toString()));\r\n        } else if (type == Target.class) {\r\n            Target t = (Target) annotation;\r\n            ElementType[] elements = t.value();\r\n            ListExpression elementExprs = new ListExpression();\r\n            for (ElementType element : elements) {\r\n                elementExprs.addExpression(new PropertyExpression(\r\n                        new ClassExpression(ClassHelper.ELEMENT_TYPE_TYPE), element.name()));\r\n            }\r\n            node.setMember(\"value\", elementExprs);\r\n        } else {\r\n            Method[] declaredMethods;\r\n            try {\r\n                declaredMethods = type.getDeclaredMethods();\r\n            } catch (SecurityException se) {\r\n                declaredMethods = EMPTY_METHOD_ARRAY;\r\n            }\r\n            for (Method declaredMethod : declaredMethods) {\r\n                try {\r\n                    Object value = declaredMethod.invoke(annotation);\r\n                    Expression valueExpression = annotationValueToExpression(value);\r\n                    if (valueExpression == null)\r\n                        continue;\r\n                    node.setMember(declaredMethod.getName(), valueExpression);\r\n                } catch (IllegalAccessException | InvocationTargetException e) {\r\n                }\r\n            }\r\n        }\r\n    }\r"
        ],
        [
            "ExternalGroovyClassDoc::annotations()",
            "  48  \n  49 -\n  50  ",
            "    public GroovyAnnotationRef[] annotations() {\n        return annotationRefs.toArray(new GroovyAnnotationRef[0]);\n    }",
            "  55  \n  56 +\n  57  ",
            "    public GroovyAnnotationRef[] annotations() {\n        return annotationRefs.toArray(EMPTY_GROOVYANNOTATIONREF_ARRAY);\n    }"
        ],
        [
            "ExternalGroovyClassDoc::serializableFields()",
            " 173  \n 174 -\n 175  ",
            "    public GroovyFieldDoc[] serializableFields() {\n        return new GroovyFieldDoc[0];\n    }",
            " 180  \n 181 +\n 182  ",
            "    public GroovyFieldDoc[] serializableFields() {\n        return EMPTY_GROOVYFIELDDOC_ARRAY;\n    }"
        ],
        [
            "CharsetToolkit::getAvailableCharsets()",
            " 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410 -\n 411  ",
            "    /**\n     * Retrieves all the available <code>Charset</code>s on the platform,\n     * among which the default <code>charset</code>.\n     *\n     * @return an array of <code>Charset</code>s.\n     */\n    public static Charset[] getAvailableCharsets() {\n        Collection collection = Charset.availableCharsets().values();\n        return (Charset[]) collection.toArray(new Charset[0]);\n    }",
            " 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411 +\n 412  ",
            "    /**\n     * Retrieves all the available <code>Charset</code>s on the platform,\n     * among which the default <code>charset</code>.\n     *\n     * @return an array of <code>Charset</code>s.\n     */\n    public static Charset[] getAvailableCharsets() {\n        Collection collection = Charset.availableCharsets().values();\n        return (Charset[]) collection.toArray(EMPTY_CHARSET_ARRAY);\n    }"
        ],
        [
            "SimpleGroovyDoc::calculateTags(String)",
            "  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113 -\n 114  ",
            "    private void calculateTags(String rawCommentText) {\n        String trimmed = RAW_COMMENT_PATTERN.matcher(rawCommentText).replaceFirst(\"@\");\n        if (trimmed.equals(rawCommentText)) return;\n        String cleaned = TRIMMED_COMMENT_PATTERN.matcher(trimmed).replaceAll(\"$1\").trim();\n        String[] split = cleaned.split(\"(?m)^@\");\n        List<GroovyTag> result = new ArrayList<GroovyTag>();\n        for (String s : split) {\n            String tagname = null;\n            if (s.startsWith(\"param\") || s.startsWith(\"throws\")) {\n                Matcher m = TAG3_PATTERN.matcher(s);\n                if (m.find()) {\n                    tagname = m.group(1);\n                    result.add(new SimpleGroovyTag(tagname, m.group(2), m.group(3)));\n                }\n            } else {\n                Matcher m = TAG2_PATTERN.matcher(s);\n                if (m.find()) {\n                    tagname = m.group(1);\n                    result.add(new SimpleGroovyTag(tagname, null, m.group(2)));\n                }\n            }\n            if (\"deprecated\".equals(tagname)) {\n                setDeprecated(true);\n            }\n        }\n        tags = result.toArray(new GroovyTag[0]);\n    }",
            "  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114 +\n 115  ",
            "    private void calculateTags(String rawCommentText) {\n        String trimmed = RAW_COMMENT_PATTERN.matcher(rawCommentText).replaceFirst(\"@\");\n        if (trimmed.equals(rawCommentText)) return;\n        String cleaned = TRIMMED_COMMENT_PATTERN.matcher(trimmed).replaceAll(\"$1\").trim();\n        String[] split = cleaned.split(\"(?m)^@\");\n        List<GroovyTag> result = new ArrayList<GroovyTag>();\n        for (String s : split) {\n            String tagname = null;\n            if (s.startsWith(\"param\") || s.startsWith(\"throws\")) {\n                Matcher m = TAG3_PATTERN.matcher(s);\n                if (m.find()) {\n                    tagname = m.group(1);\n                    result.add(new SimpleGroovyTag(tagname, m.group(2), m.group(3)));\n                }\n            } else {\n                Matcher m = TAG2_PATTERN.matcher(s);\n                if (m.find()) {\n                    tagname = m.group(1);\n                    result.add(new SimpleGroovyTag(tagname, null, m.group(2)));\n                }\n            }\n            if (\"deprecated\".equals(tagname)) {\n                setDeprecated(true);\n            }\n        }\n        tags = result.toArray(EMPTY_GROOVYTAG_ARRAY);\n    }"
        ],
        [
            "SimpleGroovyClassDoc::enumConstants()",
            " 182  \n 183  \n 184  \n 185  \n 186  \n 187 -\n 188  ",
            "    /**\n     * returns a sorted array of enum constants\n     */\n    public GroovyFieldDoc[] enumConstants() {\n        Collections.sort(enumConstants);\n        return enumConstants.toArray(new GroovyFieldDoc[0]);\n    }",
            " 187  \n 188  \n 189  \n 190  \n 191  \n 192 +\n 193  ",
            "    /**\n     * returns a sorted array of enum constants\n     */\n    public GroovyFieldDoc[] enumConstants() {\n        Collections.sort(enumConstants);\n        return enumConstants.toArray(EMPTY_GROOVYFIELDDOC_ARRAY);\n    }"
        ],
        [
            "FileSystemCompilerFacade::main(String)",
            "  34  \n  35  \n  36  \n  37  \n  38  \n  39  \n  40 -\n  41  \n  42  ",
            "    public static void main(String[] args) {\n        List<String> argList = new ArrayList<String>(Arrays.asList(args));\n        boolean forceLookupUnnamedFiles = argList.contains(\"--forceLookupUnnamedFiles\");\n        if (forceLookupUnnamedFiles) {\n            argList.remove(\"--forceLookupUnnamedFiles\");\n        }\n        String[] newArgs = forceLookupUnnamedFiles ? argList.toArray(new String[0]) : args;\n        FileSystemCompiler.commandLineCompileWithErrorHandling(newArgs, forceLookupUnnamedFiles);\n    }",
            "  36  \n  37  \n  38  \n  39  \n  40  \n  41  \n  42 +\n  43  \n  44  ",
            "    public static void main(String[] args) {\n        List<String> argList = new ArrayList<String>(Arrays.asList(args));\n        boolean forceLookupUnnamedFiles = argList.contains(\"--forceLookupUnnamedFiles\");\n        if (forceLookupUnnamedFiles) {\n            argList.remove(\"--forceLookupUnnamedFiles\");\n        }\n        String[] newArgs = forceLookupUnnamedFiles ? argList.toArray(EMPTY_STRING_ARRAY) : args;\n        FileSystemCompiler.commandLineCompileWithErrorHandling(newArgs, forceLookupUnnamedFiles);\n    }"
        ],
        [
            "StrangeBeanBeanInfo::getEventSetDescriptors()",
            "  27  \n  28  \n  29  \n  30 -\n  31 -\n  32 -\n  33  \n  34  \n  35  \n  36  \n  37  \n  38  \n  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  ",
            "    public EventSetDescriptor[] getEventSetDescriptors() {\n        try {\n            Method[] events = StrangeEventListener.class.getMethods();\n            Method addListener = StrangeBean.class.getMethod(\"addStrangeEventListener\", new Class[] {StrangeEventListener.class});\n            Method removeListener = StrangeBean.class.getMethod(\"removeStrangeEventListener\", new Class[] {StrangeEventListener.class});\n            Method getListeners = StrangeBean.class.getMethod(\"getStrangeEventListeners\", new Class[0]);\n            \n            return new EventSetDescriptor[] {\n                new EventSetDescriptor( \n                        \"strangeEvent\",\n                        StrangeEventListener.class, \n                        events,\n                        addListener,\n                        removeListener,\n                        getListeners)\n            };\n        } catch (Exception e) {\n            e.printStackTrace(System.out);\n            return super.getEventSetDescriptors();\n        }\n    }",
            "  28  \n  29  \n  30  \n  31 +\n  32 +\n  33 +\n  34  \n  35  \n  36  \n  37  \n  38  \n  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  ",
            "    public EventSetDescriptor[] getEventSetDescriptors() {\n        try {\n            Method[] events = StrangeEventListener.class.getMethods();\n            Method addListener = StrangeBean.class.getMethod(\"addStrangeEventListener\", StrangeEventListener.class);\n            Method removeListener = StrangeBean.class.getMethod(\"removeStrangeEventListener\", StrangeEventListener.class);\n            Method getListeners = StrangeBean.class.getMethod(\"getStrangeEventListeners\", EMPTY_CLASS_ARRAY);\n            \n            return new EventSetDescriptor[] {\n                new EventSetDescriptor( \n                        \"strangeEvent\",\n                        StrangeEventListener.class, \n                        events,\n                        addListener,\n                        removeListener,\n                        getListeners)\n            };\n        } catch (Exception e) {\n            e.printStackTrace(System.out);\n            return super.getEventSetDescriptors();\n        }\n    }"
        ],
        [
            "ExternalGroovyClassDoc::interfaces()",
            " 145  \n 146 -\n 147  ",
            "    public GroovyClassDoc[] interfaces() {\n        return new GroovyClassDoc[0];\n    }",
            " 152  \n 153 +\n 154  ",
            "    public GroovyClassDoc[] interfaces() {\n        return EMPTY_GROOVYCLASSDOC_ARRAY;\n    }"
        ],
        [
            "Grape::resolve(Map,List,Map)",
            " 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202 -\n 203  \n 204  \n 205  \n 206  ",
            "    public static URI[] resolve(Map<String, Object> args, List depsInfo, Map... dependencies) {\n        URI[] uris = null;\n        if (enableGrapes) {\n            GrapeEngine instance = getInstance();\n            if (instance != null) {\n                if (!args.containsKey(AUTO_DOWNLOAD_SETTING)) {\n                    args.put(AUTO_DOWNLOAD_SETTING, enableAutoDownload);\n                }\n                if (!args.containsKey(DISABLE_CHECKSUMS_SETTING)) {\n                    args.put(DISABLE_CHECKSUMS_SETTING, disableChecksums);\n                }\n                uris = instance.resolve(args, depsInfo, dependencies);\n            }\n        }\n        if (uris == null) {\n            return new URI[0];\n        } else {\n            return uris;\n        }\n    }",
            " 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204 +\n 205  \n 206  \n 207  \n 208  ",
            "    public static URI[] resolve(Map<String, Object> args, List depsInfo, Map... dependencies) {\n        URI[] uris = null;\n        if (enableGrapes) {\n            GrapeEngine instance = getInstance();\n            if (instance != null) {\n                if (!args.containsKey(AUTO_DOWNLOAD_SETTING)) {\n                    args.put(AUTO_DOWNLOAD_SETTING, enableAutoDownload);\n                }\n                if (!args.containsKey(DISABLE_CHECKSUMS_SETTING)) {\n                    args.put(DISABLE_CHECKSUMS_SETTING, disableChecksums);\n                }\n                uris = instance.resolve(args, depsInfo, dependencies);\n            }\n        }\n        if (uris == null) {\n            return EMPTY_URI_ARRAY;\n        } else {\n            return uris;\n        }\n    }"
        ],
        [
            "ExternalGroovyClassDoc::importedPackages()",
            " 133  \n 134 -\n 135  ",
            "    public GroovyPackageDoc[] importedPackages() {\n        return new GroovyPackageDoc[0];\n    }",
            " 140  \n 141 +\n 142  ",
            "    public GroovyPackageDoc[] importedPackages() {\n        return EMPTY_GROOVYPACKAGEDOC_ARRAY;\n    }"
        ],
        [
            "ExternalGroovyClassDoc::interfaceTypes()",
            " 149  \n 150 -\n 151  ",
            "    public GroovyType[] interfaceTypes() {\n        return new GroovyType[0];\n    }",
            " 156  \n 157 +\n 158  ",
            "    public GroovyType[] interfaceTypes() {\n        return EMPTY_GROOVYTYPE_ARRAY;\n    }"
        ],
        [
            "Sql::CreatePreparedStatementCommand::execute(Connection,String)",
            "4583  \n4584  \n4585  \n4586 -\n4587  \n4588  \n4589  \n4590  \n4591  \n4592  \n4593  \n4594  \n4595  \n4596  \n4597  \n4598  \n4599  \n4600  \n4601  ",
            "        @Override\n        protected PreparedStatement execute(Connection connection, String sql) throws SQLException {\n            if (returnGeneratedKeys == USE_COLUMN_NAMES && keyColumnNames != null) {\n                return connection.prepareStatement(sql, keyColumnNames.toArray(new String[0]));\n            }\n            if (returnGeneratedKeys != 0) {\n                return connection.prepareStatement(sql, returnGeneratedKeys);\n            }\n            if (appearsLikeStoredProc(sql)) {\n                if (resultSetHoldability == -1) {\n                    return connection.prepareCall(sql, resultSetType, resultSetConcurrency);\n                }\n                return connection.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability);\n            }\n            if (resultSetHoldability == -1) {\n                return connection.prepareStatement(sql, resultSetType, resultSetConcurrency);\n            }\n            return connection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability);\n        }",
            "4584  \n4585  \n4586  \n4587 +\n4588  \n4589  \n4590  \n4591  \n4592  \n4593  \n4594  \n4595  \n4596  \n4597  \n4598  \n4599  \n4600  \n4601  \n4602  ",
            "        @Override\n        protected PreparedStatement execute(Connection connection, String sql) throws SQLException {\n            if (returnGeneratedKeys == USE_COLUMN_NAMES && keyColumnNames != null) {\n                return connection.prepareStatement(sql, keyColumnNames.toArray(EMPTY_STRING_ARRAY));\n            }\n            if (returnGeneratedKeys != 0) {\n                return connection.prepareStatement(sql, returnGeneratedKeys);\n            }\n            if (appearsLikeStoredProc(sql)) {\n                if (resultSetHoldability == -1) {\n                    return connection.prepareCall(sql, resultSetType, resultSetConcurrency);\n                }\n                return connection.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability);\n            }\n            if (resultSetHoldability == -1) {\n                return connection.prepareStatement(sql, resultSetType, resultSetConcurrency);\n            }\n            return connection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability);\n        }"
        ],
        [
            "TableSorter::TableSorter()",
            "  54  \n  55 -\n  56  ",
            "    public TableSorter() {\n        indexes = new int[0]; // For consistency.\n    }",
            "  55  \n  56 +\n  57  ",
            "    public TableSorter() {\n        indexes = EMPTY_INT_ARRAY; // For consistency.\n    }"
        ],
        [
            "SimpleGroovyProgramElementDoc::annotations()",
            " 100  \n 101 -\n 102  ",
            "    public GroovyAnnotationRef[] annotations() {\n        return annotationRefs.toArray(new GroovyAnnotationRef[0]);\n    }",
            " 101  \n 102 +\n 103  ",
            "    public GroovyAnnotationRef[] annotations() {\n        return annotationRefs.toArray(EMPTY_GROOVYANNOTATIONREF_ARRAY);\n    }"
        ],
        [
            "SimpleGroovyPackageDoc::exceptions()",
            "  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101 -\n 102  ",
            "    public GroovyClassDoc[] exceptions() {\n        List<GroovyClassDoc> result = new ArrayList<GroovyClassDoc>(classDocs.values().size());\n        for (GroovyClassDoc doc : classDocs.values()) {\n            if (doc.isException()) {\n                result.add(doc);\n            }\n        }\n        return result.toArray(new GroovyClassDoc[0]);\n    }",
            "  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102 +\n 103  ",
            "    public GroovyClassDoc[] exceptions() {\n        List<GroovyClassDoc> result = new ArrayList<GroovyClassDoc>(classDocs.values().size());\n        for (GroovyClassDoc doc : classDocs.values()) {\n            if (doc.isException()) {\n                result.add(doc);\n            }\n        }\n        return result.toArray(EMPTY_GROOVYCLASSDOC_ARRAY);\n    }"
        ]
    ],
    "4da8d37d07a3c3c4fa16dcce1e488c9f6d5be118": [
        [
            "AutoCloneASTTransformation::createSimpleClone(ClassNode,List,List)",
            " 201  \n 202 -\n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  ",
            "    private static void createSimpleClone(ClassNode cNode, List<FieldNode> fieldNodes, List<String> excludes) {\r\n        if (cNode.getDeclaredConstructors().isEmpty()) {\n            // add no-arg constructor\r\n            cNode.addConstructor(ACC_PUBLIC, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, block(EmptyStatement.INSTANCE));\r\n        }\r\n        addSimpleCloneHelperMethod(cNode, fieldNodes, excludes);\r\n        final Expression result = varX(\"_result\", cNode);\r\n        ClassNode[] exceptions = {make(CloneNotSupportedException.class)};\r\n        cNode.addMethod(\"clone\", ACC_PUBLIC, GenericsUtils.nonGeneric(cNode), Parameter.EMPTY_ARRAY, exceptions, block(\r\n            declS(result, ctorX(cNode)),\r\n            stmt(callThisX(\"cloneOrCopyMembers\", args(result))),\r\n            returnS(result)));\r\n    }\r",
            " 225  \n 226 +\n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  ",
            "    private static void createSimpleClone(ClassNode cNode, List<FieldNode> fieldNodes, List<String> excludes) {\r\n        if (cNode.getDeclaredConstructors().isEmpty()) {\r\n            // add no-arg constructor\r\n            cNode.addConstructor(ACC_PUBLIC, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, block(EmptyStatement.INSTANCE));\r\n        }\r\n        addSimpleCloneHelperMethod(cNode, fieldNodes, excludes);\r\n        final Expression result = varX(\"_result\", cNode);\r\n        ClassNode[] exceptions = {make(CloneNotSupportedException.class)};\r\n        cNode.addMethod(\"clone\", ACC_PUBLIC, GenericsUtils.nonGeneric(cNode), Parameter.EMPTY_ARRAY, exceptions, block(\r\n            declS(result, ctorX(cNode)),\r\n            stmt(callThisX(\"cloneOrCopyMembers\", args(result))),\r\n            returnS(result)));\r\n    }\r"
        ],
        [
            "AutoCloneASTTransformation::createCloneCopyConstructor(ClassNode,List,List)",
            " 140  \n 141 -\n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  ",
            "    private static void createCloneCopyConstructor(ClassNode cNode, List<FieldNode> list, List<String> excludes) {\r\n        if (cNode.getDeclaredConstructors().isEmpty()) {\n            // add no-arg constructor\r\n            BlockStatement noArgBody = new BlockStatement();\r\n            noArgBody.addStatement(EmptyStatement.INSTANCE);\r\n            cNode.addConstructor(ACC_PUBLIC, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, noArgBody);\r\n        }\r\n        boolean hasThisCons = false;\r\n        for (ConstructorNode consNode : cNode.getDeclaredConstructors()) {\r\n            Parameter[] parameters = consNode.getParameters();\r\n            if (parameters.length == 1 && parameters[0].getType().equals(cNode)) {\r\n                hasThisCons = true;\r\n            }\r\n        }\r\n        if (!hasThisCons) {\r\n            BlockStatement initBody = new BlockStatement();\r\n            Parameter initParam = param(GenericsUtils.nonGeneric(cNode), \"other\");\r\n            final Expression other = varX(initParam);\r\n            boolean hasParent = cNode.getSuperClass() != ClassHelper.OBJECT_TYPE;\r\n            if (hasParent) {\r\n                initBody.addStatement(stmt(ctorX(ClassNode.SUPER, other)));\r\n            }\r\n            for (FieldNode fieldNode : list) {\r\n                String name = fieldNode.getName();\r\n                if (excludes != null && excludes.contains(name)) continue;\r\n                ClassNode fieldType = fieldNode.getType();\r\n                Expression direct = propX(other, name);\r\n                Expression to = propX(varX(\"this\"), name);\r\n                Statement assignDirect = assignS(to, direct);\r\n                Statement assignCloned = assignS(to, castX(fieldType, callCloneDirectX(direct)));\r\n                Statement assignClonedDynamic = assignS(to, castX(fieldType, callCloneDynamicX(direct)));\r\n                if (isCloneableType(fieldType)) {\r\n                    initBody.addStatement(assignCloned);\r\n                } else if (!possiblyCloneable(fieldType)) {\r\n                    initBody.addStatement(assignDirect);\r\n                } else {\r\n                    initBody.addStatement(ifElseS(isInstanceOfX(direct, CLONEABLE_TYPE), assignClonedDynamic, assignDirect));\r\n                }\r\n            }\r\n            cNode.addConstructor(ACC_PROTECTED, params(initParam), ClassNode.EMPTY_ARRAY, initBody);\r\n        }\r\n        ClassNode[] exceptions = {make(CloneNotSupportedException.class)};\r\n        cNode.addMethod(\"clone\", ACC_PUBLIC, GenericsUtils.nonGeneric(cNode), Parameter.EMPTY_ARRAY, exceptions, block(stmt(ctorX(cNode, args(varX(\"this\"))))));\r\n    }\r",
            " 164  \n 165 +\n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  ",
            "    private static void createCloneCopyConstructor(ClassNode cNode, List<FieldNode> list, List<String> excludes) {\r\n        if (cNode.getDeclaredConstructors().isEmpty()) {\r\n            // add no-arg constructor\r\n            BlockStatement noArgBody = new BlockStatement();\r\n            noArgBody.addStatement(EmptyStatement.INSTANCE);\r\n            cNode.addConstructor(ACC_PUBLIC, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, noArgBody);\r\n        }\r\n        boolean hasThisCons = false;\r\n        for (ConstructorNode consNode : cNode.getDeclaredConstructors()) {\r\n            Parameter[] parameters = consNode.getParameters();\r\n            if (parameters.length == 1 && parameters[0].getType().equals(cNode)) {\r\n                hasThisCons = true;\r\n            }\r\n        }\r\n        if (!hasThisCons) {\r\n            BlockStatement initBody = new BlockStatement();\r\n            Parameter initParam = param(GenericsUtils.nonGeneric(cNode), \"other\");\r\n            final Expression other = varX(initParam);\r\n            boolean hasParent = cNode.getSuperClass() != ClassHelper.OBJECT_TYPE;\r\n            if (hasParent) {\r\n                initBody.addStatement(stmt(ctorX(ClassNode.SUPER, other)));\r\n            }\r\n            for (FieldNode fieldNode : list) {\r\n                String name = fieldNode.getName();\r\n                if (excludes != null && excludes.contains(name)) continue;\r\n                ClassNode fieldType = fieldNode.getType();\r\n                Expression direct = propX(other, name);\r\n                Expression to = propX(varX(\"this\"), name);\r\n                Statement assignDirect = assignS(to, direct);\r\n                Statement assignCloned = assignS(to, castX(fieldType, callCloneDirectX(direct)));\r\n                Statement assignClonedDynamic = assignS(to, castX(fieldType, callCloneDynamicX(direct)));\r\n                if (isCloneableType(fieldType)) {\r\n                    initBody.addStatement(assignCloned);\r\n                } else if (!possiblyCloneable(fieldType)) {\r\n                    initBody.addStatement(assignDirect);\r\n                } else {\r\n                    initBody.addStatement(ifElseS(isInstanceOfX(direct, CLONEABLE_TYPE), assignClonedDynamic, assignDirect));\r\n                }\r\n            }\r\n            cNode.addConstructor(ACC_PROTECTED, params(initParam), ClassNode.EMPTY_ARRAY, initBody);\r\n        }\r\n        ClassNode[] exceptions = {make(CloneNotSupportedException.class)};\r\n        cNode.addMethod(\"clone\", ACC_PUBLIC, GenericsUtils.nonGeneric(cNode), Parameter.EMPTY_ARRAY, exceptions, block(stmt(ctorX(cNode, args(varX(\"this\"))))));\r\n    }\r"
        ]
    ],
    "afa59389f3f362ed8bf37b80c1793b0f864a8721": [
        [
            "InnerClassCompletionVisitor::addDefaultMethods(InnerClassNode)",
            " 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256 -\n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292 -\n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  \n 306  ",
            "    private void addDefaultMethods(InnerClassNode node) {\r\n        final boolean isStatic = isStatic(node);\r\n\r\n        ClassNode outerClass = node.getOuterClass();\r\n        final String classInternalName = org.codehaus.groovy.classgen.asm.BytecodeHelper.getClassInternalName(node);\r\n        final String outerClassInternalName = getInternalName(outerClass, isStatic);\r\n        final String outerClassDescriptor = getTypeDescriptor(outerClass, isStatic);\r\n        final int objectDistance = getObjectDistance(outerClass);\r\n\r\n        // add missing method dispatcher\r\n        Parameter[] parameters = new Parameter[]{\r\n                new Parameter(ClassHelper.STRING_TYPE, \"name\"),\r\n                new Parameter(ClassHelper.OBJECT_TYPE, \"args\")\r\n        };\r\n\r\n        String methodName = \"methodMissing\";\r\n        if (isStatic)\r\n            addCompilationErrorOnCustomMethodNode(node, methodName, parameters);\r\n\r\n        MethodNode method = node.addSyntheticMethod(\r\n                methodName,\r\n                Opcodes.ACC_PUBLIC,\r\n                ClassHelper.OBJECT_TYPE,\r\n                parameters,\r\n                ClassNode.EMPTY_ARRAY,\r\n                null\r\n        );\r\n\r\n        BlockStatement block = new BlockStatement();\r\n        if (isStatic) {\r\n            setMethodDispatcherCode(block, new ClassExpression(outerClass), parameters);\r\n        } else {\r\n            block.addStatement(\r\n                    new BytecodeSequence(new BytecodeInstruction() {\r\n                        public void visit(MethodVisitor mv) {\r\n                            getThis(mv,classInternalName,outerClassDescriptor,outerClassInternalName);\r\n                            mv.visitVarInsn(ALOAD, 1);\r\n                            mv.visitVarInsn(ALOAD, 2);\r\n                            mv.visitMethodInsn(INVOKEVIRTUAL, outerClassInternalName, \"this$dist$invoke$\" + objectDistance, \"(Ljava/lang/String;Ljava/lang/Object;)Ljava/lang/Object;\", false);\r\n                            mv.visitInsn(ARETURN);\r\n                        }\r\n                    })\r\n            );\r\n        }\r\n        method.setCode(block);\r\n\r\n        // add static missing method dispatcher\r\n        methodName = \"$static_methodMissing\";\r\n        if (isStatic)\r\n            addCompilationErrorOnCustomMethodNode(node, methodName, parameters);\r\n\r\n        method = node.addSyntheticMethod(\r\n                methodName,\r\n                Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\r\n                ClassHelper.OBJECT_TYPE,\r\n                parameters,\r\n                ClassNode.EMPTY_ARRAY,\r\n                null\r\n        );\r\n\r\n        block = new BlockStatement();\r\n        setMethodDispatcherCode(block, new ClassExpression(outerClass), parameters);\r\n        method.setCode(block);\r\n\r\n        // add property setter dispatcher\r\n        parameters = new Parameter[]{\r\n                new Parameter(ClassHelper.STRING_TYPE, \"name\"),\r\n                new Parameter(ClassHelper.OBJECT_TYPE, \"val\")\r\n        };\r\n\r\n        methodName = \"propertyMissing\";\r\n        if (isStatic)\r\n            addCompilationErrorOnCustomMethodNode(node, methodName, parameters);\r\n\r\n        method = node.addSyntheticMethod(\r\n                methodName,\r\n                Opcodes.ACC_PUBLIC,\r\n                ClassHelper.VOID_TYPE,\r\n                parameters,\r\n                ClassNode.EMPTY_ARRAY,\r\n                null\r\n        );\r\n\r\n        block = new BlockStatement();\r\n        if (isStatic) {\r\n            setPropertySetterDispatcher(block, new ClassExpression(node.getOuterClass()), parameters);\r\n        } else {\r\n            block.addStatement(\r\n                    new BytecodeSequence(new BytecodeInstruction() {\r\n                        public void visit(MethodVisitor mv) {\r\n                            getThis(mv,classInternalName,outerClassDescriptor,outerClassInternalName);\r\n                            mv.visitVarInsn(ALOAD, 1);\r\n                            mv.visitVarInsn(ALOAD, 2);\r\n                            mv.visitMethodInsn(INVOKEVIRTUAL, outerClassInternalName, \"this$dist$set$\" + objectDistance, \"(Ljava/lang/String;Ljava/lang/Object;)V\", false);\r\n                            mv.visitInsn(RETURN);\r\n                        }\r\n                    })\r\n            );\r\n        }\r\n        method.setCode(block);\r\n\r\n        // add property getter dispatcher\r\n        parameters = new Parameter[]{\r\n                new Parameter(ClassHelper.STRING_TYPE, \"name\")\r\n        };\r\n\r\n        methodName = \"propertyMissing\";\r\n        if (isStatic)\r\n            addCompilationErrorOnCustomMethodNode(node, methodName, parameters);\r\n\r\n        method = node.addSyntheticMethod(\r\n                methodName,\r\n                Opcodes.ACC_PUBLIC,\r\n                ClassHelper.OBJECT_TYPE,\r\n                parameters,\r\n                ClassNode.EMPTY_ARRAY,\r\n                null\r\n        );\r\n\r\n        block = new BlockStatement();\r\n        if (isStatic) {\r\n            setPropertyGetterDispatcher(block, new ClassExpression(node.getOuterClass()), parameters);\r\n        } else {\r\n            block.addStatement(\r\n                    new BytecodeSequence(new BytecodeInstruction() {\r\n                        public void visit(MethodVisitor mv) {\r\n                            getThis(mv,classInternalName,outerClassDescriptor,outerClassInternalName);\r\n                            mv.visitVarInsn(ALOAD, 1);\r\n                            mv.visitMethodInsn(INVOKEVIRTUAL, outerClassInternalName, \"this$dist$get$\" + objectDistance, \"(Ljava/lang/String;)Ljava/lang/Object;\", false);\r\n                            mv.visitInsn(ARETURN);\r\n                        }\r\n                    })\r\n            );\r\n        }\r\n        method.setCode(block);\r\n    }\r",
            " 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256 +\n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272 +\n 273 +\n 274 +\n 275 +\n 276 +\n 277 +\n 278 +\n 279 +\n 280 +\n 281 +\n 282 +\n 283 +\n 284 +\n 285 +\n 286 +\n 287 +\n 288 +\n 289 +\n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309  \n 310 +\n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324 +\n 325 +\n 326 +\n 327 +\n 328 +\n 329 +\n 330 +\n 331 +\n 332 +\n 333 +\n 334 +\n 335 +\n 336 +\n 337 +\n 338 +\n 339 +\n 340 +\n 341 +\n 342  ",
            "    private void addDefaultMethods(InnerClassNode node) {\r\n        final boolean isStatic = isStatic(node);\r\n\r\n        ClassNode outerClass = node.getOuterClass();\r\n        final String classInternalName = org.codehaus.groovy.classgen.asm.BytecodeHelper.getClassInternalName(node);\r\n        final String outerClassInternalName = getInternalName(outerClass, isStatic);\r\n        final String outerClassDescriptor = getTypeDescriptor(outerClass, isStatic);\r\n        final int objectDistance = getObjectDistance(outerClass);\r\n\r\n        // add missing method dispatcher\r\n        Parameter[] parameters = new Parameter[]{\r\n                new Parameter(ClassHelper.STRING_TYPE, \"name\"),\r\n                new Parameter(ClassHelper.OBJECT_TYPE, \"args\")\r\n        };\r\n\r\n        String methodName = \"methodMissing\";\r\n        if (isStatic)\r\n            addCompilationErrorOnCustomMethodNode(node, methodName, parameters);\r\n\r\n        MethodNode method = node.addSyntheticMethod(\r\n                methodName,\r\n                Opcodes.ACC_PUBLIC,\r\n                ClassHelper.OBJECT_TYPE,\r\n                parameters,\r\n                ClassNode.EMPTY_ARRAY,\r\n                null\r\n        );\r\n\r\n        BlockStatement block = new BlockStatement();\r\n        if (isStatic) {\r\n            setMethodDispatcherCode(block, new ClassExpression(outerClass), parameters);\r\n        } else {\r\n            block.addStatement(\r\n                    new BytecodeSequence(new BytecodeInstruction() {\r\n                        public void visit(MethodVisitor mv) {\r\n                            getThis(mv,classInternalName,outerClassDescriptor,outerClassInternalName);\r\n                            mv.visitVarInsn(ALOAD, 1);\r\n                            mv.visitVarInsn(ALOAD, 2);\r\n                            mv.visitMethodInsn(INVOKEVIRTUAL, outerClassInternalName, \"this$dist$invoke$\" + objectDistance, \"(Ljava/lang/String;Ljava/lang/Object;)Ljava/lang/Object;\", false);\r\n                            mv.visitInsn(ARETURN);\r\n                        }\r\n                    })\r\n            );\r\n        }\r\n        method.setCode(block);\r\n\r\n        // add static missing method dispatcher\r\n        methodName = \"$static_methodMissing\";\r\n        if (isStatic)\r\n            addCompilationErrorOnCustomMethodNode(node, methodName, parameters);\r\n\r\n        method = node.addSyntheticMethod(\r\n                methodName,\r\n                Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\r\n                ClassHelper.OBJECT_TYPE,\r\n                parameters,\r\n                ClassNode.EMPTY_ARRAY,\r\n                null\r\n        );\r\n\r\n        block = new BlockStatement();\r\n        setMethodDispatcherCode(block, new ClassExpression(outerClass), parameters);\r\n        method.setCode(block);\r\n\r\n        // add property setter dispatcher\r\n        parameters = new Parameter[]{\r\n                new Parameter(ClassHelper.STRING_TYPE, \"name\"),\r\n                new Parameter(ClassHelper.OBJECT_TYPE, \"val\")\r\n        };\r\n\r\n        methodName = \"propertyMissing\";\r\n        if (isStatic)\r\n            addCompilationErrorOnCustomMethodNode(node, methodName, parameters);\r\n\r\n        method = node.addSyntheticMethod(\r\n                methodName,\r\n                Opcodes.ACC_PUBLIC,\r\n                ClassHelper.VOID_TYPE,\r\n                parameters,\r\n                ClassNode.EMPTY_ARRAY,\r\n                null\r\n        );\r\n\r\n        block = new BlockStatement();\r\n        if (isStatic) {\r\n            setPropertySetterDispatcher(block, new ClassExpression(outerClass), parameters);\r\n        } else {\r\n            block.addStatement(\r\n                    new BytecodeSequence(new BytecodeInstruction() {\r\n                        public void visit(MethodVisitor mv) {\r\n                            getThis(mv,classInternalName,outerClassDescriptor,outerClassInternalName);\r\n                            mv.visitVarInsn(ALOAD, 1);\r\n                            mv.visitVarInsn(ALOAD, 2);\r\n                            mv.visitMethodInsn(INVOKEVIRTUAL, outerClassInternalName, \"this$dist$set$\" + objectDistance, \"(Ljava/lang/String;Ljava/lang/Object;)V\", false);\r\n                            mv.visitInsn(RETURN);\r\n                        }\r\n                    })\r\n            );\r\n        }\r\n        method.setCode(block);\r\n\r\n        // add static property missing setter dispatcher\r\n        methodName = \"$static_propertyMissing\";\r\n        if (isStatic)\r\n            addCompilationErrorOnCustomMethodNode(node, methodName, parameters);\r\n\r\n        method = node.addSyntheticMethod(\r\n                methodName,\r\n                Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\r\n                ClassHelper.VOID_TYPE,\r\n                parameters,\r\n                ClassNode.EMPTY_ARRAY,\r\n                null\r\n        );\r\n\r\n        block = new BlockStatement();\r\n        setPropertySetterDispatcher(block, new ClassExpression(outerClass), parameters);\r\n        method.setCode(block);\r\n\r\n        // add property getter dispatcher\r\n        parameters = new Parameter[]{\r\n                new Parameter(ClassHelper.STRING_TYPE, \"name\")\r\n        };\r\n\r\n        methodName = \"propertyMissing\";\r\n        if (isStatic)\r\n            addCompilationErrorOnCustomMethodNode(node, methodName, parameters);\r\n\r\n        method = node.addSyntheticMethod(\r\n                methodName,\r\n                Opcodes.ACC_PUBLIC,\r\n                ClassHelper.OBJECT_TYPE,\r\n                parameters,\r\n                ClassNode.EMPTY_ARRAY,\r\n                null\r\n        );\r\n\r\n        block = new BlockStatement();\r\n        if (isStatic) {\r\n            setPropertyGetterDispatcher(block, new ClassExpression(outerClass), parameters);\r\n        } else {\r\n            block.addStatement(\r\n                    new BytecodeSequence(new BytecodeInstruction() {\r\n                        public void visit(MethodVisitor mv) {\r\n                            getThis(mv,classInternalName,outerClassDescriptor,outerClassInternalName);\r\n                            mv.visitVarInsn(ALOAD, 1);\r\n                            mv.visitMethodInsn(INVOKEVIRTUAL, outerClassInternalName, \"this$dist$get$\" + objectDistance, \"(Ljava/lang/String;)Ljava/lang/Object;\", false);\r\n                            mv.visitInsn(ARETURN);\r\n                        }\r\n                    })\r\n            );\r\n        }\r\n        method.setCode(block);\r\n\r\n        // add static property missing getter dispatcher\r\n        methodName = \"$static_propertyMissing\";\r\n        if (isStatic)\r\n            addCompilationErrorOnCustomMethodNode(node, methodName, parameters);\r\n\r\n        method = node.addSyntheticMethod(\r\n                methodName,\r\n                Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\r\n                ClassHelper.OBJECT_TYPE,\r\n                parameters,\r\n                ClassNode.EMPTY_ARRAY,\r\n                null\r\n        );\r\n\r\n        block = new BlockStatement();\r\n        setPropertyGetterDispatcher(block, new ClassExpression(outerClass), parameters);\r\n        method.setCode(block);\r\n    }\r"
        ],
        [
            "MetaClassImpl::setProperty(Class,Object,String,Object,boolean,boolean)",
            "2599  \n2600  \n2601  \n2602  \n2603  \n2604  \n2605  \n2606  \n2607  \n2608  \n2609  \n2610  \n2611  \n2612  \n2613  \n2614  \n2615  \n2616  \n2617  \n2618  \n2619  \n2620  \n2621  \n2622  \n2623  \n2624  \n2625  \n2626  \n2627  \n2628  \n2629  \n2630  \n2631  \n2632  \n2633  \n2634  \n2635  \n2636  \n2637  \n2638  \n2639  \n2640  \n2641  \n2642  \n2643  \n2644  \n2645  \n2646  \n2647  \n2648  \n2649  \n2650  \n2651  \n2652  \n2653  \n2654  \n2655  \n2656  \n2657  \n2658  \n2659  \n2660  \n2661  \n2662  \n2663  \n2664  \n2665  \n2666  \n2667  \n2668  \n2669  \n2670  \n2671  \n2672  \n2673  \n2674  \n2675  \n2676  \n2677  \n2678  \n2679  \n2680  \n2681  \n2682  \n2683  \n2684  \n2685  \n2686  \n2687  \n2688  \n2689  \n2690  \n2691  \n2692  \n2693  \n2694  \n2695  \n2696  \n2697  \n2698  \n2699  \n2700  \n2701  \n2702  \n2703  \n2704  \n2705  \n2706  \n2707  \n2708  \n2709  \n2710  \n2711  \n2712  \n2713  \n2714  \n2715  \n2716  \n2717  \n2718  \n2719  \n2720  \n2721  \n2722  \n2723  \n2724  \n2725  \n2726  \n2727  \n2728  \n2729  \n2730  \n2731  \n2732  \n2733  \n2734  \n2735  \n2736  \n2737  \n2738  \n2739  \n2740  \n2741  \n2742  \n2743  \n2744  \n2745  \n2746  \n2747  \n2748  \n2749  \n2750  \n2751  \n2752  \n2753  \n2754 -\n2755  ",
            "   /**\n     * <p>Retrieves a property on the given receiver for the specified arguments. The sender is the class that is requesting the property from the object.\n     * The MetaClass will attempt to establish the method to invoke based on the name and arguments provided.\n     *\n     * <p>The useSuper and fromInsideClass help the Groovy runtime perform optimisations on the call to go directly\n     * to the super class if necessary\n     *\n     * @param sender The java.lang.Class instance that is mutating the property\n     * @param object The Object which the property is being set on\n     * @param name The name of the property\n     * @param newValue The new value of the property to set\n     * @param useSuper Whether the call is to a super class property\n     * @param fromInsideClass Whether the call was invoked from the inside or the outside of the class.\n     */\n    public void setProperty(Class sender, Object object, String name, Object newValue, boolean useSuper, boolean fromInsideClass) {\n        checkInitalised();\n\n        //----------------------------------------------------------------------\n        // handling of static\n        //----------------------------------------------------------------------\n        boolean isStatic = theClass != Class.class && object instanceof Class;\n        if (isStatic && object != theClass) {\n            MetaClass mc = registry.getMetaClass((Class) object);\n            mc.getProperty(sender, object, name, useSuper, fromInsideClass);\n            return;\n        }\n\n        //----------------------------------------------------------------------\n        // Unwrap wrapped values fo now - the new MOP will handle them properly\n        //----------------------------------------------------------------------\n        if (newValue instanceof Wrapper) newValue = ((Wrapper) newValue).unwrap();\n\n        MetaMethod method = null;\n        Object[] arguments = null;\n\n        //----------------------------------------------------------------------\n        // setter\n        //----------------------------------------------------------------------\n        MetaProperty mp = getMetaProperty(sender, name, useSuper, isStatic);\n        MetaProperty field = null;\n        if (mp != null) {\n            if (mp instanceof MetaBeanProperty) {\n                MetaBeanProperty mbp = (MetaBeanProperty) mp;\n                method = mbp.getSetter();\n                MetaProperty f = mbp.getField();\n                if (method != null || (f != null && !Modifier.isFinal(f.getModifiers()))) {\n                    arguments = new Object[]{newValue};\n                    field = f;\n                }\n            } else {\n                field = mp;\n            }\n        }\n\n        // check for a category method named like a setter\n        if (!useSuper && !isStatic && GroovyCategorySupport.hasCategoryInCurrentThread()\n                && name.length() > 0) {\n            String getterName = GroovyCategorySupport.getPropertyCategorySetterName(name);\n            if (getterName != null) {\n                MetaMethod categoryMethod = getCategoryMethodSetter(sender, getterName, false);\n                if (categoryMethod != null) {\n                    method = categoryMethod;\n                    arguments = new Object[]{newValue};\n                }\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // listener method\n        //----------------------------------------------------------------------\n        boolean ambiguousListener = false;\n        if (method == null) {\n            method = (MetaMethod) listeners.get(name);\n            ambiguousListener = method == AMBIGUOUS_LISTENER_METHOD;\n            if (method != null &&\n                    !ambiguousListener &&\n                    newValue instanceof Closure) {\n                // let's create a dynamic proxy\n                Object proxy = Proxy.newProxyInstance(\n                        theClass.getClassLoader(),\n                        new Class[]{method.getParameterTypes()[0].getTheClass()},\n                        new ConvertedClosure((Closure) newValue, name));\n                arguments = new Object[]{proxy};\n                newValue = proxy;\n            } else {\n                method = null;\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // turn setProperty on a Map to put on the Map itself\n        //----------------------------------------------------------------------\n        if (method == null && !isStatic && this.isMap) {\n            ((Map) object).put(name, newValue);\n            return;\n        }\n\n        //----------------------------------------------------------------------\n        // field\n        //----------------------------------------------------------------------\n        if (method == null && field != null) {\n            if (Modifier.isFinal(field.getModifiers())) {\n                throw new ReadOnlyPropertyException(name, theClass);\n            }\n            if(!(this.isMap && isPrivateOrPkgPrivate(field.getModifiers()))) {\n                field.setProperty(object, newValue);\n                return;\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // generic set method\n        //----------------------------------------------------------------------\n        // check for a generic get method provided through a category\n        if (method == null && !useSuper && !isStatic && GroovyCategorySupport.hasCategoryInCurrentThread()) {\n            method = getCategoryMethodSetter(sender, \"set\", true);\n            if (method != null) arguments = new Object[]{name, newValue};\n        }\n\n        // the generic method is valid, if available (!=null), if static or\n        // if it is not static and we do no static access\n        if (method == null && genericSetMethod != null && !(!genericSetMethod.isStatic() && isStatic)) {\n            arguments = new Object[]{name, newValue};\n            method = genericSetMethod;\n        }\n\n        //----------------------------------------------------------------------\n        // executing the getter method\n        //----------------------------------------------------------------------\n        if (method != null) {\n            if (arguments.length == 1) {\n                newValue = DefaultTypeTransformation.castToType(\n                        newValue,\n                        method.getParameterTypes()[0].getTheClass());\n                arguments[0] = newValue;\n            } else {\n                newValue = DefaultTypeTransformation.castToType(\n                        newValue,\n                        method.getParameterTypes()[1].getTheClass());\n                arguments[1] = newValue;\n            }\n            method.doMethodInvoke(object, arguments);\n            return;\n        }\n\n        //----------------------------------------------------------------------\n        // error due to missing method/field\n        //----------------------------------------------------------------------\n        if (ambiguousListener) {\n            throw new GroovyRuntimeException(\"There are multiple listeners for the property \" + name + \". Please do not use the bean short form to access this listener.\");\n        }\n        if (mp != null) {\n            throw new ReadOnlyPropertyException(name, theClass);\n        }\n\n        invokeMissingProperty(object, name, newValue, false);\n    }",
            "2599  \n2600  \n2601  \n2602  \n2603  \n2604  \n2605  \n2606  \n2607  \n2608  \n2609  \n2610  \n2611  \n2612  \n2613  \n2614  \n2615  \n2616  \n2617  \n2618  \n2619  \n2620  \n2621  \n2622  \n2623  \n2624  \n2625  \n2626  \n2627  \n2628  \n2629  \n2630  \n2631  \n2632  \n2633  \n2634  \n2635  \n2636  \n2637  \n2638  \n2639  \n2640  \n2641  \n2642  \n2643  \n2644  \n2645  \n2646  \n2647  \n2648  \n2649  \n2650  \n2651  \n2652  \n2653  \n2654  \n2655  \n2656  \n2657  \n2658  \n2659  \n2660  \n2661  \n2662  \n2663  \n2664  \n2665  \n2666  \n2667  \n2668  \n2669  \n2670  \n2671  \n2672  \n2673  \n2674  \n2675  \n2676  \n2677  \n2678  \n2679  \n2680  \n2681  \n2682  \n2683  \n2684  \n2685  \n2686  \n2687  \n2688  \n2689  \n2690  \n2691  \n2692  \n2693  \n2694  \n2695  \n2696  \n2697  \n2698  \n2699  \n2700  \n2701  \n2702  \n2703  \n2704  \n2705  \n2706  \n2707  \n2708  \n2709  \n2710  \n2711  \n2712  \n2713  \n2714  \n2715  \n2716  \n2717  \n2718  \n2719  \n2720  \n2721  \n2722  \n2723  \n2724  \n2725  \n2726  \n2727  \n2728  \n2729  \n2730  \n2731  \n2732  \n2733  \n2734  \n2735  \n2736  \n2737  \n2738  \n2739  \n2740  \n2741  \n2742  \n2743  \n2744  \n2745  \n2746  \n2747  \n2748  \n2749  \n2750  \n2751  \n2752  \n2753  \n2754 +\n2755 +\n2756 +\n2757 +\n2758  ",
            "   /**\n     * <p>Retrieves a property on the given receiver for the specified arguments. The sender is the class that is requesting the property from the object.\n     * The MetaClass will attempt to establish the method to invoke based on the name and arguments provided.\n     *\n     * <p>The useSuper and fromInsideClass help the Groovy runtime perform optimisations on the call to go directly\n     * to the super class if necessary\n     *\n     * @param sender The java.lang.Class instance that is mutating the property\n     * @param object The Object which the property is being set on\n     * @param name The name of the property\n     * @param newValue The new value of the property to set\n     * @param useSuper Whether the call is to a super class property\n     * @param fromInsideClass Whether the call was invoked from the inside or the outside of the class.\n     */\n    public void setProperty(Class sender, Object object, String name, Object newValue, boolean useSuper, boolean fromInsideClass) {\n        checkInitalised();\n\n        //----------------------------------------------------------------------\n        // handling of static\n        //----------------------------------------------------------------------\n        boolean isStatic = theClass != Class.class && object instanceof Class;\n        if (isStatic && object != theClass) {\n            MetaClass mc = registry.getMetaClass((Class) object);\n            mc.getProperty(sender, object, name, useSuper, fromInsideClass);\n            return;\n        }\n\n        //----------------------------------------------------------------------\n        // Unwrap wrapped values fo now - the new MOP will handle them properly\n        //----------------------------------------------------------------------\n        if (newValue instanceof Wrapper) newValue = ((Wrapper) newValue).unwrap();\n\n        MetaMethod method = null;\n        Object[] arguments = null;\n\n        //----------------------------------------------------------------------\n        // setter\n        //----------------------------------------------------------------------\n        MetaProperty mp = getMetaProperty(sender, name, useSuper, isStatic);\n        MetaProperty field = null;\n        if (mp != null) {\n            if (mp instanceof MetaBeanProperty) {\n                MetaBeanProperty mbp = (MetaBeanProperty) mp;\n                method = mbp.getSetter();\n                MetaProperty f = mbp.getField();\n                if (method != null || (f != null && !Modifier.isFinal(f.getModifiers()))) {\n                    arguments = new Object[]{newValue};\n                    field = f;\n                }\n            } else {\n                field = mp;\n            }\n        }\n\n        // check for a category method named like a setter\n        if (!useSuper && !isStatic && GroovyCategorySupport.hasCategoryInCurrentThread()\n                && name.length() > 0) {\n            String getterName = GroovyCategorySupport.getPropertyCategorySetterName(name);\n            if (getterName != null) {\n                MetaMethod categoryMethod = getCategoryMethodSetter(sender, getterName, false);\n                if (categoryMethod != null) {\n                    method = categoryMethod;\n                    arguments = new Object[]{newValue};\n                }\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // listener method\n        //----------------------------------------------------------------------\n        boolean ambiguousListener = false;\n        if (method == null) {\n            method = (MetaMethod) listeners.get(name);\n            ambiguousListener = method == AMBIGUOUS_LISTENER_METHOD;\n            if (method != null &&\n                    !ambiguousListener &&\n                    newValue instanceof Closure) {\n                // let's create a dynamic proxy\n                Object proxy = Proxy.newProxyInstance(\n                        theClass.getClassLoader(),\n                        new Class[]{method.getParameterTypes()[0].getTheClass()},\n                        new ConvertedClosure((Closure) newValue, name));\n                arguments = new Object[]{proxy};\n                newValue = proxy;\n            } else {\n                method = null;\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // turn setProperty on a Map to put on the Map itself\n        //----------------------------------------------------------------------\n        if (method == null && !isStatic && this.isMap) {\n            ((Map) object).put(name, newValue);\n            return;\n        }\n\n        //----------------------------------------------------------------------\n        // field\n        //----------------------------------------------------------------------\n        if (method == null && field != null) {\n            if (Modifier.isFinal(field.getModifiers())) {\n                throw new ReadOnlyPropertyException(name, theClass);\n            }\n            if(!(this.isMap && isPrivateOrPkgPrivate(field.getModifiers()))) {\n                field.setProperty(object, newValue);\n                return;\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // generic set method\n        //----------------------------------------------------------------------\n        // check for a generic get method provided through a category\n        if (method == null && !useSuper && !isStatic && GroovyCategorySupport.hasCategoryInCurrentThread()) {\n            method = getCategoryMethodSetter(sender, \"set\", true);\n            if (method != null) arguments = new Object[]{name, newValue};\n        }\n\n        // the generic method is valid, if available (!=null), if static or\n        // if it is not static and we do no static access\n        if (method == null && genericSetMethod != null && !(!genericSetMethod.isStatic() && isStatic)) {\n            arguments = new Object[]{name, newValue};\n            method = genericSetMethod;\n        }\n\n        //----------------------------------------------------------------------\n        // executing the getter method\n        //----------------------------------------------------------------------\n        if (method != null) {\n            if (arguments.length == 1) {\n                newValue = DefaultTypeTransformation.castToType(\n                        newValue,\n                        method.getParameterTypes()[0].getTheClass());\n                arguments[0] = newValue;\n            } else {\n                newValue = DefaultTypeTransformation.castToType(\n                        newValue,\n                        method.getParameterTypes()[1].getTheClass());\n                arguments[1] = newValue;\n            }\n            method.doMethodInvoke(object, arguments);\n            return;\n        }\n\n        //----------------------------------------------------------------------\n        // error due to missing method/field\n        //----------------------------------------------------------------------\n        if (ambiguousListener) {\n            throw new GroovyRuntimeException(\"There are multiple listeners for the property \" + name + \". Please do not use the bean short form to access this listener.\");\n        }\n        if (mp != null) {\n            throw new ReadOnlyPropertyException(name, theClass);\n        }\n\n        if ((isStatic || object instanceof Class) && !\"metaClass\".equals(name))\n            invokeStaticMissingProperty(object, name, newValue, false);\n        else\n            invokeMissingProperty(object, name, newValue, false);\n    }"
        ]
    ]
}