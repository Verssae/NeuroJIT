{
    "f2864a8236536148a618474fa28d27c74f563a45": [
        [
            "TraitASTTransformation::processField(FieldNode,MethodNode,MethodNode,ClassNode,ClassNode,Set)",
            " 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388  \n 389 -\n 390 -\n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  ",
            "    private void processField(final FieldNode field, final MethodNode initializer, final MethodNode staticInitializer, final ClassNode fieldHelper, final ClassNode trait, final Set<String> knownFields) {\n        Expression initialExpression = field.getInitialExpression();\n        MethodNode selectedMethod = field.isStatic()?staticInitializer:initializer;\n        if (initialExpression != null) {\n            VariableExpression thisObject = new VariableExpression(selectedMethod.getParameters()[0]);\n            ExpressionStatement initCode = new ExpressionStatement(initialExpression);\n            processBody(thisObject, selectedMethod, initCode, trait, fieldHelper, knownFields);\n            BlockStatement code = (BlockStatement) selectedMethod.getCode();\n            MethodCallExpression mce = new MethodCallExpression(\n                    new CastExpression(createReceiverType(field.isStatic(), fieldHelper), thisObject),\n                    Traits.helperSetterName(field),\n                    initCode.getExpression()\n            );\n            mce.setImplicitThis(false);\n            mce.setSourcePosition(initialExpression);\n            code.addStatement(new ExpressionStatement(mce));\n        }\n        // define setter/getter helper methods\n        fieldHelper.addMethod(\n                Traits.helperSetterName(field),\n                ACC_PUBLIC | ACC_ABSTRACT,\n                ClassHelper.VOID_TYPE,\n                new Parameter[]{new Parameter(field.getOriginType(), \"val\")},\n                ClassNode.EMPTY_ARRAY,\n                null\n        );\n        fieldHelper.addMethod(\n                Traits.helperGetterName(field),\n                ACC_PUBLIC | ACC_ABSTRACT,\n                field.getOriginType(),\n                Parameter.EMPTY_ARRAY,\n                ClassNode.EMPTY_ARRAY,\n                null\n        );\n\n        // dummy fields are only used to carry annotations if instance field\n        // and to differentiate from static fields otherwise\n        FieldNode dummyField = new FieldNode(\n                (field.isStatic()?Traits.STATIC_FIELD_PREFIX:\"\")+Traits.remappedFieldName(field.getOwner(),field.getName()),\n                ACC_STATIC|ACC_PUBLIC | ACC_FINAL | ACC_SYNTHETIC,\n                field.getOriginType(),\n                fieldHelper,\n                null\n        );\n        // copy annotations from field to dummy field\n        List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n        List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n        copyAnnotatedNodeAnnotations(field, copied, notCopied);\n        dummyField.addAnnotations(copied);\n        fieldHelper.addField(dummyField);\n    }",
            " 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388 +\n 389 +\n 390 +\n 391  \n 392 +\n 393 +\n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  ",
            "    private void processField(final FieldNode field, final MethodNode initializer, final MethodNode staticInitializer, final ClassNode fieldHelper, final ClassNode trait, final Set<String> knownFields) {\n        Expression initialExpression = field.getInitialExpression();\n        MethodNode selectedMethod = field.isStatic()?staticInitializer:initializer;\n        if (initialExpression != null) {\n            VariableExpression thisObject = new VariableExpression(selectedMethod.getParameters()[0]);\n            ExpressionStatement initCode = new ExpressionStatement(initialExpression);\n            processBody(thisObject, selectedMethod, initCode, trait, fieldHelper, knownFields);\n            BlockStatement code = (BlockStatement) selectedMethod.getCode();\n            MethodCallExpression mce = new MethodCallExpression(\n                    new CastExpression(createReceiverType(field.isStatic(), fieldHelper), thisObject),\n                    Traits.helperSetterName(field),\n                    initCode.getExpression()\n            );\n            mce.setImplicitThis(false);\n            mce.setSourcePosition(initialExpression);\n            code.addStatement(new ExpressionStatement(mce));\n        }\n        // define setter/getter helper methods\n        fieldHelper.addMethod(\n                Traits.helperSetterName(field),\n                ACC_PUBLIC | ACC_ABSTRACT,\n                ClassHelper.VOID_TYPE,\n                new Parameter[]{new Parameter(field.getOriginType(), \"val\")},\n                ClassNode.EMPTY_ARRAY,\n                null\n        );\n        fieldHelper.addMethod(\n                Traits.helperGetterName(field),\n                ACC_PUBLIC | ACC_ABSTRACT,\n                field.getOriginType(),\n                Parameter.EMPTY_ARRAY,\n                ClassNode.EMPTY_ARRAY,\n                null\n        );\n\n        // dummy fields are only used to carry annotations if instance field\n        // and to differentiate from static fields otherwise\n        String dummyFieldName = (field.isStatic() ? Traits.STATIC_FIELD_PREFIX : Traits.FIELD_PREFIX) +\n                (field.isPublic()? Traits.PUBLIC_FIELD_PREFIX : Traits.PRIVATE_FIELD_PREFIX)+\n                Traits.remappedFieldName(field.getOwner(), field.getName());\n        FieldNode dummyField = new FieldNode(\n                dummyFieldName,\n                ACC_STATIC | ACC_PUBLIC | ACC_FINAL | ACC_SYNTHETIC,\n                field.getOriginType(),\n                fieldHelper,\n                null\n        );\n        // copy annotations from field to dummy field\n        List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n        List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n        copyAnnotatedNodeAnnotations(field, copied, notCopied);\n        dummyField.addAnnotations(copied);\n        fieldHelper.addField(dummyField);\n    }"
        ],
        [
            "TraitComposer::applyTrait(ClassNode,ClassNode,TraitHelpersTuple)",
            " 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197 -\n 198  \n 199  \n 200 -\n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209 -\n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  ",
            "    private static void applyTrait(final ClassNode trait, final ClassNode cNode, final TraitHelpersTuple helpers) {\n        boolean isTraitForceOverride = !trait.getAnnotations(Traits.FORCEOVERRIDE_CLASSNODE).isEmpty();\n        ClassNode helperClassNode = helpers.getHelper();\n        ClassNode fieldHelperClassNode = helpers.getFieldHelper();\n        Map genericsSpec = GenericsUtils.createGenericsSpec(cNode, new HashMap());\n        genericsSpec = GenericsUtils.createGenericsSpec(trait, genericsSpec);\n\n        for (MethodNode methodNode : helperClassNode.getAllDeclaredMethods()) {\n            boolean isForceOverride = isTraitForceOverride || Traits.isForceOverride(methodNode);\n            String name = methodNode.getName();\n            Parameter[] helperMethodParams = methodNode.getParameters();\n            boolean isAbstract = methodNode.isAbstract();\n            if (!isAbstract && helperMethodParams.length > 0 && ((methodNode.getModifiers() & Opcodes.ACC_STATIC) == Opcodes.ACC_STATIC) && !name.contains(\"$\")) {\n                ArgumentListExpression argList = new ArgumentListExpression();\n                argList.addExpression(new VariableExpression(\"this\"));\n                Parameter[] origParams = new Parameter[helperMethodParams.length - 1];\n                Parameter[] params = new Parameter[helperMethodParams.length - 1];\n                for (int i = 1; i < helperMethodParams.length; i++) {\n                    Parameter parameter = helperMethodParams[i];\n                    ClassNode originType = parameter.getOriginType();\n                    ClassNode fixedType = AbstractASTTransformation.correctToGenericsSpecRecurse(genericsSpec, originType);\n                    Parameter newParam = new Parameter(fixedType, \"arg\" + i);\n                    List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n                    List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n                    AbstractASTTransformation.copyAnnotatedNodeAnnotations(parameter, copied, notCopied);\n                    newParam.addAnnotations(copied);\n                    params[i - 1] = newParam;\n                    origParams[i-1] = parameter;\n                    argList.addExpression(new VariableExpression(params[i - 1]));\n                }\n                if (shouldSkipMethod(cNode, name, params, isForceOverride)) {\n                    continue;\n                }\n                createForwarderMethod(trait, cNode, methodNode, helperClassNode, genericsSpec, helperMethodParams, origParams, params, argList);\n            }\n        }\n        cNode.addObjectInitializerStatements(new ExpressionStatement(\n                new MethodCallExpression(\n                        new ClassExpression(helperClassNode),\n                        Traits.INIT_METHOD,\n                        new ArgumentListExpression(new VariableExpression(\"this\")))\n        ));\n        cNode.addStaticInitializerStatements(Collections.<Statement>singletonList(new ExpressionStatement(\n                new MethodCallExpression(\n                        new ClassExpression(helperClassNode),\n                        Traits.STATIC_INIT_METHOD,\n                        new ArgumentListExpression(new VariableExpression(\"this\")))\n        )), false);\n        if (fieldHelperClassNode != null) {\n            // we should implement the field helper interface too\n            cNode.addInterface(fieldHelperClassNode);\n            // implementation of methods\n            List<MethodNode> declaredMethods = fieldHelperClassNode.getAllDeclaredMethods();\n            Collections.sort(declaredMethods, GETTER_FIRST_COMPARATOR);\n            for (MethodNode methodNode : declaredMethods) {\n                String fieldName = methodNode.getName();\n                if (fieldName.endsWith(Traits.DIRECT_GETTER_SUFFIX) || fieldName.endsWith(Traits.DIRECT_SETTER_SUFFIX)) {\n                    int suffixIdx = fieldName.lastIndexOf(\"$\");\n                    fieldName = fieldName.substring(0, suffixIdx);\n                    String operation = methodNode.getName().substring(suffixIdx + 1);\n                    boolean getter = \"get\".equals(operation);\n                    ClassNode returnType = AbstractASTTransformation.correctToGenericsSpecRecurse(genericsSpec, methodNode.getReturnType());\n                    int isStatic = 0;\n                    FieldNode helperField = fieldHelperClassNode.getField(fieldName);\n                    if (helperField==null) {\n                        // try to find a static one\n                        helperField = fieldHelperClassNode.getField(Traits.STATIC_FIELD_PREFIX+fieldName);\n                        isStatic = Opcodes.ACC_STATIC;\n                    }\n                    if (getter) {\n                        // add field\n                        if (helperField!=null) {\n                            List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n                            List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n                            AbstractASTTransformation.copyAnnotatedNodeAnnotations(helperField, copied, notCopied);\n                            FieldNode fieldNode = cNode.addField(fieldName, Opcodes.ACC_PRIVATE | isStatic, returnType, null);\n                            fieldNode.addAnnotations(copied);\n                        }\n                    }\n                    Parameter[] newParams;\n                    if (getter) {\n                        newParams = Parameter.EMPTY_ARRAY;\n                    } else {\n                        ClassNode originType = methodNode.getParameters()[0].getOriginType();\n                        ClassNode fixedType = originType.isGenericsPlaceHolder()?ClassHelper.OBJECT_TYPE:AbstractASTTransformation.correctToGenericsSpecRecurse(genericsSpec, originType);\n                        newParams = new Parameter[]{new Parameter(fixedType, \"val\")};\n                    }\n\n                    Expression fieldExpr = new VariableExpression(cNode.getField(fieldName));\n                    Statement body =\n                            getter ? new ReturnStatement(fieldExpr) :\n                                    new ExpressionStatement(\n                                            new BinaryExpression(\n                                                    fieldExpr,\n                                                    Token.newSymbol(Types.EQUAL, 0, 0),\n                                                    new VariableExpression(newParams[0])\n                                            )\n                                    );\n                    MethodNode impl = new MethodNode(\n                            methodNode.getName(),\n                            Opcodes.ACC_PUBLIC | isStatic,\n                            returnType,\n                            newParams,\n                            ClassNode.EMPTY_ARRAY,\n                            body\n                    );\n                    impl.addAnnotation(new AnnotationNode(COMPILESTATIC_CLASSNODE));\n                    cNode.addMethod(impl);\n                }\n            }\n        }\n    }",
            " 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197 +\n 198 +\n 199  \n 200 +\n 201 +\n 202 +\n 203 +\n 204 +\n 205  \n 206 +\n 207 +\n 208 +\n 209 +\n 210 +\n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219 +\n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  ",
            "    private static void applyTrait(final ClassNode trait, final ClassNode cNode, final TraitHelpersTuple helpers) {\n        boolean isTraitForceOverride = !trait.getAnnotations(Traits.FORCEOVERRIDE_CLASSNODE).isEmpty();\n        ClassNode helperClassNode = helpers.getHelper();\n        ClassNode fieldHelperClassNode = helpers.getFieldHelper();\n        Map genericsSpec = GenericsUtils.createGenericsSpec(cNode, new HashMap());\n        genericsSpec = GenericsUtils.createGenericsSpec(trait, genericsSpec);\n\n        for (MethodNode methodNode : helperClassNode.getAllDeclaredMethods()) {\n            boolean isForceOverride = isTraitForceOverride || Traits.isForceOverride(methodNode);\n            String name = methodNode.getName();\n            Parameter[] helperMethodParams = methodNode.getParameters();\n            boolean isAbstract = methodNode.isAbstract();\n            if (!isAbstract && helperMethodParams.length > 0 && ((methodNode.getModifiers() & Opcodes.ACC_STATIC) == Opcodes.ACC_STATIC) && !name.contains(\"$\")) {\n                ArgumentListExpression argList = new ArgumentListExpression();\n                argList.addExpression(new VariableExpression(\"this\"));\n                Parameter[] origParams = new Parameter[helperMethodParams.length - 1];\n                Parameter[] params = new Parameter[helperMethodParams.length - 1];\n                for (int i = 1; i < helperMethodParams.length; i++) {\n                    Parameter parameter = helperMethodParams[i];\n                    ClassNode originType = parameter.getOriginType();\n                    ClassNode fixedType = AbstractASTTransformation.correctToGenericsSpecRecurse(genericsSpec, originType);\n                    Parameter newParam = new Parameter(fixedType, \"arg\" + i);\n                    List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n                    List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n                    AbstractASTTransformation.copyAnnotatedNodeAnnotations(parameter, copied, notCopied);\n                    newParam.addAnnotations(copied);\n                    params[i - 1] = newParam;\n                    origParams[i-1] = parameter;\n                    argList.addExpression(new VariableExpression(params[i - 1]));\n                }\n                if (shouldSkipMethod(cNode, name, params, isForceOverride)) {\n                    continue;\n                }\n                createForwarderMethod(trait, cNode, methodNode, helperClassNode, genericsSpec, helperMethodParams, origParams, params, argList);\n            }\n        }\n        cNode.addObjectInitializerStatements(new ExpressionStatement(\n                new MethodCallExpression(\n                        new ClassExpression(helperClassNode),\n                        Traits.INIT_METHOD,\n                        new ArgumentListExpression(new VariableExpression(\"this\")))\n        ));\n        cNode.addStaticInitializerStatements(Collections.<Statement>singletonList(new ExpressionStatement(\n                new MethodCallExpression(\n                        new ClassExpression(helperClassNode),\n                        Traits.STATIC_INIT_METHOD,\n                        new ArgumentListExpression(new VariableExpression(\"this\")))\n        )), false);\n        if (fieldHelperClassNode != null) {\n            // we should implement the field helper interface too\n            cNode.addInterface(fieldHelperClassNode);\n            // implementation of methods\n            List<MethodNode> declaredMethods = fieldHelperClassNode.getAllDeclaredMethods();\n            Collections.sort(declaredMethods, GETTER_FIRST_COMPARATOR);\n            for (MethodNode methodNode : declaredMethods) {\n                String fieldName = methodNode.getName();\n                if (fieldName.endsWith(Traits.DIRECT_GETTER_SUFFIX) || fieldName.endsWith(Traits.DIRECT_SETTER_SUFFIX)) {\n                    int suffixIdx = fieldName.lastIndexOf(\"$\");\n                    fieldName = fieldName.substring(0, suffixIdx);\n                    String operation = methodNode.getName().substring(suffixIdx + 1);\n                    boolean getter = \"get\".equals(operation);\n                    ClassNode returnType = AbstractASTTransformation.correctToGenericsSpecRecurse(genericsSpec, methodNode.getReturnType());\n                    int isStatic = 0;\n                    boolean publicField = true;\n                    FieldNode helperField = fieldHelperClassNode.getField(Traits.FIELD_PREFIX + Traits.PUBLIC_FIELD_PREFIX + fieldName);\n                    if (helperField==null) {\n                        publicField = false;\n                        helperField = fieldHelperClassNode.getField(Traits.FIELD_PREFIX + Traits.PRIVATE_FIELD_PREFIX + fieldName);\n                    }\n                    if (helperField==null) {\n                        publicField = true;\n                        // try to find a static one\n                        helperField = fieldHelperClassNode.getField(Traits.STATIC_FIELD_PREFIX+Traits.PUBLIC_FIELD_PREFIX+fieldName);\n                        if (helperField==null) {\n                            publicField = false;\n                            helperField = fieldHelperClassNode.getField(Traits.STATIC_FIELD_PREFIX+Traits.PRIVATE_FIELD_PREFIX +fieldName);\n                        }\n                        isStatic = Opcodes.ACC_STATIC;\n                    }\n                    if (getter) {\n                        // add field\n                        if (helperField!=null) {\n                            List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n                            List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n                            AbstractASTTransformation.copyAnnotatedNodeAnnotations(helperField, copied, notCopied);\n                            FieldNode fieldNode = cNode.addField(fieldName, (publicField?Opcodes.ACC_PUBLIC:Opcodes.ACC_PRIVATE) | isStatic, returnType, null);\n                            fieldNode.addAnnotations(copied);\n                        }\n                    }\n                    Parameter[] newParams;\n                    if (getter) {\n                        newParams = Parameter.EMPTY_ARRAY;\n                    } else {\n                        ClassNode originType = methodNode.getParameters()[0].getOriginType();\n                        ClassNode fixedType = originType.isGenericsPlaceHolder()?ClassHelper.OBJECT_TYPE:AbstractASTTransformation.correctToGenericsSpecRecurse(genericsSpec, originType);\n                        newParams = new Parameter[]{new Parameter(fixedType, \"val\")};\n                    }\n\n                    Expression fieldExpr = new VariableExpression(cNode.getField(fieldName));\n                    Statement body =\n                            getter ? new ReturnStatement(fieldExpr) :\n                                    new ExpressionStatement(\n                                            new BinaryExpression(\n                                                    fieldExpr,\n                                                    Token.newSymbol(Types.EQUAL, 0, 0),\n                                                    new VariableExpression(newParams[0])\n                                            )\n                                    );\n                    MethodNode impl = new MethodNode(\n                            methodNode.getName(),\n                            Opcodes.ACC_PUBLIC | isStatic,\n                            returnType,\n                            newParams,\n                            ClassNode.EMPTY_ARRAY,\n                            body\n                    );\n                    impl.addAnnotation(new AnnotationNode(COMPILESTATIC_CLASSNODE));\n                    cNode.addMethod(impl);\n                }\n            }\n        }\n    }"
        ]
    ],
    "622742192996de555c29eb9c39b743429b95c1bd": [
        [
            "StaticTypeCheckingVisitor::doInferClosureParameterTypes(ClassNode,Expression,ClosureExpression,MethodNode,Expression,Expression)",
            "2098  \n2099  \n2100  \n2101  \n2102  \n2103  \n2104  \n2105  \n2106  \n2107  \n2108  \n2109  \n2110  \n2111  \n2112  \n2113  \n2114  \n2115  \n2116  \n2117  \n2118  \n2119  \n2120  \n2121  \n2122  \n2123  \n2124  \n2125  \n2126  \n2127  \n2128  \n2129  \n2130  \n2131  \n2132  \n2133  \n2134  \n2135  \n2136  \n2137  \n2138  \n2139  \n2140  \n2141  \n2142  \n2143  \n2144  \n2145  \n2146  \n2147  \n2148  \n2149  \n2150  \n2151  \n2152  \n2153  \n2154  \n2155  \n2156  \n2157  \n2158  \n2159  \n2160  \n2161  \n2162  \n2163  \n2164  \n2165  \n2166  \n2167  \n2168  \n2169  \n2170  \n2171  \n2172  \n2173  \n2174  \n2175  \n2176  \n2177  \n2178  \n2179  \n2180  \n2181  \n2182  \n2183  \n2184  \n2185  \n2186  \n2187  \n2188  \n2189  \n2190  \n2191  \n2192  \n2193  \n2194  \n2195  \n2196  \n2197  \n2198  \n2199  \n2200  \n2201  \n2202  \n2203  \n2204  \n2205 -\n2206  \n2207  \n2208  \n2209  \n2210  \n2211  \n2212  ",
            "    private void doInferClosureParameterTypes(final ClassNode receiver, final Expression arguments, final ClosureExpression expression, final MethodNode selectedMethod, final Expression hintClass, final Expression options) {\n        List<ClassNode[]> closureSignatures = getSignaturesFromHint(expression,selectedMethod,hintClass,options);\n        List<ClassNode[]> candidates = new LinkedList<ClassNode[]>();\n        for (ClassNode[] signature : closureSignatures) {\n            // in order to compute the inferred types of the closure parameters, we're using the following trick:\n            // 1. create a dummy MethodNode for which the return type is a class node for which the generic types are the types returned by the hint\n            // 2. call inferReturnTypeGenerics\n            // 3. fetch inferred types from the result of inferReturnTypeGenerics\n            // In practice, it could be done differently but it has the main advantage of reusing\n            // existing code, hence reducing the amount of code to debug in case of failure.\n            final int id = System.identityHashCode(expression);\n            ClassNode dummyResultNode = new ClassNode(\"cl$\" + id, 0, OBJECT_TYPE).getPlainNodeReference();\n            final GenericsType[] genericTypes = new GenericsType[signature.length];\n            for (int i = 0; i < signature.length; i++) {\n                genericTypes[i] = new GenericsType(signature[i]);\n            }\n            dummyResultNode.setGenericsTypes(genericTypes);\n            MethodNode dummyMN = selectedMethod instanceof ExtensionMethodNode ? ((ExtensionMethodNode) selectedMethod).getExtensionMethodNode() : selectedMethod;\n            dummyMN = new MethodNode(\n                    dummyMN.getName(),\n                    dummyMN.getModifiers(),\n                    dummyResultNode,\n                    dummyMN.getParameters(),\n                    dummyMN.getExceptions(),\n                    EmptyStatement.INSTANCE\n                    );\n            dummyMN.setDeclaringClass(selectedMethod.getDeclaringClass());\n            dummyMN.setGenericsTypes(selectedMethod.getGenericsTypes());\n            if (selectedMethod instanceof ExtensionMethodNode) {\n                ExtensionMethodNode orig = (ExtensionMethodNode) selectedMethod;\n                dummyMN = new ExtensionMethodNode(\n                        dummyMN,\n                        dummyMN.getName(),\n                        dummyMN.getModifiers(),\n                        dummyResultNode,\n                        orig.getParameters(),\n                        orig.getExceptions(),\n                        EmptyStatement.INSTANCE,\n                        orig.isStaticExtension()\n                        );\n                dummyMN.setDeclaringClass(orig.getDeclaringClass());\n                dummyMN.setGenericsTypes(orig.getGenericsTypes());\n            }\n            ClassNode classNode = inferReturnTypeGenerics(receiver, dummyMN, arguments);\n            ClassNode[] inferred = new ClassNode[classNode.getGenericsTypes().length];\n            for (int i = 0; i < classNode.getGenericsTypes().length; i++) {\n                GenericsType genericsType = classNode.getGenericsTypes()[i];\n                ClassNode value = createUsableClassNodeFromGenericsType(genericsType);\n                inferred[i] = value;\n            }\n            Parameter[] closureParams = expression.getParameters();\n            if (signature.length == closureParams.length // same number of arguments\n                    || (signature.length == 1 && closureParams.length == 0) // implicit it\n                    || (closureParams.length > signature.length && inferred[inferred.length - 1].isArray())) { // vargs\n                candidates.add(inferred);\n            }\n        }\n        Parameter[] closureParams = expression.getParameters();\n        if (candidates.size()>1) {\n            Iterator<ClassNode[]> candIt = candidates.iterator();\n            while (candIt.hasNext()) {\n                ClassNode[] inferred = candIt.next();\n                final int length = closureParams.length;\n                for (int i = 0; i < length; i++) {\n                    Parameter closureParam = closureParams[i];\n                    final ClassNode originType = closureParam.getOriginType();\n                    ClassNode inferredType;\n                    if (i<inferred.length-1 || inferred.length==closureParams.length) {\n                        inferredType = inferred[i];\n                    } else { // vargs?\n                        ClassNode lastArgInferred = inferred[inferred.length-1];\n                        if (lastArgInferred.isArray()) {\n                            inferredType = lastArgInferred.getComponentType();\n                        } else {\n                            candIt.remove();\n                            continue;\n                        }\n                    }\n                    if (!typeCheckMethodArgumentWithGenerics(originType, inferredType, i== length -1)) {\n                        candIt.remove();\n                    }\n                }\n            }\n            if (candidates.size()>1) {\n                addError(\"Ambiguous prototypes for closure. More than one target method matches. Please use explicit argument types.\", expression);\n            }\n        }\n        if (candidates.size()==1) {\n            ClassNode[] inferred = candidates.get(0);\n            if (closureParams.length==0 && inferred.length==1) {\n                expression.putNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS, inferred);\n            } else {\n                final int length = closureParams.length;\n                for (int i = 0; i < length; i++) {\n                    Parameter closureParam = closureParams[i];\n                    final ClassNode originType = closureParam.getOriginType();\n                    ClassNode inferredType = OBJECT_TYPE;\n                    if (i<inferred.length-1 || inferred.length==closureParams.length) {\n                        inferredType = inferred[i];\n                    } else { // vargs?\n                            ClassNode lastArgInferred = inferred[inferred.length-1];\n                            if (lastArgInferred.isArray()) {\n                                inferredType = lastArgInferred.getComponentType();\n                            } else {\n                                addError(\"Incorrect number of parameters. Expected \"+inferred.length+\" but found \"+closureParams.length, expression);\n                            }\n                    }\n                    if (!typeCheckMethodArgumentWithGenerics(originType, inferredType, i== length -1)) {\n                        addError(\"Expected parameter of type \"+ inferredType.toString(false)+\" but got \"+originType.toString(false), closureParam.getType());\n                    }\n                    typeCheckingContext.controlStructureVariables.put(closureParam, inferredType);\n                }\n            }\n        }\n    }",
            "2098  \n2099  \n2100  \n2101  \n2102  \n2103  \n2104  \n2105  \n2106  \n2107  \n2108  \n2109  \n2110  \n2111  \n2112  \n2113  \n2114  \n2115  \n2116  \n2117  \n2118  \n2119  \n2120  \n2121  \n2122  \n2123  \n2124  \n2125  \n2126  \n2127  \n2128  \n2129  \n2130  \n2131  \n2132  \n2133  \n2134  \n2135  \n2136  \n2137  \n2138  \n2139  \n2140  \n2141  \n2142  \n2143  \n2144  \n2145  \n2146  \n2147  \n2148  \n2149  \n2150  \n2151  \n2152  \n2153  \n2154  \n2155  \n2156  \n2157  \n2158  \n2159  \n2160  \n2161  \n2162  \n2163  \n2164  \n2165  \n2166  \n2167  \n2168  \n2169  \n2170  \n2171  \n2172  \n2173  \n2174  \n2175  \n2176  \n2177  \n2178  \n2179  \n2180  \n2181  \n2182  \n2183  \n2184  \n2185  \n2186  \n2187  \n2188  \n2189  \n2190  \n2191  \n2192  \n2193  \n2194  \n2195  \n2196  \n2197  \n2198  \n2199  \n2200  \n2201  \n2202  \n2203  \n2204  \n2205 +\n2206 +\n2207 +\n2208 +\n2209 +\n2210 +\n2211  \n2212  \n2213  \n2214  \n2215  \n2216  \n2217  ",
            "    private void doInferClosureParameterTypes(final ClassNode receiver, final Expression arguments, final ClosureExpression expression, final MethodNode selectedMethod, final Expression hintClass, final Expression options) {\n        List<ClassNode[]> closureSignatures = getSignaturesFromHint(expression,selectedMethod,hintClass,options);\n        List<ClassNode[]> candidates = new LinkedList<ClassNode[]>();\n        for (ClassNode[] signature : closureSignatures) {\n            // in order to compute the inferred types of the closure parameters, we're using the following trick:\n            // 1. create a dummy MethodNode for which the return type is a class node for which the generic types are the types returned by the hint\n            // 2. call inferReturnTypeGenerics\n            // 3. fetch inferred types from the result of inferReturnTypeGenerics\n            // In practice, it could be done differently but it has the main advantage of reusing\n            // existing code, hence reducing the amount of code to debug in case of failure.\n            final int id = System.identityHashCode(expression);\n            ClassNode dummyResultNode = new ClassNode(\"cl$\" + id, 0, OBJECT_TYPE).getPlainNodeReference();\n            final GenericsType[] genericTypes = new GenericsType[signature.length];\n            for (int i = 0; i < signature.length; i++) {\n                genericTypes[i] = new GenericsType(signature[i]);\n            }\n            dummyResultNode.setGenericsTypes(genericTypes);\n            MethodNode dummyMN = selectedMethod instanceof ExtensionMethodNode ? ((ExtensionMethodNode) selectedMethod).getExtensionMethodNode() : selectedMethod;\n            dummyMN = new MethodNode(\n                    dummyMN.getName(),\n                    dummyMN.getModifiers(),\n                    dummyResultNode,\n                    dummyMN.getParameters(),\n                    dummyMN.getExceptions(),\n                    EmptyStatement.INSTANCE\n                    );\n            dummyMN.setDeclaringClass(selectedMethod.getDeclaringClass());\n            dummyMN.setGenericsTypes(selectedMethod.getGenericsTypes());\n            if (selectedMethod instanceof ExtensionMethodNode) {\n                ExtensionMethodNode orig = (ExtensionMethodNode) selectedMethod;\n                dummyMN = new ExtensionMethodNode(\n                        dummyMN,\n                        dummyMN.getName(),\n                        dummyMN.getModifiers(),\n                        dummyResultNode,\n                        orig.getParameters(),\n                        orig.getExceptions(),\n                        EmptyStatement.INSTANCE,\n                        orig.isStaticExtension()\n                        );\n                dummyMN.setDeclaringClass(orig.getDeclaringClass());\n                dummyMN.setGenericsTypes(orig.getGenericsTypes());\n            }\n            ClassNode classNode = inferReturnTypeGenerics(receiver, dummyMN, arguments);\n            ClassNode[] inferred = new ClassNode[classNode.getGenericsTypes().length];\n            for (int i = 0; i < classNode.getGenericsTypes().length; i++) {\n                GenericsType genericsType = classNode.getGenericsTypes()[i];\n                ClassNode value = createUsableClassNodeFromGenericsType(genericsType);\n                inferred[i] = value;\n            }\n            Parameter[] closureParams = expression.getParameters();\n            if (signature.length == closureParams.length // same number of arguments\n                    || (signature.length == 1 && closureParams.length == 0) // implicit it\n                    || (closureParams.length > signature.length && inferred[inferred.length - 1].isArray())) { // vargs\n                candidates.add(inferred);\n            }\n        }\n        Parameter[] closureParams = expression.getParameters();\n        if (candidates.size()>1) {\n            Iterator<ClassNode[]> candIt = candidates.iterator();\n            while (candIt.hasNext()) {\n                ClassNode[] inferred = candIt.next();\n                final int length = closureParams.length;\n                for (int i = 0; i < length; i++) {\n                    Parameter closureParam = closureParams[i];\n                    final ClassNode originType = closureParam.getOriginType();\n                    ClassNode inferredType;\n                    if (i<inferred.length-1 || inferred.length==closureParams.length) {\n                        inferredType = inferred[i];\n                    } else { // vargs?\n                        ClassNode lastArgInferred = inferred[inferred.length-1];\n                        if (lastArgInferred.isArray()) {\n                            inferredType = lastArgInferred.getComponentType();\n                        } else {\n                            candIt.remove();\n                            continue;\n                        }\n                    }\n                    if (!typeCheckMethodArgumentWithGenerics(originType, inferredType, i== length -1)) {\n                        candIt.remove();\n                    }\n                }\n            }\n            if (candidates.size()>1) {\n                addError(\"Ambiguous prototypes for closure. More than one target method matches. Please use explicit argument types.\", expression);\n            }\n        }\n        if (candidates.size()==1) {\n            ClassNode[] inferred = candidates.get(0);\n            if (closureParams.length==0 && inferred.length==1) {\n                expression.putNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS, inferred);\n            } else {\n                final int length = closureParams.length;\n                for (int i = 0; i < length; i++) {\n                    Parameter closureParam = closureParams[i];\n                    final ClassNode originType = closureParam.getOriginType();\n                    ClassNode inferredType = OBJECT_TYPE;\n                    if (i<inferred.length-1 || inferred.length==closureParams.length) {\n                        inferredType = inferred[i];\n                    } else { // vargs?\n                            ClassNode lastArgInferred = inferred[inferred.length-1];\n                            if (lastArgInferred.isArray()) {\n                                inferredType = lastArgInferred.getComponentType();\n                            } else {\n                                addError(\"Incorrect number of parameters. Expected \"+inferred.length+\" but found \"+closureParams.length, expression);\n                            }\n                    }\n                    boolean lastArg = i == length - 1;\n                    if (lastArg && inferredType.isArray()) {\n                        if (inferredType.getComponentType().equals(originType)) {\n                            inferredType = originType;\n                        }\n                    } else if (!typeCheckMethodArgumentWithGenerics(originType, inferredType, lastArg)) {\n                        addError(\"Expected parameter of type \"+ inferredType.toString(false)+\" but got \"+originType.toString(false), closureParam.getType());\n                    }\n                    typeCheckingContext.controlStructureVariables.put(closureParam, inferredType);\n                }\n            }\n        }\n    }"
        ]
    ],
    "ab0c1a46dcac49b07519e99857ca07a2b72af9bb": [
        [
            "StaticTypeCheckingVisitor::existsProperty(PropertyExpression,boolean,ClassCodeVisitorSupport)",
            " 946  \n 947  \n 948  \n 949  \n 950  \n 951  \n 952  \n 953  \n 954  \n 955  \n 956  \n 957  \n 958  \n 959  \n 960  \n 961  \n 962  \n 963  \n 964  \n 965  \n 966  \n 967  \n 968  \n 969  \n 970  \n 971  \n 972  \n 973  \n 974  \n 975  \n 976  \n 977  \n 978  \n 979  \n 980  \n 981  \n 982  \n 983  \n 984  \n 985  \n 986  \n 987  \n 988  \n 989  \n 990  \n 991  \n 992  \n 993  \n 994  \n 995  \n 996  \n 997  \n 998  \n 999  \n1000  \n1001  \n1002  \n1003  \n1004  \n1005  \n1006  \n1007  \n1008  \n1009  \n1010  \n1011  \n1012  \n1013  \n1014  \n1015  \n1016  \n1017  \n1018  \n1019  \n1020  \n1021  \n1022  \n1023  \n1024  \n1025  \n1026  \n1027  \n1028  \n1029  \n1030  \n1031  \n1032  \n1033  \n1034  \n1035  \n1036  \n1037  \n1038  \n1039  \n1040  \n1041  \n1042  \n1043  \n1044  \n1045  \n1046  \n1047  \n1048  \n1049  \n1050  \n1051  \n1052  \n1053  \n1054  \n1055  \n1056  \n1057  \n1058  \n1059  \n1060  \n1061  \n1062  \n1063  \n1064  \n1065  \n1066  \n1067  \n1068  \n1069  \n1070  \n1071  \n1072  \n1073  \n1074  \n1075  \n1076  \n1077  \n1078  \n1079  \n1080  \n1081  \n1082  \n1083  \n1084  \n1085  \n1086  \n1087  \n1088  \n1089  \n1090  \n1091  \n1092  \n1093  \n1094  \n1095  \n1096  \n1097  \n1098  \n1099  ",
            "    /**\n     * Checks whether a property exists on the receiver, or on any of the possible receiver classes (found in the\n     * temporary type information table)\n     *\n     * @param pexp             a property expression\n     * @param readMode         if true, look for property read, else for property set\n     * @param visitor          if not null, when the property node is found, visit it with the provided visitor\n     * @return true if the property is defined in any of the possible receiver classes\n     */\n    protected boolean existsProperty(final PropertyExpression pexp, final boolean readMode, final ClassCodeVisitorSupport visitor) {\n        super.visitPropertyExpression(pexp);\n\n        String propertyName = pexp.getPropertyAsString();\n        if (propertyName == null) return false;\n\n        Expression objectExpression = pexp.getObjectExpression();\n        final ClassNode objectExpressionType = getType(objectExpression);\n\n        boolean staticOnlyAccess = isClassClassNodeWrappingConcreteType(objectExpressionType);\n        if (objectExpressionType.isArray() && \"length\".equals(pexp.getPropertyAsString())) {\n            storeType(pexp, int_TYPE);\n            if (visitor != null) {\n                PropertyNode node = new PropertyNode(\"length\", Opcodes.ACC_PUBLIC | Opcodes.ACC_FINAL, int_TYPE, objectExpressionType, null, null, null);\n                visitor.visitProperty(node);\n            }\n            return true;\n        }\n\n        boolean foundGetterOrSetter = false;\n        List<Receiver<String>> receivers = new LinkedList<Receiver<String>>();\n        List<Receiver<String>> owners = makeOwnerList(objectExpression);\n        addReceivers(receivers, owners, pexp.isImplicitThis());\n\n        String capName = MetaClassHelper.capitalize(propertyName);\n        boolean isAttributeExpression = pexp instanceof AttributeExpression;\n        HashSet<ClassNode> handledNodes = new HashSet<ClassNode>();\n        for (Receiver<String> receiver : receivers) {\n            ClassNode testClass = receiver.getType();\n                LinkedList<ClassNode> queue = new LinkedList<ClassNode>();\n                queue.add(testClass);\n                while (!queue.isEmpty()) {\n                    ClassNode current = queue.removeFirst();\n                    if (handledNodes.contains(current)) continue;\n                    handledNodes.add(current);\n                    Set<ClassNode> allInterfaces = current.getAllInterfaces();\n                    for (ClassNode intf : allInterfaces) {\n                        //TODO: apply right generics here!\n                        queue.add(GenericsUtils.parameterizeType(current, intf));\n                    }\n\n                    // in case of a lookup on Class we look for instance methods on Class\n                    // as well, since in case of a static property access we have the class\n                    // itself in the list of receivers already;\n                    boolean staticOnly;\n                    if (isClassClassNodeWrappingConcreteType(current)) {\n                        staticOnly = false;\n                    } else {\n                        staticOnly = staticOnlyAccess;\n                    }\n\n                    FieldNode field = current.getDeclaredField(propertyName);\n                    field  = allowStaticAccessToMember(field, staticOnly);\n                    if (storeField(field, isAttributeExpression, pexp, current, visitor, receiver.getData())) return true;\n\n                    PropertyNode propertyNode = current.getProperty(propertyName);\n                    propertyNode = allowStaticAccessToMember(propertyNode, staticOnly);\n                    if (storeProperty(propertyNode, pexp, current, visitor, receiver.getData())) return true;\n\n                    boolean isThisExpression = objectExpression instanceof VariableExpression && \n                                                ((VariableExpression)objectExpression).isThisExpression();\n                    if (storeField(field, isThisExpression, pexp, receiver.getType(), visitor, receiver.getData())) return true;\n\n                    MethodNode getter = current.getGetterMethod(\"get\" + capName);\n                    getter = allowStaticAccessToMember(getter, staticOnly);\n                    if (getter == null) getter = current.getGetterMethod(\"is\" + capName);\n                    getter = allowStaticAccessToMember(getter, staticOnly);\n                    MethodNode setter = current.getSetterMethod(\"set\" + capName, false);\n                    setter = allowStaticAccessToMember(setter, staticOnly);\n\n                    // TODO: remove this visit\n                    // need to visit even if we only look for a setter for compatibility\n                    if (visitor != null && getter!=null) visitor.visitMethod(getter);\n\n                    if (readMode) {\n                        if (getter!=null) {\n                            ClassNode cn = inferReturnTypeGenerics(current, getter, ArgumentListExpression.EMPTY_ARGUMENTS);\n                            storeInferredTypeForPropertyExpression(pexp, cn);\n                            pexp.removeNodeMetaData(StaticTypesMarker.READONLY_PROPERTY);\n                            String delegationData = receiver.getData();\n                            if (delegationData!=null) pexp.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER, delegationData);\n                            return true;\n                        }\n                    } else {\n                        if (setter != null) {\n                            // TODO: remove this visit\n                            // need to visit even if we only look for a setter for compatibility\n                            if (visitor != null && field!=null) visitor.visitField(field);\n\n                            //TODO: apply generics on parameter[0]? \n                            storeType(pexp, setter.getParameters()[0].getType());\n                            SetterInfo info = new SetterInfo(current, setter);\n                            BinaryExpression enclosingBinaryExpression = typeCheckingContext.getEnclosingBinaryExpression();\n                            if (enclosingBinaryExpression!=null) putSetterInfo(enclosingBinaryExpression.getLeftExpression(), info);\n                            String delegationData = receiver.getData();\n                            if (delegationData!=null) pexp.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER, delegationData);\n                            return true;\n                        } else if (getter!=null) {\n                            pexp.putNodeMetaData(StaticTypesMarker.READONLY_PROPERTY, true);\n                        }\n                    }\n                    foundGetterOrSetter = foundGetterOrSetter || setter!=null || getter!=null;\n\n                    if (storeField(field, true, pexp, current, visitor, receiver.getData())) return true;\n                    // if the property expression is an attribute expression (o.@attr), then\n                    // we stop now, otherwise we must check the parent class\n                    if (/*!isAttributeExpression && */current.getSuperClass() != null) {\n                        queue.add(current.getUnresolvedSuperClass());\n                    }\n                }\n                // GROOVY-5568, the property may be defined by DGM\n                List<MethodNode> methods = findDGMMethodsByNameAndArguments(getTransformLoader(), testClass, \"get\" + capName, ClassNode.EMPTY_ARRAY);\n                if (!methods.isEmpty()) {\n                    List<MethodNode> methodNodes = chooseBestMethod(testClass, methods, ClassNode.EMPTY_ARRAY);\n                    if (methodNodes.size() == 1) {\n                        MethodNode getter = methodNodes.get(0);\n                        if (visitor != null) {\n                            visitor.visitMethod(getter);\n                        }\n                        ClassNode cn = inferReturnTypeGenerics(testClass, getter, ArgumentListExpression.EMPTY_ARGUMENTS);\n                        storeInferredTypeForPropertyExpression(pexp, cn);\n\n                        return true;\n                    }\n                }\n        }\n\n        for (Receiver<String> receiver : receivers) {\n            ClassNode testClass = receiver.getType();\n            ClassNode propertyType = getTypeForMapPropertyExpression(testClass, objectExpressionType, pexp);\n            if (propertyType==null) propertyType = getTypeForListPropertyExpression(testClass, objectExpressionType, pexp);\n            if (propertyType==null) propertyType = getTypeForSpreadExpression(testClass, objectExpressionType, pexp);\n            if (propertyType==null) continue;\n            if (visitor!=null) {\n                // todo : type inference on maps and lists, if possible\n                PropertyNode node = new PropertyNode(propertyName, Opcodes.ACC_PUBLIC, propertyType, objectExpressionType, null, null, null);\n                visitor.visitProperty(node);\n            }\n            storeType(pexp, propertyType);\n            String delegationData = receiver.getData();\n            if (delegationData!=null) pexp.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER, delegationData);\n            return true;\n        }\n        return foundGetterOrSetter;\n    }",
            " 946  \n 947  \n 948  \n 949  \n 950  \n 951  \n 952  \n 953  \n 954  \n 955  \n 956  \n 957  \n 958  \n 959  \n 960  \n 961  \n 962  \n 963  \n 964  \n 965 +\n 966 +\n 967 +\n 968 +\n 969 +\n 970 +\n 971 +\n 972 +\n 973 +\n 974 +\n 975 +\n 976 +\n 977 +\n 978  \n 979  \n 980  \n 981  \n 982  \n 983  \n 984  \n 985  \n 986  \n 987  \n 988  \n 989  \n 990  \n 991  \n 992  \n 993  \n 994  \n 995  \n 996  \n 997  \n 998  \n 999  \n1000  \n1001  \n1002  \n1003  \n1004  \n1005  \n1006  \n1007  \n1008  \n1009  \n1010  \n1011  \n1012  \n1013  \n1014  \n1015  \n1016  \n1017  \n1018  \n1019  \n1020  \n1021  \n1022  \n1023  \n1024  \n1025  \n1026  \n1027  \n1028  \n1029  \n1030  \n1031  \n1032  \n1033  \n1034  \n1035  \n1036  \n1037  \n1038  \n1039  \n1040  \n1041  \n1042  \n1043  \n1044  \n1045  \n1046  \n1047  \n1048  \n1049  \n1050  \n1051  \n1052  \n1053  \n1054  \n1055  \n1056  \n1057  \n1058  \n1059  \n1060  \n1061  \n1062  \n1063  \n1064  \n1065  \n1066  \n1067  \n1068  \n1069  \n1070  \n1071  \n1072  \n1073  \n1074  \n1075  \n1076  \n1077  \n1078  \n1079  \n1080  \n1081  \n1082  \n1083  \n1084  \n1085  \n1086  \n1087  \n1088  \n1089  \n1090  \n1091  \n1092  \n1093  \n1094  \n1095  \n1096  \n1097  \n1098  \n1099  \n1100  \n1101  \n1102  \n1103  \n1104  \n1105  \n1106  \n1107  \n1108  \n1109  \n1110  \n1111  \n1112  ",
            "    /**\n     * Checks whether a property exists on the receiver, or on any of the possible receiver classes (found in the\n     * temporary type information table)\n     *\n     * @param pexp             a property expression\n     * @param readMode         if true, look for property read, else for property set\n     * @param visitor          if not null, when the property node is found, visit it with the provided visitor\n     * @return true if the property is defined in any of the possible receiver classes\n     */\n    protected boolean existsProperty(final PropertyExpression pexp, final boolean readMode, final ClassCodeVisitorSupport visitor) {\n        super.visitPropertyExpression(pexp);\n\n        String propertyName = pexp.getPropertyAsString();\n        if (propertyName == null) return false;\n\n        Expression objectExpression = pexp.getObjectExpression();\n        final ClassNode objectExpressionType = getType(objectExpression);\n\n        boolean staticOnlyAccess = isClassClassNodeWrappingConcreteType(objectExpressionType);\n        if (\"this\".equals(propertyName) && staticOnlyAccess) {\n            // Outer.this\n            ClassNode outerNode = objectExpressionType.getGenericsTypes()[0].getType();\n            ClassNode current = typeCheckingContext.getEnclosingClassNode();\n            if (!current.isStaticClass() && current instanceof InnerClassNode) {\n                InnerClassNode icn = (InnerClassNode) current;\n                if (outerNode.equals(icn.getOuterClass())) {\n                    storeType(pexp, outerNode);\n                    return true;\n                }\n            }\n        }\n\n        if (objectExpressionType.isArray() && \"length\".equals(pexp.getPropertyAsString())) {\n            storeType(pexp, int_TYPE);\n            if (visitor != null) {\n                PropertyNode node = new PropertyNode(\"length\", Opcodes.ACC_PUBLIC | Opcodes.ACC_FINAL, int_TYPE, objectExpressionType, null, null, null);\n                visitor.visitProperty(node);\n            }\n            return true;\n        }\n\n        boolean foundGetterOrSetter = false;\n        List<Receiver<String>> receivers = new LinkedList<Receiver<String>>();\n        List<Receiver<String>> owners = makeOwnerList(objectExpression);\n        addReceivers(receivers, owners, pexp.isImplicitThis());\n\n        String capName = MetaClassHelper.capitalize(propertyName);\n        boolean isAttributeExpression = pexp instanceof AttributeExpression;\n        HashSet<ClassNode> handledNodes = new HashSet<ClassNode>();\n        for (Receiver<String> receiver : receivers) {\n            ClassNode testClass = receiver.getType();\n                LinkedList<ClassNode> queue = new LinkedList<ClassNode>();\n                queue.add(testClass);\n                while (!queue.isEmpty()) {\n                    ClassNode current = queue.removeFirst();\n                    if (handledNodes.contains(current)) continue;\n                    handledNodes.add(current);\n                    Set<ClassNode> allInterfaces = current.getAllInterfaces();\n                    for (ClassNode intf : allInterfaces) {\n                        //TODO: apply right generics here!\n                        queue.add(GenericsUtils.parameterizeType(current, intf));\n                    }\n\n                    // in case of a lookup on Class we look for instance methods on Class\n                    // as well, since in case of a static property access we have the class\n                    // itself in the list of receivers already;\n                    boolean staticOnly;\n                    if (isClassClassNodeWrappingConcreteType(current)) {\n                        staticOnly = false;\n                    } else {\n                        staticOnly = staticOnlyAccess;\n                    }\n\n                    FieldNode field = current.getDeclaredField(propertyName);\n                    field  = allowStaticAccessToMember(field, staticOnly);\n                    if (storeField(field, isAttributeExpression, pexp, current, visitor, receiver.getData())) return true;\n\n                    PropertyNode propertyNode = current.getProperty(propertyName);\n                    propertyNode = allowStaticAccessToMember(propertyNode, staticOnly);\n                    if (storeProperty(propertyNode, pexp, current, visitor, receiver.getData())) return true;\n\n                    boolean isThisExpression = objectExpression instanceof VariableExpression && \n                                                ((VariableExpression)objectExpression).isThisExpression();\n                    if (storeField(field, isThisExpression, pexp, receiver.getType(), visitor, receiver.getData())) return true;\n\n                    MethodNode getter = current.getGetterMethod(\"get\" + capName);\n                    getter = allowStaticAccessToMember(getter, staticOnly);\n                    if (getter == null) getter = current.getGetterMethod(\"is\" + capName);\n                    getter = allowStaticAccessToMember(getter, staticOnly);\n                    MethodNode setter = current.getSetterMethod(\"set\" + capName, false);\n                    setter = allowStaticAccessToMember(setter, staticOnly);\n\n                    // TODO: remove this visit\n                    // need to visit even if we only look for a setter for compatibility\n                    if (visitor != null && getter!=null) visitor.visitMethod(getter);\n\n                    if (readMode) {\n                        if (getter!=null) {\n                            ClassNode cn = inferReturnTypeGenerics(current, getter, ArgumentListExpression.EMPTY_ARGUMENTS);\n                            storeInferredTypeForPropertyExpression(pexp, cn);\n                            pexp.removeNodeMetaData(StaticTypesMarker.READONLY_PROPERTY);\n                            String delegationData = receiver.getData();\n                            if (delegationData!=null) pexp.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER, delegationData);\n                            return true;\n                        }\n                    } else {\n                        if (setter != null) {\n                            // TODO: remove this visit\n                            // need to visit even if we only look for a setter for compatibility\n                            if (visitor != null && field!=null) visitor.visitField(field);\n\n                            //TODO: apply generics on parameter[0]? \n                            storeType(pexp, setter.getParameters()[0].getType());\n                            SetterInfo info = new SetterInfo(current, setter);\n                            BinaryExpression enclosingBinaryExpression = typeCheckingContext.getEnclosingBinaryExpression();\n                            if (enclosingBinaryExpression!=null) putSetterInfo(enclosingBinaryExpression.getLeftExpression(), info);\n                            String delegationData = receiver.getData();\n                            if (delegationData!=null) pexp.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER, delegationData);\n                            return true;\n                        } else if (getter!=null) {\n                            pexp.putNodeMetaData(StaticTypesMarker.READONLY_PROPERTY, true);\n                        }\n                    }\n                    foundGetterOrSetter = foundGetterOrSetter || setter!=null || getter!=null;\n\n                    if (storeField(field, true, pexp, current, visitor, receiver.getData())) return true;\n                    // if the property expression is an attribute expression (o.@attr), then\n                    // we stop now, otherwise we must check the parent class\n                    if (/*!isAttributeExpression && */current.getSuperClass() != null) {\n                        queue.add(current.getUnresolvedSuperClass());\n                    }\n                }\n                // GROOVY-5568, the property may be defined by DGM\n                List<MethodNode> methods = findDGMMethodsByNameAndArguments(getTransformLoader(), testClass, \"get\" + capName, ClassNode.EMPTY_ARRAY);\n                if (!methods.isEmpty()) {\n                    List<MethodNode> methodNodes = chooseBestMethod(testClass, methods, ClassNode.EMPTY_ARRAY);\n                    if (methodNodes.size() == 1) {\n                        MethodNode getter = methodNodes.get(0);\n                        if (visitor != null) {\n                            visitor.visitMethod(getter);\n                        }\n                        ClassNode cn = inferReturnTypeGenerics(testClass, getter, ArgumentListExpression.EMPTY_ARGUMENTS);\n                        storeInferredTypeForPropertyExpression(pexp, cn);\n\n                        return true;\n                    }\n                }\n        }\n\n        for (Receiver<String> receiver : receivers) {\n            ClassNode testClass = receiver.getType();\n            ClassNode propertyType = getTypeForMapPropertyExpression(testClass, objectExpressionType, pexp);\n            if (propertyType==null) propertyType = getTypeForListPropertyExpression(testClass, objectExpressionType, pexp);\n            if (propertyType==null) propertyType = getTypeForSpreadExpression(testClass, objectExpressionType, pexp);\n            if (propertyType==null) continue;\n            if (visitor!=null) {\n                // todo : type inference on maps and lists, if possible\n                PropertyNode node = new PropertyNode(propertyName, Opcodes.ACC_PUBLIC, propertyType, objectExpressionType, null, null, null);\n                visitor.visitProperty(node);\n            }\n            storeType(pexp, propertyType);\n            String delegationData = receiver.getData();\n            if (delegationData!=null) pexp.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER, delegationData);\n            return true;\n        }\n        return foundGetterOrSetter;\n    }"
        ]
    ],
    "36a5a8dfdd4827663961cbca6b5dce2cc0a918b6": [
        [
            "DefaultStrategy::buildMethod(BuilderASTTransformation,MethodNode,AnnotationNode)",
            " 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177 -\n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  ",
            "    public void buildMethod(BuilderASTTransformation transform, MethodNode mNode, AnnotationNode anno) {\n        if (transform.getMemberValue(anno, \"includes\") != null || transform.getMemberValue(anno, \"includes\") != null) {\n            transform.addError(\"Error during \" + BuilderASTTransformation.MY_TYPE_NAME +\n                    \" processing: includes/excludes only allowed on classes\", anno);\n        }\n        String prefix = transform.getMemberStringValue(anno, \"prefix\", \"\");\n        if (unsupportedAttribute(transform, anno, \"forClass\")) return;\n        final int visibility = ACC_PUBLIC | ACC_STATIC | ACC_SYNTHETIC;\n        ClassNode buildee = mNode.getDeclaringClass();\n        String builderClassName = transform.getMemberStringValue(anno, \"builderClassName\", buildee.getName() + \"Builder\");\n        final String fullName = buildee.getName() + \"$\" + builderClassName;\n        ClassNode builder = new InnerClassNode(buildee, fullName, visibility, ClassHelper.OBJECT_TYPE);\n        buildee.getModule().addClass(builder);\n        buildee.addMethod(createBuilderMethod(transform, anno, builder));\n        for (Parameter parameter : mNode.getParameters()) {\n            builder.addField(createFieldCopy(buildee, parameter));\n            builder.addMethod(createBuilderMethodForProp(builder, new PropertyInfo(parameter.getName(), parameter.getType()), prefix));\n        }\n        builder.addMethod(createBuildMethodForMethod(transform, anno, buildee, mNode, mNode.getParameters()));\n    }",
            " 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176 +\n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  ",
            "    public void buildMethod(BuilderASTTransformation transform, MethodNode mNode, AnnotationNode anno) {\n        if (transform.getMemberValue(anno, \"includes\") != null || transform.getMemberValue(anno, \"includes\") != null) {\n            transform.addError(\"Error during \" + BuilderASTTransformation.MY_TYPE_NAME +\n                    \" processing: includes/excludes only allowed on classes\", anno);\n        }\n        String prefix = transform.getMemberStringValue(anno, \"prefix\", \"\");\n        if (unsupportedAttribute(transform, anno, \"forClass\")) return;\n        final int visibility = ACC_PUBLIC | ACC_STATIC;\n        ClassNode buildee = mNode.getDeclaringClass();\n        String builderClassName = transform.getMemberStringValue(anno, \"builderClassName\", buildee.getName() + \"Builder\");\n        final String fullName = buildee.getName() + \"$\" + builderClassName;\n        ClassNode builder = new InnerClassNode(buildee, fullName, visibility, ClassHelper.OBJECT_TYPE);\n        buildee.getModule().addClass(builder);\n        buildee.addMethod(createBuilderMethod(transform, anno, builder));\n        for (Parameter parameter : mNode.getParameters()) {\n            builder.addField(createFieldCopy(buildee, parameter));\n            builder.addMethod(createBuilderMethodForProp(builder, new PropertyInfo(parameter.getName(), parameter.getType()), prefix));\n        }\n        builder.addMethod(createBuildMethodForMethod(transform, anno, buildee, mNode, mNode.getParameters()));\n    }"
        ],
        [
            "InitializerStrategy::createBuilderMethod(BuilderASTTransformation,AnnotationNode,String,ClassNode,int)",
            " 161  \n 162  \n 163  \n 164  \n 165 -\n 166  \n 167  \n 168  ",
            "    private static MethodNode createBuilderMethod(BuilderASTTransformation transform, AnnotationNode anno, String buildMethodName, ClassNode builder, int numFields) {\n        String builderMethodName = transform.getMemberStringValue(anno, \"builderMethodName\", \"createInitializer\");\n        final BlockStatement body = new BlockStatement();\n        body.addStatement(returnS(callX(builder, buildMethodName)));\n        final int visibility = ACC_PUBLIC | ACC_STATIC | ACC_SYNTHETIC;\n        ClassNode returnType = makeClassSafeWithGenerics(builder, unsetGenTypes(numFields));\n        return new MethodNode(builderMethodName, visibility, returnType, NO_PARAMS, NO_EXCEPTIONS, body);\n    }",
            " 162  \n 163  \n 164  \n 165  \n 166 +\n 167  \n 168  \n 169  ",
            "    private static MethodNode createBuilderMethod(BuilderASTTransformation transform, AnnotationNode anno, String buildMethodName, ClassNode builder, int numFields) {\n        String builderMethodName = transform.getMemberStringValue(anno, \"builderMethodName\", \"createInitializer\");\n        final BlockStatement body = new BlockStatement();\n        body.addStatement(returnS(callX(builder, buildMethodName)));\n        final int visibility = ACC_PUBLIC | ACC_STATIC;\n        ClassNode returnType = makeClassSafeWithGenerics(builder, unsetGenTypes(numFields));\n        return new MethodNode(builderMethodName, visibility, returnType, NO_PARAMS, NO_EXCEPTIONS, body);\n    }"
        ],
        [
            "ImmutableASTTransformation::validateConstructors(ClassNode)",
            " 415  \n 416  \n 417  \n 418 -\n 419 -\n 420  \n 421  \n 422  \n 423  \n 424  \n 425  \n 426  \n 427  ",
            "    private boolean validateConstructors(ClassNode cNode) {\n        List<ConstructorNode> declaredConstructors = cNode.getDeclaredConstructors();\n        for (ConstructorNode constructorNode : declaredConstructors) {\n            // allow Synthetic constructors added by other transforms\n            if ((constructorNode.getModifiers() & ACC_SYNTHETIC) != 0) {\n                continue;\n            }\n            // TODO: allow constructors which only call provided constructor?\n            addError(\"Explicit constructors not allowed for \" + MY_TYPE_NAME + \" class: \" + cNode.getNameWithoutPackage(), constructorNode);\n            return false;\n        }\n        return true;\n    }",
            " 416  \n 417  \n 418  \n 419 +\n 420 +\n 421 +\n 422  \n 423  \n 424  \n 425  \n 426  \n 427  \n 428  \n 429  ",
            "    private boolean validateConstructors(ClassNode cNode) {\n        List<ConstructorNode> declaredConstructors = cNode.getDeclaredConstructors();\n        for (ConstructorNode constructorNode : declaredConstructors) {\n            // allow constructors added by other transforms if flagged as safe\n            Object nodeMetaData = constructorNode.getNodeMetaData(IMMUTABLE_SAFE_FLAG);\n            if (nodeMetaData != null && ((Boolean)nodeMetaData)) {\n                continue;\n            }\n            // TODO: allow constructors which only call provided constructor?\n            addError(\"Explicit constructors not allowed for \" + MY_TYPE_NAME + \" class: \" + cNode.getNameWithoutPackage(), constructorNode);\n            return false;\n        }\n        return true;\n    }"
        ],
        [
            "InitializerStrategy::createBuildeeConstructors(BuilderASTTransformation,ClassNode,ClassNode,List)",
            " 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201 -\n 202 -\n 203  \n 204  \n 205  \n 206  \n 207  \n 208  ",
            "    private static void createBuildeeConstructors(BuilderASTTransformation transform, ClassNode buildee, ClassNode builder, List<FieldNode> fields) {\n        ClassNode paramType = makeClassSafeWithGenerics(builder, setGenTypes(fields.size()));\n        List<Expression> argsList = new ArrayList<Expression>();\n        for (FieldNode fieldNode : fields) {\n            argsList.add(propX(varX(\"initializer\"), fieldNode.getName()));\n        }\n        Expression args = new ArgumentListExpression(argsList);\n        buildee.addConstructor(ACC_PUBLIC | ACC_SYNTHETIC, params(param(paramType, \"initializer\")), NO_EXCEPTIONS, block(ctorThisS(args)));\n        if (!transform.hasAnnotation(buildee, ImmutableASTTransformation.MY_TYPE)) {\n            final BlockStatement body = new BlockStatement();\n            body.addStatement(ctorSuperS());\n            initializeFields(fields, body);\n            buildee.addConstructor(ACC_PRIVATE | ACC_SYNTHETIC, getParams(fields), NO_EXCEPTIONS, body);\n        }\n    }",
            " 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202 +\n 203 +\n 204 +\n 205 +\n 206  \n 207  \n 208  \n 209  \n 210  \n 211  ",
            "    private static void createBuildeeConstructors(BuilderASTTransformation transform, ClassNode buildee, ClassNode builder, List<FieldNode> fields) {\n        ClassNode paramType = makeClassSafeWithGenerics(builder, setGenTypes(fields.size()));\n        List<Expression> argsList = new ArrayList<Expression>();\n        for (FieldNode fieldNode : fields) {\n            argsList.add(propX(varX(\"initializer\"), fieldNode.getName()));\n        }\n        Expression args = new ArgumentListExpression(argsList);\n        ConstructorNode initializer = buildee.addConstructor(ACC_PUBLIC, params(param(paramType, \"initializer\")), NO_EXCEPTIONS, block(ctorThisS(args)));\n        if (transform.hasAnnotation(buildee, ImmutableASTTransformation.MY_TYPE)) {\n            initializer.putNodeMetaData(ImmutableASTTransformation.IMMUTABLE_SAFE_FLAG, Boolean.TRUE);\n        } else {\n            final BlockStatement body = new BlockStatement();\n            body.addStatement(ctorSuperS());\n            initializeFields(fields, body);\n            buildee.addConstructor(ACC_PRIVATE | ACC_SYNTHETIC, getParams(fields), NO_EXCEPTIONS, body);\n        }\n    }"
        ],
        [
            "DefaultStrategy::buildClass(BuilderASTTransformation,ClassNode,AnnotationNode)",
            " 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197 -\n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  ",
            "    public void buildClass(BuilderASTTransformation transform, ClassNode buildee, AnnotationNode anno) {\n        List<String> excludes = new ArrayList<String>();\n        List<String> includes = new ArrayList<String>();\n        if (!getIncludeExclude(transform, anno, buildee, excludes, includes)) return;\n        String prefix = transform.getMemberStringValue(anno, \"prefix\", \"\");\n        if (unsupportedAttribute(transform, anno, \"forClass\")) return;\n        final int visibility = ACC_PUBLIC | ACC_STATIC | ACC_SYNTHETIC;\n        String builderClassName = transform.getMemberStringValue(anno, \"builderClassName\", buildee.getName() + \"Builder\");\n        final String fullName = buildee.getName() + \"$\" + builderClassName;\n        ClassNode builder = new InnerClassNode(buildee, fullName, visibility, ClassHelper.OBJECT_TYPE);\n        buildee.getModule().addClass(builder);\n        buildee.addMethod(createBuilderMethod(transform, anno, builder));\n        List<FieldNode> fields = getInstancePropertyFields(buildee);\n        List<FieldNode> filteredFields = selectFieldsFromExistingClass(fields, includes, excludes);\n        for (FieldNode fieldNode : filteredFields) {\n            builder.addField(createFieldCopy(buildee, fieldNode));\n            builder.addMethod(createBuilderMethodForProp(builder, new PropertyInfo(fieldNode.getName(), fieldNode.getType()), prefix));\n        }\n        builder.addMethod(createBuildMethod(transform, anno, buildee, filteredFields));\n    }",
            " 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196 +\n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  ",
            "    public void buildClass(BuilderASTTransformation transform, ClassNode buildee, AnnotationNode anno) {\n        List<String> excludes = new ArrayList<String>();\n        List<String> includes = new ArrayList<String>();\n        if (!getIncludeExclude(transform, anno, buildee, excludes, includes)) return;\n        String prefix = transform.getMemberStringValue(anno, \"prefix\", \"\");\n        if (unsupportedAttribute(transform, anno, \"forClass\")) return;\n        final int visibility = ACC_PUBLIC | ACC_STATIC;\n        String builderClassName = transform.getMemberStringValue(anno, \"builderClassName\", buildee.getName() + \"Builder\");\n        final String fullName = buildee.getName() + \"$\" + builderClassName;\n        ClassNode builder = new InnerClassNode(buildee, fullName, visibility, ClassHelper.OBJECT_TYPE);\n        buildee.getModule().addClass(builder);\n        buildee.addMethod(createBuilderMethod(transform, anno, builder));\n        List<FieldNode> fields = getInstancePropertyFields(buildee);\n        List<FieldNode> filteredFields = selectFieldsFromExistingClass(fields, includes, excludes);\n        for (FieldNode fieldNode : filteredFields) {\n            builder.addField(createFieldCopy(buildee, fieldNode));\n            builder.addMethod(createBuilderMethodForProp(builder, new PropertyInfo(fieldNode.getName(), fieldNode.getType()), prefix));\n        }\n        builder.addMethod(createBuildMethod(transform, anno, buildee, filteredFields));\n    }"
        ],
        [
            "InitializerStrategy::createInnerHelperClass(ClassNode,String,List)",
            " 149  \n 150  \n 151 -\n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  ",
            "    private ClassNode createInnerHelperClass(ClassNode buildee, String builderClassName, List<FieldNode> fields) {\n        final String fullName = buildee.getName() + \"$\" + builderClassName;\n        final int visibility = ACC_PUBLIC | ACC_STATIC | ACC_SYNTHETIC;\n        ClassNode builder = new InnerClassNode(buildee, fullName, visibility, ClassHelper.OBJECT_TYPE);\n        GenericsType[] gtypes = new GenericsType[fields.size()];\n        for (int i = 0; i < gtypes.length; i++) {\n            gtypes[i] = makePlaceholder(i);\n        }\n        builder.setGenericsTypes(gtypes);\n        return builder;\n    }",
            " 150  \n 151  \n 152 +\n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  ",
            "    private ClassNode createInnerHelperClass(ClassNode buildee, String builderClassName, List<FieldNode> fields) {\n        final String fullName = buildee.getName() + \"$\" + builderClassName;\n        final int visibility = ACC_PUBLIC | ACC_STATIC;\n        ClassNode builder = new InnerClassNode(buildee, fullName, visibility, ClassHelper.OBJECT_TYPE);\n        GenericsType[] gtypes = new GenericsType[fields.size()];\n        for (int i = 0; i < gtypes.length; i++) {\n            gtypes[i] = makePlaceholder(i);\n        }\n        builder.setGenericsTypes(gtypes);\n        return builder;\n    }"
        ],
        [
            "DefaultStrategy::createBuilderMethod(BuilderASTTransformation,AnnotationNode,ClassNode)",
            " 226  \n 227  \n 228  \n 229  \n 230 -\n 231  \n 232  ",
            "    private static MethodNode createBuilderMethod(BuilderASTTransformation transform, AnnotationNode anno, ClassNode builder) {\n        String builderMethodName = transform.getMemberStringValue(anno, \"builderMethodName\", \"builder\");\n        final BlockStatement body = new BlockStatement();\n        body.addStatement(returnS(ctorX(builder)));\n        final int visibility = ACC_PUBLIC | ACC_STATIC | ACC_SYNTHETIC;\n        return new MethodNode(builderMethodName, visibility, builder, NO_PARAMS, NO_EXCEPTIONS, body);\n    }",
            " 225  \n 226  \n 227  \n 228  \n 229 +\n 230  \n 231  ",
            "    private static MethodNode createBuilderMethod(BuilderASTTransformation transform, AnnotationNode anno, ClassNode builder) {\n        String builderMethodName = transform.getMemberStringValue(anno, \"builderMethodName\", \"builder\");\n        final BlockStatement body = new BlockStatement();\n        body.addStatement(returnS(ctorX(builder)));\n        final int visibility = ACC_PUBLIC | ACC_STATIC;\n        return new MethodNode(builderMethodName, visibility, builder, NO_PARAMS, NO_EXCEPTIONS, body);\n    }"
        ]
    ],
    "8827857771434e4eef4a9b8bf75a4bc4d7bc64e8": [
        [
            "CharScanner::parseDouble(char,int,int)",
            " 694  \n 695  \n 696  \n 697  \n 698  \n 699  \n 700  \n 701  \n 702  \n 703  \n 704  \n 705  \n 706  \n 707  \n 708  \n 709  \n 710  \n 711  \n 712  \n 713  \n 714  \n 715  \n 716  \n 717  \n 718  \n 719  \n 720  \n 721  \n 722  \n 723  \n 724  \n 725  \n 726  \n 727  \n 728  \n 729  \n 730  \n 731  \n 732  \n 733  \n 734  \n 735  \n 736  \n 737  \n 738  \n 739  \n 740  \n 741  \n 742  \n 743  \n 744  \n 745  \n 746  \n 747  \n 748  \n 749  \n 750  \n 751  \n 752  \n 753  ",
            "    public static double parseDouble(char[] buffer, int from, int to) {\n        double value;\n        boolean simple = true;\n        int digitsPastPoint = 0;\n\n        int index = from;\n\n        if (buffer[index] == '-') {\n            index++;\n        }\n\n        boolean foundDot = false;\n        for (; index < to; index++) {\n            char ch = buffer[index];\n            if (isNumberDigit(ch)) {\n                if (foundDot == true) {\n                    digitsPastPoint++;\n                }\n            } else if (ch == '.') {\n                foundDot = true;\n            } else if (ch == 'E' || ch == 'e' || ch == '-' || ch == '+') {\n                simple = false;\n            } else {\n                die(\"unexpected character \" + ch);\n            }\n        }\n\n        if (digitsPastPoint >= powersOf10.length - 1) {\n            simple = false;\n        }\n\n        final int length = index - from;\n\n        if (!foundDot && simple) {\n            if (isInteger(buffer, from, length)) {\n                value = parseIntFromTo(buffer, from, index);\n            } else {\n                value = parseLongFromTo(buffer, from, index);\n            }\n        } else if (foundDot && simple) {\n            long lvalue;\n\n            if (length < powersOf10.length) {\n                if (isInteger(buffer, from, length)) {\n                    lvalue = parseIntFromToIgnoreDot(buffer, from, index);\n                } else {\n                    lvalue = parseLongFromToIgnoreDot(buffer, from, index);\n                }\n\n                double power = powersOf10[digitsPastPoint];\n                value = lvalue / power;\n            } else {\n                value = Double.parseDouble(new String(buffer, from, length));\n            }\n        } else {\n            value = Double.parseDouble(new String(buffer, from, index - from));\n        }\n\n        return value;\n    }",
            " 697  \n 698  \n 699  \n 700  \n 701  \n 702  \n 703  \n 704  \n 705  \n 706  \n 707  \n 708  \n 709  \n 710  \n 711  \n 712  \n 713  \n 714  \n 715  \n 716 +\n 717 +\n 718 +\n 719  \n 720  \n 721  \n 722  \n 723  \n 724  \n 725  \n 726  \n 727  \n 728  \n 729  \n 730  \n 731  \n 732  \n 733  \n 734  \n 735  \n 736  \n 737  \n 738  \n 739  \n 740  \n 741  \n 742  \n 743  \n 744  \n 745  \n 746  \n 747  \n 748  \n 749  \n 750  \n 751  \n 752  \n 753  \n 754  \n 755  \n 756  \n 757  \n 758  \n 759  ",
            "    public static double parseDouble(char[] buffer, int from, int to) {\n        double value;\n        boolean simple = true;\n        int digitsPastPoint = 0;\n\n        int index = from;\n\n        if (buffer[index] == '-') {\n            index++;\n        }\n\n        boolean foundDot = false;\n        for (; index < to; index++) {\n            char ch = buffer[index];\n            if (isNumberDigit(ch)) {\n                if (foundDot == true) {\n                    digitsPastPoint++;\n                }\n            } else if (ch == '.') {\n                if (foundDot) {\n                    die(\"unexpected character \" + ch);\n                }\n                foundDot = true;\n            } else if (ch == 'E' || ch == 'e' || ch == '-' || ch == '+') {\n                simple = false;\n            } else {\n                die(\"unexpected character \" + ch);\n            }\n        }\n\n        if (digitsPastPoint >= powersOf10.length - 1) {\n            simple = false;\n        }\n\n        final int length = index - from;\n\n        if (!foundDot && simple) {\n            if (isInteger(buffer, from, length)) {\n                value = parseIntFromTo(buffer, from, index);\n            } else {\n                value = parseLongFromTo(buffer, from, index);\n            }\n        } else if (foundDot && simple) {\n            long lvalue;\n\n            if (length < powersOf10.length) {\n                if (isInteger(buffer, from, length)) {\n                    lvalue = parseIntFromToIgnoreDot(buffer, from, index);\n                } else {\n                    lvalue = parseLongFromToIgnoreDot(buffer, from, index);\n                }\n\n                double power = powersOf10[digitsPastPoint];\n                value = lvalue / power;\n            } else {\n                value = Double.parseDouble(new String(buffer, from, length));\n            }\n        } else {\n            value = Double.parseDouble(new String(buffer, from, index - from));\n        }\n\n        return value;\n    }"
        ],
        [
            "CharScanner::parseJsonNumber(char,int,int,int)",
            " 611  \n 612  \n 613  \n 614  \n 615  \n 616  \n 617  \n 618  \n 619  \n 620  \n 621  \n 622  \n 623  \n 624  \n 625  \n 626  \n 627  \n 628  \n 629  \n 630  \n 631  \n 632  \n 633  \n 634  \n 635  \n 636  \n 637  \n 638  \n 639  \n 640  \n 641  \n 642  \n 643  \n 644  \n 645  \n 646  \n 647  \n 648  \n 649  \n 650  \n 651  \n 652  \n 653  \n 654  \n 655  \n 656  \n 657  \n 658  \n 659  \n 660  \n 661  \n 662  \n 663  \n 664  \n 665  \n 666  \n 667  \n 668  \n 669  \n 670  \n 671  \n 672  \n 673  \n 674  \n 675  \n 676  ",
            "    public static Number parseJsonNumber(char[] buffer, int from, int max, int size[]) {\n        Number value = null;\n        boolean simple = true;\n        int digitsPastPoint = 0;\n\n        int index = from;\n\n        if (buffer[index] == '-') {\n            index++;\n        }\n\n        boolean foundDot = false;\n        for (; index < max; index++) {\n            char ch = buffer[index];\n            if (isNumberDigit(ch)) {\n                if (foundDot == true) {\n                    digitsPastPoint++;\n                }\n            } else if (ch <= 32 || isDelimiter(ch)) {\n                break;\n            } else if (ch == '.') {\n                foundDot = true;\n            } else if (ch == 'E' || ch == 'e' || ch == '-' || ch == '+') {\n                simple = false;\n            } else {\n                die(\"unexpected character \" + ch);\n            }\n        }\n\n        if (digitsPastPoint >= powersOf10.length - 1) {\n            simple = false;\n        }\n\n        final int length = index - from;\n\n        if (!foundDot && simple) {\n            if (isInteger(buffer, from, length)) {\n                value = parseIntFromTo(buffer, from, index);\n            } else {\n                value = parseLongFromTo(buffer, from, index);\n            }\n        } else if (foundDot && simple) {\n            BigDecimal lvalue;\n\n            if (length < powersOf10.length) {\n                if (isInteger(buffer, from, length)) {\n                    lvalue = new BigDecimal(parseIntFromToIgnoreDot(buffer, from, index));\n                } else {\n                    lvalue = new BigDecimal(parseLongFromToIgnoreDot(buffer, from, index));\n                }\n\n                BigDecimal power = new BigDecimal(powersOf10[digitsPastPoint]);\n                value = lvalue.divide(power);\n            } else {\n                value = new BigDecimal(new String(buffer, from, length));\n            }\n        } else {\n            value = new BigDecimal(new String(buffer, from, index - from));\n        }\n\n        if (size != null) {\n            size[0] = index;\n        }\n\n        return value;\n    }",
            " 611  \n 612  \n 613  \n 614  \n 615  \n 616  \n 617  \n 618  \n 619  \n 620  \n 621  \n 622  \n 623  \n 624  \n 625  \n 626  \n 627  \n 628  \n 629  \n 630  \n 631  \n 632 +\n 633 +\n 634 +\n 635  \n 636  \n 637  \n 638  \n 639  \n 640  \n 641  \n 642  \n 643  \n 644  \n 645  \n 646  \n 647  \n 648  \n 649  \n 650  \n 651  \n 652  \n 653  \n 654  \n 655  \n 656  \n 657  \n 658  \n 659  \n 660  \n 661  \n 662  \n 663  \n 664  \n 665  \n 666  \n 667  \n 668  \n 669  \n 670  \n 671  \n 672  \n 673  \n 674  \n 675  \n 676  \n 677  \n 678  \n 679  ",
            "    public static Number parseJsonNumber(char[] buffer, int from, int max, int size[]) {\n        Number value = null;\n        boolean simple = true;\n        int digitsPastPoint = 0;\n\n        int index = from;\n\n        if (buffer[index] == '-') {\n            index++;\n        }\n\n        boolean foundDot = false;\n        for (; index < max; index++) {\n            char ch = buffer[index];\n            if (isNumberDigit(ch)) {\n                if (foundDot == true) {\n                    digitsPastPoint++;\n                }\n            } else if (ch <= 32 || isDelimiter(ch)) {\n                break;\n            } else if (ch == '.') {\n                if (foundDot) {\n                    die(\"unexpected character \" + ch);\n                }\n                foundDot = true;\n            } else if (ch == 'E' || ch == 'e' || ch == '-' || ch == '+') {\n                simple = false;\n            } else {\n                die(\"unexpected character \" + ch);\n            }\n        }\n\n        if (digitsPastPoint >= powersOf10.length - 1) {\n            simple = false;\n        }\n\n        final int length = index - from;\n\n        if (!foundDot && simple) {\n            if (isInteger(buffer, from, length)) {\n                value = parseIntFromTo(buffer, from, index);\n            } else {\n                value = parseLongFromTo(buffer, from, index);\n            }\n        } else if (foundDot && simple) {\n            BigDecimal lvalue;\n\n            if (length < powersOf10.length) {\n                if (isInteger(buffer, from, length)) {\n                    lvalue = new BigDecimal(parseIntFromToIgnoreDot(buffer, from, index));\n                } else {\n                    lvalue = new BigDecimal(parseLongFromToIgnoreDot(buffer, from, index));\n                }\n\n                BigDecimal power = new BigDecimal(powersOf10[digitsPastPoint]);\n                value = lvalue.divide(power);\n            } else {\n                value = new BigDecimal(new String(buffer, from, length));\n            }\n        } else {\n            value = new BigDecimal(new String(buffer, from, index - from));\n        }\n\n        if (size != null) {\n            size[0] = index;\n        }\n\n        return value;\n    }"
        ],
        [
            "NumberValue::bigDecimalValue()",
            " 147  \n 148 -\n 149  ",
            "    public BigDecimal bigDecimalValue() {\n        return new BigDecimal(buffer, startIndex, endIndex - startIndex);\n    }",
            " 149  \n 150 +\n 151 +\n 152 +\n 153 +\n 154 +\n 155  ",
            "    public BigDecimal bigDecimalValue() {\n        try {\n            return new BigDecimal(buffer, startIndex, endIndex - startIndex);\n        } catch (NumberFormatException e) {\n            throw new JsonException(\"unable to parse \" + new String(buffer, startIndex, endIndex - startIndex), e);\n        }\n    }"
        ]
    ],
    "38c2a64c72e346e09cc9f9da7ceff5a65aa3da8e": [
        [
            "StaticTypeCheckingVisitor::checkOrMarkPrivateAccess(Expression,MethodNode)",
            " 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372 -\n 373 -\n 374 -\n 375  \n 376  \n 377  ",
            "    /**\n     * Given a method node, checks if we are calling a private method from an inner class.\n     */\n    private void checkOrMarkPrivateAccess(Expression source, MethodNode mn) {\n        if (mn==null) {\n            return;\n        }\n        ClassNode declaringClass = mn.getDeclaringClass();\n        ClassNode enclosingClassNode = typeCheckingContext.getEnclosingClassNode();\n        if (declaringClass != enclosingClassNode || typeCheckingContext.getEnclosingClosure() != null) {\n            int mods = mn.getModifiers();\n            boolean sameModule = declaringClass.getModule() == enclosingClassNode.getModule();\n            String packageName = declaringClass.getPackageName();\n            if (packageName==null) {\n                packageName = \"\";\n            }\n            if ((Modifier.isPrivate(mods) && sameModule)\n                    || (Modifier.isProtected(mods) && !packageName.equals(enclosingClassNode.getPackageName()))) {\n                addPrivateFieldOrMethodAccess(source, sameModule? declaringClass : enclosingClassNode, StaticTypesMarker.PV_METHODS_ACCESS, mn);\n            }\n        }\n    }",
            " 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372 +\n 373 +\n 374 +\n 375 +\n 376 +\n 377 +\n 378 +\n 379 +\n 380 +\n 381 +\n 382 +\n 383  \n 384  \n 385  ",
            "    /**\n     * Given a method node, checks if we are calling a private method from an inner class.\n     */\n    private void checkOrMarkPrivateAccess(Expression source, MethodNode mn) {\n        if (mn==null) {\n            return;\n        }\n        ClassNode declaringClass = mn.getDeclaringClass();\n        ClassNode enclosingClassNode = typeCheckingContext.getEnclosingClassNode();\n        if (declaringClass != enclosingClassNode || typeCheckingContext.getEnclosingClosure() != null) {\n            int mods = mn.getModifiers();\n            boolean sameModule = declaringClass.getModule() == enclosingClassNode.getModule();\n            String packageName = declaringClass.getPackageName();\n            if (packageName==null) {\n                packageName = \"\";\n            }\n            if ((Modifier.isPrivate(mods) && sameModule)) {\n                addPrivateFieldOrMethodAccess(source, declaringClass, StaticTypesMarker.PV_METHODS_ACCESS, mn);\n            } else if (Modifier.isProtected(mods) && !packageName.equals(enclosingClassNode.getPackageName())\n                    && !implementsInterfaceOrIsSubclassOf(enclosingClassNode, declaringClass)) {\n                ClassNode cn = enclosingClassNode;\n                while ((cn = cn.getOuterClass()) != null) {\n                    if (implementsInterfaceOrIsSubclassOf(cn, declaringClass)) {\n                        addPrivateFieldOrMethodAccess(source, cn, StaticTypesMarker.PV_METHODS_ACCESS, mn);\n                        break;\n                    }\n                }\n            }\n        }\n    }"
        ],
        [
            "StaticInvocationWriter::tryBridgeMethod(MethodNode,Expression,boolean,TupleExpression)",
            " 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180 -\n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190 -\n 191  \n 192 -\n 193 -\n 194 -\n 195 -\n 196 -\n 197 -\n 198 -\n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  ",
            "    /**\n     * Attempts to make a direct method call on a bridge method, if it exists.\n     */\n    protected boolean tryBridgeMethod(MethodNode target, Expression receiver, boolean implicitThis, TupleExpression args) {\n        ClassNode lookupClassNode;\n        if (target.isProtected()) {\n            lookupClassNode = controller.getClassNode();\n            if (controller.isInClosure()) {\n                lookupClassNode = lookupClassNode.getOuterClass();\n            }\n        } else {\n            lookupClassNode = target.getDeclaringClass().redirect();\n        }\n        Map<MethodNode, MethodNode> bridges = lookupClassNode.getNodeMetaData(PRIVATE_BRIDGE_METHODS);\n        MethodNode bridge = bridges==null?null:bridges.get(target);\n        if (bridge != null) {\n            Expression fixedReceiver = receiver;\n            ClassNode declaringClass = bridge.getDeclaringClass();\n            if (implicitThis && !controller.isInClosure()) {\n                ClassNode classNode = controller.getClassNode();\n                while (!classNode.isDerivedFrom(declaringClass)\n                        && !classNode.implementsInterface(declaringClass)\n                        && classNode instanceof InnerClassNode) {\n                    classNode = classNode.getOuterClass();\n                }\n                fixedReceiver = new PropertyExpression(new ClassExpression(classNode), \"this\");\n            }\n            ArgumentListExpression newArgs = new ArgumentListExpression(target.isStatic()?new ConstantExpression(null):fixedReceiver);\n            for (Expression expression : args.getExpressions()) {\n                newArgs.addExpression(expression);\n            }\n            return writeDirectMethodCall(bridge, implicitThis, fixedReceiver, newArgs);\n        }\n        return false;\n    }",
            " 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180 +\n 181  \n 182  \n 183 +\n 184 +\n 185 +\n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194 +\n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  ",
            "    /**\n     * Attempts to make a direct method call on a bridge method, if it exists.\n     */\n    protected boolean tryBridgeMethod(MethodNode target, Expression receiver, boolean implicitThis, TupleExpression args) {\n        ClassNode lookupClassNode;\n        if (target.isProtected()) {\n            lookupClassNode = controller.getClassNode();\n            while (lookupClassNode != null && !lookupClassNode.isDerivedFrom(target.getDeclaringClass())) {\n                lookupClassNode = lookupClassNode.getOuterClass();\n            }\n            if (lookupClassNode == null) {\n                return false;\n            }\n        } else {\n            lookupClassNode = target.getDeclaringClass().redirect();\n        }\n        Map<MethodNode, MethodNode> bridges = lookupClassNode.getNodeMetaData(PRIVATE_BRIDGE_METHODS);\n        MethodNode bridge = bridges==null?null:bridges.get(target);\n        if (bridge != null) {\n            Expression fixedReceiver = receiver;\n            if (implicitThis && !controller.isInClosure()) {\n                fixedReceiver = new PropertyExpression(new ClassExpression(lookupClassNode), \"this\");\n            }\n            ArgumentListExpression newArgs = new ArgumentListExpression(target.isStatic()?new ConstantExpression(null):fixedReceiver);\n            for (Expression expression : args.getExpressions()) {\n                newArgs.addExpression(expression);\n            }\n            return writeDirectMethodCall(bridge, implicitThis, fixedReceiver, newArgs);\n        }\n        return false;\n    }"
        ],
        [
            "StaticInvocationWriter::writeDirectMethodCall(MethodNode,boolean,Expression,TupleExpression)",
            " 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  ",
            "    @Override\n    protected boolean writeDirectMethodCall(final MethodNode target, final boolean implicitThis, final Expression receiver, final TupleExpression args) {\n        if (target==null) return false;\n\n        if (target instanceof ExtensionMethodNode) {\n            ExtensionMethodNode emn = (ExtensionMethodNode) target;\n            MethodNode node = emn.getExtensionMethodNode();\n            String methodName = target.getName();\n\n            MethodVisitor mv = controller.getMethodVisitor();\n            int argumentsToRemove = 0;\n            List<Expression> argumentList = new LinkedList<Expression>(args.getExpressions());\n\n            if (emn.isStaticExtension()) {\n                // it's a static extension method\n                argumentList.add(0, ConstantExpression.NULL);\n            } else {\n                argumentList.add(0, receiver);\n            }\n\n            Parameter[] parameters = node.getParameters();\n            loadArguments(argumentList, parameters);\n\n            String owner = BytecodeHelper.getClassInternalName(node.getDeclaringClass());\n            String desc = BytecodeHelper.getMethodDescriptor(target.getReturnType(), parameters);\n            mv.visitMethodInsn(INVOKESTATIC, owner, methodName, desc, false);\n            ClassNode ret = target.getReturnType().redirect();\n            if (ret == ClassHelper.VOID_TYPE) {\n                ret = ClassHelper.OBJECT_TYPE;\n                mv.visitInsn(ACONST_NULL);\n            }\n            argumentsToRemove += argumentList.size();\n            controller.getOperandStack().remove(argumentsToRemove);\n            controller.getOperandStack().push(ret);\n            return true;\n        } else {\n            if (target == StaticTypeCheckingVisitor.CLOSURE_CALL_VARGS) {\n                // wrap arguments into an array\n                ArrayExpression arr = new ArrayExpression(ClassHelper.OBJECT_TYPE, args.getExpressions());\n                return super.writeDirectMethodCall(target, implicitThis, receiver, new ArgumentListExpression(arr));\n            }\n            ClassNode classNode = controller.getClassNode();\n            if (classNode.isDerivedFrom(ClassHelper.CLOSURE_TYPE)\n                    && controller.isInClosure()\n                    && !target.isPublic()\n                    && target.getDeclaringClass() != classNode) {\n                if (!tryBridgeMethod(target, receiver, implicitThis, args)) {\n                    // replace call with an invoker helper call\n                    ArrayExpression arr = new ArrayExpression(ClassHelper.OBJECT_TYPE, args.getExpressions());\n                    MethodCallExpression mce = new MethodCallExpression(\n                            INVOKERHELER_RECEIVER,\n                            target.isStatic() ? \"invokeStaticMethod\" : \"invokeMethodSafe\",\n                            new ArgumentListExpression(\n                                    target.isStatic() ?\n                                            new ClassExpression(target.getDeclaringClass()) :\n                                            receiver,\n                                    new ConstantExpression(target.getName()),\n                                    arr\n                            )\n                    );\n                    mce.setMethodTarget(target.isStatic() ? INVOKERHELPER_INVOKESTATICMETHOD : INVOKERHELPER_INVOKEMETHOD);\n                    mce.visit(controller.getAcg());\n                    return true;\n                }\n                return true;\n            }\n            if (target.isPrivate()) {\n                if (tryPrivateMethod(target, implicitThis, receiver, args, classNode)) return true;\n            } else if (target.isProtected()) {\n                ClassNode node = receiver==null?ClassHelper.OBJECT_TYPE:controller.getTypeChooser().resolveType(receiver, controller.getClassNode());\n                boolean isThisOrSuper = false;\n                if (receiver instanceof VariableExpression) {\n                    isThisOrSuper = ((VariableExpression) receiver).isThisExpression() || ((VariableExpression) receiver).isSuperExpression();\n                }\n                if (!implicitThis && !isThisOrSuper\n                        && StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(node,target.getDeclaringClass())) {\n                    ASTNode src = receiver==null?args:receiver;\n                    controller.getSourceUnit().addError(\n                            new SyntaxException(\"Method \" + target.getName() + \" is protected in \" + target.getDeclaringClass().toString(false),\n                                    src.getLineNumber(), src.getColumnNumber(), src.getLastLineNumber(), src.getLastColumnNumber()));\n                }\n            }\n            if (receiver != null) {\n                if (!(receiver instanceof VariableExpression) || !((VariableExpression) receiver).isSuperExpression()) {\n                    // in order to avoid calls to castToType, which is the dynamic behaviour, we make sure that we call CHECKCAST instead\n                    // then replace the top operand type\n                    Expression checkCastReceiver = new CheckcastReceiverExpression(receiver, target);\n                    return super.writeDirectMethodCall(target, implicitThis, checkCastReceiver, args);\n                }\n            }\n            return super.writeDirectMethodCall(target, implicitThis, receiver, args);\n        }\n    }",
            " 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285 +\n 286 +\n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  ",
            "    @Override\n    protected boolean writeDirectMethodCall(final MethodNode target, final boolean implicitThis, final Expression receiver, final TupleExpression args) {\n        if (target==null) return false;\n\n        if (target instanceof ExtensionMethodNode) {\n            ExtensionMethodNode emn = (ExtensionMethodNode) target;\n            MethodNode node = emn.getExtensionMethodNode();\n            String methodName = target.getName();\n\n            MethodVisitor mv = controller.getMethodVisitor();\n            int argumentsToRemove = 0;\n            List<Expression> argumentList = new LinkedList<Expression>(args.getExpressions());\n\n            if (emn.isStaticExtension()) {\n                // it's a static extension method\n                argumentList.add(0, ConstantExpression.NULL);\n            } else {\n                argumentList.add(0, receiver);\n            }\n\n            Parameter[] parameters = node.getParameters();\n            loadArguments(argumentList, parameters);\n\n            String owner = BytecodeHelper.getClassInternalName(node.getDeclaringClass());\n            String desc = BytecodeHelper.getMethodDescriptor(target.getReturnType(), parameters);\n            mv.visitMethodInsn(INVOKESTATIC, owner, methodName, desc, false);\n            ClassNode ret = target.getReturnType().redirect();\n            if (ret == ClassHelper.VOID_TYPE) {\n                ret = ClassHelper.OBJECT_TYPE;\n                mv.visitInsn(ACONST_NULL);\n            }\n            argumentsToRemove += argumentList.size();\n            controller.getOperandStack().remove(argumentsToRemove);\n            controller.getOperandStack().push(ret);\n            return true;\n        } else {\n            if (target == StaticTypeCheckingVisitor.CLOSURE_CALL_VARGS) {\n                // wrap arguments into an array\n                ArrayExpression arr = new ArrayExpression(ClassHelper.OBJECT_TYPE, args.getExpressions());\n                return super.writeDirectMethodCall(target, implicitThis, receiver, new ArgumentListExpression(arr));\n            }\n            ClassNode classNode = controller.getClassNode();\n            if (classNode.isDerivedFrom(ClassHelper.CLOSURE_TYPE)\n                    && controller.isInClosure()\n                    && !target.isPublic()\n                    && target.getDeclaringClass() != classNode) {\n                if (!tryBridgeMethod(target, receiver, implicitThis, args)) {\n                    // replace call with an invoker helper call\n                    ArrayExpression arr = new ArrayExpression(ClassHelper.OBJECT_TYPE, args.getExpressions());\n                    MethodCallExpression mce = new MethodCallExpression(\n                            INVOKERHELER_RECEIVER,\n                            target.isStatic() ? \"invokeStaticMethod\" : \"invokeMethodSafe\",\n                            new ArgumentListExpression(\n                                    target.isStatic() ?\n                                            new ClassExpression(target.getDeclaringClass()) :\n                                            receiver,\n                                    new ConstantExpression(target.getName()),\n                                    arr\n                            )\n                    );\n                    mce.setMethodTarget(target.isStatic() ? INVOKERHELPER_INVOKESTATICMETHOD : INVOKERHELPER_INVOKEMETHOD);\n                    mce.visit(controller.getAcg());\n                    return true;\n                }\n                return true;\n            }\n            if (target.isPrivate()) {\n                if (tryPrivateMethod(target, implicitThis, receiver, args, classNode)) return true;\n            } else if (target.isProtected()) {\n                ClassNode node = receiver==null?ClassHelper.OBJECT_TYPE:controller.getTypeChooser().resolveType(receiver, controller.getClassNode());\n                boolean isThisOrSuper = false;\n                if (receiver instanceof VariableExpression) {\n                    isThisOrSuper = ((VariableExpression) receiver).isThisExpression() || ((VariableExpression) receiver).isSuperExpression();\n                }\n                if (!implicitThis && !isThisOrSuper\n                        && StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(node,target.getDeclaringClass())) {\n                    ASTNode src = receiver==null?args:receiver;\n                    controller.getSourceUnit().addError(\n                            new SyntaxException(\"Method \" + target.getName() + \" is protected in \" + target.getDeclaringClass().toString(false),\n                                    src.getLineNumber(), src.getColumnNumber(), src.getLastLineNumber(), src.getLastColumnNumber()));\n                } else if (!node.isDerivedFrom(target.getDeclaringClass()) && tryBridgeMethod(target, receiver, implicitThis, args)) {\n                    return true;\n                }\n            }\n            if (receiver != null) {\n                if (!(receiver instanceof VariableExpression) || !((VariableExpression) receiver).isSuperExpression()) {\n                    // in order to avoid calls to castToType, which is the dynamic behaviour, we make sure that we call CHECKCAST instead\n                    // then replace the top operand type\n                    Expression checkCastReceiver = new CheckcastReceiverExpression(receiver, target);\n                    return super.writeDirectMethodCall(target, implicitThis, checkCastReceiver, args);\n                }\n            }\n            return super.writeDirectMethodCall(target, implicitThis, receiver, args);\n        }\n    }"
        ]
    ],
    "0d86565c503595965ce2ed697e87ddafe7c40491": [
        [
            "DefaultTypeTransformation::compareToWithEqualityCheck(Object,Object,boolean)",
            " 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564  \n 565  \n 566  \n 567  \n 568  \n 569  \n 570  \n 571  \n 572  \n 573  \n 574  \n 575  \n 576  \n 577  \n 578  \n 579  \n 580  \n 581  \n 582  \n 583 -\n 584  \n 585  \n 586  \n 587  \n 588  \n 589  \n 590  \n 591  \n 592  \n 593  \n 594  \n 595  \n 596  \n 597  \n 598  \n 599  \n 600  \n 601  \n 602  \n 603  \n 604  \n 605  ",
            "    private static int compareToWithEqualityCheck(Object left, Object right, boolean equalityCheckOnly) {\n        if (left == right) {\n            return 0;\n        }\n        if (left == null) {\n            return -1;\n        }\n        else if (right == null) {\n            return 1;\n        }\n        if (left instanceof Comparable) {\n            if (left instanceof Number) {\n                if (right instanceof Character || right instanceof Number) {\n                    return DefaultGroovyMethods.compareTo((Number) left, castToNumber(right));\n                }\n                if (isValidCharacterString(right)) {\n                    return DefaultGroovyMethods.compareTo((Number) left, ShortTypeHandling.castToChar(right));\n                }\n            }\n            else if (left instanceof Character) {\n                if (isValidCharacterString(right)) {\n                    return DefaultGroovyMethods.compareTo((Character)left, ShortTypeHandling.castToChar(right));\n                }\n                if (right instanceof Number) {\n                    return DefaultGroovyMethods.compareTo((Character)left,(Number)right);\n                }\n            }\n            else if (right instanceof Number) {\n                if (isValidCharacterString(left)) {\n                    return DefaultGroovyMethods.compareTo(ShortTypeHandling.castToChar(left),(Number) right);\n                }\n            }\n            else if (left instanceof String && right instanceof Character) {\n                return ((String) left).compareTo(right.toString());\n            }\n            else if (left instanceof String && right instanceof GString) {\n                return ((String) left).compareTo(right.toString());\n            }\n            if (!equalityCheckOnly || left.getClass().isAssignableFrom(right.getClass())\n                    || (right.getClass() != Object.class && right.getClass().isAssignableFrom(left.getClass())) //GROOVY-4046\n                    || (left instanceof GString && right instanceof String)) {\n                Comparable comparable = (Comparable) left;\n                // GROOVY-7876: when comparing for equality we try to only call compareTo when an assignable\n                // relationship holds but with a container/holder class and because of erasure, we might still end\n                // up with the prospect of a ClassCastException which we want to ignore but only if testing equality\n                try {\n                    return comparable.compareTo(right);\n                } catch (ClassCastException cce) {\n                    if (!equalityCheckOnly) throw cce;\n                }\n            }\n        }\n\n        if (equalityCheckOnly) {\n            return -1; // anything other than 0\n        }\n        throw new GroovyRuntimeException(\n                MessageFormat.format(\"Cannot compare {0} with value ''{1}'' and {2} with value ''{3}''\",\n                        left.getClass().getName(),\n                        left,\n                        right.getClass().getName(),\n                        right));\n    }",
            " 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564  \n 565  \n 566  \n 567  \n 568  \n 569  \n 570  \n 571  \n 572  \n 573  \n 574  \n 575  \n 576  \n 577  \n 578  \n 579  \n 580  \n 581 +\n 582 +\n 583 +\n 584  \n 585  \n 586 +\n 587  \n 588  \n 589  \n 590  \n 591  \n 592  \n 593  \n 594  \n 595  \n 596  \n 597  \n 598  \n 599  \n 600  \n 601  \n 602  \n 603  \n 604  \n 605  \n 606  \n 607  \n 608  ",
            "    private static int compareToWithEqualityCheck(Object left, Object right, boolean equalityCheckOnly) {\n        if (left == right) {\n            return 0;\n        }\n        if (left == null) {\n            return -1;\n        }\n        else if (right == null) {\n            return 1;\n        }\n        if (left instanceof Comparable) {\n            if (left instanceof Number) {\n                if (right instanceof Character || right instanceof Number) {\n                    return DefaultGroovyMethods.compareTo((Number) left, castToNumber(right));\n                }\n                if (isValidCharacterString(right)) {\n                    return DefaultGroovyMethods.compareTo((Number) left, ShortTypeHandling.castToChar(right));\n                }\n            }\n            else if (left instanceof Character) {\n                if (isValidCharacterString(right)) {\n                    return DefaultGroovyMethods.compareTo((Character)left, ShortTypeHandling.castToChar(right));\n                }\n                if (right instanceof Number) {\n                    return DefaultGroovyMethods.compareTo((Character)left,(Number)right);\n                }\n            }\n            else if (right instanceof Number) {\n                if (isValidCharacterString(left)) {\n                    return DefaultGroovyMethods.compareTo(ShortTypeHandling.castToChar(left),(Number) right);\n                }\n            }\n            else if (left instanceof String && right instanceof Character) {\n                return ((String) left).compareTo(right.toString());\n            }\n            else if (left instanceof String && right instanceof GString) {\n                return ((String) left).compareTo(right.toString());\n            }\n            else if (left instanceof GString && right instanceof String) {\n                return ((GString) left).compareTo(right);\n            }\n            if (!equalityCheckOnly || left.getClass().isAssignableFrom(right.getClass())\n                    || (right.getClass() != Object.class && right.getClass().isAssignableFrom(left.getClass())) //GROOVY-4046\n            ) {\n                Comparable comparable = (Comparable) left;\n                // GROOVY-7876: when comparing for equality we try to only call compareTo when an assignable\n                // relationship holds but with a container/holder class and because of erasure, we might still end\n                // up with the prospect of a ClassCastException which we want to ignore but only if testing equality\n                try {\n                    return comparable.compareTo(right);\n                } catch (ClassCastException cce) {\n                    if (!equalityCheckOnly) throw cce;\n                }\n            }\n        }\n\n        if (equalityCheckOnly) {\n            return -1; // anything other than 0\n        }\n        throw new GroovyRuntimeException(\n                MessageFormat.format(\"Cannot compare {0} with value ''{1}'' and {2} with value ''{3}''\",\n                        left.getClass().getName(),\n                        left,\n                        right.getClass().getName(),\n                        right));\n    }"
        ]
    ],
    "01fdb705c4ca0737949c4fd323b62736c27716a8": [
        [
            "Sql::newInstance(Map)",
            " 516  \n 517  \n 518  \n 519  \n 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528  \n 529  \n 530  \n 531  \n 532  \n 533  \n 534  \n 535  \n 536  \n 537  \n 538  \n 539  \n 540  \n 541  \n 542  \n 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564  \n 565  \n 566  \n 567  \n 568  \n 569  \n 570  \n 571  \n 572  \n 573  \n 574  \n 575  \n 576  \n 577  \n 578  \n 579  \n 580  \n 581  \n 582 -\n 583 -\n 584 -\n 585  \n 586  \n 587  \n 588  \n 589  \n 590  \n 591  \n 592  \n 593  \n 594  \n 595  \n 596  \n 597  \n 598  ",
            "    /**\n     * Creates a new Sql instance given parameters in a Map.\n     * Recognized keys for the Map include:\n     * <pre>\n     * driverClassName the fully qualified class name of the driver class\n     * driver          a synonym for driverClassName\n     * url             a database url of the form: <code>jdbc:<em>subprotocol</em>:<em>subname</em></code>\n     * user            the database user on whose behalf the connection is being made\n     * password        the user's password\n     * properties      a list of arbitrary string tag/value pairs as connection arguments;\n     *                 normally at least a \"user\" and \"password\" property should be included\n     * <em>other</em>           any of the public setter methods of this class may be used with property notation\n     *                 e.g. <em>cacheStatements: true, resultSetConcurrency: ResultSet.CONCUR_READ_ONLY</em>\n     * </pre>\n     * Of these, '<code>url</code>' is required. Others may be needed depending on your database.<br>\n     * If '<code>properties</code>' is supplied, neither '<code>user</code>' nor '<code>password</code>' should be supplied.<br>\n     * If one of '<code>user</code>' or '<code>password</code>' is supplied, both should be supplied.\n     *<p>\n     * Example usage:\n     * <pre>\n     * import groovy.sql.Sql\n     * import static java.sql.ResultSet.*\n     *\n     * def sql = Sql.newInstance(\n     *     url:'jdbc:hsqldb:mem:testDB',\n     *     user:'sa',\n     *     password:'',\n     *     driver:'org.hsqldb.jdbc.JDBCDriver',\n     *     cacheStatements: true,\n     *     resultSetConcurrency: CONCUR_READ_ONLY\n     * )\n     * </pre>\n     * \n     * @param args a Map contain further arguments\n     * @return a new Sql instance with a connection\n     * @throws SQLException           if a database access error occurs\n     * @throws ClassNotFoundException if the driver class cannot be found or loaded\n     */\n    public static Sql newInstance(Map<String, Object> args) throws SQLException, ClassNotFoundException {\n        if (!args.containsKey(\"url\"))\n            throw new IllegalArgumentException(\"Argument 'url' is required\");\n\n        if (args.get(\"url\") == null)\n            throw new IllegalArgumentException(\"Argument 'url' must not be null\");\n\n        if (args.containsKey(\"driverClassName\") && args.containsKey(\"driver\"))\n            throw new IllegalArgumentException(\"Only one of 'driverClassName' and 'driver' should be provided\");\n\n        // Make a copy so destructive operations will not affect the caller\n        Map<String, Object> sqlArgs = new HashMap<String, Object>(args);\n\n        Object driverClassName = sqlArgs.remove(\"driverClassName\");\n        if (driverClassName == null) driverClassName = sqlArgs.remove(\"driver\");\n        if (driverClassName != null) loadDriver(driverClassName.toString());\n\n        Properties props = (Properties) sqlArgs.remove(\"properties\");\n        if (props != null && sqlArgs.containsKey(\"user\"))\n            throw new IllegalArgumentException(\"Only one of 'properties' and 'user' should be supplied\");\n        if (props != null && sqlArgs.containsKey(\"password\"))\n            throw new IllegalArgumentException(\"Only one of 'properties' and 'password' should be supplied\");\n        if (sqlArgs.containsKey(\"user\") ^ sqlArgs.containsKey(\"password\"))\n            throw new IllegalArgumentException(\"Found one but not both of 'user' and 'password'\");\n\n        Object url = sqlArgs.remove(\"url\");\n        Connection connection;\n        if (props != null) {\n            System.err.println(\"url = \" + url);\n            System.err.println(\"props = \" + props);\n            connection = DriverManager.getConnection(url.toString(), new Properties(props));\n        } else if (sqlArgs.containsKey(\"user\")) {\n            Object user = sqlArgs.remove(\"user\");\n            Object password = sqlArgs.remove(\"password\");\n            connection = DriverManager.getConnection(url.toString(),\n                    (user == null ? null : user.toString()),\n                    (password == null ? null : password.toString()));\n        } else {\n            connection = DriverManager.getConnection(url.toString());\n        }\n\n        Sql result = (Sql) InvokerHelper.invokeConstructorOf(Sql.class, sqlArgs);\n        result.setConnection(connection);\n        return result;\n    }",
            " 516  \n 517  \n 518  \n 519  \n 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528  \n 529  \n 530  \n 531  \n 532  \n 533  \n 534  \n 535  \n 536  \n 537  \n 538  \n 539  \n 540  \n 541  \n 542  \n 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564  \n 565  \n 566  \n 567  \n 568  \n 569  \n 570  \n 571  \n 572  \n 573  \n 574  \n 575  \n 576  \n 577  \n 578  \n 579  \n 580  \n 581 +\n 582  \n 583 +\n 584 +\n 585 +\n 586 +\n 587 +\n 588 +\n 589 +\n 590 +\n 591  \n 592  \n 593 +\n 594  \n 595 +\n 596  \n 597  \n 598  \n 599  \n 600 +\n 601  \n 602  \n 603  \n 604  \n 605  \n 606  \n 607  ",
            "    /**\n     * Creates a new Sql instance given parameters in a Map.\n     * Recognized keys for the Map include:\n     * <pre>\n     * driverClassName the fully qualified class name of the driver class\n     * driver          a synonym for driverClassName\n     * url             a database url of the form: <code>jdbc:<em>subprotocol</em>:<em>subname</em></code>\n     * user            the database user on whose behalf the connection is being made\n     * password        the user's password\n     * properties      a list of arbitrary string tag/value pairs as connection arguments;\n     *                 normally at least a \"user\" and \"password\" property should be included\n     * <em>other</em>           any of the public setter methods of this class may be used with property notation\n     *                 e.g. <em>cacheStatements: true, resultSetConcurrency: ResultSet.CONCUR_READ_ONLY</em>\n     * </pre>\n     * Of these, '<code>url</code>' is required. Others may be needed depending on your database.<br>\n     * If '<code>properties</code>' is supplied, neither '<code>user</code>' nor '<code>password</code>' should be supplied.<br>\n     * If one of '<code>user</code>' or '<code>password</code>' is supplied, both should be supplied.\n     *<p>\n     * Example usage:\n     * <pre>\n     * import groovy.sql.Sql\n     * import static java.sql.ResultSet.*\n     *\n     * def sql = Sql.newInstance(\n     *     url:'jdbc:hsqldb:mem:testDB',\n     *     user:'sa',\n     *     password:'',\n     *     driver:'org.hsqldb.jdbc.JDBCDriver',\n     *     cacheStatements: true,\n     *     resultSetConcurrency: CONCUR_READ_ONLY\n     * )\n     * </pre>\n     * \n     * @param args a Map contain further arguments\n     * @return a new Sql instance with a connection\n     * @throws SQLException           if a database access error occurs\n     * @throws ClassNotFoundException if the driver class cannot be found or loaded\n     */\n    public static Sql newInstance(Map<String, Object> args) throws SQLException, ClassNotFoundException {\n        if (!args.containsKey(\"url\"))\n            throw new IllegalArgumentException(\"Argument 'url' is required\");\n\n        if (args.get(\"url\") == null)\n            throw new IllegalArgumentException(\"Argument 'url' must not be null\");\n\n        if (args.containsKey(\"driverClassName\") && args.containsKey(\"driver\"))\n            throw new IllegalArgumentException(\"Only one of 'driverClassName' and 'driver' should be provided\");\n\n        // Make a copy so destructive operations will not affect the caller\n        Map<String, Object> sqlArgs = new HashMap<String, Object>(args);\n\n        Object driverClassName = sqlArgs.remove(\"driverClassName\");\n        if (driverClassName == null) driverClassName = sqlArgs.remove(\"driver\");\n        if (driverClassName != null) loadDriver(driverClassName.toString());\n\n        Properties props = (Properties) sqlArgs.remove(\"properties\");\n        if (props != null && sqlArgs.containsKey(\"user\"))\n            throw new IllegalArgumentException(\"Only one of 'properties' and 'user' should be supplied\");\n        if (props != null && sqlArgs.containsKey(\"password\"))\n            throw new IllegalArgumentException(\"Only one of 'properties' and 'password' should be supplied\");\n        if (sqlArgs.containsKey(\"user\") ^ sqlArgs.containsKey(\"password\"))\n            throw new IllegalArgumentException(\"Found one but not both of 'user' and 'password'\");\n\n        Object url = sqlArgs.remove(\"url\");\n        Connection connection;\n        LOG.fine(\"url = \" + url);\n        if (props != null) {\n            Properties propsCopy = new Properties(props);\n            connection = DriverManager.getConnection(url.toString(), propsCopy);\n            if (propsCopy.containsKey(\"password\")) {\n                // don't log the password\n                propsCopy = new Properties(propsCopy);\n                propsCopy.setProperty(\"password\", \"***\");\n            }\n            LOG.fine(\"props = \" + propsCopy);\n        } else if (sqlArgs.containsKey(\"user\")) {\n            Object user = sqlArgs.remove(\"user\");\n            LOG.fine(\"user = \" + user);\n            Object password = sqlArgs.remove(\"password\");\n            LOG.fine(\"password = \" + (password == null ? \"null\" : \"***\"));\n            connection = DriverManager.getConnection(url.toString(),\n                    (user == null ? null : user.toString()),\n                    (password == null ? null : password.toString()));\n        } else {\n            LOG.fine(\"No user/password specified\");\n            connection = DriverManager.getConnection(url.toString());\n        }\n\n        Sql result = (Sql) InvokerHelper.invokeConstructorOf(Sql.class, sqlArgs);\n        result.setConnection(connection);\n        return result;\n    }"
        ]
    ],
    "774415910b4f34eb09e0fa2154be91df3902974d": [
        [
            "AnnotationCollectorTransform::getTargetAnnotationList(AnnotationNode,AnnotationNode,SourceUnit)",
            " 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  \n 306  \n 307  \n 308 -\n 309  \n 310  \n 311  \n 312  \n 313  \n 314  ",
            "    /**\n     * Returns a list of AnnotationNodes for the value attribute of the given \n     * AnnotationNode. \n     * \n     * @param collector     the node containing the value member with the list\n     * @param source        the source unit for error reporting\n     * @return              a list of string constants\n     */\n    protected List<AnnotationNode> getTargetAnnotationList(AnnotationNode collector, AnnotationNode aliasAnnotationUsage, SourceUnit source) {\n        List<AnnotationNode> stored     = getStoredTargetList(aliasAnnotationUsage, source);\n        List<AnnotationNode> targetList = getTargetListFromValue(collector, aliasAnnotationUsage, source);\n        int size = targetList.size()+stored.size();\n        if (size==0) return Collections.EMPTY_LIST;\n        List<AnnotationNode> ret = new ArrayList<AnnotationNode>(size);\n        ret.addAll(stored);\n        ret.addAll(targetList);\n\n        return ret;\n    }",
            " 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319 +\n 320 +\n 321 +\n 322  \n 323  \n 324  \n 325  \n 326  \n 327  ",
            "    /**\n     * Returns a list of AnnotationNodes for the value attribute of the given \n     * AnnotationNode. \n     * \n     * @param collector     the node containing the value member with the list\n     * @param source        the source unit for error reporting\n     * @return              a list of string constants\n     */\n    protected List<AnnotationNode> getTargetAnnotationList(AnnotationNode collector, AnnotationNode aliasAnnotationUsage, SourceUnit source) {\n        List<AnnotationNode> stored     = getStoredTargetList(aliasAnnotationUsage, source);\n        List<AnnotationNode> targetList = getTargetListFromValue(collector, aliasAnnotationUsage, source);\n        int size = targetList.size()+stored.size();\n        if (size == 0) {\n            return Collections.emptyList();\n        }\n        List<AnnotationNode> ret = new ArrayList<AnnotationNode>(size);\n        ret.addAll(stored);\n        ret.addAll(targetList);\n\n        return ret;\n    }"
        ],
        [
            "Traits::isTrait(Class)",
            " 161  \n 162  \n 163  \n 164  \n 165  \n 166 -\n 167  \n 168  ",
            "    /**\n     * Returns true if the specified class is a trait.\n     * @param clazz a class to test\n     * @return true if the classnode represents a trait\n     */\n    public static boolean isTrait(final Class clazz) {\n        return clazz!=null && clazz.getAnnotation(Trait.class)!=null;\n    }",
            " 161  \n 162  \n 163  \n 164  \n 165  \n 166 +\n 167  \n 168  ",
            "    /**\n     * Returns true if the specified class is a trait.\n     * @param clazz a class to test\n     * @return true if the classnode represents a trait\n     */\n    public static boolean isTrait(final Class<?> clazz) {\n        return clazz!=null && clazz.getAnnotation(Trait.class)!=null;\n    }"
        ],
        [
            "AnnotationCollectorTransform::ClassChanger::transformClass(ClassNode)",
            "  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100 -\n 101 -\n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127 -\n 128  \n 129  \n 130  ",
            "        /**\n         * Method to transform the given ClassNode, if it is annotated with \n         * {@link AnnotationCollector}. See class description for what the\n         * transformation includes.\n         */\n        public void transformClass(ClassNode cn) {\n            AnnotationNode collector = null;\n            for (ListIterator<AnnotationNode> it = cn.getAnnotations().listIterator(); it.hasNext();) {\n                AnnotationNode an = it.next();\n                if (an.getClassNode().getName().equals(AnnotationCollector.class.getName())) {\n                    collector = an;\n                    break;\n                }\n            }\n            if (collector==null) return;\n            \n            // force final class, remove interface, annotation, enum and abstract modifiers\n            cn.setModifiers((ACC_FINAL+cn.getModifiers()) & ~(ACC_ENUM|ACC_INTERFACE|ACC_ANNOTATION|ACC_ABSTRACT));\n            // force Object super class\n            cn.setSuperClass(ClassHelper.OBJECT_TYPE);\n            // force no interfaces implemented\n            cn.setInterfaces(ClassNode.EMPTY_ARRAY);\n\n            // add static value():Object[][] method\n            List<AnnotationNode> meta = getMeta(cn); \n            List<Expression> outer = new ArrayList<Expression>(meta.size());\n            for (AnnotationNode an : meta) {\n                Expression serialized = serialize(an);\n                outer.add(serialized);\n            }\n\n            ArrayExpression ae = new ArrayExpression(ClassHelper.OBJECT_TYPE.makeArray(), outer);\n            Statement code = new ReturnStatement(ae);\n            cn.addMethod(   \"value\", ACC_PUBLIC+ACC_STATIC,\n                            ClassHelper.OBJECT_TYPE.makeArray().makeArray(), \n                            Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY,\n                            code);\n\n            // remove annotations\n            for (ListIterator<AnnotationNode> it = cn.getAnnotations().listIterator(); it.hasNext();) {\n                AnnotationNode an = it.next();\n                if (an==collector) continue;\n                it.remove();\n            }\n        }",
            "  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100 +\n 101 +\n 102 +\n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128 +\n 129 +\n 130 +\n 131  \n 132  \n 133  ",
            "        /**\n         * Method to transform the given ClassNode, if it is annotated with \n         * {@link AnnotationCollector}. See class description for what the\n         * transformation includes.\n         */\n        public void transformClass(ClassNode cn) {\n            AnnotationNode collector = null;\n            for (ListIterator<AnnotationNode> it = cn.getAnnotations().listIterator(); it.hasNext();) {\n                AnnotationNode an = it.next();\n                if (an.getClassNode().getName().equals(AnnotationCollector.class.getName())) {\n                    collector = an;\n                    break;\n                }\n            }\n            if (collector == null) {\n                return;\n            }\n            // force final class, remove interface, annotation, enum and abstract modifiers\n            cn.setModifiers((ACC_FINAL+cn.getModifiers()) & ~(ACC_ENUM|ACC_INTERFACE|ACC_ANNOTATION|ACC_ABSTRACT));\n            // force Object super class\n            cn.setSuperClass(ClassHelper.OBJECT_TYPE);\n            // force no interfaces implemented\n            cn.setInterfaces(ClassNode.EMPTY_ARRAY);\n\n            // add static value():Object[][] method\n            List<AnnotationNode> meta = getMeta(cn); \n            List<Expression> outer = new ArrayList<Expression>(meta.size());\n            for (AnnotationNode an : meta) {\n                Expression serialized = serialize(an);\n                outer.add(serialized);\n            }\n\n            ArrayExpression ae = new ArrayExpression(ClassHelper.OBJECT_TYPE.makeArray(), outer);\n            Statement code = new ReturnStatement(ae);\n            cn.addMethod(   \"value\", ACC_PUBLIC+ACC_STATIC,\n                            ClassHelper.OBJECT_TYPE.makeArray().makeArray(), \n                            Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY,\n                            code);\n\n            // remove annotations\n            for (ListIterator<AnnotationNode> it = cn.getAnnotations().listIterator(); it.hasNext();) {\n                AnnotationNode an = it.next();\n                if (an == collector) {\n                    continue;\n                }\n                it.remove();\n            }\n        }"
        ],
        [
            "AnnotationCollectorTransform::makeExpression(Object)",
            " 275  \n 276 -\n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  ",
            "    private static Expression makeExpression(Object o) {\n        if (o instanceof Class) return new ClassExpression(ClassHelper.make((Class) o));\n        //TODO: value as Annotation here!\n        if (o instanceof Object[][]) {\n            List<AnnotationNode> annotations = makeListOfAnnotations((Object[][])o);\n            ListExpression le = new ListExpression();\n            for (AnnotationNode an : annotations) {\n                le.addExpression(new AnnotationConstantExpression(an));\n            }\n            return le;\n        } else if (o instanceof Object[]) {\n            ListExpression le = new ListExpression();\n            Object[] values = (Object[]) o;\n            for (Object val : values) {\n                le.addExpression(makeExpression(val));\n            }\n            return le;\n        }\n        return new ConstantExpression(o,true);\n    }",
            " 284  \n 285 +\n 286 +\n 287 +\n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  ",
            "    private static Expression makeExpression(Object o) {\n        if (o instanceof Class) {\n            return new ClassExpression(ClassHelper.make((Class) o));\n        }\n        //TODO: value as Annotation here!\n        if (o instanceof Object[][]) {\n            List<AnnotationNode> annotations = makeListOfAnnotations((Object[][])o);\n            ListExpression le = new ListExpression();\n            for (AnnotationNode an : annotations) {\n                le.addExpression(new AnnotationConstantExpression(an));\n            }\n            return le;\n        } else if (o instanceof Object[]) {\n            ListExpression le = new ListExpression();\n            Object[] values = (Object[]) o;\n            for (Object val : values) {\n                le.addExpression(makeExpression(val));\n            }\n            return le;\n        }\n        return new ConstantExpression(o,true);\n    }"
        ],
        [
            "AnnotationCollectorTransform::ClassChanger::serialize(AnnotationNode)",
            " 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160 -\n 161 -\n 162  ",
            "        private Expression serialize(AnnotationNode an) {\n            MapExpression map = new MapExpression();\n            for (String key : an.getMembers().keySet()) {\n                map.addMapEntryExpression(new ConstantExpression(key), serialize(an.getMember(key)));\n            }\n            List<Expression> l = new ArrayList<Expression>(2);\n            l.add(new ClassExpression(an.getClassNode()));\n            l.add(map);\n            ArrayExpression ae = new ArrayExpression(ClassHelper.OBJECT_TYPE, l);\n            return ae;\n        }",
            " 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163 +\n 164  ",
            "        private Expression serialize(AnnotationNode an) {\n            MapExpression map = new MapExpression();\n            for (String key : an.getMembers().keySet()) {\n                map.addMapEntryExpression(new ConstantExpression(key), serialize(an.getMember(key)));\n            }\n            List<Expression> l = new ArrayList<Expression>(2);\n            l.add(new ClassExpression(an.getClassNode()));\n            l.add(map);\n            return new ArrayExpression(ClassHelper.OBJECT_TYPE, l);\n        }"
        ],
        [
            "AnnotationCollectorTransform::makeListOfAnnotations(Object)",
            " 253  \n 254 -\n 255 -\n 256  \n 257  \n 258 -\n 259  \n 260  \n 261  \n 262  \n 263  \n 264 -\n 265  \n 266 -\n 267 -\n 268 -\n 269  \n 270  \n 271  \n 272  \n 273  ",
            "    private static List<AnnotationNode> makeListOfAnnotations(Object[][] data) {\n        if (data.length==0) return Collections.EMPTY_LIST;\n\n        List<AnnotationNode> ret = new ArrayList<AnnotationNode>(data.length);\n        for (Object[] inner : data) {\n            Class anno = (Class) inner[0];\n            AnnotationNode toAdd = new AnnotationNode(ClassHelper.make(anno));\n            ret.add(toAdd);\n\n            @SuppressWarnings(\"unchecked\")\n            Map<String,Object> member = (Map<String, Object>) inner[1];\n            if (member.isEmpty()) continue;\n            Map<String, Expression> generated = new HashMap<String, Expression>(member.size());\n            for (String name : member.keySet()) {\n                Object val = member.get(name);\n                generated.put(name, makeExpression(val));\n            }\n            copyMembers(generated, toAdd);\n        }\n        return ret;\n    }",
            " 260  \n 261 +\n 262 +\n 263 +\n 264  \n 265  \n 266 +\n 267  \n 268  \n 269  \n 270  \n 271  \n 272 +\n 273 +\n 274 +\n 275  \n 276 +\n 277 +\n 278  \n 279  \n 280  \n 281  \n 282  ",
            "    private static List<AnnotationNode> makeListOfAnnotations(Object[][] data) {\n        if (data.length == 0) {\n            return Collections.emptyList();\n        }\n        List<AnnotationNode> ret = new ArrayList<AnnotationNode>(data.length);\n        for (Object[] inner : data) {\n            Class<?> anno = (Class) inner[0];\n            AnnotationNode toAdd = new AnnotationNode(ClassHelper.make(anno));\n            ret.add(toAdd);\n\n            @SuppressWarnings(\"unchecked\")\n            Map<String,Object> member = (Map<String, Object>) inner[1];\n            if (member.isEmpty()) {\n                continue;\n            }\n            Map<String, Expression> generated = new HashMap<String, Expression>(member.size());\n            for (Map.Entry<String, Object> entry : member.entrySet()) {\n                generated.put(entry.getKey(), makeExpression(entry.getValue()));\n            }\n            copyMembers(generated, toAdd);\n        }\n        return ret;\n    }"
        ],
        [
            "AnnotationCollectorTransform::getTargetListFromValue(AnnotationNode,AnnotationNode,SourceUnit)",
            " 178  \n 179  \n 180 -\n 181  \n 182  \n 183 -\n 184  \n 185  \n 186  \n 187 -\n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  ",
            "    private List<AnnotationNode> getTargetListFromValue(AnnotationNode collector, AnnotationNode aliasAnnotationUsage, SourceUnit source) {\n        Expression memberValue = collector.getMember(\"value\");\n        if (memberValue == null) return Collections.EMPTY_LIST;\n        if (!(memberValue instanceof ListExpression)) {\n            addError(\"Annotation collector expected a list of classes, but got a \"+memberValue.getClass(), collector, source);\n            return Collections.EMPTY_LIST;\n        }\n        ListExpression memberListExp = (ListExpression) memberValue;\n        List<Expression> memberList = memberListExp.getExpressions();\n        if (memberList.isEmpty()) return Collections.EMPTY_LIST;\n        List<AnnotationNode> ret = new ArrayList<AnnotationNode>();\n        for (Expression e : memberList) {\n            AnnotationNode toAdd = new AnnotationNode(e.getType());\n            toAdd.setSourcePosition(aliasAnnotationUsage);\n            ret.add(toAdd);\n        }\n        return ret;\n    }",
            " 180  \n 181  \n 182 +\n 183 +\n 184 +\n 185  \n 186  \n 187 +\n 188  \n 189  \n 190  \n 191 +\n 192 +\n 193 +\n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  ",
            "    private List<AnnotationNode> getTargetListFromValue(AnnotationNode collector, AnnotationNode aliasAnnotationUsage, SourceUnit source) {\n        Expression memberValue = collector.getMember(\"value\");\n        if (memberValue == null) {\n            return Collections.emptyList();\n        }\n        if (!(memberValue instanceof ListExpression)) {\n            addError(\"Annotation collector expected a list of classes, but got a \"+memberValue.getClass(), collector, source);\n            return Collections.emptyList();\n        }\n        ListExpression memberListExp = (ListExpression) memberValue;\n        List<Expression> memberList = memberListExp.getExpressions();\n        if (memberList.isEmpty()) {\n            return Collections.emptyList();\n        }\n        List<AnnotationNode> ret = new ArrayList<AnnotationNode>();\n        for (Expression e : memberList) {\n            AnnotationNode toAdd = new AnnotationNode(e.getType());\n            toAdd.setSourcePosition(aliasAnnotationUsage);\n            ret.add(toAdd);\n        }\n        return ret;\n    }"
        ],
        [
            "Traits::getBridgeMethodTarget(Method)",
            " 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220 -\n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  ",
            "    /**\n     * Reflection API to find the method corresponding to the default implementation of a trait, given a bridge method.\n     * @param someMethod a method node\n     * @return null if it is not a method implemented in a trait. If it is, returns the method from the trait class.\n     */\n    public static Method getBridgeMethodTarget(Method someMethod) {\n        TraitBridge annotation = someMethod.getAnnotation(TraitBridge.class);\n        if (annotation==null) {\n            return null;\n        }\n        Class aClass = annotation.traitClass();\n        String desc = annotation.desc();\n        for (Method method : aClass.getDeclaredMethods()) {\n            String methodDescriptor = BytecodeHelper.getMethodDescriptor(method.getReturnType(), method.getParameterTypes());\n            if (desc.equals(methodDescriptor)) {\n                return method;\n            }\n        }\n        return null;\n    }",
            " 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220 +\n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  ",
            "    /**\n     * Reflection API to find the method corresponding to the default implementation of a trait, given a bridge method.\n     * @param someMethod a method node\n     * @return null if it is not a method implemented in a trait. If it is, returns the method from the trait class.\n     */\n    public static Method getBridgeMethodTarget(Method someMethod) {\n        TraitBridge annotation = someMethod.getAnnotation(TraitBridge.class);\n        if (annotation==null) {\n            return null;\n        }\n        Class<?> aClass = annotation.traitClass();\n        String desc = annotation.desc();\n        for (Method method : aClass.getDeclaredMethods()) {\n            String methodDescriptor = BytecodeHelper.getMethodDescriptor(method.getReturnType(), method.getParameterTypes());\n            if (desc.equals(methodDescriptor)) {\n                return method;\n            }\n        }\n        return null;\n    }"
        ],
        [
            "AnnotationCollectorTransform::getTargetListFromAnnotations(ClassNode)",
            " 215  \n 216  \n 217 -\n 218 -\n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  ",
            "    private static List<AnnotationNode> getTargetListFromAnnotations(ClassNode alias) {\n        List<AnnotationNode> annotations = alias.getAnnotations();\n        if (annotations.size() < 2) return Collections.EMPTY_LIST;\n        \n        List<AnnotationNode> ret = new ArrayList<AnnotationNode>(annotations.size());\n        for (AnnotationNode an : annotations) {\n            ClassNode type = an.getClassNode();\n            if (type.getName().equals(AnnotationCollector.class.getName())) continue;\n            AnnotationNode toAdd = new AnnotationNode(type);\n            copyMembers(an, toAdd);\n            ret.add(toAdd);\n        }\n        return ret;\n    }",
            " 221  \n 222  \n 223 +\n 224 +\n 225 +\n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  ",
            "    private static List<AnnotationNode> getTargetListFromAnnotations(ClassNode alias) {\n        List<AnnotationNode> annotations = alias.getAnnotations();\n        if (annotations.size() < 2) {\n            return Collections.emptyList();\n        }\n        List<AnnotationNode> ret = new ArrayList<AnnotationNode>(annotations.size());\n        for (AnnotationNode an : annotations) {\n            ClassNode type = an.getClassNode();\n            if (type.getName().equals(AnnotationCollector.class.getName())) continue;\n            AnnotationNode toAdd = new AnnotationNode(type);\n            copyMembers(an, toAdd);\n            ret.add(toAdd);\n        }\n        return ret;\n    }"
        ]
    ],
    "2c79476307ea5bc38b0f7c94a981b2b24eaf33a7": [
        [
            "StaticTypeCheckingVisitor::getResultType(ClassNode,int,ClassNode,BinaryExpression)",
            "3590  \n3591  \n3592  \n3593  \n3594  \n3595  \n3596  \n3597  \n3598  \n3599 -\n3600  \n3601  \n3602  \n3603  \n3604  \n3605  \n3606  \n3607  \n3608  \n3609  \n3610  \n3611  \n3612  \n3613  \n3614  \n3615  \n3616  \n3617  \n3618  \n3619  \n3620  \n3621  \n3622  \n3623  \n3624  \n3625  \n3626  \n3627  \n3628  \n3629  \n3630  \n3631  \n3632  \n3633  \n3634  \n3635  \n3636  \n3637  \n3638  \n3639  \n3640  \n3641  \n3642  \n3643  \n3644  \n3645  \n3646  \n3647  \n3648  \n3649  \n3650  \n3651  \n3652  \n3653  \n3654  \n3655  \n3656  \n3657  \n3658  \n3659  \n3660  \n3661  \n3662  \n3663  \n3664  \n3665  \n3666  \n3667  \n3668  \n3669  \n3670  \n3671  \n3672  \n3673  \n3674  \n3675  \n3676  \n3677  \n3678  \n3679  \n3680  \n3681  \n3682  \n3683  \n3684  \n3685  \n3686  \n3687  \n3688  \n3689  \n3690  \n3691  \n3692  \n3693  \n3694  \n3695  \n3696  \n3697  \n3698  \n3699  \n3700  \n3701  \n3702  \n3703  \n3704  \n3705  \n3706  \n3707  \n3708  \n3709  \n3710  \n3711  \n3712  \n3713  \n3714  \n3715  \n3716  \n3717  \n3718  \n3719  ",
            "    protected ClassNode getResultType(ClassNode left, int op, ClassNode right, BinaryExpression expr) {\n        ClassNode leftRedirect = left.redirect();\n        ClassNode rightRedirect = right.redirect();\n\n        Expression leftExpression = expr.getLeftExpression();\n        Expression rightExpression = expr.getRightExpression();\n        if (op == ASSIGN || op == ASSIGNMENT_OPERATOR || op == ELVIS_EQUAL) {\n            if (leftRedirect.isArray() && implementsInterfaceOrIsSubclassOf(rightRedirect, Collection_TYPE)) return leftRedirect;\n            if (leftRedirect.implementsInterface(Collection_TYPE) && rightRedirect.implementsInterface(Collection_TYPE)) {\n                // because of type inferrence, we must perform an additional check if the right expression\n                // is an empty list expression ([]). In that case and only in that case, the inferred type\n                // will be wrong, so we will prefer the left type\n                if (rightExpression instanceof ListExpression) {\n                    List<Expression> list = ((ListExpression) rightExpression).getExpressions();\n                    if (list.isEmpty()) return left;\n                }\n                return right;\n            }\n            if (rightRedirect.implementsInterface(Collection_TYPE) && rightRedirect.isDerivedFrom(leftRedirect)) {\n                // ex : def foos = ['a','b','c']\n                return right;\n            }\n            if (rightRedirect.isDerivedFrom(CLOSURE_TYPE) && isSAMType(leftRedirect) && rightExpression instanceof ClosureExpression) {\n                return inferSAMTypeGenericsInAssignment(left, findSAM(left),right,(ClosureExpression) rightExpression);\n            }\n\n            if (leftExpression instanceof VariableExpression) {\n                ClassNode initialType = getOriginalDeclarationType(leftExpression).redirect();\n                if (isPrimitiveType(right) && initialType.isDerivedFrom(Number_TYPE)) {\n                    return getWrapper(right);\n                }\n\n                if (isPrimitiveType(initialType) && rightRedirect.isDerivedFrom(Number_TYPE))  {\n                    return getUnwrapper(right);\n                }\n\n                // as anything can be assigned to a String, Class or boolean, return the left type instead\n                if (STRING_TYPE.equals(initialType)\n                        || CLASS_Type.equals(initialType)\n                        || Boolean_TYPE.equals(initialType)\n                        || boolean_TYPE.equals(initialType)) {\n                    return initialType;\n                }\n            }\n            return right;\n        } else if (isBoolIntrinsicOp(op)) {\n            return boolean_TYPE;\n        } else if (isArrayOp(op)) {\n            // using getPNR() to ignore generics at this point\n            // and a different binary expression not to pollute the AST\n            BinaryExpression newExpr = binX(expr.getLeftExpression(), expr.getOperation(), rightExpression);\n            newExpr.setSourcePosition(expr);\n            MethodNode method = findMethodOrFail(newExpr, left.getPlainNodeReference(), \"getAt\", right.getPlainNodeReference());\n            if (method!=null && implementsInterfaceOrIsSubclassOf(right, RANGE_TYPE)) {\n                return inferReturnTypeGenerics(left, method, rightExpression);\n            }\n            return method!=null?inferComponentType(left, right):null;\n        } else if (op == FIND_REGEX) {\n            // this case always succeeds the result is a Matcher\n            return Matcher_TYPE;\n        }\n        // the left operand is determining the result of the operation\n        // for primitives and their wrapper we use a fixed table here\n        else if (isNumberType(leftRedirect) && isNumberType(rightRedirect)) {\n            if (isOperationInGroup(op)) {\n                if (isIntCategory(leftRedirect) && isIntCategory(rightRedirect)) return int_TYPE;\n                if (isLongCategory(leftRedirect) && isLongCategory(rightRedirect)) return long_TYPE;\n                if (isFloat(leftRedirect) && isFloat(rightRedirect)) return float_TYPE;\n                if (isDouble(leftRedirect) && isDouble(rightRedirect)) return double_TYPE;\n            } else if (isPowerOperator(op)) {\n                return Number_TYPE;\n            } else if (isBitOperator(op)) {\n                if (isIntCategory(getUnwrapper(leftRedirect)) && isIntCategory(getUnwrapper(rightRedirect))) return int_TYPE;\n                if (isLongCategory(getUnwrapper(leftRedirect)) && isLongCategory(getUnwrapper(rightRedirect))) return long_TYPE;\n                if (isBigIntCategory(getUnwrapper(leftRedirect)) && isBigIntCategory(getUnwrapper(rightRedirect))) return BigInteger_TYPE;\n            } else if (isCompareToBoolean(op) || op == COMPARE_EQUAL || op == COMPARE_NOT_EQUAL) {\n                return boolean_TYPE;\n            }\n        } else if (char_TYPE.equals(leftRedirect) && char_TYPE.equals(rightRedirect)) {\n            if (isCompareToBoolean(op) || op == COMPARE_EQUAL || op == COMPARE_NOT_EQUAL) {\n                return boolean_TYPE;\n            }\n        }\n\n\n        // try to find a method for the operation\n        String operationName = getOperationName(op);\n        if (isShiftOperation(operationName) && isNumberCategory(leftRedirect) && (isIntCategory(rightRedirect) || isLongCategory(rightRedirect))) {\n            return leftRedirect;\n        }\n\n        // Divisions may produce different results depending on operand types\n        if (isNumberCategory(getWrapper(rightRedirect)) && (isNumberCategory(getWrapper(leftRedirect)) && (DIVIDE == op || DIVIDE_EQUAL == op))) {\n            if (isFloatingCategory(leftRedirect) || isFloatingCategory(rightRedirect)) {\n                if (!isPrimitiveType(leftRedirect) || !isPrimitiveType(rightRedirect)) {\n                    return Double_TYPE;\n                }\n                return double_TYPE;\n            }\n            if (DIVIDE == op) {\n                return BigDecimal_TYPE;\n            }\n            return leftRedirect;\n        } else if (isOperationInGroup(op)) {\n            if (isNumberCategory(getWrapper(leftRedirect)) && isNumberCategory(getWrapper(rightRedirect))) {\n                return getGroupOperationResultType(leftRedirect, rightRedirect);\n            }\n        }\n        if (isNumberCategory(getWrapper(rightRedirect)) && isNumberCategory(getWrapper(leftRedirect)) && (MOD == op || MOD_EQUAL == op)) {\n            return leftRedirect;\n        }\n\n        // GROOVY-5890\n        // do not mix Class<Foo> with Foo\n        if (leftExpression instanceof ClassExpression) {\n            left = CLASS_Type.getPlainNodeReference();\n        }\n\n        MethodNode method = findMethodOrFail(expr, left, operationName, right);\n        if (method != null) {\n            storeTargetMethod(expr, method);\n            typeCheckMethodsWithGenericsOrFail(left, new ClassNode[]{right}, method, expr);\n            if (isAssignment(op)) return left;\n            if (isCompareToBoolean(op)) return boolean_TYPE;\n            if (op == COMPARE_TO) return int_TYPE;\n            return inferReturnTypeGenerics(left, method, args(rightExpression));\n        }\n        //TODO: other cases\n        return null;\n    }",
            "3592  \n3593  \n3594  \n3595  \n3596 +\n3597 +\n3598 +\n3599 +\n3600  \n3601  \n3602  \n3603  \n3604  \n3605 +\n3606  \n3607  \n3608  \n3609  \n3610  \n3611  \n3612  \n3613  \n3614  \n3615  \n3616  \n3617  \n3618  \n3619  \n3620  \n3621  \n3622  \n3623  \n3624  \n3625  \n3626  \n3627  \n3628  \n3629  \n3630  \n3631  \n3632  \n3633  \n3634  \n3635  \n3636  \n3637  \n3638  \n3639  \n3640  \n3641  \n3642  \n3643  \n3644  \n3645  \n3646  \n3647  \n3648  \n3649  \n3650  \n3651  \n3652  \n3653  \n3654  \n3655  \n3656  \n3657  \n3658  \n3659  \n3660  \n3661  \n3662  \n3663  \n3664  \n3665  \n3666  \n3667  \n3668  \n3669  \n3670  \n3671  \n3672  \n3673  \n3674  \n3675  \n3676  \n3677  \n3678  \n3679  \n3680  \n3681  \n3682  \n3683  \n3684  \n3685  \n3686  \n3687  \n3688  \n3689  \n3690  \n3691  \n3692  \n3693  \n3694  \n3695  \n3696  \n3697  \n3698  \n3699  \n3700  \n3701  \n3702  \n3703  \n3704  \n3705  \n3706  \n3707  \n3708  \n3709  \n3710  \n3711  \n3712  \n3713  \n3714  \n3715  \n3716  \n3717  \n3718  \n3719  \n3720  \n3721  \n3722  \n3723  \n3724  \n3725  ",
            "    protected ClassNode getResultType(ClassNode left, int op, ClassNode right, BinaryExpression expr) {\n        ClassNode leftRedirect = left.redirect();\n        ClassNode rightRedirect = right.redirect();\n\n        if (op == COMPARE_NOT_IDENTICAL || op == COMPARE_IDENTICAL) {\n            return boolean_TYPE;\n        }\n\n        Expression leftExpression = expr.getLeftExpression();\n        Expression rightExpression = expr.getRightExpression();\n        if (op == ASSIGN || op == ASSIGNMENT_OPERATOR || op == ELVIS_EQUAL) {\n            if (leftRedirect.isArray() && implementsInterfaceOrIsSubclassOf(rightRedirect, Collection_TYPE)) return leftRedirect;\n            if (leftRedirect.implementsInterface(Collection_TYPE) && rightRedirect.implementsInterface(Collection_TYPE)) {\n                // because of type inference, we must perform an additional check if the right expression\n                // is an empty list expression ([]). In that case and only in that case, the inferred type\n                // will be wrong, so we will prefer the left type\n                if (rightExpression instanceof ListExpression) {\n                    List<Expression> list = ((ListExpression) rightExpression).getExpressions();\n                    if (list.isEmpty()) return left;\n                }\n                return right;\n            }\n            if (rightRedirect.implementsInterface(Collection_TYPE) && rightRedirect.isDerivedFrom(leftRedirect)) {\n                // ex : def foos = ['a','b','c']\n                return right;\n            }\n            if (rightRedirect.isDerivedFrom(CLOSURE_TYPE) && isSAMType(leftRedirect) && rightExpression instanceof ClosureExpression) {\n                return inferSAMTypeGenericsInAssignment(left, findSAM(left),right,(ClosureExpression) rightExpression);\n            }\n\n            if (leftExpression instanceof VariableExpression) {\n                ClassNode initialType = getOriginalDeclarationType(leftExpression).redirect();\n                if (isPrimitiveType(right) && initialType.isDerivedFrom(Number_TYPE)) {\n                    return getWrapper(right);\n                }\n\n                if (isPrimitiveType(initialType) && rightRedirect.isDerivedFrom(Number_TYPE))  {\n                    return getUnwrapper(right);\n                }\n\n                // as anything can be assigned to a String, Class or boolean, return the left type instead\n                if (STRING_TYPE.equals(initialType)\n                        || CLASS_Type.equals(initialType)\n                        || Boolean_TYPE.equals(initialType)\n                        || boolean_TYPE.equals(initialType)) {\n                    return initialType;\n                }\n            }\n            return right;\n        } else if (isBoolIntrinsicOp(op)) {\n            return boolean_TYPE;\n        } else if (isArrayOp(op)) {\n            // using getPNR() to ignore generics at this point\n            // and a different binary expression not to pollute the AST\n            BinaryExpression newExpr = binX(expr.getLeftExpression(), expr.getOperation(), rightExpression);\n            newExpr.setSourcePosition(expr);\n            MethodNode method = findMethodOrFail(newExpr, left.getPlainNodeReference(), \"getAt\", right.getPlainNodeReference());\n            if (method!=null && implementsInterfaceOrIsSubclassOf(right, RANGE_TYPE)) {\n                return inferReturnTypeGenerics(left, method, rightExpression);\n            }\n            return method!=null?inferComponentType(left, right):null;\n        } else if (op == FIND_REGEX) {\n            // this case always succeeds the result is a Matcher\n            return Matcher_TYPE;\n        }\n        // the left operand is determining the result of the operation\n        // for primitives and their wrapper we use a fixed table here\n        else if (isNumberType(leftRedirect) && isNumberType(rightRedirect)) {\n            if (isOperationInGroup(op)) {\n                if (isIntCategory(leftRedirect) && isIntCategory(rightRedirect)) return int_TYPE;\n                if (isLongCategory(leftRedirect) && isLongCategory(rightRedirect)) return long_TYPE;\n                if (isFloat(leftRedirect) && isFloat(rightRedirect)) return float_TYPE;\n                if (isDouble(leftRedirect) && isDouble(rightRedirect)) return double_TYPE;\n            } else if (isPowerOperator(op)) {\n                return Number_TYPE;\n            } else if (isBitOperator(op)) {\n                if (isIntCategory(getUnwrapper(leftRedirect)) && isIntCategory(getUnwrapper(rightRedirect))) return int_TYPE;\n                if (isLongCategory(getUnwrapper(leftRedirect)) && isLongCategory(getUnwrapper(rightRedirect))) return long_TYPE;\n                if (isBigIntCategory(getUnwrapper(leftRedirect)) && isBigIntCategory(getUnwrapper(rightRedirect))) return BigInteger_TYPE;\n            } else if (isCompareToBoolean(op) || op == COMPARE_EQUAL || op == COMPARE_NOT_EQUAL) {\n                return boolean_TYPE;\n            }\n        } else if (char_TYPE.equals(leftRedirect) && char_TYPE.equals(rightRedirect)) {\n            if (isCompareToBoolean(op) || op == COMPARE_EQUAL || op == COMPARE_NOT_EQUAL) {\n                return boolean_TYPE;\n            }\n        }\n\n\n        // try to find a method for the operation\n        String operationName = getOperationName(op);\n        if (isShiftOperation(operationName) && isNumberCategory(leftRedirect) && (isIntCategory(rightRedirect) || isLongCategory(rightRedirect))) {\n            return leftRedirect;\n        }\n\n        // Divisions may produce different results depending on operand types\n        if (isNumberCategory(getWrapper(rightRedirect)) && (isNumberCategory(getWrapper(leftRedirect)) && (DIVIDE == op || DIVIDE_EQUAL == op))) {\n            if (isFloatingCategory(leftRedirect) || isFloatingCategory(rightRedirect)) {\n                if (!isPrimitiveType(leftRedirect) || !isPrimitiveType(rightRedirect)) {\n                    return Double_TYPE;\n                }\n                return double_TYPE;\n            }\n            if (DIVIDE == op) {\n                return BigDecimal_TYPE;\n            }\n            return leftRedirect;\n        } else if (isOperationInGroup(op)) {\n            if (isNumberCategory(getWrapper(leftRedirect)) && isNumberCategory(getWrapper(rightRedirect))) {\n                return getGroupOperationResultType(leftRedirect, rightRedirect);\n            }\n        }\n        if (isNumberCategory(getWrapper(rightRedirect)) && isNumberCategory(getWrapper(leftRedirect)) && (MOD == op || MOD_EQUAL == op)) {\n            return leftRedirect;\n        }\n\n        // GROOVY-5890\n        // do not mix Class<Foo> with Foo\n        if (leftExpression instanceof ClassExpression) {\n            left = CLASS_Type.getPlainNodeReference();\n        }\n\n        MethodNode method = findMethodOrFail(expr, left, operationName, right);\n        if (method != null) {\n            storeTargetMethod(expr, method);\n            typeCheckMethodsWithGenericsOrFail(left, new ClassNode[]{right}, method, expr);\n            if (isAssignment(op)) return left;\n            if (isCompareToBoolean(op)) return boolean_TYPE;\n            if (op == COMPARE_TO) return int_TYPE;\n            return inferReturnTypeGenerics(left, method, args(rightExpression));\n        }\n        //TODO: other cases\n        return null;\n    }"
        ]
    ],
    "802c4d6e58adaefc0c009790ef165bc61f8af3db": [
        [
            "TupleConstructorASTTransformation::createConstructor(ClassNode,boolean,boolean,boolean,boolean,boolean,boolean,List,List)",
            " 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164 -\n 165 -\n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  ",
            "    public static void createConstructor(ClassNode cNode, boolean includeFields, boolean includeProperties, boolean includeSuperFields, boolean includeSuperProperties, boolean callSuper, boolean force, List<String> excludes, List<String> includes) {\r\n        // no processing if existing constructors found\r\n        List<ConstructorNode> constructors = cNode.getDeclaredConstructors();\r\n        if (constructors.size() > 1 && !force) return;\r\n        boolean foundEmpty = constructors.size() == 1 && constructors.get(0).getFirstStatement() == null;\r\n        if (constructors.size() == 1 && !foundEmpty && !force) return;\r\n        // HACK: JavaStubGenerator could have snuck in a constructor we don't want\r\n        if (foundEmpty) constructors.remove(0);\r\n\r\n        List<FieldNode> superList = new ArrayList<FieldNode>();\r\n        if (includeSuperProperties) {\r\n            superList.addAll(getSuperPropertyFields(cNode.getSuperClass()));\r\n        }\r\n        if (includeSuperFields) {\r\n            superList.addAll(getSuperNonPropertyFields(cNode.getSuperClass()));\r\n        }\r\n\r\n        List<FieldNode> list = new ArrayList<FieldNode>();\r\n        if (includeProperties) {\r\n            list.addAll(getInstancePropertyFields(cNode));\r\n        }\r\n        if (includeFields) {\r\n            list.addAll(getInstanceNonPropertyFields(cNode));\r\n        }\r\n\r\n        final List<Parameter> params = new ArrayList<Parameter>();\r\n        final List<Expression> superParams = new ArrayList<Expression>();\r\n        final BlockStatement body = new BlockStatement();\r\n        for (FieldNode fNode : superList) {\r\n            String name = fNode.getName();\r\n            if (shouldSkip(name, excludes, includes)) continue;\r\n            params.add(createParam(fNode, name));\r\n            if (callSuper) {\r\n                superParams.add(varX(name));\r\n            } else {\r\n                body.addStatement(assignS(propX(varX(\"this\"), name), varX(name)));\r\n            }\r\n        }\r\n        if (callSuper) {\r\n            body.addStatement(stmt(ctorX(ClassNode.SUPER, args(superParams))));\r\n        }\r\n        for (FieldNode fNode : list) {\r\n            String name = fNode.getName();\r\n            if (shouldSkip(name, excludes, includes)) continue;\r\n            params.add(createParam(fNode, name));\r\n            body.addStatement(assignS(propX(varX(\"this\"), name), varX(name)));\r\n        }\r\n        cNode.addConstructor(new ConstructorNode(ACC_PUBLIC, params.toArray(new Parameter[params.size()]), ClassNode.EMPTY_ARRAY, body));\r\n        // add map constructor if needed, don't do it for LinkedHashMap for now (would lead to duplicate signature)\r\n        // or if there is only one Map property (for backwards compatibility)\r\n        if (params.size() > 0) {\r\n            ClassNode firstParam = params.get(0).getType();\r\n            if (params.size() > 1 || firstParam.equals(ClassHelper.OBJECT_TYPE)) {\r\n                if (firstParam.equals(ClassHelper.MAP_TYPE)) {\r\n                    addMapConstructors(cNode, true, \"The class \" + cNode.getName() + \" was incorrectly initialized via the map constructor with null.\");\r\n                } else {\r\n                    ClassNode candidate = HMAP_TYPE;\r\n                    while (candidate != null) {\r\n                        if (candidate.equals(firstParam)) {\r\n                            addMapConstructors(cNode, true, \"The class \" + cNode.getName() + \" was incorrectly initialized via the map constructor with null.\");\r\n                            break;\r\n                        }\r\n                        candidate = candidate.getSuperClass();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r",
            " 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164 +\n 165 +\n 166 +\n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  ",
            "    public static void createConstructor(ClassNode cNode, boolean includeFields, boolean includeProperties, boolean includeSuperFields, boolean includeSuperProperties, boolean callSuper, boolean force, List<String> excludes, List<String> includes) {\r\n        // no processing if existing constructors found\r\n        List<ConstructorNode> constructors = cNode.getDeclaredConstructors();\r\n        if (constructors.size() > 1 && !force) return;\r\n        boolean foundEmpty = constructors.size() == 1 && constructors.get(0).getFirstStatement() == null;\r\n        if (constructors.size() == 1 && !foundEmpty && !force) return;\r\n        // HACK: JavaStubGenerator could have snuck in a constructor we don't want\r\n        if (foundEmpty) constructors.remove(0);\r\n\r\n        List<FieldNode> superList = new ArrayList<FieldNode>();\r\n        if (includeSuperProperties) {\r\n            superList.addAll(getSuperPropertyFields(cNode.getSuperClass()));\r\n        }\r\n        if (includeSuperFields) {\r\n            superList.addAll(getSuperNonPropertyFields(cNode.getSuperClass()));\r\n        }\r\n\r\n        List<FieldNode> list = new ArrayList<FieldNode>();\r\n        if (includeProperties) {\r\n            list.addAll(getInstancePropertyFields(cNode));\r\n        }\r\n        if (includeFields) {\r\n            list.addAll(getInstanceNonPropertyFields(cNode));\r\n        }\r\n\r\n        final List<Parameter> params = new ArrayList<Parameter>();\r\n        final List<Expression> superParams = new ArrayList<Expression>();\r\n        final BlockStatement body = new BlockStatement();\r\n        for (FieldNode fNode : superList) {\r\n            String name = fNode.getName();\r\n            if (shouldSkip(name, excludes, includes)) continue;\r\n            params.add(createParam(fNode, name));\r\n            if (callSuper) {\r\n                superParams.add(varX(name));\r\n            } else {\r\n                body.addStatement(assignS(propX(varX(\"this\"), name), varX(name)));\r\n            }\r\n        }\r\n        if (callSuper) {\r\n            body.addStatement(stmt(ctorX(ClassNode.SUPER, args(superParams))));\r\n        }\r\n        for (FieldNode fNode : list) {\r\n            String name = fNode.getName();\r\n            if (shouldSkip(name, excludes, includes)) continue;\r\n            Parameter nextParam = createParam(fNode, name);\r\n            params.add(nextParam);\r\n            body.addStatement(assignS(propX(varX(\"this\"), name), varX(nextParam)));\r\n        }\r\n        cNode.addConstructor(new ConstructorNode(ACC_PUBLIC, params.toArray(new Parameter[params.size()]), ClassNode.EMPTY_ARRAY, body));\r\n        // add map constructor if needed, don't do it for LinkedHashMap for now (would lead to duplicate signature)\r\n        // or if there is only one Map property (for backwards compatibility)\r\n        if (params.size() > 0) {\r\n            ClassNode firstParam = params.get(0).getType();\r\n            if (params.size() > 1 || firstParam.equals(ClassHelper.OBJECT_TYPE)) {\r\n                if (firstParam.equals(ClassHelper.MAP_TYPE)) {\r\n                    addMapConstructors(cNode, true, \"The class \" + cNode.getName() + \" was incorrectly initialized via the map constructor with null.\");\r\n                } else {\r\n                    ClassNode candidate = HMAP_TYPE;\r\n                    while (candidate != null) {\r\n                        if (candidate.equals(firstParam)) {\r\n                            addMapConstructors(cNode, true, \"The class \" + cNode.getName() + \" was incorrectly initialized via the map constructor with null.\");\r\n                            break;\r\n                        }\r\n                        candidate = candidate.getSuperClass();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r"
        ]
    ],
    "de59288028f41460a7d0aaa57e58d32e1ef7327e": [
        [
            "AsmClassGenerator::visitAttributeOrProperty(PropertyExpression,MethodCallerMultiAdapter)",
            " 835  \n 836  \n 837  \n 838  \n 839  \n 840  \n 841  \n 842  \n 843  \n 844  \n 845  \n 846  \n 847  \n 848  \n 849  \n 850  \n 851  \n 852  \n 853  \n 854  \n 855  \n 856  \n 857  \n 858  \n 859  \n 860  \n 861  \n 862  \n 863  \n 864  \n 865  \n 866  \n 867  \n 868  \n 869  \n 870  \n 871  \n 872  \n 873  \n 874  \n 875  \n 876  \n 877  \n 878  \n 879  \n 880  \n 881  \n 882  \n 883  \n 884  \n 885  \n 886  \n 887  \n 888  \n 889  \n 890  \n 891  \n 892  \n 893  \n 894  \n 895  \n 896  \n 897  \n 898  \n 899  \n 900  \n 901  \n 902  \n 903  \n 904  \n 905  \n 906  \n 907  \n 908  \n 909  \n 910  \n 911  \n 912  \n 913  \n 914  \n 915  \n 916  \n 917  \n 918  \n 919  \n 920  \n 921  \n 922  \n 923  \n 924  \n 925  \n 926  \n 927  \n 928  \n 929  \n 930  \n 931  \n 932  \n 933 -\n 934  \n 935  \n 936  \n 937  \n 938  \n 939  \n 940  \n 941  \n 942  \n 943  \n 944  \n 945  \n 946  \n 947  \n 948  \n 949  \n 950  \n 951  \n 952  \n 953  \n 954  \n 955  \n 956  \n 957  \n 958  \n 959  \n 960  ",
            "    private void visitAttributeOrProperty(PropertyExpression expression, MethodCallerMultiAdapter adapter) {\n        MethodVisitor mv = controller.getMethodVisitor();\n\n        Expression objectExpression = expression.getObjectExpression();\n        ClassNode classNode = controller.getClassNode();\n        if (isThisOrSuper(objectExpression)) {\n            // let's use the field expression if it's available\n            String name = expression.getPropertyAsString();\n            if (name != null) {\n                FieldNode field = null;\n                boolean privateSuperField = false;\n                if (isSuperExpression(objectExpression)) {\n                    field = classNode.getSuperClass().getDeclaredField(name);\n                    if (field != null && ((field.getModifiers() & ACC_PRIVATE) != 0)) {\n                        privateSuperField = true;\n                    }\n                } else {\n                \tif (controller.isNotExplicitThisInClosure(expression.isImplicitThis())) {\n                        field = classNode.getDeclaredField(name);\n                        if (field==null && classNode instanceof InnerClassNode) {\n                            ClassNode outer = classNode.getOuterClass();\n                            FieldNode outerClassField;\n                            while (outer!=null) {\n                                outerClassField = outer.getDeclaredField(name);\n                                if (outerClassField!=null && outerClassField.isStatic() && outerClassField.isFinal()) {\n                                    if (outer!=classNode.getOuterClass() && Modifier.isPrivate(outerClassField.getModifiers())) {\n                                        throw new GroovyBugError(\"Trying to access private constant field [\"+outerClassField.getDeclaringClass()+\"#\"+outerClassField.getName()+\"] from inner class\");\n                                    }\n                                    PropertyExpression pexp = new PropertyExpression(\n                                            new ClassExpression(outer),\n                                            expression.getProperty()\n                                    );\n                                    pexp.visit(controller.getAcg());\n                                    return;\n                                }\n                                outer = outer.getSuperClass();\n                            }\n                        }\n                        if (field==null\n                                && expression instanceof AttributeExpression\n                                && isThisExpression(objectExpression)\n                                && controller.isStaticContext()) {\n                            // GROOVY-6183\n                            ClassNode current = classNode.getSuperClass();\n                            while (field==null && current!=null) {\n                                field = current.getDeclaredField(name);\n                                current = current.getSuperClass();\n                            }\n                            if (field!=null && (field.isProtected() || field.isPublic())) {\n                                visitFieldExpression(new FieldExpression(field));\n                                return;\n                            }\n                        }\n                \t}\n                }\n                if (field != null && !privateSuperField) {//GROOVY-4497: don't visit super field if it is private\n                    visitFieldExpression(new FieldExpression(field));\n                    return;\n                }\n            }\n            if (isSuperExpression(objectExpression)) {\n                String prefix;\n                if (controller.getCompileStack().isLHS()) {\n                    prefix = \"set\";\n                } else {\n                    prefix = \"get\";\n                }\n                String propName = prefix + MetaClassHelper.capitalize(name);\n                visitMethodCallExpression(new MethodCallExpression(objectExpression, propName, MethodCallExpression.NO_ARGUMENTS));\n                return;\n            }\n        }\n\n        final String propName = expression.getPropertyAsString();\n        //TODO: add support for super here too\n        if (expression.getObjectExpression() instanceof ClassExpression &&\n            propName!=null && propName.equals(\"this\"))\n        {\n            // we have something like A.B.this, and need to make it\n            // into this.this$0.this$0, where this.this$0 returns\n            // A.B and this.this$0.this$0 return A.\n            ClassNode type = objectExpression.getType();\n            ClassNode iterType = classNode;\n            if (controller.getCompileStack().isInSpecialConstructorCall() && classNode instanceof InnerClassNode) {\n                boolean staticInnerClass = classNode.isStaticClass();\n                // Outer.this in a special constructor call\n                if (classNode.getOuterClass().equals(type)) {\n                    ConstructorNode ctor = controller.getConstructorNode();\n                    Expression receiver = !staticInnerClass ? new VariableExpression(ctor.getParameters()[0]) : new ClassExpression(type);\n                    receiver.setSourcePosition(expression);\n                    receiver.visit(this);\n                    return;\n                }\n            }\n            mv.visitVarInsn(ALOAD, 0);\n            while (!iterType.equals(type)) {\n                String ownerName = BytecodeHelper.getClassInternalName(iterType);\n                if (iterType.getOuterClass()==null) break;\n                ClassNode thisFieldType = iterType.getField(\"this$0\").getType();\n                iterType = iterType.getOuterClass();\n                if (ClassHelper.CLOSURE_TYPE.equals(thisFieldType)) {\n                    mv.visitFieldInsn(GETFIELD, ownerName, \"this$0\", BytecodeHelper.getTypeDescription(ClassHelper.CLOSURE_TYPE));\n                    mv.visitMethodInsn(INVOKEVIRTUAL, BytecodeHelper.getClassInternalName(ClassHelper.CLOSURE_TYPE), \"getThisObject\", \"()Ljava/lang/Object;\", false);\n                    mv.visitTypeInsn(CHECKCAST, BytecodeHelper.getClassInternalName(iterType));\n                } else {\n                    String typeName = BytecodeHelper.getTypeDescription(iterType);\n                    mv.visitFieldInsn(GETFIELD, ownerName, \"this$0\", typeName);\n                }\n            }\n            controller.getOperandStack().push(type);\n            return;\n        }\n\n        if (adapter == getProperty && !expression.isSpreadSafe() && propName != null) {\n            controller.getCallSiteWriter().makeGetPropertySite(objectExpression, propName, expression.isSafe(), expression.isImplicitThis());\n        } else if (adapter == getGroovyObjectProperty && !expression.isSpreadSafe() && propName != null) {\n            controller.getCallSiteWriter().makeGroovyObjectGetPropertySite(objectExpression, propName, expression.isSafe(), expression.isImplicitThis());\n        } else {\n            // todo: for improved modularity and extensibility, this should be moved into a writer\n            if (controller.getCompileStack().isLHS()) controller.getOperandStack().box();\n            controller.getInvocationWriter().makeCall(\n                    expression,\n                    objectExpression, // receiver\n                    new CastExpression(ClassHelper.STRING_TYPE, expression.getProperty()), // messageName\n                    MethodCallExpression.NO_ARGUMENTS, adapter,\n                    expression.isSafe(), expression.isSpreadSafe(), expression.isImplicitThis()",
            " 835  \n 836  \n 837  \n 838  \n 839  \n 840  \n 841  \n 842  \n 843  \n 844  \n 845  \n 846  \n 847  \n 848  \n 849  \n 850  \n 851  \n 852  \n 853  \n 854  \n 855  \n 856  \n 857  \n 858  \n 859  \n 860  \n 861  \n 862  \n 863  \n 864  \n 865  \n 866  \n 867  \n 868  \n 869  \n 870  \n 871  \n 872  \n 873  \n 874  \n 875  \n 876  \n 877  \n 878  \n 879  \n 880  \n 881  \n 882  \n 883  \n 884  \n 885  \n 886  \n 887  \n 888  \n 889  \n 890  \n 891  \n 892  \n 893  \n 894  \n 895  \n 896  \n 897  \n 898  \n 899  \n 900  \n 901  \n 902  \n 903  \n 904  \n 905  \n 906  \n 907  \n 908  \n 909  \n 910  \n 911  \n 912  \n 913  \n 914  \n 915  \n 916  \n 917  \n 918  \n 919  \n 920  \n 921  \n 922  \n 923  \n 924  \n 925  \n 926  \n 927  \n 928  \n 929  \n 930  \n 931  \n 932  \n 933 +\n 934 +\n 935 +\n 936  \n 937  \n 938  \n 939  \n 940  \n 941  \n 942  \n 943  \n 944  \n 945  \n 946  \n 947  \n 948  \n 949  \n 950  \n 951  \n 952  \n 953  \n 954  \n 955  \n 956  \n 957  \n 958  \n 959  \n 960  \n 961  \n 962  ",
            "    private void visitAttributeOrProperty(PropertyExpression expression, MethodCallerMultiAdapter adapter) {\n        MethodVisitor mv = controller.getMethodVisitor();\n\n        Expression objectExpression = expression.getObjectExpression();\n        ClassNode classNode = controller.getClassNode();\n        if (isThisOrSuper(objectExpression)) {\n            // let's use the field expression if it's available\n            String name = expression.getPropertyAsString();\n            if (name != null) {\n                FieldNode field = null;\n                boolean privateSuperField = false;\n                if (isSuperExpression(objectExpression)) {\n                    field = classNode.getSuperClass().getDeclaredField(name);\n                    if (field != null && ((field.getModifiers() & ACC_PRIVATE) != 0)) {\n                        privateSuperField = true;\n                    }\n                } else {\n                \tif (controller.isNotExplicitThisInClosure(expression.isImplicitThis())) {\n                        field = classNode.getDeclaredField(name);\n                        if (field==null && classNode instanceof InnerClassNode) {\n                            ClassNode outer = classNode.getOuterClass();\n                            FieldNode outerClassField;\n                            while (outer!=null) {\n                                outerClassField = outer.getDeclaredField(name);\n                                if (outerClassField!=null && outerClassField.isStatic() && outerClassField.isFinal()) {\n                                    if (outer!=classNode.getOuterClass() && Modifier.isPrivate(outerClassField.getModifiers())) {\n                                        throw new GroovyBugError(\"Trying to access private constant field [\"+outerClassField.getDeclaringClass()+\"#\"+outerClassField.getName()+\"] from inner class\");\n                                    }\n                                    PropertyExpression pexp = new PropertyExpression(\n                                            new ClassExpression(outer),\n                                            expression.getProperty()\n                                    );\n                                    pexp.visit(controller.getAcg());\n                                    return;\n                                }\n                                outer = outer.getSuperClass();\n                            }\n                        }\n                        if (field==null\n                                && expression instanceof AttributeExpression\n                                && isThisExpression(objectExpression)\n                                && controller.isStaticContext()) {\n                            // GROOVY-6183\n                            ClassNode current = classNode.getSuperClass();\n                            while (field==null && current!=null) {\n                                field = current.getDeclaredField(name);\n                                current = current.getSuperClass();\n                            }\n                            if (field!=null && (field.isProtected() || field.isPublic())) {\n                                visitFieldExpression(new FieldExpression(field));\n                                return;\n                            }\n                        }\n                \t}\n                }\n                if (field != null && !privateSuperField) {//GROOVY-4497: don't visit super field if it is private\n                    visitFieldExpression(new FieldExpression(field));\n                    return;\n                }\n            }\n            if (isSuperExpression(objectExpression)) {\n                String prefix;\n                if (controller.getCompileStack().isLHS()) {\n                    prefix = \"set\";\n                } else {\n                    prefix = \"get\";\n                }\n                String propName = prefix + MetaClassHelper.capitalize(name);\n                visitMethodCallExpression(new MethodCallExpression(objectExpression, propName, MethodCallExpression.NO_ARGUMENTS));\n                return;\n            }\n        }\n\n        final String propName = expression.getPropertyAsString();\n        //TODO: add support for super here too\n        if (expression.getObjectExpression() instanceof ClassExpression &&\n            propName!=null && propName.equals(\"this\"))\n        {\n            // we have something like A.B.this, and need to make it\n            // into this.this$0.this$0, where this.this$0 returns\n            // A.B and this.this$0.this$0 return A.\n            ClassNode type = objectExpression.getType();\n            ClassNode iterType = classNode;\n            if (controller.getCompileStack().isInSpecialConstructorCall() && classNode instanceof InnerClassNode) {\n                boolean staticInnerClass = classNode.isStaticClass();\n                // Outer.this in a special constructor call\n                if (classNode.getOuterClass().equals(type)) {\n                    ConstructorNode ctor = controller.getConstructorNode();\n                    Expression receiver = !staticInnerClass ? new VariableExpression(ctor.getParameters()[0]) : new ClassExpression(type);\n                    receiver.setSourcePosition(expression);\n                    receiver.visit(this);\n                    return;\n                }\n            }\n            mv.visitVarInsn(ALOAD, 0);\n            while (!iterType.equals(type)) {\n                String ownerName = BytecodeHelper.getClassInternalName(iterType);\n                if (iterType.getOuterClass()==null) break;\n                FieldNode thisField = iterType.getField(\"this$0\");\n                if (thisField==null) break;\n                ClassNode thisFieldType = thisField.getType();\n                iterType = iterType.getOuterClass();\n                if (ClassHelper.CLOSURE_TYPE.equals(thisFieldType)) {\n                    mv.visitFieldInsn(GETFIELD, ownerName, \"this$0\", BytecodeHelper.getTypeDescription(ClassHelper.CLOSURE_TYPE));\n                    mv.visitMethodInsn(INVOKEVIRTUAL, BytecodeHelper.getClassInternalName(ClassHelper.CLOSURE_TYPE), \"getThisObject\", \"()Ljava/lang/Object;\", false);\n                    mv.visitTypeInsn(CHECKCAST, BytecodeHelper.getClassInternalName(iterType));\n                } else {\n                    String typeName = BytecodeHelper.getTypeDescription(iterType);\n                    mv.visitFieldInsn(GETFIELD, ownerName, \"this$0\", typeName);\n                }\n            }\n            controller.getOperandStack().push(type);\n            return;\n        }\n\n        if (adapter == getProperty && !expression.isSpreadSafe() && propName != null) {\n            controller.getCallSiteWriter().makeGetPropertySite(objectExpression, propName, expression.isSafe(), expression.isImplicitThis());\n        } else if (adapter == getGroovyObjectProperty && !expression.isSpreadSafe() && propName != null) {\n            controller.getCallSiteWriter().makeGroovyObjectGetPropertySite(objectExpression, propName, expression.isSafe(), expression.isImplicitThis());\n        } else {\n            // todo: for improved modularity and extensibility, this should be moved into a writer\n            if (controller.getCompileStack().isLHS()) controller.getOperandStack().box();\n            controller.getInvocationWriter().makeCall(\n                    expression,\n                    objectExpression, // receiver\n                    new CastExpression(ClassHelper.STRING_TYPE, expression.getProperty()), // messageName\n                    MethodCallExpression.NO_ARGUMENTS, adapter,\n                    expression.isSafe(), expression.isSpreadSafe(), expression.isImplicitThis()"
        ]
    ],
    "4971552b85e5c12d4ebf49ddac181523c5160baa": [
        [
            "StaticTypesCallSiteWriter::makeSingleArgumentCall(Expression,String,Expression)",
            " 623  \n 624  \n 625  \n 626  \n 627  \n 628  \n 629  \n 630  \n 631  \n 632  \n 633  \n 634  \n 635  \n 636  \n 637  \n 638  \n 639  \n 640  \n 641  \n 642  \n 643  ",
            "    @Override\n    public void makeSingleArgumentCall(final Expression receiver, final String message, final Expression arguments) {\n        TypeChooser typeChooser = controller.getTypeChooser();\n        ClassNode classNode = controller.getClassNode();\n        ClassNode rType = typeChooser.resolveType(receiver, classNode);\n        ClassNode aType = typeChooser.resolveType(arguments, classNode);\n        if (trySubscript(receiver, message, arguments, rType, aType)) {\n            return;\n        }\n        // now try with flow type instead of declaration type\n        rType = receiver.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);\n        if (rType!=null && trySubscript(receiver, message, arguments, rType, aType)) {\n            return;\n        }\n        // todo: more cases\n        throw new GroovyBugError(\n                \"At line \" + receiver.getLineNumber() + \" column \" + receiver.getColumnNumber() + \"\\n\" +\n                \"On receiver: \" + receiver.getText() + \" with message: \" + message + \" and arguments: \" + arguments.getText() + \"\\n\" +\n                \"This method should not have been called. Please try to create a simple example reproducing\\n\" +\n                \"this error and file a bug report at https://issues.apache.org/jira/browse/GROOVY\");\n    }",
            " 623  \n 624  \n 625  \n 626  \n 627  \n 628  \n 629  \n 630  \n 631  \n 632  \n 633  \n 634 +\n 635 +\n 636 +\n 637 +\n 638 +\n 639  \n 640  \n 641  \n 642  \n 643  \n 644  \n 645  \n 646  \n 647  \n 648  ",
            "    @Override\n    public void makeSingleArgumentCall(final Expression receiver, final String message, final Expression arguments) {\n        TypeChooser typeChooser = controller.getTypeChooser();\n        ClassNode classNode = controller.getClassNode();\n        ClassNode rType = typeChooser.resolveType(receiver, classNode);\n        ClassNode aType = typeChooser.resolveType(arguments, classNode);\n        if (trySubscript(receiver, message, arguments, rType, aType)) {\n            return;\n        }\n        // now try with flow type instead of declaration type\n        rType = receiver.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);\n        if (receiver instanceof VariableExpression && receiver.getNodeMetaData().isEmpty()) {\n            // TODO: can STCV be made smarter to avoid this check?\n            VariableExpression ve = (VariableExpression) ((VariableExpression)receiver).getAccessedVariable();\n            rType = ve.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);\n        }\n        if (rType!=null && trySubscript(receiver, message, arguments, rType, aType)) {\n            return;\n        }\n        // todo: more cases\n        throw new GroovyBugError(\n                \"At line \" + receiver.getLineNumber() + \" column \" + receiver.getColumnNumber() + \"\\n\" +\n                \"On receiver: \" + receiver.getText() + \" with message: \" + message + \" and arguments: \" + arguments.getText() + \"\\n\" +\n                \"This method should not have been called. Please try to create a simple example reproducing\\n\" +\n                \"this error and file a bug report at https://issues.apache.org/jira/browse/GROOVY\");\n    }"
        ]
    ],
    "690d1e4870c4107e78bfb05fc0fa23886c3cddd1": [
        [
            "ASTTransformationCollectorCodeVisitor::visitAnnotations(AnnotatedNode)",
            "  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102 -\n 103 -\n 104 -\n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  ",
            "    /**\n     * If the annotation is annotated with {@link GroovyASTTransformation}\n     * the annotation is added to <code>stageVisitors</code> at the appropriate processor visitor.\n     *\n     * @param node the node to process\n     */\n    public void visitAnnotations(AnnotatedNode node) {\n        super.visitAnnotations(node);\n\n        Map<Integer, List<AnnotationNode>> existing = new TreeMap<Integer, List<AnnotationNode>>();\n        Map<Integer, List<AnnotationNode>> replacements = new LinkedHashMap<Integer, List<AnnotationNode>>();\n        Map<Integer, AnnotationCollectorMode> modes = new LinkedHashMap<Integer, AnnotationCollectorMode>();\n        int index = 0;\n        for (AnnotationNode annotation : node.getAnnotations()) {\n            findCollectedAnnotations(annotation, node, index, modes, existing, replacements);\n            index++;\n        }\n        for (Integer replacementIndex : replacements.keySet()) {\n            mergeCollectedAnnotations(modes.get(replacementIndex), existing, replacements.get(replacementIndex));\n            existing.put(replacementIndex, replacements.get(replacementIndex));\n        }\n        List<AnnotationNode> mergedList = new ArrayList<AnnotationNode>();\n        for (List<AnnotationNode> next : existing.values()) {\n            mergedList.addAll(next);\n        }\n\n        node.getAnnotations().clear();\n        node.getAnnotations().addAll(mergedList);\n\n        for (AnnotationNode annotation : node.getAnnotations()) {\n            Annotation transformClassAnnotation = getTransformClassAnnotation(annotation.getClassNode());\n            if (transformClassAnnotation == null) {\n                // skip if there is no such annotation\n                continue;\n            }\n            addTransformsToClassNode(annotation, transformClassAnnotation);\n        }\n    }",
            "  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102 +\n 103 +\n 104 +\n 105 +\n 106 +\n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  ",
            "    /**\n     * If the annotation is annotated with {@link GroovyASTTransformation}\n     * the annotation is added to <code>stageVisitors</code> at the appropriate processor visitor.\n     *\n     * @param node the node to process\n     */\n    public void visitAnnotations(AnnotatedNode node) {\n        super.visitAnnotations(node);\n\n        Map<Integer, List<AnnotationNode>> existing = new TreeMap<Integer, List<AnnotationNode>>();\n        Map<Integer, List<AnnotationNode>> replacements = new LinkedHashMap<Integer, List<AnnotationNode>>();\n        Map<Integer, AnnotationCollectorMode> modes = new LinkedHashMap<Integer, AnnotationCollectorMode>();\n        int index = 0;\n        for (AnnotationNode annotation : node.getAnnotations()) {\n            findCollectedAnnotations(annotation, node, index, modes, existing, replacements);\n            index++;\n        }\n        for (Map.Entry<Integer, List<AnnotationNode>> entry : replacements.entrySet()) {\n            Integer replacementIndex = entry.getKey();\n            List<AnnotationNode> annotationNodeList = entry.getValue();\n            mergeCollectedAnnotations(modes.get(replacementIndex), existing, annotationNodeList);\n            existing.put(replacementIndex, annotationNodeList);\n        }\n        List<AnnotationNode> mergedList = new ArrayList<AnnotationNode>();\n        for (List<AnnotationNode> next : existing.values()) {\n            mergedList.addAll(next);\n        }\n\n        node.getAnnotations().clear();\n        node.getAnnotations().addAll(mergedList);\n\n        for (AnnotationNode annotation : node.getAnnotations()) {\n            Annotation transformClassAnnotation = getTransformClassAnnotation(annotation.getClassNode());\n            if (transformClassAnnotation == null) {\n                // skip if there is no such annotation\n                continue;\n            }\n            addTransformsToClassNode(annotation, transformClassAnnotation);\n        }\n    }"
        ],
        [
            "ASTTransformationCollectorCodeVisitor::deleteReplacement(boolean,Map,List)",
            " 162  \n 163  \n 164  \n 165  \n 166  \n 167 -\n 168 -\n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  ",
            "    private static void deleteReplacement(boolean mergeParams, Map<Integer, List<AnnotationNode>> existingMap, List<AnnotationNode> replacements) {\n        Iterator<AnnotationNode> nodeIterator = replacements.iterator();\n        while (nodeIterator.hasNext()) {\n            boolean remove = false;\n            AnnotationNode replacement = nodeIterator.next();\n            for (Integer key : existingMap.keySet()) {\n                for (AnnotationNode existing : existingMap.get(key)) {\n                    if (replacement.getClassNode().getName().equals(existing.getClassNode().getName())) {\n                        if (mergeParams) {\n                            mergeParameters(existing, replacement);\n                        }\n                        remove = true;\n                    }\n                }\n            }\n            if (remove) {\n                nodeIterator.remove();\n            }\n        }\n    }",
            " 164  \n 165  \n 166  \n 167  \n 168  \n 169 +\n 170 +\n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  ",
            "    private static void deleteReplacement(boolean mergeParams, Map<Integer, List<AnnotationNode>> existingMap, List<AnnotationNode> replacements) {\n        Iterator<AnnotationNode> nodeIterator = replacements.iterator();\n        while (nodeIterator.hasNext()) {\n            boolean remove = false;\n            AnnotationNode replacement = nodeIterator.next();\n            for (Map.Entry<Integer, List<AnnotationNode>> entry : existingMap.entrySet()) {\n                for (AnnotationNode existing : entry.getValue()) {\n                    if (replacement.getClassNode().getName().equals(existing.getClassNode().getName())) {\n                        if (mergeParams) {\n                            mergeParameters(existing, replacement);\n                        }\n                        remove = true;\n                    }\n                }\n            }\n            if (remove) {\n                nodeIterator.remove();\n            }\n        }\n    }"
        ]
    ],
    "02dd6d669d7d5cb4abc376d2c7672f3ac9fe12d9": [
        [
            "AutoImplementASTTransformation::visit(ASTNode,SourceUnit)",
            "  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88 -\n  89  \n  90  \n  91  ",
            "    public void visit(ASTNode[] nodes, SourceUnit source) {\n        init(nodes, source);\n        AnnotatedNode parent = (AnnotatedNode) nodes[1];\n        AnnotationNode anno = (AnnotationNode) nodes[0];\n        if (!MY_TYPE.equals(anno.getClassNode())) return;\n\n        if (parent instanceof ClassNode) {\n            ClassNode cNode = (ClassNode) parent;\n            if (!checkNotInterface(cNode, MY_TYPE_NAME)) return;\n            ClassNode exception = getMemberClassValue(anno, \"exception\");\n            if (exception != null && Undefined.isUndefinedException(exception)) {\n                exception = null;\n            }\n            String message = getMemberStringValue(anno, \"message\");\n            Expression code = anno.getMember(\"code\");\n            if (code != null && !(code instanceof ClosureExpression)) {\n                addError(\"Expected closure value for annotation parameter 'code'. Found \" + code, cNode);\n                return;\n            }\n            createMethods(cNode, exception, message, (ClosureExpression) code);\n            if (code != null) {\n                anno.setMember(\"code\", new ClosureExpression(new Parameter[0], EmptyStatement.INSTANCE));\n            }\n        }\n    }",
            "  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88 +\n  89  \n  90  \n  91  ",
            "    public void visit(ASTNode[] nodes, SourceUnit source) {\n        init(nodes, source);\n        AnnotatedNode parent = (AnnotatedNode) nodes[1];\n        AnnotationNode anno = (AnnotationNode) nodes[0];\n        if (!MY_TYPE.equals(anno.getClassNode())) return;\n\n        if (parent instanceof ClassNode) {\n            ClassNode cNode = (ClassNode) parent;\n            if (!checkNotInterface(cNode, MY_TYPE_NAME)) return;\n            ClassNode exception = getMemberClassValue(anno, \"exception\");\n            if (exception != null && Undefined.isUndefinedException(exception)) {\n                exception = null;\n            }\n            String message = getMemberStringValue(anno, \"message\");\n            Expression code = anno.getMember(\"code\");\n            if (code != null && !(code instanceof ClosureExpression)) {\n                addError(\"Expected closure value for annotation parameter 'code'. Found \" + code, cNode);\n                return;\n            }\n            createMethods(cNode, exception, message, (ClosureExpression) code);\n            if (code != null) {\n                anno.setMember(\"code\", new ClosureExpression(Parameter.EMPTY_ARRAY, EmptyStatement.INSTANCE));\n            }\n        }\n    }"
        ],
        [
            "MapConstructorASTTransformation::visit(ASTNode,SourceUnit)",
            "  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131 -\n 132  \n 133  \n 134  \n 135  \n 136  \n 137  ",
            "    public void visit(ASTNode[] nodes, SourceUnit source) {\n        init(nodes, source);\n        AnnotatedNode parent = (AnnotatedNode) nodes[1];\n        AnnotationNode anno = (AnnotationNode) nodes[0];\n        if (!MY_TYPE.equals(anno.getClassNode())) return;\n\n        if (parent instanceof ClassNode) {\n            ClassNode cNode = (ClassNode) parent;\n            if (!checkNotInterface(cNode, MY_TYPE_NAME)) return;\n            boolean includeFields = memberHasValue(anno, \"includeFields\", true);\n            boolean includeProperties = !memberHasValue(anno, \"includeProperties\", false);\n            boolean includeSuperProperties = memberHasValue(anno, \"includeSuperProperties\", true);\n            boolean includeSuperFields = memberHasValue(anno, \"includeSuperFields\", true);\n            boolean includeStatic = memberHasValue(anno, \"includeStatic\", true);\n            boolean allProperties = memberHasValue(anno, \"allProperties\", true);\n            boolean noArg = memberHasValue(anno, \"noArg\", true);\n            boolean specialNamedArgHandling = !memberHasValue(anno, \"specialNamedArgHandling\", false);\n            List<String> excludes = getMemberStringList(anno, \"excludes\");\n            List<String> includes = getMemberStringList(anno, \"includes\");\n            boolean allNames = memberHasValue(anno, \"allNames\", true);\n            if (!checkIncludeExcludeUndefinedAware(anno, excludes, includes, MY_TYPE_NAME)) return;\n            if (!checkPropertyList(cNode, includes, \"includes\", anno, MY_TYPE_NAME, includeFields, includeSuperProperties, allProperties))\n                return;\n            if (!checkPropertyList(cNode, excludes, \"excludes\", anno, MY_TYPE_NAME, includeFields, includeSuperProperties, allProperties))\n                return;\n            final GroovyClassLoader classLoader = compilationUnit != null ? compilationUnit.getTransformLoader() : source.getClassLoader();\n            final PropertyHandler handler = PropertyHandler.createPropertyHandler(this, classLoader, cNode);\n            if (handler == null) return;\n            if (!handler.validateAttributes(this, anno)) return;\n\n            Expression pre = anno.getMember(\"pre\");\n            if (pre != null && !(pre instanceof ClosureExpression)) {\n                addError(\"Expected closure value for annotation parameter 'pre'. Found \" + pre, cNode);\n                return;\n            }\n            Expression post = anno.getMember(\"post\");\n            if (post != null && !(post instanceof ClosureExpression)) {\n                addError(\"Expected closure value for annotation parameter 'post'. Found \" + post, cNode);\n                return;\n            }\n\n            createConstructors(this, anno, handler, cNode, includeFields, includeProperties, includeSuperProperties, includeSuperFields, noArg, allNames, allProperties, specialNamedArgHandling, includeStatic, excludes, includes, (ClosureExpression) pre, (ClosureExpression) post, source);\n\n            if (pre != null) {\n                anno.setMember(\"pre\", new ClosureExpression(new Parameter[0], EmptyStatement.INSTANCE));\n            }\n            if (post != null) {\n                anno.setMember(\"post\", new ClosureExpression(new Parameter[0], EmptyStatement.INSTANCE));\n            }\n        }\n    }",
            "  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131 +\n 132  \n 133  \n 134  \n 135  \n 136  \n 137  ",
            "    public void visit(ASTNode[] nodes, SourceUnit source) {\n        init(nodes, source);\n        AnnotatedNode parent = (AnnotatedNode) nodes[1];\n        AnnotationNode anno = (AnnotationNode) nodes[0];\n        if (!MY_TYPE.equals(anno.getClassNode())) return;\n\n        if (parent instanceof ClassNode) {\n            ClassNode cNode = (ClassNode) parent;\n            if (!checkNotInterface(cNode, MY_TYPE_NAME)) return;\n            boolean includeFields = memberHasValue(anno, \"includeFields\", true);\n            boolean includeProperties = !memberHasValue(anno, \"includeProperties\", false);\n            boolean includeSuperProperties = memberHasValue(anno, \"includeSuperProperties\", true);\n            boolean includeSuperFields = memberHasValue(anno, \"includeSuperFields\", true);\n            boolean includeStatic = memberHasValue(anno, \"includeStatic\", true);\n            boolean allProperties = memberHasValue(anno, \"allProperties\", true);\n            boolean noArg = memberHasValue(anno, \"noArg\", true);\n            boolean specialNamedArgHandling = !memberHasValue(anno, \"specialNamedArgHandling\", false);\n            List<String> excludes = getMemberStringList(anno, \"excludes\");\n            List<String> includes = getMemberStringList(anno, \"includes\");\n            boolean allNames = memberHasValue(anno, \"allNames\", true);\n            if (!checkIncludeExcludeUndefinedAware(anno, excludes, includes, MY_TYPE_NAME)) return;\n            if (!checkPropertyList(cNode, includes, \"includes\", anno, MY_TYPE_NAME, includeFields, includeSuperProperties, allProperties))\n                return;\n            if (!checkPropertyList(cNode, excludes, \"excludes\", anno, MY_TYPE_NAME, includeFields, includeSuperProperties, allProperties))\n                return;\n            final GroovyClassLoader classLoader = compilationUnit != null ? compilationUnit.getTransformLoader() : source.getClassLoader();\n            final PropertyHandler handler = PropertyHandler.createPropertyHandler(this, classLoader, cNode);\n            if (handler == null) return;\n            if (!handler.validateAttributes(this, anno)) return;\n\n            Expression pre = anno.getMember(\"pre\");\n            if (pre != null && !(pre instanceof ClosureExpression)) {\n                addError(\"Expected closure value for annotation parameter 'pre'. Found \" + pre, cNode);\n                return;\n            }\n            Expression post = anno.getMember(\"post\");\n            if (post != null && !(post instanceof ClosureExpression)) {\n                addError(\"Expected closure value for annotation parameter 'post'. Found \" + post, cNode);\n                return;\n            }\n\n            createConstructors(this, anno, handler, cNode, includeFields, includeProperties, includeSuperProperties, includeSuperFields, noArg, allNames, allProperties, specialNamedArgHandling, includeStatic, excludes, includes, (ClosureExpression) pre, (ClosureExpression) post, source);\n\n            if (pre != null) {\n                anno.setMember(\"pre\", new ClosureExpression(Parameter.EMPTY_ARRAY, EmptyStatement.INSTANCE));\n            }\n            if (post != null) {\n                anno.setMember(\"post\", new ClosureExpression(new Parameter[0], EmptyStatement.INSTANCE));\n            }\n        }\n    }"
        ],
        [
            "TupleConstructorASTTransformation::visit(ASTNode,SourceUnit)",
            " 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159 -\n 160  \n 161  \n 162 -\n 163  \n 164  \n 165  ",
            "    public void visit(ASTNode[] nodes, SourceUnit source) {\r\n        init(nodes, source);\r\n        AnnotatedNode parent = (AnnotatedNode) nodes[1];\r\n        AnnotationNode anno = (AnnotationNode) nodes[0];\r\n        if (!MY_TYPE.equals(anno.getClassNode())) return;\r\n\r\n        if (parent instanceof ClassNode) {\r\n            ClassNode cNode = (ClassNode) parent;\r\n            if (!checkNotInterface(cNode, MY_TYPE_NAME)) return;\r\n            boolean includeFields = memberHasValue(anno, \"includeFields\", true);\r\n            boolean includeProperties = !memberHasValue(anno, \"includeProperties\", false);\r\n            boolean includeSuperFields = memberHasValue(anno, \"includeSuperFields\", true);\r\n            boolean includeSuperProperties = memberHasValue(anno, \"includeSuperProperties\", true);\r\n            boolean allProperties = memberHasValue(anno, \"allProperties\", true);\r\n            List<String> excludes = getMemberStringList(anno, \"excludes\");\r\n            List<String> includes = getMemberStringList(anno, \"includes\");\r\n            boolean allNames = memberHasValue(anno, \"allNames\", true);\r\n            if (!checkIncludeExcludeUndefinedAware(anno, excludes, includes, MY_TYPE_NAME)) return;\r\n            if (!checkPropertyList(cNode, includes, \"includes\", anno, MY_TYPE_NAME, includeFields, includeSuperProperties, allProperties, includeSuperFields, false))\r\n                return;\r\n            if (!checkPropertyList(cNode, excludes, \"excludes\", anno, MY_TYPE_NAME, includeFields, includeSuperProperties, allProperties, includeSuperFields, false))\r\n                return;\r\n            final GroovyClassLoader classLoader = compilationUnit != null ? compilationUnit.getTransformLoader() : source.getClassLoader();\r\n            final PropertyHandler handler = PropertyHandler.createPropertyHandler(this, classLoader, cNode);\r\n            if (handler == null) return;\r\n            if (!handler.validateAttributes(this, anno)) return;\r\n\r\n            Expression pre = anno.getMember(\"pre\");\r\n            if (pre != null && !(pre instanceof ClosureExpression)) {\r\n                addError(\"Expected closure value for annotation parameter 'pre'. Found \" + pre, cNode);\r\n                return;\r\n            }\r\n            Expression post = anno.getMember(\"post\");\r\n            if (post != null && !(post instanceof ClosureExpression)) {\r\n                addError(\"Expected closure value for annotation parameter 'post'. Found \" + post, cNode);\r\n                return;\r\n            }\r\n\r\n            createConstructor(this, anno, cNode, includeFields, includeProperties, includeSuperFields, includeSuperProperties,\r\n                    excludes, includes, allNames, allProperties,\r\n                    sourceUnit, handler, (ClosureExpression) pre, (ClosureExpression) post);\r\n\r\n            if (pre != null) {\r\n                anno.setMember(\"pre\", new ClosureExpression(new Parameter[0], EmptyStatement.INSTANCE));\r\n            }\r\n            if (post != null) {\r\n                anno.setMember(\"post\", new ClosureExpression(new Parameter[0], EmptyStatement.INSTANCE));\r\n            }\r\n        }\r\n    }\r",
            " 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159 +\n 160  \n 161  \n 162 +\n 163  \n 164  \n 165  ",
            "    public void visit(ASTNode[] nodes, SourceUnit source) {\r\n        init(nodes, source);\r\n        AnnotatedNode parent = (AnnotatedNode) nodes[1];\r\n        AnnotationNode anno = (AnnotationNode) nodes[0];\r\n        if (!MY_TYPE.equals(anno.getClassNode())) return;\r\n\r\n        if (parent instanceof ClassNode) {\r\n            ClassNode cNode = (ClassNode) parent;\r\n            if (!checkNotInterface(cNode, MY_TYPE_NAME)) return;\r\n            boolean includeFields = memberHasValue(anno, \"includeFields\", true);\r\n            boolean includeProperties = !memberHasValue(anno, \"includeProperties\", false);\r\n            boolean includeSuperFields = memberHasValue(anno, \"includeSuperFields\", true);\r\n            boolean includeSuperProperties = memberHasValue(anno, \"includeSuperProperties\", true);\r\n            boolean allProperties = memberHasValue(anno, \"allProperties\", true);\r\n            List<String> excludes = getMemberStringList(anno, \"excludes\");\r\n            List<String> includes = getMemberStringList(anno, \"includes\");\r\n            boolean allNames = memberHasValue(anno, \"allNames\", true);\r\n            if (!checkIncludeExcludeUndefinedAware(anno, excludes, includes, MY_TYPE_NAME)) return;\r\n            if (!checkPropertyList(cNode, includes, \"includes\", anno, MY_TYPE_NAME, includeFields, includeSuperProperties, allProperties, includeSuperFields, false))\r\n                return;\r\n            if (!checkPropertyList(cNode, excludes, \"excludes\", anno, MY_TYPE_NAME, includeFields, includeSuperProperties, allProperties, includeSuperFields, false))\r\n                return;\r\n            final GroovyClassLoader classLoader = compilationUnit != null ? compilationUnit.getTransformLoader() : source.getClassLoader();\r\n            final PropertyHandler handler = PropertyHandler.createPropertyHandler(this, classLoader, cNode);\r\n            if (handler == null) return;\r\n            if (!handler.validateAttributes(this, anno)) return;\r\n\r\n            Expression pre = anno.getMember(\"pre\");\r\n            if (pre != null && !(pre instanceof ClosureExpression)) {\r\n                addError(\"Expected closure value for annotation parameter 'pre'. Found \" + pre, cNode);\r\n                return;\r\n            }\r\n            Expression post = anno.getMember(\"post\");\r\n            if (post != null && !(post instanceof ClosureExpression)) {\r\n                addError(\"Expected closure value for annotation parameter 'post'. Found \" + post, cNode);\r\n                return;\r\n            }\r\n\r\n            createConstructor(this, anno, cNode, includeFields, includeProperties, includeSuperFields, includeSuperProperties,\r\n                    excludes, includes, allNames, allProperties,\r\n                    sourceUnit, handler, (ClosureExpression) pre, (ClosureExpression) post);\r\n\r\n            if (pre != null) {\r\n                anno.setMember(\"pre\", new ClosureExpression(Parameter.EMPTY_ARRAY, EmptyStatement.INSTANCE));\r\n            }\r\n            if (post != null) {\r\n                anno.setMember(\"post\", new ClosureExpression(Parameter.EMPTY_ARRAY, EmptyStatement.INSTANCE));\r\n            }\r\n        }\r\n    }\r"
        ]
    ]
}