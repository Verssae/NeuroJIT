{
    "f39b83eebb6133086e01d98c1f3fb3af38f2dd09": [
        [
            "RabbitMQConsumer::closeConnectionAndChannel()",
            " 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134 -\n 135 -\n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  ",
            "    /**\n     * If needed, close Connection and Channels\n     */\n    private void closeConnectionAndChannel() throws IOException, TimeoutException {\n        if (startConsumerCallable != null) {\n            startConsumerCallable.stop();\n        }\n        for (RabbitConsumer consumer : this.consumers) {\n            try {\n                consumer.stop();\n            } catch (TimeoutException e) {\n                log.error(\"Timeout occured\");\n                throw e;\n            }\n        }\n        this.consumers.clear();\n        if (conn != null) {\n            log.debug(\"Closing connection: {} with timeout: {} ms.\", conn, closeTimeout);\n            conn.close(closeTimeout);\n            conn = null;\n        }\n    }",
            " 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134 +\n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  ",
            "    /**\n     * If needed, close Connection and Channels\n     */\n    private void closeConnectionAndChannel() throws IOException, TimeoutException {\n        if (startConsumerCallable != null) {\n            startConsumerCallable.stop();\n        }\n        for (RabbitConsumer consumer : this.consumers) {\n            try {\n                consumer.stop();\n            } catch (TimeoutException e) {\n                log.warn(\"Timeout occurred while stopping consumer. This exception is ignored\", e);\n            }\n        }\n        this.consumers.clear();\n        if (conn != null) {\n            log.debug(\"Closing connection: {} with timeout: {} ms.\", conn, closeTimeout);\n            conn.close(closeTimeout);\n            conn = null;\n        }\n    }"
        ],
        [
            "RabbitConsumer::handleCancelOk(String)",
            " 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231 -\n 232  ",
            "    /**\n     * No-op implementation of {@link Consumer#handleCancelOk}.\n     * \n     * @param consumerTag\n     *            the defined consumer tag (client- or server-generated)\n     */\n    public void handleCancelOk(String consumerTag) {\n        // no work to do\n        log.debug(\"Recieved cancelOk signal on the rabbitMQ channel\");\n    }",
            " 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230 +\n 231  ",
            "    /**\n     * No-op implementation of {@link Consumer#handleCancelOk}.\n     *\n     * @param consumerTag\n     *            the defined consumer tag (client- or server-generated)\n     */\n    public void handleCancelOk(String consumerTag) {\n        // no work to do\n        log.debug(\"Received cancelOk signal on the rabbitMQ channel\");\n    }"
        ],
        [
            "RabbitConsumer::handleCancel(String)",
            " 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242 -\n 243  ",
            "    /**\n     * No-op implementation of {@link Consumer#handleCancel(String)}\n     * \n     * @param consumerTag\n     *            the defined consumer tag (client- or server-generated)\n     */\n    public void handleCancel(String consumerTag) throws IOException {\n        // no work to do\n        log.debug(\"Recieved cancel signal on the rabbitMQ channel\");\n    }",
            " 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241 +\n 242  ",
            "    /**\n     * No-op implementation of {@link Consumer#handleCancel(String)}\n     *\n     * @param consumerTag\n     *            the defined consumer tag (client- or server-generated)\n     */\n    public void handleCancel(String consumerTag) throws IOException {\n        // no work to do\n        log.debug(\"Received cancel signal on the rabbitMQ channel\");\n    }"
        ],
        [
            "RabbitConsumer::handleRecoverOk(String)",
            " 275  \n 276  \n 277  \n 278  \n 279  \n 280 -\n 281  ",
            "    /**\n     * No-op implementation of {@link Consumer#handleRecoverOk}.\n     */\n    public void handleRecoverOk(String consumerTag) {\n        // no work to do\n        log.debug(\"Recieved recover ok signal on the rabbitMQ channel\");\n    }",
            " 274  \n 275  \n 276  \n 277  \n 278  \n 279 +\n 280  ",
            "    /**\n     * No-op implementation of {@link Consumer#handleRecoverOk}.\n     */\n    public void handleRecoverOk(String consumerTag) {\n        // no work to do\n        log.debug(\"Received recover ok signal on the rabbitMQ channel\");\n    }"
        ],
        [
            "RabbitConsumer::handleDelivery(String,Envelope,AMQP,byte)",
            "  62  \n  63  \n  64 -\n  65  \n  66 -\n  67  \n  68  \n  69 -\n  70 -\n  71  \n  72  \n  73  \n  74  \n  75 -\n  76  \n  77 -\n  78 -\n  79 -\n  80 -\n  81 -\n  82 -\n  83 -\n  84 -\n  85  ",
            "    @Override\n    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n    \ttry {\n            if (!consumer.getEndpoint().isAutoAck()) {\n            \tlock.acquire();\n            }\n            //Channel might be open because while we were waiting for the lock, stop() has been succesfully called.\n            if (!channel.isOpen()) return;\n            \n            try {\n                doHandleDelivery(consumerTag, envelope, properties, body);\n            } finally {\n                if (!consumer.getEndpoint().isAutoAck()) {\n                \tlock.release();\n                }\n\t\t\t}\n    \t\t\n    \t} catch (InterruptedException e) {\n        \tlog.error(\"Thread Interrupted!\");\n    \t\t\n    \t}\n        \n\t\t\t\n    }",
            "  62  \n  63  \n  64 +\n  65  \n  66 +\n  67  \n  68  \n  69 +\n  70 +\n  71 +\n  72 +\n  73  \n  74  \n  75  \n  76  \n  77 +\n  78  \n  79 +\n  80 +\n  81 +\n  82 +\n  83 +\n  84  ",
            "    @Override\n    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n        try {\n            if (!consumer.getEndpoint().isAutoAck()) {\n                lock.acquire();\n            }\n            //Channel might be open because while we were waiting for the lock, stop() has been succesfully called.\n            if (!channel.isOpen()) {\n                return;\n            }\n\n            try {\n                doHandleDelivery(consumerTag, envelope, properties, body);\n            } finally {\n                if (!consumer.getEndpoint().isAutoAck()) {\n                    lock.release();\n                }\n            }\n\n        } catch (InterruptedException e) {\n            log.warn(\"Thread Interrupted!\");\n        }\n    }"
        ],
        [
            "RabbitConsumer::handleShutdownSignal(String,ShutdownSignalException)",
            " 245  \n 246  \n 247  \n 248  \n 249 -\n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  ",
            "    /**\n     * No-op implementation of {@link Consumer#handleShutdownSignal}.\n     */\n    public void handleShutdownSignal(String consumerTag, ShutdownSignalException sig) {\n        log.info(\"Recieved shutdown signal on the rabbitMQ channel\");\n\n        // Check if the consumer closed the connection or something else\n        if (!sig.isInitiatedByApplication()) {\n            // Something else closed the connection so reconnect\n            boolean connected = false;\n            while (!connected && !stopping) {\n                try {\n                    reconnect();\n                    connected = true;\n                } catch (IOException | TimeoutException e) {\n                    log.warn(\"Unable to obtain a RabbitMQ channel. Will try again\");\n\n                    Integer networkRecoveryInterval = consumer.getEndpoint().getNetworkRecoveryInterval();\n                    final long connectionRetryInterval = networkRecoveryInterval != null && networkRecoveryInterval > 0\n                            ? networkRecoveryInterval : 100L;\n                    try {\n                        Thread.sleep(connectionRetryInterval);\n                    } catch (InterruptedException e1) {\n                        Thread.currentThread().interrupt();\n                    }\n                }\n            }\n        }\n    }",
            " 244  \n 245  \n 246  \n 247  \n 248 +\n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  ",
            "    /**\n     * No-op implementation of {@link Consumer#handleShutdownSignal}.\n     */\n    public void handleShutdownSignal(String consumerTag, ShutdownSignalException sig) {\n        log.info(\"Received shutdown signal on the rabbitMQ channel\");\n\n        // Check if the consumer closed the connection or something else\n        if (!sig.isInitiatedByApplication()) {\n            // Something else closed the connection so reconnect\n            boolean connected = false;\n            while (!connected && !stopping) {\n                try {\n                    reconnect();\n                    connected = true;\n                } catch (IOException | TimeoutException e) {\n                    log.warn(\"Unable to obtain a RabbitMQ channel. Will try again\");\n\n                    Integer networkRecoveryInterval = consumer.getEndpoint().getNetworkRecoveryInterval();\n                    final long connectionRetryInterval = networkRecoveryInterval != null && networkRecoveryInterval > 0\n                            ? networkRecoveryInterval : 100L;\n                    try {\n                        Thread.sleep(connectionRetryInterval);\n                    } catch (InterruptedException e1) {\n                        Thread.currentThread().interrupt();\n                    }\n                }\n            }\n        }\n    }"
        ]
    ],
    "b5d907fb95f856585f1508fe805bec25dec7c4c4": [
        [
            "AggregateProcessor::doForceCompletionOnStop()",
            "1438  \n1439  \n1440  \n1441  \n1442  \n1443 -\n1444  \n1445  \n1446  \n1447  \n1448 -\n1449  \n1450  \n1451  \n1452  \n1453  \n1454  \n1455  \n1456  ",
            "    private void doForceCompletionOnStop() {\n        int expected = forceCompletionOfAllGroups();\n\n        StopWatch watch = new StopWatch();\n        while (inProgressCompleteExchanges.size() > 0) {\n            LOG.trace(\"Waiting for {} inflight exchanges to complete\", inProgressCompleteExchanges.size());\n            try {\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                // break out as we got interrupted such as the JVM terminating\n                LOG.warn(\"Interrupted while waiting for {} inflight exchanges to complete.\", inProgressCompleteExchanges.size());\n                break;\n            }\n        }\n\n        if (expected > 0) {\n            LOG.info(\"Forcing completion of all groups with {} exchanges completed in {}\", expected, TimeUtils.printDuration(watch.stop()));\n        }\n    }",
            "1438  \n1439  \n1440  \n1441  \n1442  \n1443 +\n1444  \n1445  \n1446  \n1447  \n1448 +\n1449  \n1450  \n1451  \n1452  \n1453  \n1454  \n1455  \n1456  ",
            "    private void doForceCompletionOnStop() {\n        int expected = forceCompletionOfAllGroups();\n\n        StopWatch watch = new StopWatch();\n        while (inProgressCompleteExchanges.size() > 0) {\n            LOG.trace(\"Waiting for {} inflight exchanges to complete\", getInProgressCompleteExchanges());\n            try {\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                // break out as we got interrupted such as the JVM terminating\n                LOG.warn(\"Interrupted while waiting for {} inflight exchanges to complete.\", getInProgressCompleteExchanges());\n                break;\n            }\n        }\n\n        if (expected > 0) {\n            LOG.info(\"Forcing completion of all groups with {} exchanges completed in {}\", expected, TimeUtils.printDuration(watch.stop()));\n        }\n    }"
        ],
        [
            "SnmpTrapConsumer::processPdu(CommandResponderEvent)",
            " 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131 -\n 132  \n 133  ",
            "    public void processPdu(CommandResponderEvent event) {\n        PDU pdu = event.getPDU();\n        // check PDU not null\n        if (pdu != null) {\n            // check for INFORM\n            // code take from the book \"Essential SNMP\"\n            if ((pdu.getType() != PDU.TRAP) && (pdu.getType() != PDU.V1TRAP) && (pdu.getType() != PDU.REPORT)\n                && (pdu.getType() != PDU.RESPONSE)) {\n                // first response the inform-message and then process the\n                // message\n                pdu.setErrorIndex(0);\n                pdu.setErrorStatus(0);\n                pdu.setType(PDU.RESPONSE);\n                StatusInformation statusInformation = new StatusInformation();\n                StateReference ref = event.getStateReference();\n                try {\n                    event.getMessageDispatcher().returnResponsePdu(event.getMessageProcessingModel(),\n                                                                   event.getSecurityModel(),\n                                                                   event.getSecurityName(),\n                                                                   event.getSecurityLevel(), pdu,\n                                                                   event.getMaxSizeResponsePDU(), ref,\n                                                                   statusInformation);\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"response to INFORM sent\");\n                    }\n                } catch (MessageException ex) {\n                    getExceptionHandler().handleException(ex);\n                }\n            }\n            processPDU(pdu, event);\n        } else {\n            LOG.debug(\"Received invalid trap PDU: \" + pdu);\n        }\n    }",
            " 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131 +\n 132  \n 133  ",
            "    public void processPdu(CommandResponderEvent event) {\n        PDU pdu = event.getPDU();\n        // check PDU not null\n        if (pdu != null) {\n            // check for INFORM\n            // code take from the book \"Essential SNMP\"\n            if ((pdu.getType() != PDU.TRAP) && (pdu.getType() != PDU.V1TRAP) && (pdu.getType() != PDU.REPORT)\n                && (pdu.getType() != PDU.RESPONSE)) {\n                // first response the inform-message and then process the\n                // message\n                pdu.setErrorIndex(0);\n                pdu.setErrorStatus(0);\n                pdu.setType(PDU.RESPONSE);\n                StatusInformation statusInformation = new StatusInformation();\n                StateReference ref = event.getStateReference();\n                try {\n                    event.getMessageDispatcher().returnResponsePdu(event.getMessageProcessingModel(),\n                                                                   event.getSecurityModel(),\n                                                                   event.getSecurityName(),\n                                                                   event.getSecurityLevel(), pdu,\n                                                                   event.getMaxSizeResponsePDU(), ref,\n                                                                   statusInformation);\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"response to INFORM sent\");\n                    }\n                } catch (MessageException ex) {\n                    getExceptionHandler().handleException(ex);\n                }\n            }\n            processPDU(pdu, event);\n        } else {\n            LOG.debug(\"Received invalid trap PDU\");\n        }\n    }"
        ],
        [
            "DisruptorReference::removeEndpoint(DisruptorEndpoint)",
            " 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371 -\n 372  ",
            "    public synchronized void removeEndpoint(final DisruptorEndpoint disruptorEndpoint) {\n        LOGGER.debug(\"Removing Endpoint: \" + disruptorEndpoint);\n        if (getEndpointCount() == 1) {\n            LOGGER.debug(\"Last Endpoint removed, shutdown disruptor\");\n            //Shutdown our disruptor\n            shutdownDisruptor(false);\n\n            //As there are no endpoints dependent on this Disruptor, we may also shutdown our executor\n            shutdownExecutor();\n        }\n        endpoints.remove(disruptorEndpoint);\n        LOGGER.debug(\"Endpoint removed: {}, new total endpoints {}\", disruptorEndpoint, endpoints.size());\n    }",
            " 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371 +\n 372  ",
            "    public synchronized void removeEndpoint(final DisruptorEndpoint disruptorEndpoint) {\n        LOGGER.debug(\"Removing Endpoint: \" + disruptorEndpoint);\n        if (getEndpointCount() == 1) {\n            LOGGER.debug(\"Last Endpoint removed, shutdown disruptor\");\n            //Shutdown our disruptor\n            shutdownDisruptor(false);\n\n            //As there are no endpoints dependent on this Disruptor, we may also shutdown our executor\n            shutdownExecutor();\n        }\n        endpoints.remove(disruptorEndpoint);\n        LOGGER.debug(\"Endpoint removed: {}, new total endpoints {}\", disruptorEndpoint, getEndpointCount());\n    }"
        ],
        [
            "OsgiCamelContextPublisher::registerCamelContext(CamelContext)",
            "  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116 -\n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  ",
            "    public ServiceRegistration<?> registerCamelContext(CamelContext camelContext) throws InvalidSyntaxException {\n        // avoid registering the same service again\n        // we must include unique camel management name so the symbolic name becomes unique,\n        // in case the bundle has more than one CamelContext\n        String name = camelContext.getName();\n        String managementName = camelContext.getManagementName();\n        String symbolicName = bundleContext.getBundle().getSymbolicName();\n\n        if (!lookupCamelContext(bundleContext, symbolicName, name)) {\n            Version bundleVersion = getBundleVersion(bundleContext.getBundle());\n\n            Dictionary<String, Object > props = new Hashtable<String, Object>();\n            props.put(CONTEXT_SYMBOLIC_NAME_PROPERTY, symbolicName);\n            props.put(CONTEXT_VERSION_PROPERTY, bundleVersion);\n            props.put(CONTEXT_NAME_PROPERTY, name);\n            if (managementName != null) {\n                props.put(CONTEXT_MANAGEMENT_NAME_PROPERTY, managementName);\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Registering CamelContext [{}] of in OSGi registry\", camelContext.getName());\n            }\n\n            ServiceRegistration<?> reg = bundleContext.registerService(CamelContext.class.getName(), camelContext, props);\n            if (reg != null) {\n                registrations.put(camelContext, reg);\n            }\n            return reg;\n        } else {\n            return null;\n        }\n    }",
            "  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116 +\n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  ",
            "    public ServiceRegistration<?> registerCamelContext(CamelContext camelContext) throws InvalidSyntaxException {\n        // avoid registering the same service again\n        // we must include unique camel management name so the symbolic name becomes unique,\n        // in case the bundle has more than one CamelContext\n        String name = camelContext.getName();\n        String managementName = camelContext.getManagementName();\n        String symbolicName = bundleContext.getBundle().getSymbolicName();\n\n        if (!lookupCamelContext(bundleContext, symbolicName, name)) {\n            Version bundleVersion = getBundleVersion(bundleContext.getBundle());\n\n            Dictionary<String, Object > props = new Hashtable<String, Object>();\n            props.put(CONTEXT_SYMBOLIC_NAME_PROPERTY, symbolicName);\n            props.put(CONTEXT_VERSION_PROPERTY, bundleVersion);\n            props.put(CONTEXT_NAME_PROPERTY, name);\n            if (managementName != null) {\n                props.put(CONTEXT_MANAGEMENT_NAME_PROPERTY, managementName);\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Registering CamelContext [{}] of in OSGi registry\", name);\n            }\n\n            ServiceRegistration<?> reg = bundleContext.registerService(CamelContext.class.getName(), camelContext, props);\n            if (reg != null) {\n                registrations.put(camelContext, reg);\n            }\n            return reg;\n        } else {\n            return null;\n        }\n    }"
        ],
        [
            "BacklogDebugger::NodeBreakpoint::beforeProcess(Exchange,Processor,ProcessorDefinition)",
            " 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564 -\n 565  \n 566  \n 567  \n 568 -\n 569  \n 570 -\n 571  \n 572  \n 573  \n 574  \n 575  \n 576  ",
            "        @Override\n        public void beforeProcess(Exchange exchange, Processor processor, ProcessorDefinition<?> definition) {\n            // store a copy of the message so we can see that from the debugger\n            Date timestamp = new Date();\n            String toNode = definition.getId();\n            String routeId = ProcessorDefinitionHelper.getRouteId(definition);\n            String exchangeId = exchange.getExchangeId();\n            String messageAsXml = MessageHelper.dumpAsXml(exchange.getIn(), true, 2, isBodyIncludeStreams(), isBodyIncludeFiles(), getBodyMaxChars());\n            long uid = debugCounter.incrementAndGet();\n\n            BacklogTracerEventMessage msg = new DefaultBacklogTracerEventMessage(uid, timestamp, routeId, toNode, exchangeId, messageAsXml);\n            suspendedBreakpointMessages.put(nodeId, msg);\n\n            // suspend at this breakpoint\n            final SuspendedExchange se = suspendedBreakpoints.get(nodeId);\n            if (se != null) {\n                // now wait until we should continue\n                logger.log(\"NodeBreakpoint at node \" + toNode + \" is waiting to continue for exchangeId: \" + exchange.getExchangeId());\n                try {\n                    boolean hit = se.getLatch().await(fallbackTimeout, TimeUnit.SECONDS);\n                    if (!hit) {\n                        logger.log(\"NodeBreakpoint at node \" + toNode + \" timed out and is continued exchangeId: \" + exchange.getExchangeId(), LoggingLevel.WARN);\n                    } else {\n                        logger.log(\"NodeBreakpoint at node \" + toNode + \" is continued exchangeId: \" + exchange.getExchangeId());\n                    }\n                } catch (InterruptedException e) {\n                    // ignore\n                }\n            }\n        }",
            " 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564 +\n 565  \n 566  \n 567  \n 568 +\n 569  \n 570 +\n 571  \n 572  \n 573  \n 574  \n 575  \n 576  ",
            "        @Override\n        public void beforeProcess(Exchange exchange, Processor processor, ProcessorDefinition<?> definition) {\n            // store a copy of the message so we can see that from the debugger\n            Date timestamp = new Date();\n            String toNode = definition.getId();\n            String routeId = ProcessorDefinitionHelper.getRouteId(definition);\n            String exchangeId = exchange.getExchangeId();\n            String messageAsXml = MessageHelper.dumpAsXml(exchange.getIn(), true, 2, isBodyIncludeStreams(), isBodyIncludeFiles(), getBodyMaxChars());\n            long uid = debugCounter.incrementAndGet();\n\n            BacklogTracerEventMessage msg = new DefaultBacklogTracerEventMessage(uid, timestamp, routeId, toNode, exchangeId, messageAsXml);\n            suspendedBreakpointMessages.put(nodeId, msg);\n\n            // suspend at this breakpoint\n            final SuspendedExchange se = suspendedBreakpoints.get(nodeId);\n            if (se != null) {\n                // now wait until we should continue\n                logger.log(\"NodeBreakpoint at node \" + toNode + \" is waiting to continue for exchangeId: \" + exchangeId);\n                try {\n                    boolean hit = se.getLatch().await(fallbackTimeout, TimeUnit.SECONDS);\n                    if (!hit) {\n                        logger.log(\"NodeBreakpoint at node \" + toNode + \" timed out and is continued exchangeId: \" + exchangeId, LoggingLevel.WARN);\n                    } else {\n                        logger.log(\"NodeBreakpoint at node \" + toNode + \" is continued exchangeId: \" + exchangeId);\n                    }\n                } catch (InterruptedException e) {\n                    // ignore\n                }\n            }\n        }"
        ],
        [
            "JmsEndpoint::configureListenerContainer(AbstractMessageListenerContainer,JmsConsumer)",
            " 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232 -\n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  ",
            "    public void configureListenerContainer(AbstractMessageListenerContainer listenerContainer, JmsConsumer consumer) {\n        if (destinationName != null) {\n            listenerContainer.setDestinationName(destinationName);\n            log.debug(\"Using destinationName: {} on listenerContainer: {}\", destinationName, listenerContainer);\n        } else if (destination != null) {\n            listenerContainer.setDestination(destination);\n            log.debug(\"Using destination: {} on listenerContainer: {}\", destinationName, listenerContainer);\n        } else {\n            DestinationResolver resolver = getDestinationResolver();\n            if (resolver != null) {\n                listenerContainer.setDestinationResolver(resolver);\n            } else {\n                throw new IllegalArgumentException(\"Neither destination, destinationName or destinationResolver are specified on this endpoint!\");\n            }\n            log.debug(\"Using destinationResolver: {} on listenerContainer: {}\", resolver, listenerContainer);\n        }\n        listenerContainer.setPubSubDomain(pubSubDomain);\n\n        // include destination name as part of thread and transaction name\n        String consumerName = getThreadName();\n\n        if (configuration.getTaskExecutor() != null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Using custom TaskExecutor: {} on listener container: {}\", configuration.getTaskExecutor(), listenerContainer);\n            }\n            setContainerTaskExecutor(listenerContainer, configuration.getTaskExecutor());\n            // we are using a shared thread pool that this listener container is using.\n            // store a reference to the consumer, but we should not shutdown the thread pool when the consumer stops\n            // as the lifecycle of the shared thread pool is handled elsewhere\n            if (configuration.getTaskExecutor() instanceof ExecutorService) {\n                consumer.setListenerContainerExecutorService((ExecutorService) configuration.getTaskExecutor(), false);\n            }\n        } else if ((listenerContainer instanceof DefaultJmsMessageListenerContainer && configuration.getDefaultTaskExecutorType() == null)\n                || !(listenerContainer instanceof DefaultJmsMessageListenerContainer)) {\n            // preserve backwards compatibility if an explicit Default TaskExecutor Type was not set;\n            // otherwise, defer the creation of the TaskExecutor\n            // use a cached pool as DefaultMessageListenerContainer will throttle pool sizing\n            ExecutorService executor = getCamelContext().getExecutorServiceManager().newCachedThreadPool(consumer, consumerName);\n            setContainerTaskExecutor(listenerContainer, executor);\n            // we created a new private thread pool that this listener container is using, now store a reference on the consumer\n            // so when the consumer is stopped we can shutdown the thread pool also, to ensure all resources is shutdown\n            consumer.setListenerContainerExecutorService(executor, true);\n        } else {\n            // do nothing, as we're working with a DefaultJmsMessageListenerContainer with an explicit DefaultTaskExecutorType,\n            // so DefaultJmsMessageListenerContainer#createDefaultTaskExecutor will handle the creation\n            log.debug(\"Deferring creation of TaskExecutor for listener container: {} as per policy: {}\",\n                    listenerContainer, configuration.getDefaultTaskExecutorType());\n        }\n\n        // set a default transaction name if none provided\n        if (configuration.getTransactionName() == null) {\n            if (listenerContainer instanceof DefaultMessageListenerContainer) {\n                ((DefaultMessageListenerContainer) listenerContainer).setTransactionName(consumerName);\n            }\n        }\n    }",
            " 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232 +\n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  ",
            "    public void configureListenerContainer(AbstractMessageListenerContainer listenerContainer, JmsConsumer consumer) {\n        if (destinationName != null) {\n            listenerContainer.setDestinationName(destinationName);\n            log.debug(\"Using destinationName: {} on listenerContainer: {}\", destinationName, listenerContainer);\n        } else if (destination != null) {\n            listenerContainer.setDestination(destination);\n            log.debug(\"Using destination: {} on listenerContainer: {}\", destinationName, listenerContainer);\n        } else {\n            DestinationResolver resolver = getDestinationResolver();\n            if (resolver != null) {\n                listenerContainer.setDestinationResolver(resolver);\n            } else {\n                throw new IllegalArgumentException(\"Neither destination, destinationName or destinationResolver are specified on this endpoint!\");\n            }\n            log.debug(\"Using destinationResolver: {} on listenerContainer: {}\", resolver, listenerContainer);\n        }\n        listenerContainer.setPubSubDomain(pubSubDomain);\n\n        // include destination name as part of thread and transaction name\n        String consumerName = getThreadName();\n\n        if (configuration.getTaskExecutor() != null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Using custom TaskExecutor: {} on listener container: {}\", configuration.getTaskExecutor(), listenerContainer);\n            }\n            setContainerTaskExecutor(listenerContainer, configuration.getTaskExecutor());\n            // we are using a shared thread pool that this listener container is using.\n            // store a reference to the consumer, but we should not shutdown the thread pool when the consumer stops\n            // as the lifecycle of the shared thread pool is handled elsewhere\n            if (configuration.getTaskExecutor() instanceof ExecutorService) {\n                consumer.setListenerContainerExecutorService((ExecutorService) configuration.getTaskExecutor(), false);\n            }\n        } else if ((listenerContainer instanceof DefaultJmsMessageListenerContainer && configuration.getDefaultTaskExecutorType() == null)\n                || !(listenerContainer instanceof DefaultJmsMessageListenerContainer)) {\n            // preserve backwards compatibility if an explicit Default TaskExecutor Type was not set;\n            // otherwise, defer the creation of the TaskExecutor\n            // use a cached pool as DefaultMessageListenerContainer will throttle pool sizing\n            ExecutorService executor = getCamelContext().getExecutorServiceManager().newCachedThreadPool(consumer, consumerName);\n            setContainerTaskExecutor(listenerContainer, executor);\n            // we created a new private thread pool that this listener container is using, now store a reference on the consumer\n            // so when the consumer is stopped we can shutdown the thread pool also, to ensure all resources is shutdown\n            consumer.setListenerContainerExecutorService(executor, true);\n        } else {\n            // do nothing, as we're working with a DefaultJmsMessageListenerContainer with an explicit DefaultTaskExecutorType,\n            // so DefaultJmsMessageListenerContainer#createDefaultTaskExecutor will handle the creation\n            log.debug(\"Deferring creation of TaskExecutor for listener container: {} as per policy: {}\",\n                    listenerContainer, getDefaultTaskExecutorType());\n        }\n\n        // set a default transaction name if none provided\n        if (configuration.getTransactionName() == null) {\n            if (listenerContainer instanceof DefaultMessageListenerContainer) {\n                ((DefaultMessageListenerContainer) listenerContainer).setTransactionName(consumerName);\n            }\n        }\n    }"
        ],
        [
            "InjectorManager::afterClasses()",
            "  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81 -\n  82 -\n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  ",
            "    /** Lets close all of the injectors we have created so far */\n    public void afterClasses() throws CloseFailedException {\n        Injector injector = injectors.get(moduleType);\n        if (injector != null) {\n            classScope.close(injector);\n        } else {\n            System.out.println(\"Could not close Class scope as there is no Injector for module type \"\n                               + injector);\n        }\n\n        // NOTE that we don't have any good hooks yet to call complete()\n        // when the JVM is completed to ensure real singletons shut down\n        // correctly\n        //\n        if (isCloseSingletonsAfterClasses()) {\n            closeInjectors();\n        }\n    }",
            "  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81 +\n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  ",
            "    /** Lets close all of the injectors we have created so far */\n    public void afterClasses() throws CloseFailedException {\n        Injector injector = injectors.get(moduleType);\n        if (injector != null) {\n            classScope.close(injector);\n        } else {\n            System.out.println(\"Could not close Class scope as there is no Injector for module type\");\n        }\n\n        // NOTE that we don't have any good hooks yet to call complete()\n        // when the JVM is completed to ensure real singletons shut down\n        // correctly\n        //\n        if (isCloseSingletonsAfterClasses()) {\n            closeInjectors();\n        }\n    }"
        ]
    ],
    "e0ff3755efc141714aa48ae4c0d1024249dfd0cf": [
        [
            "SparkComponent::doCreateConsumer(CamelContext,Processor,String,String,String,String,String,RestConfiguration,Map,boolean)",
            " 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302 -\n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344  \n 345  \n 346  \n 347  ",
            "    Consumer doCreateConsumer(CamelContext camelContext, Processor processor, String verb, String basePath, String uriTemplate,\n                              String consumes, String produces, RestConfiguration configuration, Map<String, Object> parameters, boolean api) throws Exception {\n\n        String path = basePath;\n        if (uriTemplate != null) {\n            // make sure to avoid double slashes\n            if (uriTemplate.startsWith(\"/\")) {\n                path = path + uriTemplate;\n            } else {\n                path = path + \"/\" + uriTemplate;\n            }\n        }\n        path = FileUtil.stripLeadingSeparator(path);\n\n        RestConfiguration config = configuration;\n        if (config == null) {\n            config = camelContext.getRestConfiguration(\"spark-rest\", true);\n        }\n\n        Map<String, Object> map = new HashMap<String, Object>();\n        if (consumes != null) {\n            map.put(\"accept\", consumes);\n        }\n\n        // setup endpoint options\n        if (config.getEndpointProperties() != null && !config.getEndpointProperties().isEmpty()) {\n            map.putAll(config.getEndpointProperties());\n        }\n\n        if (ObjectHelper.isNotEmpty(path)) {\n            // spark-rest uses :name syntax instead of {name} so we need to replace those\n            Matcher matcher = pattern.matcher(path);\n            path = matcher.replaceAll(\":$1\");\n        }\n\n        // prefix path with context-path if configured in rest-dsl configuration\n        String contextPath = config.getContextPath();\n        if (ObjectHelper.isNotEmpty(contextPath)) {\n            contextPath = FileUtil.stripTrailingSeparator(contextPath);\n            contextPath = FileUtil.stripLeadingSeparator(contextPath);\n            if (ObjectHelper.isNotEmpty(contextPath)) {\n                path = contextPath + \"/\" + path;\n            }\n        }\n\n        String url;\n        if (api) {\n            url = \"spark-rest:%s:%s?matchOnUriPrefix=true\";\n        } else {\n            url = \"spark-rest:%s:%s\";\n        }\n\n        url = String.format(url, verb, path);\n\n        String query = URISupport.createQueryString(map);\n        if (!query.isEmpty()) {\n            url = url + \"?\" + query;\n        }\n\n        // get the endpoint\n        SparkEndpoint endpoint = camelContext.getEndpoint(url, SparkEndpoint.class);\n        setProperties(camelContext, endpoint, parameters);\n\n        // configure consumer properties\n        Consumer consumer = endpoint.createConsumer(processor);\n        if (config.isEnableCORS()) {\n            // if CORS is enabled then configure that on the spark consumer\n            if (config.getConsumerProperties() == null) {\n                config.setConsumerProperties(new HashMap<String, Object>());\n            }\n            config.getConsumerProperties().put(\"enableCors\", true);\n        }\n        if (config.getConsumerProperties() != null && !config.getConsumerProperties().isEmpty()) {\n            setProperties(camelContext, consumer, config.getConsumerProperties());\n        }\n        return consumer;\n    }",
            " 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302 +\n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344  \n 345  \n 346  \n 347  ",
            "    Consumer doCreateConsumer(CamelContext camelContext, Processor processor, String verb, String basePath, String uriTemplate,\n                              String consumes, String produces, RestConfiguration configuration, Map<String, Object> parameters, boolean api) throws Exception {\n\n        String path = basePath;\n        if (uriTemplate != null) {\n            // make sure to avoid double slashes\n            if (uriTemplate.startsWith(\"/\")) {\n                path = path + uriTemplate;\n            } else {\n                path = path + \"/\" + uriTemplate;\n            }\n        }\n        path = FileUtil.stripLeadingSeparator(path);\n\n        RestConfiguration config = configuration;\n        if (config == null) {\n            config = camelContext.getRestConfiguration(\"spark-rest\", true);\n        }\n\n        Map<String, Object> map = new HashMap<String, Object>();\n        if (consumes != null) {\n            map.put(\"accept\", consumes);\n        }\n\n        // setup endpoint options\n        if (config.getEndpointProperties() != null && !config.getEndpointProperties().isEmpty()) {\n            map.putAll(config.getEndpointProperties());\n        }\n\n        if (ObjectHelper.isNotEmpty(path)) {\n            // spark-rest uses :name syntax instead of {name} so we need to replace those\n            Matcher matcher = PATTERN.matcher(path);\n            path = matcher.replaceAll(\":$1\");\n        }\n\n        // prefix path with context-path if configured in rest-dsl configuration\n        String contextPath = config.getContextPath();\n        if (ObjectHelper.isNotEmpty(contextPath)) {\n            contextPath = FileUtil.stripTrailingSeparator(contextPath);\n            contextPath = FileUtil.stripLeadingSeparator(contextPath);\n            if (ObjectHelper.isNotEmpty(contextPath)) {\n                path = contextPath + \"/\" + path;\n            }\n        }\n\n        String url;\n        if (api) {\n            url = \"spark-rest:%s:%s?matchOnUriPrefix=true\";\n        } else {\n            url = \"spark-rest:%s:%s\";\n        }\n\n        url = String.format(url, verb, path);\n\n        String query = URISupport.createQueryString(map);\n        if (!query.isEmpty()) {\n            url = url + \"?\" + query;\n        }\n\n        // get the endpoint\n        SparkEndpoint endpoint = camelContext.getEndpoint(url, SparkEndpoint.class);\n        setProperties(camelContext, endpoint, parameters);\n\n        // configure consumer properties\n        Consumer consumer = endpoint.createConsumer(processor);\n        if (config.isEnableCORS()) {\n            // if CORS is enabled then configure that on the spark consumer\n            if (config.getConsumerProperties() == null) {\n                config.setConsumerProperties(new HashMap<String, Object>());\n            }\n            config.getConsumerProperties().put(\"enableCors\", true);\n        }\n        if (config.getConsumerProperties() != null && !config.getConsumerProperties().isEmpty()) {\n            setProperties(camelContext, consumer, config.getConsumerProperties());\n        }\n        return consumer;\n    }"
        ],
        [
            "DdbStreamConsumerTest::GetRecordsAnswer::answer(InvocationOnMock)",
            " 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190 -\n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  ",
            "        @Override\n        public GetRecordsResult answer(InvocationOnMock invocation) throws Throwable {\n            final String shardIterator = ((GetRecordsRequest) invocation.getArguments()[0]).getShardIterator();\n            // note that HashMap returns null when there is no entry in the map.\n            // A null 'nextShardIterator' indicates that the shard has finished\n            // and we should move onto the next shard.\n            String nextShardIterator = shardIterators.get(shardIterator);\n            Matcher m = SHARD_ITERATOR_PATTERN.matcher(shardIterator);\n            Collection<Record> ans = answers.get(shardIterator);\n            if (nextShardIterator == null && m.matches()) { // last shard iterates forever.\n                Integer num = Integer.parseInt(m.group(1));\n                nextShardIterator = \"shard_iterator_d_\" + pad(Integer.toString(num + 1), 3);\n            }\n            if (null == ans) { // default to an empty list of records.\n                ans = createRecords();\n            }\n            return new GetRecordsResult()\n                    .withRecords(ans)\n                    .withNextShardIterator(nextShardIterator);\n        }",
            " 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190 +\n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  ",
            "        @Override\n        public GetRecordsResult answer(InvocationOnMock invocation) throws Throwable {\n            final String shardIterator = ((GetRecordsRequest) invocation.getArguments()[0]).getShardIterator();\n            // note that HashMap returns null when there is no entry in the map.\n            // A null 'nextShardIterator' indicates that the shard has finished\n            // and we should move onto the next shard.\n            String nextShardIterator = shardIterators.get(shardIterator);\n            Matcher m = shardIteratorPattern.matcher(shardIterator);\n            Collection<Record> ans = answers.get(shardIterator);\n            if (nextShardIterator == null && m.matches()) { // last shard iterates forever.\n                Integer num = Integer.parseInt(m.group(1));\n                nextShardIterator = \"shard_iterator_d_\" + pad(Integer.toString(num + 1), 3);\n            }\n            if (null == ans) { // default to an empty list of records.\n                ans = createRecords();\n            }\n            return new GetRecordsResult()\n                    .withRecords(ans)\n                    .withNextShardIterator(nextShardIterator);\n        }"
        ],
        [
            "JasyptPropertiesParser::parseProperty(String,String,Properties)",
            "  51  \n  52  \n  53  \n  54  \n  55  \n  56 -\n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  ",
            "    @Override\n    public String parseProperty(String key, String value, Properties properties) {\n        log.trace(format(\"Parsing property '%s=%s'\", key, value));\n        if (value != null) {\n            initEncryptor();\n            Matcher matcher = pattern.matcher(value);\n            while (matcher.find()) {\n                log.trace(format(\"Decrypting part '%s'\", matcher.group(0)));\n                String decrypted = encryptor.decrypt(matcher.group(1));\n                value = value.replace(matcher.group(0), decrypted);\n            }\n        }\n        return value;\n    }",
            "  51  \n  52  \n  53  \n  54  \n  55  \n  56 +\n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  ",
            "    @Override\n    public String parseProperty(String key, String value, Properties properties) {\n        log.trace(format(\"Parsing property '%s=%s'\", key, value));\n        if (value != null) {\n            initEncryptor();\n            Matcher matcher = PATTERN.matcher(value);\n            while (matcher.find()) {\n                log.trace(format(\"Decrypting part '%s'\", matcher.group(0)));\n                String decrypted = encryptor.decrypt(matcher.group(1));\n                value = value.replace(matcher.group(0), decrypted);\n            }\n        }\n        return value;\n    }"
        ],
        [
            "DropboxConfigurationValidator::validatePathInUnix(String)",
            " 119  \n 120 -\n 121  \n 122  \n 123  \n 124  ",
            "    private static void validatePathInUnix(String path) throws DropboxException {\n        Matcher matcher = pattern.matcher(path);\n        if (!matcher.matches()) {\n            throw new DropboxException(path + \" is not a valid path, must be in UNIX form!\");\n        }\n    }",
            " 119  \n 120 +\n 121  \n 122  \n 123  \n 124  ",
            "    private static void validatePathInUnix(String path) throws DropboxException {\n        Matcher matcher = PATTERN.matcher(path);\n        if (!matcher.matches()) {\n            throw new DropboxException(path + \" is not a valid path, must be in UNIX form!\");\n        }\n    }"
        ]
    ],
    "3b977b01c914e76a65e1ad10bf4597deeecf0b35": [
        [
            "GrpcProducer::process(Exchange,AsyncCallback)",
            "  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72 -\n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  ",
            "    @Override\n    public boolean process(Exchange exchange, AsyncCallback callback) {\n        Message message = exchange.getIn();\n\n        StreamObserver<Object> asyncHandler = new StreamObserver<Object>() {\n\n            @SuppressWarnings(\"unchecked\")\n            @Override\n            public void onNext(Object response) {\n                final Object currentBody = exchange.getOut().getBody();\n                List<Object> returnBody = new ArrayList<Object>();\n                if (currentBody instanceof List) {\n                    returnBody = (List<Object>)currentBody;\n                }\n                returnBody.add(response);\n                exchange.getOut().setBody(returnBody);\n            }\n\n            @Override\n            public void onError(Throwable t) {\n                exchange.setException(t);\n                callback.done(true);\n            }\n\n            @Override\n            public void onCompleted() {\n                exchange.getOut().setHeaders(exchange.getIn().getHeaders());\n                callback.done(false);\n            }\n        };\n        try {\n            GrpcUtils.invokeAsyncMethod(grpcStub, configuration.getMethod(), message.getBody(), asyncHandler);\n        } catch (Exception e) {\n            exchange.setException(e);\n            return true;\n        }\n        return false;\n    }",
            "  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72 +\n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85 +\n  86  \n  87  \n  88  \n  89  ",
            "    @Override\n    public boolean process(Exchange exchange, AsyncCallback callback) {\n        Message message = exchange.getIn();\n\n        StreamObserver<Object> asyncHandler = new StreamObserver<Object>() {\n\n            @SuppressWarnings(\"unchecked\")\n            @Override\n            public void onNext(Object response) {\n                final Object currentBody = exchange.getOut().getBody();\n                List<Object> returnBody = new ArrayList<Object>();\n                if (currentBody instanceof List) {\n                    returnBody = (List<Object>)currentBody;\n                }\n                returnBody.add(response);\n                exchange.getOut().setBody(returnBody);\n            }\n\n            @Override\n            public void onError(Throwable t) {\n                exchange.setException(t);\n                callback.done(false);\n            }\n\n            @Override\n            public void onCompleted() {\n                exchange.getOut().setHeaders(exchange.getIn().getHeaders());\n                callback.done(false);\n            }\n        };\n        try {\n            GrpcUtils.invokeAsyncMethod(grpcStub, configuration.getMethod(), message.getBody(), asyncHandler);\n        } catch (Exception e) {\n            exchange.setException(e);\n            callback.done(true);\n            return true;\n        }\n        return false;\n    }"
        ]
    ],
    "958f7f33fa40868dec6a878f1c97f6d7339a9b3b": [
        [
            "Olingo4AppImpl::execute(HttpUriRequest,ContentType,FutureCallback)",
            " 799  \n 800  \n 801 -\n 802  \n 803  \n 804 -\n 805  \n 806  \n 807  \n 808  \n 809 -\n 810  \n 811  \n 812  \n 813  \n 814  \n 815  \n 816  \n 817  \n 818  \n 819  \n 820  \n 821  \n 822 -\n 823  \n 824  \n 825  \n 826  \n 827  \n 828  \n 829  \n 830  \n 831  \n 832  \n 833  \n 834  \n 835  \n 836  \n 837  \n 838  \n 839  \n 840  \n 841  \n 842  \n 843  \n 844  \n 845  \n 846  ",
            "    public void execute(HttpUriRequest httpUriRequest, ContentType contentType, FutureCallback<HttpResponse> callback) {\n        // add accept header when its not a form or multipart\n        final String contentTypeString = contentType.toString();\n        if (!ContentType.APPLICATION_FORM_URLENCODED.equals(contentType) && !contentType.toContentTypeString().startsWith(MULTIPART_MIME_TYPE)) {\n            // otherwise accept what is being sent\n            httpUriRequest.addHeader(HttpHeaders.ACCEPT, contentTypeString);\n        }\n\n        // is something being sent?\n        if (httpUriRequest instanceof HttpEntityEnclosingRequestBase && httpUriRequest.getFirstHeader(HttpHeaders.CONTENT_TYPE) == null) {\n            httpUriRequest.addHeader(HttpHeaders.CONTENT_TYPE, contentTypeString);\n        }\n\n        // set user specified custom headers\n        if (httpHeaders != null && !httpHeaders.isEmpty()) {\n            for (Map.Entry<String, String> entry : httpHeaders.entrySet()) {\n                httpUriRequest.setHeader(entry.getKey(), entry.getValue());\n            }\n        }\n\n        // add 'Accept-Charset' header to avoid BOM marker presents inside\n        // response stream\n        if (!httpUriRequest.containsHeader(HttpHeaders.ACCEPT_CHARSET)) {\n            httpUriRequest.addHeader(HttpHeaders.ACCEPT_CHARSET, Constants.UTF8);\n        }\n\n        // add client protocol version if not specified\n        if (!httpUriRequest.containsHeader(HttpHeader.ODATA_VERSION)) {\n            httpUriRequest.addHeader(HttpHeader.ODATA_VERSION, ODataServiceVersion.V40.toString());\n        }\n        if (!httpUriRequest.containsHeader(HttpHeader.ODATA_MAX_VERSION)) {\n            httpUriRequest.addHeader(HttpHeader.ODATA_MAX_VERSION, ODataServiceVersion.V40.toString());\n        }\n\n        // execute request\n        if (client instanceof CloseableHttpAsyncClient) {\n            ((CloseableHttpAsyncClient)client).execute(httpUriRequest, callback);\n        } else {\n            // invoke the callback methods explicitly after executing the\n            // request synchronously\n            try {\n                CloseableHttpResponse result = ((CloseableHttpClient)client).execute(httpUriRequest);\n                callback.completed(result);\n            } catch (IOException e) {\n                callback.failed(e);\n            }\n        }\n    }",
            " 809  \n 810  \n 811  \n 812  \n 813 +\n 814 +\n 815 +\n 816 +\n 817 +\n 818  \n 819  \n 820  \n 821  \n 822 +\n 823  \n 824  \n 825  \n 826  \n 827  \n 828  \n 829  \n 830  \n 831  \n 832  \n 833  \n 834  \n 835 +\n 836  \n 837  \n 838  \n 839  \n 840  \n 841  \n 842  \n 843  \n 844  \n 845  \n 846  \n 847  \n 848  \n 849  \n 850  \n 851  \n 852  \n 853  \n 854  \n 855  \n 856  \n 857  \n 858  \n 859  ",
            "    public void execute(HttpUriRequest httpUriRequest, ContentType contentType, FutureCallback<HttpResponse> callback) {\n        // add accept header when its not a form or multipart\n        if (!ContentType.APPLICATION_FORM_URLENCODED.equals(contentType) && !contentType.toContentTypeString().startsWith(MULTIPART_MIME_TYPE)) {\n            // otherwise accept what is being sent\n            httpUriRequest.addHeader(HttpHeaders.ACCEPT, contentType.getType().toLowerCase());\n            final String acceptCharset = contentType.getParameter(ContentType.PARAMETER_CHARSET);\n            if (null != acceptCharset) {\n                httpUriRequest.addHeader(HttpHeaders.ACCEPT_CHARSET, acceptCharset.toLowerCase());\n            }\n        }\n\n        // is something being sent?\n        if (httpUriRequest instanceof HttpEntityEnclosingRequestBase && httpUriRequest.getFirstHeader(HttpHeaders.CONTENT_TYPE) == null) {\n            httpUriRequest.addHeader(HttpHeaders.CONTENT_TYPE, contentType.toString());\n        }\n\n        // set user specified custom headers\n        if (httpHeaders != null && !httpHeaders.isEmpty()) {\n            for (Map.Entry<String, String> entry : httpHeaders.entrySet()) {\n                httpUriRequest.setHeader(entry.getKey(), entry.getValue());\n            }\n        }\n\n        // add 'Accept-Charset' header to avoid BOM marker presents inside\n        // response stream\n        if (!httpUriRequest.containsHeader(HttpHeaders.ACCEPT_CHARSET)) {\n            httpUriRequest.addHeader(HttpHeaders.ACCEPT_CHARSET, Constants.UTF8.toLowerCase());\n        }\n\n        // add client protocol version if not specified\n        if (!httpUriRequest.containsHeader(HttpHeader.ODATA_VERSION)) {\n            httpUriRequest.addHeader(HttpHeader.ODATA_VERSION, ODataServiceVersion.V40.toString());\n        }\n        if (!httpUriRequest.containsHeader(HttpHeader.ODATA_MAX_VERSION)) {\n            httpUriRequest.addHeader(HttpHeader.ODATA_MAX_VERSION, ODataServiceVersion.V40.toString());\n        }\n\n        // execute request\n        if (client instanceof CloseableHttpAsyncClient) {\n            ((CloseableHttpAsyncClient)client).execute(httpUriRequest, callback);\n        } else {\n            // invoke the callback methods explicitly after executing the\n            // request synchronously\n            try {\n                CloseableHttpResponse result = ((CloseableHttpClient)client).execute(httpUriRequest);\n                callback.completed(result);\n            } catch (IOException e) {\n                callback.failed(e);\n            }\n        }\n    }"
        ],
        [
            "Olingo4AppImpl::serializeBatchRequest(Edm,List,String)",
            " 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564  \n 565  \n 566  \n 567  \n 568  \n 569  \n 570 -\n 571  \n 572  \n 573  \n 574  \n 575  \n 576  \n 577  \n 578  \n 579  \n 580  \n 581  \n 582  \n 583  \n 584  \n 585  \n 586  \n 587  \n 588  \n 589  \n 590 -\n 591 -\n 592  \n 593  \n 594  \n 595  \n 596  \n 597  \n 598  \n 599  \n 600  \n 601  \n 602  \n 603  \n 604  \n 605  \n 606  \n 607  \n 608  \n 609  \n 610  \n 611  \n 612  \n 613  \n 614  ",
            "    private InputStream serializeBatchRequest(final Edm edm, final List<Olingo4BatchRequest> batchParts, String boundary) throws ODataException {\n        final ByteArrayOutputStream batchRequestHeaderOutputStream = new ByteArrayOutputStream();\n\n        try {\n            batchRequestHeaderOutputStream.write(boundary.getBytes(Constants.UTF8));\n            batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);\n\n            for (Olingo4BatchRequest batchPart : batchParts) {\n                writeHttpHeader(batchRequestHeaderOutputStream, HttpHeaders.CONTENT_TYPE, ContentType.APPLICATION_HTTP.toContentTypeString());\n                writeHttpHeader(batchRequestHeaderOutputStream, ODataBatchConstants.ITEM_TRANSFER_ENCODING_LINE, null);\n\n                if (batchPart instanceof Olingo4BatchQueryRequest) {\n                    final Olingo4BatchQueryRequest batchQueryPart = (Olingo4BatchQueryRequest)batchPart;\n                    final String batchQueryUri = createUri(StringUtils.isBlank(batchQueryPart.getResourceUri()) ? serviceUri : batchQueryPart.getResourceUri(),\n                                                           batchQueryPart.getResourcePath(), concatQueryParams(batchQueryPart.getQueryParams()));\n                    final UriInfo uriInfo = parseUri(edm, batchQueryPart.getResourcePath(), concatQueryParams(batchQueryPart.getQueryParams()));\n                    batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);\n\n                    batchRequestHeaderOutputStream.write((HttpGet.METHOD_NAME + \" \" + batchQueryUri + \" \" + HttpVersion.HTTP_1_1).getBytes(Constants.UTF8));\n                    batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);\n                    writeHttpHeader(batchRequestHeaderOutputStream, HttpHeaders.ACCEPT, getResourceContentType(uriInfo).toContentTypeString());\n\n                    batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);\n                    batchRequestHeaderOutputStream.write(boundary.getBytes(Constants.UTF8));\n                    batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);\n                } else if (batchPart instanceof Olingo4BatchChangeRequest) {\n                    final Olingo4BatchChangeRequest batchChangePart = (Olingo4BatchChangeRequest)batchPart;\n                    final String batchChangeUri = createUri(StringUtils.isBlank(batchChangePart.getResourceUri()) ? serviceUri : batchChangePart.getResourceUri(),\n                                                            batchChangePart.getResourcePath(), null);\n                    final UriInfo uriInfo = parseUri(edm, batchChangePart.getResourcePath(), null);\n\n                    if (batchChangePart.getOperation() != Operation.DELETE) {\n                        writeHttpHeader(batchRequestHeaderOutputStream, CONTENT_ID_HEADER, batchChangePart.getContentId());\n                    }\n\n                    batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);\n                    batchRequestHeaderOutputStream\n                        .write((batchChangePart.getOperation().getHttpMethod() + \" \" + batchChangeUri + \" \" + HttpVersion.HTTP_1_1).getBytes(Constants.UTF8));\n                    batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);\n                    writeHttpHeader(batchRequestHeaderOutputStream, HttpHeader.ODATA_VERSION, ODataServiceVersion.V40.toString());\n                    writeHttpHeader(batchRequestHeaderOutputStream, HttpHeaders.ACCEPT, getResourceContentType(uriInfo).toContentTypeString());\n                    writeHttpHeader(batchRequestHeaderOutputStream, HttpHeaders.CONTENT_TYPE, getResourceContentType(uriInfo).toContentTypeString());\n\n                    if (batchChangePart.getOperation() != Operation.DELETE) {\n                        batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);\n                        AbstractHttpEntity httpEnity = writeContent(edm, uriInfo, batchChangePart.getBody());\n\n                        batchRequestHeaderOutputStream.write(IOUtils.toByteArray(httpEnity.getContent()));\n                        batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);\n                        batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);\n                    } else {\n                        batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);\n                    }\n\n                    batchRequestHeaderOutputStream.write(boundary.getBytes(Constants.UTF8));\n                    batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);\n                } else {\n                    throw new ODataException(\"Unsupported batch part request object type: \" + batchPart);\n                }\n            }\n        } catch (Exception e) {\n            throw new ODataException(\"Error during batch request serialization\", e);\n        }\n        return new ByteArrayInputStream(batchRequestHeaderOutputStream.toByteArray());\n    }",
            " 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564  \n 565  \n 566  \n 567  \n 568  \n 569  \n 570 +\n 571 +\n 572 +\n 573 +\n 574 +\n 575 +\n 576  \n 577  \n 578  \n 579  \n 580  \n 581  \n 582  \n 583  \n 584  \n 585  \n 586  \n 587  \n 588  \n 589  \n 590  \n 591  \n 592  \n 593  \n 594  \n 595 +\n 596 +\n 597 +\n 598 +\n 599 +\n 600 +\n 601 +\n 602  \n 603  \n 604  \n 605  \n 606  \n 607  \n 608  \n 609  \n 610  \n 611  \n 612  \n 613  \n 614  \n 615  \n 616  \n 617  \n 618  \n 619  \n 620  \n 621  \n 622  \n 623  \n 624  ",
            "    private InputStream serializeBatchRequest(final Edm edm, final List<Olingo4BatchRequest> batchParts, String boundary) throws ODataException {\n        final ByteArrayOutputStream batchRequestHeaderOutputStream = new ByteArrayOutputStream();\n\n        try {\n            batchRequestHeaderOutputStream.write(boundary.getBytes(Constants.UTF8));\n            batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);\n\n            for (Olingo4BatchRequest batchPart : batchParts) {\n                writeHttpHeader(batchRequestHeaderOutputStream, HttpHeaders.CONTENT_TYPE, ContentType.APPLICATION_HTTP.toContentTypeString());\n                writeHttpHeader(batchRequestHeaderOutputStream, ODataBatchConstants.ITEM_TRANSFER_ENCODING_LINE, null);\n\n                if (batchPart instanceof Olingo4BatchQueryRequest) {\n                    final Olingo4BatchQueryRequest batchQueryPart = (Olingo4BatchQueryRequest)batchPart;\n                    final String batchQueryUri = createUri(StringUtils.isBlank(batchQueryPart.getResourceUri()) ? serviceUri : batchQueryPart.getResourceUri(),\n                                                           batchQueryPart.getResourcePath(), concatQueryParams(batchQueryPart.getQueryParams()));\n                    final UriInfo uriInfo = parseUri(edm, batchQueryPart.getResourcePath(), concatQueryParams(batchQueryPart.getQueryParams()));\n                    batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);\n\n                    batchRequestHeaderOutputStream.write((HttpGet.METHOD_NAME + \" \" + batchQueryUri + \" \" + HttpVersion.HTTP_1_1).getBytes(Constants.UTF8));\n                    batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);\n                    final ContentType acceptType = getResourceContentType(uriInfo);\n                    final String acceptCharset = acceptType.getParameter(ContentType.PARAMETER_CHARSET);\n                    writeHttpHeader(batchRequestHeaderOutputStream, HttpHeaders.ACCEPT, acceptType.getType().toLowerCase());\n                    if (null != acceptCharset) {\n                        writeHttpHeader(batchRequestHeaderOutputStream, HttpHeaders.ACCEPT_CHARSET, acceptCharset.toLowerCase());\n                    }\n\n                    batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);\n                    batchRequestHeaderOutputStream.write(boundary.getBytes(Constants.UTF8));\n                    batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);\n                } else if (batchPart instanceof Olingo4BatchChangeRequest) {\n                    final Olingo4BatchChangeRequest batchChangePart = (Olingo4BatchChangeRequest)batchPart;\n                    final String batchChangeUri = createUri(StringUtils.isBlank(batchChangePart.getResourceUri()) ? serviceUri : batchChangePart.getResourceUri(),\n                                                            batchChangePart.getResourcePath(), null);\n                    final UriInfo uriInfo = parseUri(edm, batchChangePart.getResourcePath(), null);\n\n                    if (batchChangePart.getOperation() != Operation.DELETE) {\n                        writeHttpHeader(batchRequestHeaderOutputStream, CONTENT_ID_HEADER, batchChangePart.getContentId());\n                    }\n\n                    batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);\n                    batchRequestHeaderOutputStream\n                        .write((batchChangePart.getOperation().getHttpMethod() + \" \" + batchChangeUri + \" \" + HttpVersion.HTTP_1_1).getBytes(Constants.UTF8));\n                    batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);\n                    writeHttpHeader(batchRequestHeaderOutputStream, HttpHeader.ODATA_VERSION, ODataServiceVersion.V40.toString());\n                    final ContentType acceptType = getResourceContentType(uriInfo);\n                    final String acceptCharset = acceptType.getParameter(ContentType.PARAMETER_CHARSET);\n                    writeHttpHeader(batchRequestHeaderOutputStream, HttpHeaders.ACCEPT, acceptType.getType().toLowerCase());\n                    if (null != acceptCharset) {\n                        writeHttpHeader(batchRequestHeaderOutputStream, HttpHeaders.ACCEPT_CHARSET, acceptCharset.toLowerCase());\n                    }\n                    writeHttpHeader(batchRequestHeaderOutputStream, HttpHeaders.CONTENT_TYPE, acceptType.toContentTypeString());\n\n                    if (batchChangePart.getOperation() != Operation.DELETE) {\n                        batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);\n                        AbstractHttpEntity httpEnity = writeContent(edm, uriInfo, batchChangePart.getBody());\n\n                        batchRequestHeaderOutputStream.write(IOUtils.toByteArray(httpEnity.getContent()));\n                        batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);\n                        batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);\n                    } else {\n                        batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);\n                    }\n\n                    batchRequestHeaderOutputStream.write(boundary.getBytes(Constants.UTF8));\n                    batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);\n                } else {\n                    throw new ODataException(\"Unsupported batch part request object type: \" + batchPart);\n                }\n            }\n        } catch (Exception e) {\n            throw new ODataException(\"Error during batch request serialization\", e);\n        }\n        return new ByteArrayInputStream(batchRequestHeaderOutputStream.toByteArray());\n    }"
        ],
        [
            "Olingo2AppImpl::createBatchChangeSetPart(Edm,Map,Olingo2BatchChangeRequest)",
            " 734  \n 735  \n 736  \n 737  \n 738  \n 739  \n 740  \n 741  \n 742  \n 743  \n 744  \n 745  \n 746  \n 747  \n 748  \n 749  \n 750  \n 751  \n 752  \n 753  \n 754  \n 755  \n 756  \n 757  \n 758  \n 759  \n 760  \n 761  \n 762  \n 763  \n 764  \n 765  \n 766  \n 767  \n 768  \n 769 -\n 770  \n 771  \n 772  \n 773  \n 774  \n 775  \n 776  \n 777  \n 778  \n 779  \n 780  \n 781  \n 782  \n 783  \n 784  \n 785  \n 786  ",
            "    private BatchChangeSetPart createBatchChangeSetPart(Edm edm, Map<String, String> contentIdMap,\n                                                        Olingo2BatchChangeRequest batchRequest)\n        throws EdmException, URISyntaxException, EntityProviderException, IOException, ODataApplicationException {\n\n        // build body string\n        String resourcePath = batchRequest.getResourcePath();\n        // is it a referenced entity?\n        if (resourcePath.startsWith(\"$\")) {\n            resourcePath = replaceContentId(edm, resourcePath, contentIdMap);\n        }\n\n        final UriInfoWithType uriInfo = parseUri(edm, resourcePath, null);\n\n        // serialize data into ODataResponse object, if set in request and this is not a DELETE request\n        final Map<String, String> headers = new HashMap<String, String>();\n        byte[] body = null;\n\n        if (batchRequest.getBody() != null\n            && !Operation.DELETE.equals(batchRequest.getOperation())) {\n\n            final ODataResponse response = writeContent(edm, uriInfo, batchRequest.getBody());\n            // copy response headers\n            for (String header : response.getHeaderNames()) {\n                headers.put(header, response.getHeader(header));\n            }\n\n            // get (http) entity which is for default Olingo2 implementation an InputStream\n            body = response.getEntity() instanceof InputStream\n                ? EntityProvider.readBinary((InputStream) response.getEntity()) : null;\n            if (body != null) {\n                headers.put(HttpHeaders.CONTENT_LENGTH, String.valueOf(body.length));\n            }\n        }\n\n        // Olingo is sensitive to batch part charset case!!\n        headers.put(HttpHeaders.ACCEPT, getResourceContentType(uriInfo).toString().toLowerCase());\n        if (!headers.containsKey(HttpHeaders.CONTENT_TYPE)) {\n            headers.put(HttpHeaders.CONTENT_TYPE, getContentType());\n        }\n\n        // add request headers\n        headers.putAll(batchRequest.getHeaders());\n\n        final String contentId = batchRequest.getContentId();\n        if (contentId != null) {\n            contentIdMap.put(\"$\" + contentId, resourcePath);\n        }\n        return BatchChangeSetPart.uri(createBatchUri(batchRequest))\n            .method(batchRequest.getOperation().getHttpMethod())\n            .contentId(contentId)\n            .headers(headers)\n            .body(body == null ? null : new String(body, Consts.UTF_8)).build();\n    }",
            " 734  \n 735  \n 736  \n 737  \n 738  \n 739  \n 740  \n 741  \n 742  \n 743  \n 744  \n 745  \n 746  \n 747  \n 748  \n 749  \n 750  \n 751  \n 752  \n 753  \n 754  \n 755  \n 756  \n 757  \n 758  \n 759  \n 760  \n 761  \n 762  \n 763  \n 764  \n 765  \n 766  \n 767  \n 768  \n 769 +\n 770 +\n 771 +\n 772 +\n 773 +\n 774 +\n 775  \n 776  \n 777  \n 778  \n 779  \n 780  \n 781  \n 782  \n 783  \n 784  \n 785  \n 786  \n 787  \n 788  \n 789  \n 790  \n 791  ",
            "    private BatchChangeSetPart createBatchChangeSetPart(Edm edm, Map<String, String> contentIdMap,\n                                                        Olingo2BatchChangeRequest batchRequest)\n        throws EdmException, URISyntaxException, EntityProviderException, IOException, ODataApplicationException {\n\n        // build body string\n        String resourcePath = batchRequest.getResourcePath();\n        // is it a referenced entity?\n        if (resourcePath.startsWith(\"$\")) {\n            resourcePath = replaceContentId(edm, resourcePath, contentIdMap);\n        }\n\n        final UriInfoWithType uriInfo = parseUri(edm, resourcePath, null);\n\n        // serialize data into ODataResponse object, if set in request and this is not a DELETE request\n        final Map<String, String> headers = new HashMap<String, String>();\n        byte[] body = null;\n\n        if (batchRequest.getBody() != null\n            && !Operation.DELETE.equals(batchRequest.getOperation())) {\n\n            final ODataResponse response = writeContent(edm, uriInfo, batchRequest.getBody());\n            // copy response headers\n            for (String header : response.getHeaderNames()) {\n                headers.put(header, response.getHeader(header));\n            }\n\n            // get (http) entity which is for default Olingo2 implementation an InputStream\n            body = response.getEntity() instanceof InputStream\n                ? EntityProvider.readBinary((InputStream) response.getEntity()) : null;\n            if (body != null) {\n                headers.put(HttpHeaders.CONTENT_LENGTH, String.valueOf(body.length));\n            }\n        }\n\n        // Olingo is sensitive to batch part charset case!!\n        final ContentType contentType = getResourceContentType(uriInfo);\n        headers.put(HttpHeaders.ACCEPT, contentType.withCharset(\"\").toString().toLowerCase());\n        final Charset charset = contentType.getCharset();\n        if (null != charset) {\n            headers.put(HttpHeaders.ACCEPT_CHARSET, charset.name().toLowerCase());\n        }\n        if (!headers.containsKey(HttpHeaders.CONTENT_TYPE)) {\n            headers.put(HttpHeaders.CONTENT_TYPE, getContentType());\n        }\n\n        // add request headers\n        headers.putAll(batchRequest.getHeaders());\n\n        final String contentId = batchRequest.getContentId();\n        if (contentId != null) {\n            contentIdMap.put(\"$\" + contentId, resourcePath);\n        }\n        return BatchChangeSetPart.uri(createBatchUri(batchRequest))\n            .method(batchRequest.getOperation().getHttpMethod())\n            .contentId(contentId)\n            .headers(headers)\n            .body(body == null ? null : new String(body, Consts.UTF_8)).build();\n    }"
        ],
        [
            "Olingo2AppImpl::execute(HttpUriRequest,ContentType,FutureCallback)",
            "1009  \n1010  \n1011  \n1012  \n1013  \n1014  \n1015  \n1016 -\n1017  \n1018  \n1019  \n1020 -\n1021  \n1022  \n1023  \n1024  \n1025 -\n1026  \n1027  \n1028  \n1029  \n1030  \n1031  \n1032  \n1033  \n1034  \n1035  \n1036  \n1037  \n1038  \n1039  \n1040  \n1041  \n1042  \n1043  \n1044  \n1045  \n1046  \n1047  \n1048  \n1049  \n1050  \n1051  \n1052  \n1053  \n1054  \n1055  \n1056  ",
            "    /**\n     * public for unit test, not to be used otherwise\n     */\n    public void execute(HttpUriRequest httpUriRequest, ContentType contentType,\n                        FutureCallback<HttpResponse> callback) {\n\n        // add accept header when its not a form or multipart\n        final String contentTypeString = contentType.toString();\n        if (!ContentType.APPLICATION_FORM_URLENCODED.getMimeType().equals(contentType.getMimeType())\n            && !contentType.getMimeType().startsWith(MULTIPART_MIME_TYPE)) {\n            // otherwise accept what is being sent\n            httpUriRequest.addHeader(HttpHeaders.ACCEPT, contentTypeString);\n        }\n        // is something being sent?\n        if (httpUriRequest instanceof HttpEntityEnclosingRequestBase\n            && httpUriRequest.getFirstHeader(HttpHeaders.CONTENT_TYPE) == null) {\n            httpUriRequest.addHeader(HttpHeaders.CONTENT_TYPE, contentTypeString);\n        }\n\n        // set user specified custom headers\n        if (httpHeaders != null && !httpHeaders.isEmpty()) {\n            for (Map.Entry<String, String> entry : httpHeaders.entrySet()) {\n                httpUriRequest.setHeader(entry.getKey(), entry.getValue());\n            }\n        }\n\n        // add client protocol version if not specified\n        if (!httpUriRequest.containsHeader(ODataHttpHeaders.DATASERVICEVERSION)) {\n            httpUriRequest.addHeader(ODataHttpHeaders.DATASERVICEVERSION, ODataServiceVersion.V20);\n        }\n        if (!httpUriRequest.containsHeader(MAX_DATA_SERVICE_VERSION)) {\n            httpUriRequest.addHeader(MAX_DATA_SERVICE_VERSION, ODataServiceVersion.V30);\n        }\n\n        // execute request\n        if (client instanceof CloseableHttpAsyncClient) {\n            ((CloseableHttpAsyncClient) client).execute(httpUriRequest, callback);\n        } else {\n            // invoke the callback methods explicitly after executing the\n            // request synchronously\n            try {\n                CloseableHttpResponse result = ((CloseableHttpClient) client).execute(httpUriRequest);\n                callback.completed(result);\n            } catch (IOException e) {\n                callback.failed(e);\n            }\n        }\n    }",
            "1020  \n1021  \n1022  \n1023  \n1024  \n1025  \n1026  \n1027  \n1028  \n1029  \n1030 +\n1031  \n1032  \n1033  \n1034  \n1035 +\n1036 +\n1037 +\n1038 +\n1039 +\n1040  \n1041  \n1042  \n1043  \n1044  \n1045  \n1046  \n1047  \n1048  \n1049  \n1050  \n1051  \n1052  \n1053  \n1054  \n1055  \n1056  \n1057  \n1058  \n1059  \n1060  \n1061  \n1062  \n1063  \n1064  \n1065  \n1066  \n1067  \n1068  \n1069  \n1070  ",
            "    /**\n     * public for unit test, not to be used otherwise\n     */\n    public void execute(HttpUriRequest httpUriRequest, ContentType contentType,\n                        FutureCallback<HttpResponse> callback) {\n\n        // add accept header when its not a form or multipart\n        if (!ContentType.APPLICATION_FORM_URLENCODED.getMimeType().equals(contentType.getMimeType())\n            && !contentType.getMimeType().startsWith(MULTIPART_MIME_TYPE)) {\n            // otherwise accept what is being sent\n            httpUriRequest.addHeader(HttpHeaders.ACCEPT, contentType.withCharset(\"\").toString().toLowerCase());\n        }\n        // is something being sent?\n        if (httpUriRequest instanceof HttpEntityEnclosingRequestBase\n            && httpUriRequest.getFirstHeader(HttpHeaders.CONTENT_TYPE) == null) {\n            httpUriRequest.addHeader(HttpHeaders.CONTENT_TYPE, contentType.toString());\n            final Charset charset = contentType.getCharset();\n            if (null != charset) {\n                httpUriRequest.addHeader(HttpHeaders.ACCEPT_CHARSET, charset.name().toLowerCase());\n            }\n        }\n\n        // set user specified custom headers\n        if (httpHeaders != null && !httpHeaders.isEmpty()) {\n            for (Map.Entry<String, String> entry : httpHeaders.entrySet()) {\n                httpUriRequest.setHeader(entry.getKey(), entry.getValue());\n            }\n        }\n\n        // add client protocol version if not specified\n        if (!httpUriRequest.containsHeader(ODataHttpHeaders.DATASERVICEVERSION)) {\n            httpUriRequest.addHeader(ODataHttpHeaders.DATASERVICEVERSION, ODataServiceVersion.V20);\n        }\n        if (!httpUriRequest.containsHeader(MAX_DATA_SERVICE_VERSION)) {\n            httpUriRequest.addHeader(MAX_DATA_SERVICE_VERSION, ODataServiceVersion.V30);\n        }\n\n        // execute request\n        if (client instanceof CloseableHttpAsyncClient) {\n            ((CloseableHttpAsyncClient) client).execute(httpUriRequest, callback);\n        } else {\n            // invoke the callback methods explicitly after executing the\n            // request synchronously\n            try {\n                CloseableHttpResponse result = ((CloseableHttpClient) client).execute(httpUriRequest);\n                callback.completed(result);\n            } catch (IOException e) {\n                callback.failed(e);\n            }\n        }\n    }"
        ],
        [
            "Olingo2AppImpl::createBatchQueryPart(UriInfoWithType,Olingo2BatchQueryRequest)",
            " 788  \n 789  \n 790  \n 791  \n 792  \n 793 -\n 794  \n 795  \n 796  \n 797  \n 798  \n 799  \n 800  ",
            "    private BatchQueryPart createBatchQueryPart(UriInfoWithType uriInfo, Olingo2BatchQueryRequest batchRequest) {\n\n        final Map<String, String> headers = new HashMap<String, String>(batchRequest.getHeaders());\n        if (!headers.containsKey(HttpHeaders.ACCEPT)) {\n            // Olingo is sensitive to batch part charset case!!\n            headers.put(HttpHeaders.ACCEPT, getResourceContentType(uriInfo).toString().toLowerCase());\n        }\n\n        return BatchQueryPart.method(\"GET\")\n            .uri(createBatchUri(batchRequest))\n            .headers(headers)\n            .build();\n    }",
            " 793  \n 794  \n 795  \n 796 +\n 797 +\n 798  \n 799  \n 800 +\n 801 +\n 802 +\n 803 +\n 804  \n 805 +\n 806  \n 807  \n 808  \n 809  \n 810  \n 811  ",
            "    private BatchQueryPart createBatchQueryPart(UriInfoWithType uriInfo, Olingo2BatchQueryRequest batchRequest) {\n\n        final Map<String, String> headers = new HashMap<String, String>(batchRequest.getHeaders());\n        final ContentType contentType = getResourceContentType(uriInfo);\n        final Charset charset = contentType.getCharset();\n        if (!headers.containsKey(HttpHeaders.ACCEPT)) {\n            // Olingo is sensitive to batch part charset case!!\n            headers.put(HttpHeaders.ACCEPT, contentType.withCharset(\"\").toString().toLowerCase());\n        }\n        if (!headers.containsKey(HttpHeaders.ACCEPT_CHARSET) && (null != charset)) {\n            headers.put(HttpHeaders.ACCEPT_CHARSET, charset.name().toLowerCase());\n        }\n        \n\n        return BatchQueryPart.method(\"GET\")\n            .uri(createBatchUri(batchRequest))\n            .headers(headers)\n            .build();\n    }"
        ]
    ],
    "23b84b9f0264eaf35a6ef7ebc87b223c4a7177af": [
        [
            "XsltBuilderTest::testXsltInputStream()",
            " 104  \n 105  \n 106  \n 107 -\n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  ",
            "    public void testXsltInputStream() throws Exception {\n        File styleSheet = new File(\"src/test/resources/org/apache/camel/builder/xml/example.xsl\");\n\n        XsltBuilder builder = XsltBuilder.xslt(new FileInputStream(styleSheet));\n\n        Exchange exchange = new DefaultExchange(context);\n        exchange.getIn().setBody(\"<hello>world!</hello>\");\n\n        builder.process(exchange);\n\n        assertEquals(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><goodbye>world!</goodbye>\", exchange.getOut().getBody());\n    }",
            " 105  \n 106  \n 107  \n 108 +\n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  ",
            "    public void testXsltInputStream() throws Exception {\n        File styleSheet = new File(\"src/test/resources/org/apache/camel/builder/xml/example.xsl\");\n\n        XsltBuilder builder = XsltBuilder.xslt(Files.newInputStream(Paths.get(styleSheet.getAbsolutePath())));\n\n        Exchange exchange = new DefaultExchange(context);\n        exchange.getIn().setBody(\"<hello>world!</hello>\");\n\n        builder.process(exchange);\n\n        assertEquals(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><goodbye>world!</goodbye>\", exchange.getOut().getBody());\n    }"
        ],
        [
            "FileProducerCharsetUTFOptimizedTest::testFileProducerCharsetUTFOptimized()",
            "  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64 -\n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  ",
            "    public void testFileProducerCharsetUTFOptimized() throws Exception {\n        oneExchangeDone.matchesMockWaitTime();\n\n        File file = new File(\"target/charset/output.txt\");\n        assertTrue(\"File should exist\", file.exists());\n\n        InputStream fis = IOHelper.buffered(new FileInputStream(file));\n        byte[] buffer = new byte[100];\n\n        int len = fis.read(buffer);\n        assertTrue(\"Should read data: \" + len, len != -1);\n        byte[] data = new byte[len];\n        System.arraycopy(buffer, 0, data, 0, len);\n        fis.close();\n\n        // data should be in utf, where the danish ae is -61 -90\n        assertEquals(5, data.length);\n        assertEquals(65, data[0]);\n        assertEquals(66, data[1]);\n        assertEquals(67, data[2]);\n        assertEquals(-61, data[3]);\n        assertEquals(-90, data[4]);\n    }",
            "  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67 +\n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  ",
            "    public void testFileProducerCharsetUTFOptimized() throws Exception {\n        oneExchangeDone.matchesMockWaitTime();\n\n        File file = new File(\"target/charset/output.txt\");\n        assertTrue(\"File should exist\", file.exists());\n\n        InputStream fis = Files.newInputStream(Paths.get(file.getAbsolutePath()));\n        byte[] buffer = new byte[100];\n\n        int len = fis.read(buffer);\n        assertTrue(\"Should read data: \" + len, len != -1);\n        byte[] data = new byte[len];\n        System.arraycopy(buffer, 0, data, 0, len);\n        fis.close();\n\n        // data should be in utf, where the danish ae is -61 -90\n        assertEquals(5, data.length);\n        assertEquals(65, data[0]);\n        assertEquals(66, data[1]);\n        assertEquals(67, data[2]);\n        assertEquals(-61, data[3]);\n        assertEquals(-90, data[4]);\n    }"
        ],
        [
            "IOConverterCharsetTest::testToInputStreamFileDirectByteDumpWithCharsetLatin1()",
            "  72  \n  73  \n  74  \n  75  \n  76 -\n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  ",
            "    public void testToInputStreamFileDirectByteDumpWithCharsetLatin1() throws Exception {\n        switchToDefaultCharset(StandardCharsets.UTF_8);\n        File file = new File(\"src/test/resources/org/apache/camel/converter/german.iso-8859-1.txt\");\n        try (InputStream in = IOConverter.toInputStream(file, \"ISO-8859-1\");\n        InputStream naiveIn = new FileInputStream(file)) {\n            byte[] bytes = new byte[8192];\n            in.read(bytes);\n            byte[] naiveBytes = new byte[8192];\n            naiveIn.read(naiveBytes);\n            assertFalse(\"both input streams deliver the same byte sequence\", Arrays.equals(naiveBytes, bytes));\n        }\n    }",
            "  73  \n  74  \n  75  \n  76  \n  77 +\n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  ",
            "    public void testToInputStreamFileDirectByteDumpWithCharsetLatin1() throws Exception {\n        switchToDefaultCharset(StandardCharsets.UTF_8);\n        File file = new File(\"src/test/resources/org/apache/camel/converter/german.iso-8859-1.txt\");\n        try (InputStream in = IOConverter.toInputStream(file, \"ISO-8859-1\");\n        InputStream naiveIn = Files.newInputStream(Paths.get(file.getAbsolutePath()))) {\n            byte[] bytes = new byte[8192];\n            in.read(bytes);\n            byte[] naiveBytes = new byte[8192];\n            naiveIn.read(naiveBytes);\n            assertFalse(\"both input streams deliver the same byte sequence\", Arrays.equals(naiveBytes, bytes));\n        }\n    }"
        ],
        [
            "FileProducerCharsetUTFtoISOConvertBodyToTest::setUp()",
            "  38  \n  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58 -\n  59  \n  60  \n  61  \n  62  \n  63  ",
            "    @Override\n    protected void setUp() throws Exception {\n        // use utf-8 as original payload with 00e6 which is a danish ae letter\n        utf = \"ABC\\u00e6\".getBytes(\"utf-8\");\n        iso = \"ABC\\u00e6\".getBytes(\"iso-8859-1\");\n\n        deleteDirectory(\"target/charset\");\n        createDirectory(\"target/charset/input\");\n\n        log.debug(\"utf: {}\", new String(utf, Charset.forName(\"utf-8\")));\n        log.debug(\"iso: {}\", new String(iso, Charset.forName(\"iso-8859-1\")));\n\n        for (byte b : utf) {\n            log.debug(\"utf byte: {}\", b);\n        }\n        for (byte b : iso) {\n            log.debug(\"iso byte: {}\", b);\n        }\n\n        // write the byte array to a file using plain API\n        FileOutputStream fos = new FileOutputStream(\"target/charset/input/input.txt\");\n        fos.write(utf);\n        fos.close();\n\n        super.setUp();\n    }",
            "  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61 +\n  62  \n  63  \n  64  \n  65  \n  66  ",
            "    @Override\n    protected void setUp() throws Exception {\n        // use utf-8 as original payload with 00e6 which is a danish ae letter\n        utf = \"ABC\\u00e6\".getBytes(\"utf-8\");\n        iso = \"ABC\\u00e6\".getBytes(\"iso-8859-1\");\n\n        deleteDirectory(\"target/charset\");\n        createDirectory(\"target/charset/input\");\n\n        log.debug(\"utf: {}\", new String(utf, Charset.forName(\"utf-8\")));\n        log.debug(\"iso: {}\", new String(iso, Charset.forName(\"iso-8859-1\")));\n\n        for (byte b : utf) {\n            log.debug(\"utf byte: {}\", b);\n        }\n        for (byte b : iso) {\n            log.debug(\"iso byte: {}\", b);\n        }\n\n        // write the byte array to a file using plain API\n        OutputStream fos = Files.newOutputStream(Paths.get(\"target/charset/input/input.txt\"));\n        fos.write(utf);\n        fos.close();\n\n        super.setUp();\n    }"
        ],
        [
            "XsltBuilderTest::testXsltTransformerInputStream()",
            " 117  \n 118  \n 119  \n 120  \n 121 -\n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  ",
            "    public void testXsltTransformerInputStream() throws Exception {\n        File styleSheet = new File(\"src/test/resources/org/apache/camel/builder/xml/example.xsl\");\n\n        XsltBuilder builder = new XsltBuilder();\n        builder.setTransformerInputStream(new FileInputStream(styleSheet));\n\n        Exchange exchange = new DefaultExchange(context);\n        exchange.getIn().setBody(\"<hello>world!</hello>\");\n\n        builder.process(exchange);\n\n        assertEquals(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><goodbye>world!</goodbye>\", exchange.getOut().getBody());\n    }",
            " 118  \n 119  \n 120  \n 121  \n 122 +\n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  ",
            "    public void testXsltTransformerInputStream() throws Exception {\n        File styleSheet = new File(\"src/test/resources/org/apache/camel/builder/xml/example.xsl\");\n\n        XsltBuilder builder = new XsltBuilder();\n        builder.setTransformerInputStream(Files.newInputStream(Paths.get(styleSheet.getAbsolutePath())));\n\n        Exchange exchange = new DefaultExchange(context);\n        exchange.getIn().setBody(\"<hello>world!</hello>\");\n\n        builder.process(exchange);\n\n        assertEquals(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><goodbye>world!</goodbye>\", exchange.getOut().getBody());\n    }"
        ],
        [
            "XmlLineNumberParserTest::testParseCamelContext()",
            "  45  \n  46 -\n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  ",
            "    public void testParseCamelContext() throws Exception {\n        FileInputStream fis = new FileInputStream(\"src/test/resources/org/apache/camel/util/camel-context.xml\");\n        Document dom = XmlLineNumberParser.parseXml(fis, null, \"camelContext\", null);\n        assertNotNull(dom);\n\n        NodeList list = dom.getElementsByTagName(\"camelContext\");\n        assertEquals(1, list.getLength());\n        Node node = list.item(0);\n\n        String lineNumber = (String) node.getUserData(XmlLineNumberParser.LINE_NUMBER);\n        String lineNumberEnd = (String) node.getUserData(XmlLineNumberParser.LINE_NUMBER_END);\n\n        assertEquals(\"29\", lineNumber);\n        assertEquals(\"47\", lineNumberEnd);\n    }",
            "  47  \n  48 +\n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  ",
            "    public void testParseCamelContext() throws Exception {\n        InputStream fis = Files.newInputStream(Paths.get(\"src/test/resources/org/apache/camel/util/camel-context.xml\"));\n        Document dom = XmlLineNumberParser.parseXml(fis, null, \"camelContext\", null);\n        assertNotNull(dom);\n\n        NodeList list = dom.getElementsByTagName(\"camelContext\");\n        assertEquals(1, list.getLength());\n        Node node = list.item(0);\n\n        String lineNumber = (String) node.getUserData(XmlLineNumberParser.LINE_NUMBER);\n        String lineNumberEnd = (String) node.getUserData(XmlLineNumberParser.LINE_NUMBER_END);\n\n        assertEquals(\"29\", lineNumber);\n        assertEquals(\"47\", lineNumberEnd);\n    }"
        ],
        [
            "IOHelperTest::assertReadAsWritten(String,String,String)",
            "  90  \n  91  \n  92  \n  93 -\n  94  \n  95  ",
            "    private void assertReadAsWritten(String testname, String text, String compareText) throws Exception {\n        File file = tempFile(testname);\n        write(file, text);\n        String loadText = IOHelper.loadText(new FileInputStream(file));\n        assertEquals(compareText, loadText);\n    }",
            "  91  \n  92  \n  93  \n  94 +\n  95  \n  96  ",
            "    private void assertReadAsWritten(String testname, String text, String compareText) throws Exception {\n        File file = tempFile(testname);\n        write(file, text);\n        String loadText = IOHelper.loadText(Files.newInputStream(Paths.get(file.getAbsolutePath())));\n        assertEquals(compareText, loadText);\n    }"
        ],
        [
            "FileProducerCharsetUTFOptimizedTest::setUp()",
            "  36  \n  37  \n  38  \n  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51 -\n  52  \n  53  \n  54  \n  55  \n  56  ",
            "    @Override\n    protected void setUp() throws Exception {\n        // use utf-8 as original payload with 00e6 which is a danish ae letter\n        utf = \"ABC\\u00e6\".getBytes(\"utf-8\");\n\n        deleteDirectory(\"target/charset\");\n        createDirectory(\"target/charset/input\");\n\n        log.debug(\"utf: {}\", new String(utf, Charset.forName(\"utf-8\")));\n\n        for (byte b : utf) {\n            log.debug(\"utf byte: {}\", b);\n        }\n\n        // write the byte array to a file using plain API\n        FileOutputStream fos = new FileOutputStream(\"target/charset/input/input.txt\");\n        fos.write(utf);\n        fos.close();\n\n        super.setUp();\n    }",
            "  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54 +\n  55  \n  56  \n  57  \n  58  \n  59  ",
            "    @Override\n    protected void setUp() throws Exception {\n        // use utf-8 as original payload with 00e6 which is a danish ae letter\n        utf = \"ABC\\u00e6\".getBytes(\"utf-8\");\n\n        deleteDirectory(\"target/charset\");\n        createDirectory(\"target/charset/input\");\n\n        log.debug(\"utf: {}\", new String(utf, Charset.forName(\"utf-8\")));\n\n        for (byte b : utf) {\n            log.debug(\"utf byte: {}\", b);\n        }\n\n        // write the byte array to a file using plain API\n        OutputStream fos = Files.newOutputStream(Paths.get(\"target/charset/input/input.txt\"));\n        fos.write(utf);\n        fos.close();\n\n        super.setUp();\n    }"
        ],
        [
            "IOConverterCharsetTest::testToReaderFileWithCharsetLatin1()",
            "  96  \n  97  \n  98  \n  99 -\n 100  \n 101  \n 102  \n 103  \n 104  \n 105  ",
            "    public void testToReaderFileWithCharsetLatin1() throws Exception {\n        File file = new File(\"src/test/resources/org/apache/camel/converter/german.iso-8859-1.txt\");\n        try (BufferedReader reader = IOConverter.toReader(file, \"ISO-8859-1\");\n        BufferedReader naiveReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\"))) {\n            String line = reader.readLine();\n            String naiveLine = naiveReader.readLine();\n            assertEquals(naiveLine, line);\n            assertEquals(CONTENT, line);\n        }\n    }",
            "  97  \n  98  \n  99  \n 100 +\n 101  \n 102  \n 103  \n 104  \n 105  \n 106  ",
            "    public void testToReaderFileWithCharsetLatin1() throws Exception {\n        File file = new File(\"src/test/resources/org/apache/camel/converter/german.iso-8859-1.txt\");\n        try (BufferedReader reader = IOConverter.toReader(file, \"ISO-8859-1\");\n        BufferedReader naiveReader = new BufferedReader(new InputStreamReader(Files.newInputStream(Paths.get(file.getAbsolutePath())), \"ISO-8859-1\"))) {\n            String line = reader.readLine();\n            String naiveLine = naiveReader.readLine();\n            assertEquals(naiveLine, line);\n            assertEquals(CONTENT, line);\n        }\n    }"
        ],
        [
            "IOConverterTest::testToBytes()",
            "  48  \n  49  \n  50 -\n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  ",
            "    public void testToBytes() throws Exception {\n        File file = new File(\"src/test/resources/org/apache/camel/converter/dummy.txt\");\n        byte[] data = IOConverter.toBytes(new FileInputStream(file));\n        assertEquals(\"get the wrong byte size\", file.length(), data.length);\n        assertEquals('#', (char) data[0]);\n\n        // should contain Hello World!\n        String s = new String(data);\n        assertTrue(\"Should contain Hello World!\", s.contains(\"Hello World\"));\n    }",
            "  50  \n  51  \n  52 +\n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  ",
            "    public void testToBytes() throws Exception {\n        File file = new File(\"src/test/resources/org/apache/camel/converter/dummy.txt\");\n        byte[] data = IOConverter.toBytes(Files.newInputStream(Paths.get(file.getAbsolutePath())));\n        assertEquals(\"get the wrong byte size\", file.length(), data.length);\n        assertEquals('#', (char) data[0]);\n\n        // should contain Hello World!\n        String s = new String(data);\n        assertTrue(\"Should contain Hello World!\", s.contains(\"Hello World\"));\n    }"
        ],
        [
            "FileProducerCharsetUTFtoISOTest::setUp()",
            "  37  \n  38  \n  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57 -\n  58  \n  59  \n  60  \n  61  \n  62  ",
            "    @Override\n    protected void setUp() throws Exception {\n        // use utf-8 as original payload with 00e6 which is a danish ae letter\n        utf = \"ABC\\u00e6\".getBytes(\"utf-8\");\n        iso = \"ABC\\u00e6\".getBytes(\"iso-8859-1\");\n\n        deleteDirectory(\"target/charset\");\n        createDirectory(\"target/charset/input\");\n\n        log.debug(\"utf: {}\", new String(utf, Charset.forName(\"utf-8\")));\n        log.debug(\"iso: {}\", new String(iso, Charset.forName(\"iso-8859-1\")));\n\n        for (byte b : utf) {\n            log.debug(\"utf byte: {}\", b);\n        }\n        for (byte b : iso) {\n            log.debug(\"iso byte: {}\", b);\n        }\n\n        // write the byte array to a file using plain API\n        FileOutputStream fos = new FileOutputStream(\"target/charset/input/input.txt\");\n        fos.write(utf);\n        fos.close();\n\n        super.setUp();\n    }",
            "  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60 +\n  61  \n  62  \n  63  \n  64  \n  65  ",
            "    @Override\n    protected void setUp() throws Exception {\n        // use utf-8 as original payload with 00e6 which is a danish ae letter\n        utf = \"ABC\\u00e6\".getBytes(\"utf-8\");\n        iso = \"ABC\\u00e6\".getBytes(\"iso-8859-1\");\n\n        deleteDirectory(\"target/charset\");\n        createDirectory(\"target/charset/input\");\n\n        log.debug(\"utf: {}\", new String(utf, Charset.forName(\"utf-8\")));\n        log.debug(\"iso: {}\", new String(iso, Charset.forName(\"iso-8859-1\")));\n\n        for (byte b : utf) {\n            log.debug(\"utf byte: {}\", b);\n        }\n        for (byte b : iso) {\n            log.debug(\"iso byte: {}\", b);\n        }\n\n        // write the byte array to a file using plain API\n        OutputStream fos = Files.newOutputStream(Paths.get(\"target/charset/input/input.txt\"));\n        fos.write(utf);\n        fos.close();\n\n        super.setUp();\n    }"
        ],
        [
            "IOConverterCharsetTest::testToReaderFileWithCharsetUTF8()",
            "  85  \n  86  \n  87  \n  88 -\n  89  \n  90  \n  91  \n  92  \n  93  \n  94  ",
            "    public void testToReaderFileWithCharsetUTF8() throws Exception {\n        File file = new File(\"src/test/resources/org/apache/camel/converter/german.utf-8.txt\");\n        try (BufferedReader reader = IOConverter.toReader(file, \"UTF-8\");\n        BufferedReader naiveReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8))) {\n            String line = reader.readLine();\n            String naiveLine = naiveReader.readLine();\n            assertEquals(naiveLine, line);\n            assertEquals(CONTENT, line);\n        }\n    }",
            "  86  \n  87  \n  88  \n  89 +\n  90  \n  91  \n  92  \n  93  \n  94  \n  95  ",
            "    public void testToReaderFileWithCharsetUTF8() throws Exception {\n        File file = new File(\"src/test/resources/org/apache/camel/converter/german.utf-8.txt\");\n        try (BufferedReader reader = IOConverter.toReader(file, \"UTF-8\");\n        BufferedReader naiveReader = new BufferedReader(new InputStreamReader(Files.newInputStream(Paths.get(file.getAbsolutePath())), StandardCharsets.UTF_8))) {\n            String line = reader.readLine();\n            String naiveLine = naiveReader.readLine();\n            assertEquals(naiveLine, line);\n            assertEquals(CONTENT, line);\n        }\n    }"
        ],
        [
            "FileProducerCharsetUTFtoISOConfiguredTest::testFileProducerCharsetUTFtoISO()",
            "  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70 -\n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  ",
            "    public void testFileProducerCharsetUTFtoISO() throws Exception {\n        oneExchangeDone.matchesMockWaitTime();\n\n        File file = new File(\"target/charset/output.txt\");\n        assertTrue(\"File should exist\", file.exists());\n\n        InputStream fis = IOHelper.buffered(new FileInputStream(file));\n        byte[] buffer = new byte[100];\n\n        int len = fis.read(buffer);\n        assertTrue(\"Should read data: \" + len, len != -1);\n        byte[] data = new byte[len];\n        System.arraycopy(buffer, 0, data, 0, len);\n        fis.close();\n\n        // data should be in iso, where the danish ae is -26\n        assertEquals(4, data.length);\n        assertEquals(65, data[0]);\n        assertEquals(66, data[1]);\n        assertEquals(67, data[2]);\n        assertEquals(-26, data[3]);\n    }",
            "  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70 +\n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  ",
            "    public void testFileProducerCharsetUTFtoISO() throws Exception {\n        oneExchangeDone.matchesMockWaitTime();\n\n        File file = new File(\"target/charset/output.txt\");\n        assertTrue(\"File should exist\", file.exists());\n\n        InputStream fis = Files.newInputStream(Paths.get(file.getAbsolutePath()));\n        byte[] buffer = new byte[100];\n\n        int len = fis.read(buffer);\n        assertTrue(\"Should read data: \" + len, len != -1);\n        byte[] data = new byte[len];\n        System.arraycopy(buffer, 0, data, 0, len);\n        fis.close();\n\n        // data should be in iso, where the danish ae is -26\n        assertEquals(4, data.length);\n        assertEquals(65, data[0]);\n        assertEquals(66, data[1]);\n        assertEquals(67, data[2]);\n        assertEquals(-26, data[3]);\n    }"
        ],
        [
            "XsltBuilderTest::testXsltSource()",
            " 131  \n 132  \n 133 -\n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  ",
            "    public void testXsltSource() throws Exception {\n        File file = new File(\"src/test/resources/org/apache/camel/builder/xml/example.xsl\");\n        Source styleSheet = new SAXSource(new InputSource(new FileInputStream(file)));\n\n        XsltBuilder builder = XsltBuilder.xslt(styleSheet);\n\n        Exchange exchange = new DefaultExchange(context);\n        exchange.getIn().setBody(\"<hello>world!</hello>\");\n\n        builder.process(exchange);\n\n        assertEquals(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><goodbye>world!</goodbye>\", exchange.getOut().getBody());\n    }",
            " 132  \n 133  \n 134 +\n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  ",
            "    public void testXsltSource() throws Exception {\n        File file = new File(\"src/test/resources/org/apache/camel/builder/xml/example.xsl\");\n        Source styleSheet = new SAXSource(new InputSource(Files.newInputStream(Paths.get(file.getAbsolutePath()))));\n\n        XsltBuilder builder = XsltBuilder.xslt(styleSheet);\n\n        Exchange exchange = new DefaultExchange(context);\n        exchange.getIn().setBody(\"<hello>world!</hello>\");\n\n        builder.process(exchange);\n\n        assertEquals(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><goodbye>world!</goodbye>\", exchange.getOut().getBody());\n    }"
        ],
        [
            "FileProducerCharsetUTFtoISOTest::testFileProducerCharsetUTFtoISO()",
            "  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70 -\n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  ",
            "    public void testFileProducerCharsetUTFtoISO() throws Exception {\n        oneExchangeDone.matchesMockWaitTime();\n\n        File file = new File(\"target/charset/output.txt\");\n        assertTrue(\"File should exist\", file.exists());\n\n        InputStream fis = IOHelper.buffered(new FileInputStream(file));\n        byte[] buffer = new byte[100];\n\n        int len = fis.read(buffer);\n        assertTrue(\"Should read data: \" + len, len != -1);\n        byte[] data = new byte[len];\n        System.arraycopy(buffer, 0, data, 0, len);\n        fis.close();\n\n        // data should be in iso, where the danish ae is -26\n        assertEquals(4, data.length);\n        assertEquals(65, data[0]);\n        assertEquals(66, data[1]);\n        assertEquals(67, data[2]);\n        assertEquals(-26, data[3]);\n    }",
            "  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73 +\n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  ",
            "    public void testFileProducerCharsetUTFtoISO() throws Exception {\n        oneExchangeDone.matchesMockWaitTime();\n\n        File file = new File(\"target/charset/output.txt\");\n        assertTrue(\"File should exist\", file.exists());\n\n        InputStream fis = Files.newInputStream(Paths.get(file.getAbsolutePath()));\n        byte[] buffer = new byte[100];\n\n        int len = fis.read(buffer);\n        assertTrue(\"Should read data: \" + len, len != -1);\n        byte[] data = new byte[len];\n        System.arraycopy(buffer, 0, data, 0, len);\n        fis.close();\n\n        // data should be in iso, where the danish ae is -26\n        assertEquals(4, data.length);\n        assertEquals(65, data[0]);\n        assertEquals(66, data[1]);\n        assertEquals(67, data[2]);\n        assertEquals(-26, data[3]);\n    }"
        ],
        [
            "XmlLineNumberParserTest::testParse()",
            "  29  \n  30 -\n  31  \n  32  \n  33  \n  34  \n  35  \n  36  \n  37  \n  38  \n  39  \n  40  \n  41  \n  42  \n  43  ",
            "    public void testParse() throws Exception {\n        FileInputStream fis = new FileInputStream(\"src/test/resources/org/apache/camel/util/camel-context.xml\");\n        Document dom = XmlLineNumberParser.parseXml(fis);\n        assertNotNull(dom);\n\n        NodeList list = dom.getElementsByTagName(\"beans\");\n        assertEquals(1, list.getLength());\n        Node node = list.item(0);\n\n        String lineNumber = (String) node.getUserData(XmlLineNumberParser.LINE_NUMBER);\n        String lineNumberEnd = (String) node.getUserData(XmlLineNumberParser.LINE_NUMBER_END);\n\n        assertEquals(\"24\", lineNumber);\n        assertEquals(\"49\", lineNumberEnd);\n    }",
            "  31  \n  32 +\n  33  \n  34  \n  35  \n  36  \n  37  \n  38  \n  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  ",
            "    public void testParse() throws Exception {\n        InputStream fis = Files.newInputStream(Paths.get(\"src/test/resources/org/apache/camel/util/camel-context.xml\"));\n        Document dom = XmlLineNumberParser.parseXml(fis);\n        assertNotNull(dom);\n\n        NodeList list = dom.getElementsByTagName(\"beans\");\n        assertEquals(1, list.getLength());\n        Node node = list.item(0);\n\n        String lineNumber = (String) node.getUserData(XmlLineNumberParser.LINE_NUMBER);\n        String lineNumberEnd = (String) node.getUserData(XmlLineNumberParser.LINE_NUMBER_END);\n\n        assertEquals(\"24\", lineNumber);\n        assertEquals(\"49\", lineNumberEnd);\n    }"
        ],
        [
            "IOConverterCharsetTest::testToInputStreamFileWithCharsetLatin1()",
            "  59  \n  60  \n  61  \n  62  \n  63  \n  64 -\n  65  \n  66  \n  67  \n  68  \n  69  \n  70  ",
            "    public void testToInputStreamFileWithCharsetLatin1() throws Exception {\n        switchToDefaultCharset(StandardCharsets.UTF_8);\n        File file = new File(\"src/test/resources/org/apache/camel/converter/german.iso-8859-1.txt\");\n        try (InputStream in = IOConverter.toInputStream(file, \"ISO-8859-1\");\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));\n        BufferedReader naiveReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\"))) {\n            String line = reader.readLine();\n            String naiveLine = naiveReader.readLine();\n            assertEquals(naiveLine, line);\n            assertEquals(CONTENT, line);\n        }\n    }",
            "  60  \n  61  \n  62  \n  63  \n  64  \n  65 +\n  66  \n  67  \n  68  \n  69  \n  70  \n  71  ",
            "    public void testToInputStreamFileWithCharsetLatin1() throws Exception {\n        switchToDefaultCharset(StandardCharsets.UTF_8);\n        File file = new File(\"src/test/resources/org/apache/camel/converter/german.iso-8859-1.txt\");\n        try (InputStream in = IOConverter.toInputStream(file, \"ISO-8859-1\");\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));\n        BufferedReader naiveReader = new BufferedReader(new InputStreamReader(Files.newInputStream(Paths.get(file.getAbsolutePath())), \"ISO-8859-1\"))) {\n            String line = reader.readLine();\n            String naiveLine = naiveReader.readLine();\n            assertEquals(naiveLine, line);\n            assertEquals(CONTENT, line);\n        }\n    }"
        ],
        [
            "FileProducerCharsetUTFtoISOConvertBodyToTest::testFileProducerCharsetUTFtoISOConvertBodyTo()",
            "  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71 -\n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  ",
            "    public void testFileProducerCharsetUTFtoISOConvertBodyTo() throws Exception {\n        oneExchangeDone.matchesMockWaitTime();\n\n        File file = new File(\"target/charset/output.txt\");\n        assertTrue(\"File should exist\", file.exists());\n\n        InputStream fis = IOHelper.buffered(new FileInputStream(file));\n        byte[] buffer = new byte[100];\n\n        int len = fis.read(buffer);\n        assertTrue(\"Should read data: \" + len, len != -1);\n        byte[] data = new byte[len];\n        System.arraycopy(buffer, 0, data, 0, len);\n        fis.close();\n\n\n        for (byte b : data) {\n            log.info(\"loaded byte: {}\", b);\n        }\n\n        // data should be in iso, where the danish ae is -26\n        assertEquals(4, data.length);\n        assertEquals(65, data[0]);\n        assertEquals(66, data[1]);\n        assertEquals(67, data[2]);\n        assertEquals(-26, data[3]);\n    }",
            "  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74 +\n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  ",
            "    public void testFileProducerCharsetUTFtoISOConvertBodyTo() throws Exception {\n        oneExchangeDone.matchesMockWaitTime();\n\n        File file = new File(\"target/charset/output.txt\");\n        assertTrue(\"File should exist\", file.exists());\n\n        InputStream fis = Files.newInputStream(Paths.get(file.getAbsolutePath()));\n        byte[] buffer = new byte[100];\n\n        int len = fis.read(buffer);\n        assertTrue(\"Should read data: \" + len, len != -1);\n        byte[] data = new byte[len];\n        System.arraycopy(buffer, 0, data, 0, len);\n        fis.close();\n\n\n        for (byte b : data) {\n            log.info(\"loaded byte: {}\", b);\n        }\n\n        // data should be in iso, where the danish ae is -26\n        assertEquals(4, data.length);\n        assertEquals(65, data[0]);\n        assertEquals(66, data[1]);\n        assertEquals(67, data[2]);\n        assertEquals(-26, data[3]);\n    }"
        ],
        [
            "FileProducerCharsetUTFtoUTFTest::setUp()",
            "  36  \n  37  \n  38  \n  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51 -\n  52  \n  53  \n  54  \n  55  \n  56  ",
            "    @Override\n    protected void setUp() throws Exception {\n        // use utf-8 as original payload with 00e6 which is a danish ae letter\n        utf = \"ABC\\u00e6\".getBytes(\"utf-8\");\n\n        deleteDirectory(\"target/charset\");\n        createDirectory(\"target/charset/input\");\n\n        log.debug(\"utf: {}\", new String(utf, Charset.forName(\"utf-8\")));\n\n        for (byte b : utf) {\n            log.debug(\"utf byte: {}\", b);\n        }\n\n        // write the byte array to a file using plain API\n        FileOutputStream fos = new FileOutputStream(\"target/charset/input/input.txt\");\n        fos.write(utf);\n        fos.close();\n\n        super.setUp();\n    }",
            "  36  \n  37  \n  38  \n  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51 +\n  52  \n  53  \n  54  \n  55  \n  56  ",
            "    @Override\n    protected void setUp() throws Exception {\n        // use utf-8 as original payload with 00e6 which is a danish ae letter\n        utf = \"ABC\\u00e6\".getBytes(\"utf-8\");\n\n        deleteDirectory(\"target/charset\");\n        createDirectory(\"target/charset/input\");\n\n        log.debug(\"utf: {}\", new String(utf, Charset.forName(\"utf-8\")));\n\n        for (byte b : utf) {\n            log.debug(\"utf byte: {}\", b);\n        }\n\n        // write the byte array to a file using plain API\n        OutputStream fos = Files.newOutputStream(Paths.get(\"target/charset/input/input.txt\"));\n        fos.write(utf);\n        fos.close();\n\n        super.setUp();\n    }"
        ],
        [
            "IOConverterCharsetTest::testToInputStreamFileWithCharsetUTF8withOtherDefaultEncoding()",
            "  46  \n  47  \n  48  \n  49  \n  50  \n  51 -\n  52  \n  53  \n  54  \n  55  \n  56  \n  57  ",
            "    public void testToInputStreamFileWithCharsetUTF8withOtherDefaultEncoding() throws Exception {\n        switchToDefaultCharset(StandardCharsets.ISO_8859_1);\n        File file = new File(\"src/test/resources/org/apache/camel/converter/german.utf-8.txt\");\n        try (InputStream in = IOConverter.toInputStream(file, \"UTF-8\");\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in, StandardCharsets.ISO_8859_1));\n        BufferedReader naiveReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8))) {\n            String line = reader.readLine();\n            String naiveLine = naiveReader.readLine();\n            assertEquals(naiveLine, line);\n            assertEquals(CONTENT, line);\n        }\n    }",
            "  47  \n  48  \n  49  \n  50  \n  51  \n  52 +\n  53  \n  54  \n  55  \n  56  \n  57  \n  58  ",
            "    public void testToInputStreamFileWithCharsetUTF8withOtherDefaultEncoding() throws Exception {\n        switchToDefaultCharset(StandardCharsets.ISO_8859_1);\n        File file = new File(\"src/test/resources/org/apache/camel/converter/german.utf-8.txt\");\n        try (InputStream in = IOConverter.toInputStream(file, \"UTF-8\");\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in, StandardCharsets.ISO_8859_1));\n        BufferedReader naiveReader = new BufferedReader(new InputStreamReader(Files.newInputStream(Paths.get(file.getAbsolutePath())), StandardCharsets.UTF_8))) {\n            String line = reader.readLine();\n            String naiveLine = naiveReader.readLine();\n            assertEquals(naiveLine, line);\n            assertEquals(CONTENT, line);\n        }\n    }"
        ],
        [
            "FileProducerCharsetUTFtoISOConfiguredTest::setUp()",
            "  37  \n  38  \n  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57 -\n  58  \n  59  \n  60  \n  61  \n  62  ",
            "    @Override\n    protected void setUp() throws Exception {\n        // use utf-8 as original payload with 00e6 which is a danish ae letter\n        utf = \"ABC\\u00e6\".getBytes(\"utf-8\");\n        iso = \"ABC\\u00e6\".getBytes(\"iso-8859-1\");\n\n        deleteDirectory(\"target/charset\");\n        createDirectory(\"target/charset/input\");\n\n        log.debug(\"utf: {}\", new String(utf, Charset.forName(\"utf-8\")));\n        log.debug(\"iso: {}\", new String(iso, Charset.forName(\"iso-8859-1\")));\n\n        for (byte b : utf) {\n            log.debug(\"utf byte: {}\", b);\n        }\n        for (byte b : iso) {\n            log.debug(\"iso byte: {}\", b);\n        }\n\n        // write the byte array to a file using plain API\n        FileOutputStream fos = new FileOutputStream(\"target/charset/input/input.txt\");\n        fos.write(utf);\n        fos.close();\n\n        super.setUp();\n    }",
            "  37  \n  38  \n  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57 +\n  58  \n  59  \n  60  \n  61  \n  62  ",
            "    @Override\n    protected void setUp() throws Exception {\n        // use utf-8 as original payload with 00e6 which is a danish ae letter\n        utf = \"ABC\\u00e6\".getBytes(\"utf-8\");\n        iso = \"ABC\\u00e6\".getBytes(\"iso-8859-1\");\n\n        deleteDirectory(\"target/charset\");\n        createDirectory(\"target/charset/input\");\n\n        log.debug(\"utf: {}\", new String(utf, Charset.forName(\"utf-8\")));\n        log.debug(\"iso: {}\", new String(iso, Charset.forName(\"iso-8859-1\")));\n\n        for (byte b : utf) {\n            log.debug(\"utf byte: {}\", b);\n        }\n        for (byte b : iso) {\n            log.debug(\"iso byte: {}\", b);\n        }\n\n        // write the byte array to a file using plain API\n        OutputStream fos = Files.newOutputStream(Paths.get(\"target/charset/input/input.txt\"));\n        fos.write(utf);\n        fos.close();\n\n        super.setUp();\n    }"
        ],
        [
            "XmlLineNumberParserTest::testParseCamelContextForceNamespace()",
            "  61  \n  62 -\n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  ",
            "    public void testParseCamelContextForceNamespace() throws Exception {\n        FileInputStream fis = new FileInputStream(\"src/test/resources/org/apache/camel/util/camel-context.xml\");\n        Document dom = XmlLineNumberParser.parseXml(fis, null, \"camelContext\", \"http://camel.apache.org/schema/spring\");\n        assertNotNull(dom);\n\n        NodeList list = dom.getElementsByTagName(\"camelContext\");\n        assertEquals(1, list.getLength());\n        Node node = list.item(0);\n\n        String lineNumber = (String) node.getUserData(XmlLineNumberParser.LINE_NUMBER);\n        String lineNumberEnd = (String) node.getUserData(XmlLineNumberParser.LINE_NUMBER_END);\n\n        String ns = node.getNamespaceURI();\n        assertEquals(\"http://camel.apache.org/schema/spring\", ns);\n\n        assertEquals(\"29\", lineNumber);\n        assertEquals(\"47\", lineNumberEnd);\n\n        // and there are two routes\n        list = dom.getElementsByTagName(\"route\");\n        assertEquals(2, list.getLength());\n        Node node1 = list.item(0);\n        Node node2 = list.item(1);\n\n        String lineNumber1 = (String) node1.getUserData(XmlLineNumberParser.LINE_NUMBER);\n        String lineNumberEnd1 = (String) node1.getUserData(XmlLineNumberParser.LINE_NUMBER_END);\n        assertEquals(\"31\", lineNumber1);\n        assertEquals(\"37\", lineNumberEnd1);\n\n        String lineNumber2 = (String) node2.getUserData(XmlLineNumberParser.LINE_NUMBER);\n        String lineNumberEnd2 = (String) node2.getUserData(XmlLineNumberParser.LINE_NUMBER_END);\n        assertEquals(\"39\", lineNumber2);\n        assertEquals(\"45\", lineNumberEnd2);\n    }",
            "  63  \n  64 +\n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  ",
            "    public void testParseCamelContextForceNamespace() throws Exception {\n        InputStream fis = Files.newInputStream(Paths.get(\"src/test/resources/org/apache/camel/util/camel-context.xml\"));\n        Document dom = XmlLineNumberParser.parseXml(fis, null, \"camelContext\", \"http://camel.apache.org/schema/spring\");\n        assertNotNull(dom);\n\n        NodeList list = dom.getElementsByTagName(\"camelContext\");\n        assertEquals(1, list.getLength());\n        Node node = list.item(0);\n\n        String lineNumber = (String) node.getUserData(XmlLineNumberParser.LINE_NUMBER);\n        String lineNumberEnd = (String) node.getUserData(XmlLineNumberParser.LINE_NUMBER_END);\n\n        String ns = node.getNamespaceURI();\n        assertEquals(\"http://camel.apache.org/schema/spring\", ns);\n\n        assertEquals(\"29\", lineNumber);\n        assertEquals(\"47\", lineNumberEnd);\n\n        // and there are two routes\n        list = dom.getElementsByTagName(\"route\");\n        assertEquals(2, list.getLength());\n        Node node1 = list.item(0);\n        Node node2 = list.item(1);\n\n        String lineNumber1 = (String) node1.getUserData(XmlLineNumberParser.LINE_NUMBER);\n        String lineNumberEnd1 = (String) node1.getUserData(XmlLineNumberParser.LINE_NUMBER_END);\n        assertEquals(\"31\", lineNumber1);\n        assertEquals(\"37\", lineNumberEnd1);\n\n        String lineNumber2 = (String) node2.getUserData(XmlLineNumberParser.LINE_NUMBER);\n        String lineNumberEnd2 = (String) node2.getUserData(XmlLineNumberParser.LINE_NUMBER_END);\n        assertEquals(\"39\", lineNumber2);\n        assertEquals(\"45\", lineNumberEnd2);\n    }"
        ],
        [
            "ValidatorBeanCallTest::MyValidatorBean::loadFile()",
            "  74 -\n  75 -\n  76  ",
            "        public InputStream loadFile() throws FileNotFoundException {\n            return new FileInputStream(\"src/test/resources/report.xsd\");\n        }",
            "  77 +\n  78 +\n  79  ",
            "        public InputStream loadFile() throws Exception {\n            return Files.newInputStream(Paths.get(\"src/test/resources/report.xsd\"));\n        }"
        ],
        [
            "FileProducerCharsetUTFtoUTFTest::testFileProducerCharsetUTFtoUTF()",
            "  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64 -\n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  ",
            "    public void testFileProducerCharsetUTFtoUTF() throws Exception {\n        oneExchangeDone.matchesMockWaitTime();\n\n        File file = new File(\"target/charset/output.txt\");\n        assertTrue(\"File should exist\", file.exists());\n\n        InputStream fis = IOHelper.buffered(new FileInputStream(file));\n        byte[] buffer = new byte[100];\n\n        int len = fis.read(buffer);\n        assertTrue(\"Should read data: \" + len, len != -1);\n        byte[] data = new byte[len];\n        System.arraycopy(buffer, 0, data, 0, len);\n        fis.close();\n\n        // data should be in utf, where the danish ae is -61 -90\n        assertEquals(5, data.length);\n        assertEquals(65, data[0]);\n        assertEquals(66, data[1]);\n        assertEquals(67, data[2]);\n        assertEquals(-61, data[3]);\n        assertEquals(-90, data[4]);\n    }",
            "  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64 +\n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  ",
            "    public void testFileProducerCharsetUTFtoUTF() throws Exception {\n        oneExchangeDone.matchesMockWaitTime();\n\n        File file = new File(\"target/charset/output.txt\");\n        assertTrue(\"File should exist\", file.exists());\n\n        InputStream fis = Files.newInputStream(Paths.get(file.getAbsolutePath()));\n        byte[] buffer = new byte[100];\n\n        int len = fis.read(buffer);\n        assertTrue(\"Should read data: \" + len, len != -1);\n        byte[] data = new byte[len];\n        System.arraycopy(buffer, 0, data, 0, len);\n        fis.close();\n\n        // data should be in utf, where the danish ae is -61 -90\n        assertEquals(5, data.length);\n        assertEquals(65, data[0]);\n        assertEquals(66, data[1]);\n        assertEquals(67, data[2]);\n        assertEquals(-61, data[3]);\n        assertEquals(-90, data[4]);\n    }"
        ],
        [
            "XsltBuilderTest::testXsltTemplates()",
            " 145  \n 146  \n 147 -\n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  ",
            "    public void testXsltTemplates() throws Exception {\n        File file = new File(\"src/test/resources/org/apache/camel/builder/xml/example.xsl\");\n        Source source = new SAXSource(new InputSource(new FileInputStream(file)));\n\n        XmlConverter converter = new XmlConverter();\n        Templates styleSheet = converter.getTransformerFactory().newTemplates(source);\n\n        XsltBuilder builder = XsltBuilder.xslt(styleSheet);\n\n        Exchange exchange = new DefaultExchange(context);\n        exchange.getIn().setBody(\"<hello>world!</hello>\");\n\n        builder.process(exchange);\n\n        assertEquals(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><goodbye>world!</goodbye>\", exchange.getOut().getBody());\n    }",
            " 146  \n 147  \n 148 +\n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  ",
            "    public void testXsltTemplates() throws Exception {\n        File file = new File(\"src/test/resources/org/apache/camel/builder/xml/example.xsl\");\n        Source source = new SAXSource(new InputSource(Files.newInputStream(Paths.get(file.getAbsolutePath()))));\n\n        XmlConverter converter = new XmlConverter();\n        Templates styleSheet = converter.getTransformerFactory().newTemplates(source);\n\n        XsltBuilder builder = XsltBuilder.xslt(styleSheet);\n\n        Exchange exchange = new DefaultExchange(context);\n        exchange.getIn().setBody(\"<hello>world!</hello>\");\n\n        builder.process(exchange);\n\n        assertEquals(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><goodbye>world!</goodbye>\", exchange.getOut().getBody());\n    }"
        ],
        [
            "IOConverterCharsetTest::testToInputStreamFileWithCharsetUTF8()",
            "  33  \n  34  \n  35  \n  36  \n  37  \n  38 -\n  39  \n  40  \n  41  \n  42  \n  43  \n  44  ",
            "    public void testToInputStreamFileWithCharsetUTF8() throws Exception {\n        switchToDefaultCharset(StandardCharsets.UTF_8);\n        File file = new File(\"src/test/resources/org/apache/camel/converter/german.utf-8.txt\");\n        try (InputStream in = IOConverter.toInputStream(file, \"UTF-8\");\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8)); \n        BufferedReader naiveReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8))) {\n            String line = reader.readLine();\n            String naiveLine = naiveReader.readLine();\n            assertEquals(naiveLine, line);\n            assertEquals(CONTENT, line);\n        }\n    }",
            "  34  \n  35  \n  36  \n  37  \n  38  \n  39 +\n  40  \n  41  \n  42  \n  43  \n  44  \n  45  ",
            "    public void testToInputStreamFileWithCharsetUTF8() throws Exception {\n        switchToDefaultCharset(StandardCharsets.UTF_8);\n        File file = new File(\"src/test/resources/org/apache/camel/converter/german.utf-8.txt\");\n        try (InputStream in = IOConverter.toInputStream(file, \"UTF-8\");\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8)); \n        BufferedReader naiveReader = new BufferedReader(new InputStreamReader(Files.newInputStream(Paths.get(file.getAbsolutePath())), StandardCharsets.UTF_8))) {\n            String line = reader.readLine();\n            String naiveLine = naiveReader.readLine();\n            assertEquals(naiveLine, line);\n            assertEquals(CONTENT, line);\n        }\n    }"
        ]
    ],
    "d4106e4ea218e4225bb3e7ccca24a1fd6db97071": [
        [
            "ElasticsearchProducer::process(Exchange)",
            " 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155 -\n 156  \n 157  \n 158 -\n 159  \n 160  \n 161 -\n 162  \n 163  \n 164  \n 165  \n 166  \n 167 -\n 168  \n 169  \n 170 -\n 171  \n 172  \n 173 -\n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194 -\n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  ",
            "    public void process(Exchange exchange) throws Exception {\n        if (configuration.getDisconnect() && client == null) {\n            startClient();\n        }\n        RestHighLevelClient restHighLevelClient = new HighLevelClient(client);\n        // 2. Index and type will be set by:\n        // a. If the incoming body is already an action request\n        // b. If the body is not an action request we will use headers if they\n        // are set.\n        // c. If the body is not an action request and the headers aren't set we\n        // will use the configuration.\n        // No error is thrown by the component in the event none of the above\n        // conditions are met. The java es client\n        // will throw.\n\n        Message message = exchange.getIn();\n        final ElasticsearchOperation operation = resolveOperation(exchange);\n\n        // Set the index/type headers on the exchange if necessary. This is used\n        // for type conversion.\n        boolean configIndexName = false;\n        String indexName = message.getHeader(ElasticsearchConstants.PARAM_INDEX_NAME, String.class);\n        if (indexName == null) {\n            message.setHeader(ElasticsearchConstants.PARAM_INDEX_NAME, configuration.getIndexName());\n            configIndexName = true;\n        }\n\n        boolean configIndexType = false;\n        String indexType = message.getHeader(ElasticsearchConstants.PARAM_INDEX_TYPE, String.class);\n        if (indexType == null) {\n            message.setHeader(ElasticsearchConstants.PARAM_INDEX_TYPE, configuration.getIndexType());\n            configIndexType = true;\n        }\n\n        boolean configWaitForActiveShards = false;\n        Integer waitForActiveShards = message.getHeader(ElasticsearchConstants.PARAM_WAIT_FOR_ACTIVE_SHARDS, Integer.class);\n        if (waitForActiveShards == null) {\n            message.setHeader(ElasticsearchConstants.PARAM_WAIT_FOR_ACTIVE_SHARDS, configuration.getWaitForActiveShards());\n            configWaitForActiveShards = true;\n        }\n\n        if (operation == ElasticsearchOperation.Index) {\n            IndexRequest indexRequest = ElasticsearchActionRequestConverter.toIndexRequest(message.getBody(), exchange);\n            message.setBody(restHighLevelClient.index(indexRequest).getId());\n        } else if (operation == ElasticsearchOperation.Update) {\n            UpdateRequest updateRequest = ElasticsearchActionRequestConverter.toUpdateRequest(message.getBody(), exchange);\n            message.setBody(restHighLevelClient.update(updateRequest).getId());\n        } else if (operation == ElasticsearchOperation.GetById) {\n            GetRequest getRequest = ElasticsearchActionRequestConverter.toGetRequest(message.getBody(), exchange);\n            message.setBody(restHighLevelClient.get(getRequest));\n        } else if (operation == ElasticsearchOperation.Bulk) {\n            BulkRequest bulkRequest = message.getBody(BulkRequest.class);\n            message.setBody(restHighLevelClient.bulk(bulkRequest).getItems());\n        } else if (operation == ElasticsearchOperation.BulkIndex) {\n            BulkRequest bulkRequest = ElasticsearchActionRequestConverter.toBulkRequest(message.getBody(), exchange);\n            message.setBody(restHighLevelClient.bulk(bulkRequest).getItems());\n        } else if (operation == ElasticsearchOperation.Delete) {\n            DeleteRequest deleteRequest = ElasticsearchActionRequestConverter.toDeleteRequest(message.getBody(), exchange);\n            message.setBody(restHighLevelClient.delete(deleteRequest).getResult());\n        } else if (operation == ElasticsearchOperation.DeleteIndex) {\n            DeleteRequest deleteRequest = ElasticsearchActionRequestConverter.toDeleteRequest(message.getBody(), exchange);\n            message.setBody(client.performRequest(\"Delete\", deleteRequest.index()).getStatusLine().getStatusCode());\n        } else if (operation == ElasticsearchOperation.Exists) {\n            // ExistsRequest API is deprecated, using SearchRequest instead with size=0 and terminate_after=1\n            SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();\n            sourceBuilder.size(0);\n            sourceBuilder.terminateAfter(1);\n            SearchRequest searchRequest = new SearchRequest(exchange.getIn().getHeader(ElasticsearchConstants.PARAM_INDEX_NAME, String.class));\n            searchRequest.source(sourceBuilder);\n            try {\n                restHighLevelClient.search(searchRequest);\n                message.setBody(true);\n            } catch (ElasticsearchStatusException e) {\n                if (e.status().equals(RestStatus.NOT_FOUND)) {\n                    message.setBody(false);\n                } else {\n                    throw new IllegalStateException(e);\n                }\n\n            }\n        } else if (operation == ElasticsearchOperation.Search) {\n            SearchRequest searchRequest = ElasticsearchActionRequestConverter.toSearchRequest(message.getBody(), exchange);\n            message.setBody(restHighLevelClient.search(searchRequest).getHits());\n        } else if (operation == ElasticsearchOperation.Ping) {\n            message.setBody(restHighLevelClient.ping());\n        } else if (operation == ElasticsearchOperation.Info) {\n            message.setBody(restHighLevelClient.info());\n        } else {\n            throw new IllegalArgumentException(ElasticsearchConstants.PARAM_OPERATION + \" value '\" + operation + \"' is not supported\");\n        }\n        // If we set params via the configuration on this exchange, remove them\n        // now. This preserves legacy behavior for this component and enables a\n        // use case where one message can be sent to multiple elasticsearch\n        // endpoints where the user is relying on the endpoint configuration\n        // (index/type) rather than header values. If we do not clear this out\n        // sending the same message (index request, for example) to multiple\n        // elasticsearch endpoints would have the effect overriding any\n        // subsequent endpoint index/type with the first endpoint index/type.\n        if (configIndexName) {\n            message.removeHeader(ElasticsearchConstants.PARAM_INDEX_NAME);\n        }\n\n        if (configIndexType) {\n            message.removeHeader(ElasticsearchConstants.PARAM_INDEX_TYPE);\n        }\n\n        if (configWaitForActiveShards) {\n            message.removeHeader(ElasticsearchConstants.PARAM_WAIT_FOR_ACTIVE_SHARDS);\n        }\n        if (configuration.getDisconnect()) {\n            IOHelper.close(client);\n            client = null;\n            if (configuration.getEnableSniffer()) {\n                IOHelper.close(sniffer);\n                sniffer = null;\n            }\n        }\n\n    }",
            " 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154 +\n 155  \n 156  \n 157 +\n 158  \n 159  \n 160 +\n 161  \n 162  \n 163  \n 164  \n 165  \n 166 +\n 167  \n 168  \n 169 +\n 170  \n 171  \n 172 +\n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193 +\n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  ",
            "    public void process(Exchange exchange) throws Exception {\n        if (configuration.getDisconnect() && client == null) {\n            startClient();\n        }\n        RestHighLevelClient restHighLevelClient = new HighLevelClient(client);\n        // 2. Index and type will be set by:\n        // a. If the incoming body is already an action request\n        // b. If the body is not an action request we will use headers if they\n        // are set.\n        // c. If the body is not an action request and the headers aren't set we\n        // will use the configuration.\n        // No error is thrown by the component in the event none of the above\n        // conditions are met. The java es client\n        // will throw.\n\n        Message message = exchange.getIn();\n        final ElasticsearchOperation operation = resolveOperation(exchange);\n\n        // Set the index/type headers on the exchange if necessary. This is used\n        // for type conversion.\n        boolean configIndexName = false;\n        String indexName = message.getHeader(ElasticsearchConstants.PARAM_INDEX_NAME, String.class);\n        if (indexName == null) {\n            message.setHeader(ElasticsearchConstants.PARAM_INDEX_NAME, configuration.getIndexName());\n            configIndexName = true;\n        }\n\n        boolean configIndexType = false;\n        String indexType = message.getHeader(ElasticsearchConstants.PARAM_INDEX_TYPE, String.class);\n        if (indexType == null) {\n            message.setHeader(ElasticsearchConstants.PARAM_INDEX_TYPE, configuration.getIndexType());\n            configIndexType = true;\n        }\n\n        boolean configWaitForActiveShards = false;\n        Integer waitForActiveShards = message.getHeader(ElasticsearchConstants.PARAM_WAIT_FOR_ACTIVE_SHARDS, Integer.class);\n        if (waitForActiveShards == null) {\n            message.setHeader(ElasticsearchConstants.PARAM_WAIT_FOR_ACTIVE_SHARDS, configuration.getWaitForActiveShards());\n            configWaitForActiveShards = true;\n        }\n\n        if (operation == ElasticsearchOperation.Index) {\n            IndexRequest indexRequest = message.getBody(IndexRequest.class);\n            message.setBody(restHighLevelClient.index(indexRequest).getId());\n        } else if (operation == ElasticsearchOperation.Update) {\n            UpdateRequest updateRequest = message.getBody(UpdateRequest.class);\n            message.setBody(restHighLevelClient.update(updateRequest).getId());\n        } else if (operation == ElasticsearchOperation.GetById) {\n            GetRequest getRequest = message.getBody(GetRequest.class);\n            message.setBody(restHighLevelClient.get(getRequest));\n        } else if (operation == ElasticsearchOperation.Bulk) {\n            BulkRequest bulkRequest = message.getBody(BulkRequest.class);\n            message.setBody(restHighLevelClient.bulk(bulkRequest).getItems());\n        } else if (operation == ElasticsearchOperation.BulkIndex) {\n            BulkRequest bulkRequest = message.getBody(BulkRequest.class);\n            message.setBody(restHighLevelClient.bulk(bulkRequest).getItems());\n        } else if (operation == ElasticsearchOperation.Delete) {\n            DeleteRequest deleteRequest = message.getBody(DeleteRequest.class);\n            message.setBody(restHighLevelClient.delete(deleteRequest).getResult());\n        } else if (operation == ElasticsearchOperation.DeleteIndex) {\n            DeleteRequest deleteRequest = message.getBody(DeleteRequest.class);\n            message.setBody(client.performRequest(\"Delete\", deleteRequest.index()).getStatusLine().getStatusCode());\n        } else if (operation == ElasticsearchOperation.Exists) {\n            // ExistsRequest API is deprecated, using SearchRequest instead with size=0 and terminate_after=1\n            SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();\n            sourceBuilder.size(0);\n            sourceBuilder.terminateAfter(1);\n            SearchRequest searchRequest = new SearchRequest(exchange.getIn().getHeader(ElasticsearchConstants.PARAM_INDEX_NAME, String.class));\n            searchRequest.source(sourceBuilder);\n            try {\n                restHighLevelClient.search(searchRequest);\n                message.setBody(true);\n            } catch (ElasticsearchStatusException e) {\n                if (e.status().equals(RestStatus.NOT_FOUND)) {\n                    message.setBody(false);\n                } else {\n                    throw new IllegalStateException(e);\n                }\n\n            }\n        } else if (operation == ElasticsearchOperation.Search) {\n            SearchRequest searchRequest = message.getBody(SearchRequest.class);\n            message.setBody(restHighLevelClient.search(searchRequest).getHits());\n        } else if (operation == ElasticsearchOperation.Ping) {\n            message.setBody(restHighLevelClient.ping());\n        } else if (operation == ElasticsearchOperation.Info) {\n            message.setBody(restHighLevelClient.info());\n        } else {\n            throw new IllegalArgumentException(ElasticsearchConstants.PARAM_OPERATION + \" value '\" + operation + \"' is not supported\");\n        }\n        // If we set params via the configuration on this exchange, remove them\n        // now. This preserves legacy behavior for this component and enables a\n        // use case where one message can be sent to multiple elasticsearch\n        // endpoints where the user is relying on the endpoint configuration\n        // (index/type) rather than header values. If we do not clear this out\n        // sending the same message (index request, for example) to multiple\n        // elasticsearch endpoints would have the effect overriding any\n        // subsequent endpoint index/type with the first endpoint index/type.\n        if (configIndexName) {\n            message.removeHeader(ElasticsearchConstants.PARAM_INDEX_NAME);\n        }\n\n        if (configIndexType) {\n            message.removeHeader(ElasticsearchConstants.PARAM_INDEX_TYPE);\n        }\n\n        if (configWaitForActiveShards) {\n            message.removeHeader(ElasticsearchConstants.PARAM_WAIT_FOR_ACTIVE_SHARDS);\n        }\n        if (configuration.getDisconnect()) {\n            IOHelper.close(client);\n            client = null;\n            if (configuration.getEnableSniffer()) {\n                IOHelper.close(sniffer);\n                sniffer = null;\n            }\n        }\n\n    }"
        ]
    ],
    "3659ce7332dccac7bd5a5cf7a0584fe31014e04e": [
        [
            "MQProducer::createBroker(AmazonMQ,Exchange)",
            " 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  ",
            "    private void createBroker(AmazonMQ mqClient, Exchange exchange) {\n        String brokerName;\n        String deploymentMode;\n        CreateBrokerRequest request = new CreateBrokerRequest();\n        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(MQConstants.BROKER_NAME))) {\n            brokerName = exchange.getIn().getHeader(MQConstants.BROKER_NAME, String.class);\n            request.withBrokerName(brokerName);\n        } else {\n            throw new IllegalArgumentException(\"Broker Name must be specified\");\n        }\n        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(MQConstants.BROKER_DEPLOYMENT_MODE))) {\n            deploymentMode = exchange.getIn().getHeader(MQConstants.BROKER_DEPLOYMENT_MODE, String.class);\n            request.withDeploymentMode(DeploymentMode.fromValue(deploymentMode));\n        } else {\n            throw new IllegalArgumentException(\"Deployment Mode must be specified\");\n        }\n        CreateBrokerResult result;\n        try {\n            result = mqClient.createBroker(request);\n        } catch (AmazonServiceException ase) {\n            log.trace(\"Create Broker command returned the error code {}\", ase.getErrorCode());\n            throw ase;\n        }\n        Message message = getMessageForResponse(exchange);\n        message.setBody(result);\n    }",
            " 128  \n 129  \n 130 +\n 131 +\n 132  \n 133 +\n 134 +\n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142 +\n 143 +\n 144 +\n 145 +\n 146 +\n 147 +\n 148 +\n 149 +\n 150 +\n 151 +\n 152 +\n 153 +\n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160 +\n 161 +\n 162 +\n 163 +\n 164 +\n 165 +\n 166 +\n 167 +\n 168 +\n 169 +\n 170 +\n 171 +\n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  ",
            "    private void createBroker(AmazonMQ mqClient, Exchange exchange) {\n        String brokerName;\n        String brokerEngine;\n        String brokerEngineVersion;\n        String deploymentMode;\n        String instanceType;\n        List<User> users;\n        CreateBrokerRequest request = new CreateBrokerRequest();\n        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(MQConstants.BROKER_NAME))) {\n            brokerName = exchange.getIn().getHeader(MQConstants.BROKER_NAME, String.class);\n            request.withBrokerName(brokerName);\n        } else {\n            throw new IllegalArgumentException(\"Broker Name must be specified\");\n        }\n        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(MQConstants.BROKER_ENGINE))) {\n            brokerEngine = exchange.getIn().getHeader(MQConstants.BROKER_ENGINE, String.class);\n            request.withEngineType(EngineType.fromValue(brokerEngine));\n        } else {\n            request.withEngineType(EngineType.ACTIVEMQ.name());\n        }\n        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(MQConstants.BROKER_ENGINE_VERSION))) {\n            brokerEngineVersion = exchange.getIn().getHeader(MQConstants.BROKER_ENGINE_VERSION, String.class);\n            request.withEngineVersion(brokerEngineVersion);\n        } else {\n            throw new IllegalArgumentException(\"Broker Engine Version must be specified\");\n        }\n        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(MQConstants.BROKER_DEPLOYMENT_MODE))) {\n            deploymentMode = exchange.getIn().getHeader(MQConstants.BROKER_DEPLOYMENT_MODE, String.class);\n            request.withDeploymentMode(DeploymentMode.fromValue(deploymentMode));\n        } else {\n            throw new IllegalArgumentException(\"Deployment Mode must be specified\");\n        }\n        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(MQConstants.BROKER_INSTANCE_TYPE))) {\n            instanceType = exchange.getIn().getHeader(MQConstants.BROKER_INSTANCE_TYPE, String.class);\n            request.withHostInstanceType(instanceType);\n        } else {\n            throw new IllegalArgumentException(\"Instance Type must be specified\");\n        }\n        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(MQConstants.BROKER_USERS))) {\n            users = exchange.getIn().getHeader(MQConstants.BROKER_USERS, List.class);\n            request.withUsers(users);\n        } else {\n            throw new IllegalArgumentException(\"A Users list must be specified\");\n        }\n        CreateBrokerResult result;\n        try {\n            result = mqClient.createBroker(request);\n        } catch (AmazonServiceException ase) {\n            log.trace(\"Create Broker command returned the error code {}\", ase.getErrorCode());\n            throw ase;\n        }\n        Message message = getMessageForResponse(exchange);\n        message.setBody(result);\n    }"
        ],
        [
            "MQProducerSpringTest::mqCreateBrokerTest()",
            "  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  ",
            "    @Test\n    public void mqCreateBrokerTest() throws Exception {\n\n        mock.expectedMessageCount(1);\n        Exchange exchange = template.request(\"direct:createBroker\", new Processor() {\n            @Override\n            public void process(Exchange exchange) throws Exception {\n                exchange.getIn().setHeader(MQConstants.OPERATION, MQOperations.createBroker);\n                exchange.getIn().setHeader(MQConstants.BROKER_NAME, \"test\");\n                exchange.getIn().setHeader(MQConstants.BROKER_DEPLOYMENT_MODE, DeploymentMode.SINGLE_INSTANCE);\n            }\n        });\n        \n        assertMockEndpointsSatisfied();\n        \n        CreateBrokerResult resultGet = (CreateBrokerResult) exchange.getIn().getBody();\n        assertEquals(resultGet.getBrokerId(), \"1\");\n        assertEquals(resultGet.getBrokerArn(), \"test\");\n    }",
            "  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76 +\n  77 +\n  78 +\n  79 +\n  80 +\n  81 +\n  82 +\n  83 +\n  84 +\n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  ",
            "    @Test\n    public void mqCreateBrokerTest() throws Exception {\n\n        mock.expectedMessageCount(1);\n        Exchange exchange = template.request(\"direct:createBroker\", new Processor() {\n            @Override\n            public void process(Exchange exchange) throws Exception {\n                exchange.getIn().setHeader(MQConstants.OPERATION, MQOperations.createBroker);\n                exchange.getIn().setHeader(MQConstants.BROKER_NAME, \"test\");\n                exchange.getIn().setHeader(MQConstants.BROKER_DEPLOYMENT_MODE, DeploymentMode.SINGLE_INSTANCE);\n                exchange.getIn().setHeader(MQConstants.BROKER_INSTANCE_TYPE, \"mq.t2.micro\");\n                exchange.getIn().setHeader(MQConstants.BROKER_ENGINE, EngineType.ACTIVEMQ.name());\n                exchange.getIn().setHeader(MQConstants.BROKER_ENGINE_VERSION, \"5.15.6\");\n                List<User> users = new ArrayList<>();\n                User user = new User();\n                user.setUsername(\"camel\");\n                user.setPassword(\"camelcamel12\");\n                users.add(user);\n                exchange.getIn().setHeader(MQConstants.BROKER_USERS, users);\n            }\n        });\n        \n        assertMockEndpointsSatisfied();\n        \n        CreateBrokerResult resultGet = (CreateBrokerResult) exchange.getIn().getBody();\n        assertEquals(resultGet.getBrokerId(), \"1\");\n        assertEquals(resultGet.getBrokerArn(), \"test\");\n    }"
        ],
        [
            "MQProducerTest::mqCreateBrokerTest()",
            "  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  ",
            "    @Test\n    public void mqCreateBrokerTest() throws Exception {\n\n        mock.expectedMessageCount(1);\n        Exchange exchange = template.request(\"direct:createBroker\", new Processor() {\n            @Override\n            public void process(Exchange exchange) throws Exception {\n                exchange.getIn().setHeader(MQConstants.OPERATION, MQOperations.createBroker);\n                exchange.getIn().setHeader(MQConstants.BROKER_NAME, \"test\");\n                exchange.getIn().setHeader(MQConstants.BROKER_DEPLOYMENT_MODE, DeploymentMode.SINGLE_INSTANCE);\n            }\n        });\n        \n        assertMockEndpointsSatisfied();\n        \n        CreateBrokerResult resultGet = (CreateBrokerResult) exchange.getIn().getBody();\n        assertEquals(resultGet.getBrokerId(), \"1\");\n        assertEquals(resultGet.getBrokerArn(), \"test\");\n    }",
            "  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76 +\n  77 +\n  78 +\n  79 +\n  80 +\n  81 +\n  82 +\n  83 +\n  84 +\n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  ",
            "    @Test\n    public void mqCreateBrokerTest() throws Exception {\n\n        mock.expectedMessageCount(1);\n        Exchange exchange = template.request(\"direct:createBroker\", new Processor() {\n            @Override\n            public void process(Exchange exchange) throws Exception {\n                exchange.getIn().setHeader(MQConstants.OPERATION, MQOperations.createBroker);\n                exchange.getIn().setHeader(MQConstants.BROKER_NAME, \"test\");\n                exchange.getIn().setHeader(MQConstants.BROKER_DEPLOYMENT_MODE, DeploymentMode.SINGLE_INSTANCE);\n                exchange.getIn().setHeader(MQConstants.BROKER_INSTANCE_TYPE, \"mq.t2.micro\");\n                exchange.getIn().setHeader(MQConstants.BROKER_ENGINE, EngineType.ACTIVEMQ.name());\n                exchange.getIn().setHeader(MQConstants.BROKER_ENGINE_VERSION, \"5.15.6\");\n                List<User> users = new ArrayList<>();\n                User user = new User();\n                user.setUsername(\"camel\");\n                user.setPassword(\"camelcamel12\");\n                users.add(user);\n                exchange.getIn().setHeader(MQConstants.BROKER_USERS, users);\n            }\n        });\n        \n        assertMockEndpointsSatisfied();\n        \n        CreateBrokerResult resultGet = (CreateBrokerResult) exchange.getIn().getBody();\n        assertEquals(resultGet.getBrokerId(), \"1\");\n        assertEquals(resultGet.getBrokerArn(), \"test\");\n    }"
        ]
    ],
    "a2fd6ad6ef25cff793e4f69a0fcc5e0d7bf79f06": [
        [
            "FopProducer::setEncryptionParameters(FOUserAgent,Map)",
            " 101  \n 102 -\n 103 -\n 104 -\n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  ",
            "    @SuppressWarnings(\"unchecked\")\n    private void setEncryptionParameters(FOUserAgent userAgent, Map<String, Object> headers)\n        throws Exception {\n        Map<String, Object> encryptionParameters = IntrospectionSupport\n            .extractProperties(headers, FopConstants.CAMEL_FOP_ENCRYPT);\n        if (!encryptionParameters.isEmpty()) {\n            PDFEncryptionParams encryptionParams = new PDFEncryptionParams();\n            PropertyBindingSupport.bindProperties(getEndpoint().getCamelContext(), encryptionParams, encryptionParameters);\n            userAgent.getRendererOptions().put(\"encryption-params\", encryptionParams);\n        }\n    }",
            " 101  \n 102 +\n 103 +\n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  ",
            "    @SuppressWarnings(\"unchecked\")\n    private void setEncryptionParameters(FOUserAgent userAgent, Map<String, Object> headers) {\n        Map<String, Object> encryptionParameters = PropertiesHelper\n            .extractProperties(headers, FopConstants.CAMEL_FOP_ENCRYPT);\n        if (!encryptionParameters.isEmpty()) {\n            PDFEncryptionParams encryptionParams = new PDFEncryptionParams();\n            PropertyBindingSupport.bindProperties(getEndpoint().getCamelContext(), encryptionParams, encryptionParameters);\n            userAgent.getRendererOptions().put(\"encryption-params\", encryptionParams);\n        }\n    }"
        ],
        [
            "CxfComponent::createEndpoint(String,String,Map)",
            "  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123 -\n 124 -\n 125 -\n 126 -\n 127  \n 128  \n 129 -\n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  ",
            "    /**\n     * Create a {@link CxfEndpoint} which, can be a Spring bean endpoint having\n     * URI format cxf:bean:<i>beanId</i> or transport address endpoint having URI format\n     * cxf://<i>transportAddress</i>.\n     */\n    @Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n\n        CxfEndpoint result;\n\n        Object value = parameters.remove(\"setDefaultBus\");\n        if (value != null) {\n            log.warn(\"The option setDefaultBus is @deprecated, use name defaultBus instead\");\n            if (!parameters.containsKey(\"defaultBus\")) {\n                parameters.put(\"defaultBus\", value);\n            }\n        }\n\n        if (allowStreaming != null && !parameters.containsKey(\"allowStreaming\")) {\n            parameters.put(\"allowStreaming\", Boolean.toString(allowStreaming));\n        }\n\n        if (remaining.startsWith(CxfConstants.SPRING_CONTEXT_ENDPOINT)) {\n            // Get the bean from the Spring context\n            String beanId = remaining.substring(CxfConstants.SPRING_CONTEXT_ENDPOINT.length());\n            if (beanId.startsWith(\"//\")) {\n                beanId = beanId.substring(2);\n            }\n\n            result = createCxfSpringEndpoint(beanId);\n            // need to check the CamelContext value\n            if (getCamelContext().equals(result.getCamelContext())) {\n                result.setCamelContext(getCamelContext());\n            }\n            result.setBeanId(beanId);\n\n        } else {\n            // endpoint URI does not specify a bean\n            result = createCxfEndpoint(remaining);\n        }\n\n        if (result.getCamelContext() == null) {\n            result.setCamelContext(getCamelContext());\n        }\n        setEndpointHeaderFilterStrategy(result);\n        setProperties(result, parameters);\n\n        // extract the properties.xxx and set them as properties\n        Map<String, Object> properties = IntrospectionSupport.extractProperties(parameters, \"properties.\");\n        if (properties != null) {\n            result.setProperties(properties);\n        }\n        if (result.getProperties() != null) {\n            // set the properties of MTOM\n            result.setMtomEnabled(Boolean.valueOf((String) result.getProperties().get(Message.MTOM_ENABLED)));\n        }\n\n        // use global ssl config if set\n        if (result.getSslContextParameters() == null) {\n            result.setSslContextParameters(retrieveGlobalSslContextParameters());\n        }\n\n        return result;\n    }",
            "  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123 +\n 124 +\n 125 +\n 126  \n 127  \n 128 +\n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  ",
            "    /**\n     * Create a {@link CxfEndpoint} which, can be a Spring bean endpoint having\n     * URI format cxf:bean:<i>beanId</i> or transport address endpoint having URI format\n     * cxf://<i>transportAddress</i>.\n     */\n    @Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n\n        CxfEndpoint result;\n\n        Object value = parameters.remove(\"setDefaultBus\");\n        if (value != null) {\n            log.warn(\"The option setDefaultBus is @deprecated, use name defaultBus instead\");\n            if (!parameters.containsKey(\"defaultBus\")) {\n                parameters.put(\"defaultBus\", value);\n            }\n        }\n\n        if (allowStreaming != null && !parameters.containsKey(\"allowStreaming\")) {\n            parameters.put(\"allowStreaming\", Boolean.toString(allowStreaming));\n        }\n\n        if (remaining.startsWith(CxfConstants.SPRING_CONTEXT_ENDPOINT)) {\n            // Get the bean from the Spring context\n            String beanId = remaining.substring(CxfConstants.SPRING_CONTEXT_ENDPOINT.length());\n            if (beanId.startsWith(\"//\")) {\n                beanId = beanId.substring(2);\n            }\n\n            result = createCxfSpringEndpoint(beanId);\n            // need to check the CamelContext value\n            if (getCamelContext().equals(result.getCamelContext())) {\n                result.setCamelContext(getCamelContext());\n            }\n            result.setBeanId(beanId);\n\n        } else {\n            // endpoint URI does not specify a bean\n            result = createCxfEndpoint(remaining);\n        }\n\n        if (result.getCamelContext() == null) {\n            result.setCamelContext(getCamelContext());\n        }\n        setEndpointHeaderFilterStrategy(result);\n        setProperties(result, parameters);\n\n        // extract the properties.xxx and set them as properties\n        Map<String, Object> properties = PropertiesHelper.extractProperties(parameters, \"properties.\");\n        result.setProperties(properties);\n\n        if (result.getProperties() != null) {\n            // set the properties of MTOM\n            result.setMtomEnabled(Boolean.parseBoolean((String) result.getProperties().get(Message.MTOM_ENABLED)));\n        }\n\n        // use global ssl config if set\n        if (result.getSslContextParameters() == null) {\n            result.setSslContextParameters(retrieveGlobalSslContextParameters());\n        }\n\n        return result;\n    }"
        ],
        [
            "ClassComponent::createEndpoint(String,String,Map)",
            "  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49 -\n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  ",
            "    @Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        ClassEndpoint endpoint = new ClassEndpoint(uri, this);\n        endpoint.setBeanName(remaining);\n\n        // bean name is the FQN\n        String name = endpoint.getBeanName();\n        Class<?> clazz = getCamelContext().getClassResolver().resolveMandatoryClass(name);\n\n        // the bean.xxx options is for the bean\n        Map<String, Object> options = IntrospectionSupport.extractProperties(parameters, \"bean.\");\n        endpoint.setParameters(options);\n\n        BeanHolder holder;\n\n        // if there is options then we need to create a bean instance\n        if (!options.isEmpty()) {\n            // create bean\n            Object bean = getCamelContext().getInjector().newInstance(clazz);\n\n            // now set additional properties on it\n            setProperties(bean, options);\n\n            holder = new ConstantBeanHolder(bean, getCamelContext());\n        } else {\n            // otherwise refer to the type\n            holder = new ConstantTypeBeanHolder(clazz, getCamelContext());\n        }\n\n        validateParameters(uri, options, null);\n\n        // and register the bean as a holder on the endpoint\n        endpoint.setBeanHolder(holder);\n\n        return endpoint;\n    }",
            "  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49 +\n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  ",
            "    @Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        ClassEndpoint endpoint = new ClassEndpoint(uri, this);\n        endpoint.setBeanName(remaining);\n\n        // bean name is the FQN\n        String name = endpoint.getBeanName();\n        Class<?> clazz = getCamelContext().getClassResolver().resolveMandatoryClass(name);\n\n        // the bean.xxx options is for the bean\n        Map<String, Object> options = PropertiesHelper.extractProperties(parameters, \"bean.\");\n        endpoint.setParameters(options);\n\n        BeanHolder holder;\n\n        // if there is options then we need to create a bean instance\n        if (!options.isEmpty()) {\n            // create bean\n            Object bean = getCamelContext().getInjector().newInstance(clazz);\n\n            // now set additional properties on it\n            setProperties(bean, options);\n\n            holder = new ConstantBeanHolder(bean, getCamelContext());\n        } else {\n            // otherwise refer to the type\n            holder = new ConstantTypeBeanHolder(clazz, getCamelContext());\n        }\n\n        validateParameters(uri, options, null);\n\n        // and register the bean as a holder on the endpoint\n        endpoint.setBeanHolder(holder);\n\n        return endpoint;\n    }"
        ],
        [
            "BeanComponent::createEndpoint(String,String,Map)",
            "  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56 -\n  57  \n  58  \n  59  ",
            "    @Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        BeanEndpoint endpoint = new BeanEndpoint(uri, this);\n        endpoint.setBeanName(remaining);\n        endpoint.setCache(cache);\n        setProperties(endpoint, parameters);\n\n        // the bean.xxx options is for the bean\n        Map<String, Object> options = IntrospectionSupport.extractProperties(parameters, \"bean.\");\n        endpoint.setParameters(options);\n        return endpoint;\n    }",
            "  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56 +\n  57  \n  58  \n  59  ",
            "    @Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        BeanEndpoint endpoint = new BeanEndpoint(uri, this);\n        endpoint.setBeanName(remaining);\n        endpoint.setCache(cache);\n        setProperties(endpoint, parameters);\n\n        // the bean.xxx options is for the bean\n        Map<String, Object> options = PropertiesHelper.extractProperties(parameters, \"bean.\");\n        endpoint.setParameters(options);\n        return endpoint;\n    }"
        ],
        [
            "ActiveMQComponent::convertPathToActualDestination(String,Map)",
            " 167  \n 168  \n 169  \n 170  \n 171  \n 172 -\n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  ",
            "    @Override\n    @SuppressWarnings(\"unchecked\")\n    protected String convertPathToActualDestination(String path, Map<String, Object> parameters) {\n        // support ActiveMQ destination options using the destination. prefix\n        // http://activemq.apache.org/destination-options.html\n        Map options = IntrospectionSupport.extractProperties(parameters, \"destination.\");\n\n        String query;\n        try {\n            query = URISupport.createQueryString(options);\n        } catch (URISyntaxException e) {\n            throw RuntimeCamelException.wrapRuntimeCamelException(e);\n        }\n\n        // if we have destination options then append them to the destination\n        // name\n        if (ObjectHelper.isNotEmpty(query)) {\n            return path + \"?\" + query;\n        } else {\n            return path;\n        }\n    }",
            " 167  \n 168  \n 169  \n 170  \n 171  \n 172 +\n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  ",
            "    @Override\n    @SuppressWarnings(\"unchecked\")\n    protected String convertPathToActualDestination(String path, Map<String, Object> parameters) {\n        // support ActiveMQ destination options using the destination. prefix\n        // http://activemq.apache.org/destination-options.html\n        Map options = PropertiesHelper.extractProperties(parameters, \"destination.\");\n\n        String query;\n        try {\n            query = URISupport.createQueryString(options);\n        } catch (URISyntaxException e) {\n            throw RuntimeCamelException.wrapRuntimeCamelException(e);\n        }\n\n        // if we have destination options then append them to the destination\n        // name\n        if (ObjectHelper.isNotEmpty(query)) {\n            return path + \"?\" + query;\n        } else {\n            return path;\n        }\n    }"
        ],
        [
            "AbstractAtomixClientComponent::setConfigurationProperties(C,Map)",
            "  84  \n  85  \n  86 -\n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99 -\n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  ",
            "    protected C setConfigurationProperties(C configuration, Map<String, Object> parameters) throws Exception {\n        // Resolve config for named maps\n        Map<String, Object> configs = IntrospectionSupport.extractProperties(parameters, \"resource.config.\");\n        for (Map.Entry<String, Object> entry : configs.entrySet()) {\n            String ref = (String)entry.getValue();\n            if (!EndpointHelper.isReferenceParameter(ref)) {\n                throw new IllegalArgumentException(\"The option resource.config.\" + ref + \" should be a reference\");\n            }\n\n            configuration.addResourceConfig(\n                entry.getKey(),\n                EndpointHelper.resolveReferenceParameter(getCamelContext(), ref, Properties.class));\n        }\n\n        // Resolve options for named maps\n        Map<String, Object> options = IntrospectionSupport.extractProperties(parameters, \"resource.options.\");\n        for (Map.Entry<String, Object> entry : options.entrySet()) {\n            String ref = (String)entry.getValue();\n            if (!EndpointHelper.isReferenceParameter(ref)) {\n                throw new IllegalArgumentException(\"The option resource.options.\" + ref + \" should be a reference\");\n            }\n\n            configuration.addResourceOption(\n                entry.getKey(),\n                EndpointHelper.resolveReferenceParameter(getCamelContext(), ref, Properties.class));\n        }\n\n        setProperties(configuration, parameters);\n\n        return configuration;\n    }",
            "  84  \n  85  \n  86 +\n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99 +\n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  ",
            "    protected C setConfigurationProperties(C configuration, Map<String, Object> parameters) throws Exception {\n        // Resolve config for named maps\n        Map<String, Object> configs = PropertiesHelper.extractProperties(parameters, \"resource.config.\");\n        for (Map.Entry<String, Object> entry : configs.entrySet()) {\n            String ref = (String)entry.getValue();\n            if (!EndpointHelper.isReferenceParameter(ref)) {\n                throw new IllegalArgumentException(\"The option resource.config.\" + ref + \" should be a reference\");\n            }\n\n            configuration.addResourceConfig(\n                entry.getKey(),\n                EndpointHelper.resolveReferenceParameter(getCamelContext(), ref, Properties.class));\n        }\n\n        // Resolve options for named maps\n        Map<String, Object> options = PropertiesHelper.extractProperties(parameters, \"resource.options.\");\n        for (Map.Entry<String, Object> entry : options.entrySet()) {\n            String ref = (String)entry.getValue();\n            if (!EndpointHelper.isReferenceParameter(ref)) {\n                throw new IllegalArgumentException(\"The option resource.options.\" + ref + \" should be a reference\");\n            }\n\n            configuration.addResourceOption(\n                entry.getKey(),\n                EndpointHelper.resolveReferenceParameter(getCamelContext(), ref, Properties.class));\n        }\n\n        setProperties(configuration, parameters);\n\n        return configuration;\n    }"
        ],
        [
            "AhcComponent::createEndpoint(String,String,Map)",
            "  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86 -\n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106 -\n 107  \n 108  \n 109 -\n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130 -\n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  ",
            "    @Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        String addressUri = createAddressUri(uri, remaining);\n\n        SSLContextParameters ssl = getSslContextParameters();\n        if (ssl == null) {\n            ssl = retrieveGlobalSslContextParameters();\n        }\n\n        // Do not set the HTTP URI because we still have all of the Camel internal\n        // parameters in the URI at this point.\n        AhcEndpoint endpoint = createAhcEndpoint(uri, this, null);\n        setEndpointHeaderFilterStrategy(endpoint);\n        endpoint.setClient(getClient());\n        endpoint.setClientConfig(getClientConfig());\n        endpoint.setBinding(getBinding());\n        endpoint.setSslContextParameters(ssl);\n        \n        setProperties(endpoint, parameters);\n\n        if (IntrospectionSupport.hasProperties(parameters, CLIENT_CONFIG_PREFIX)) {\n            DefaultAsyncHttpClientConfig.Builder builder = endpoint.getClientConfig() == null\n                    ? new DefaultAsyncHttpClientConfig.Builder() : AhcComponent.cloneConfig(endpoint.getClientConfig());\n            \n            if (endpoint.getClient() != null) {\n                log.warn(\"The user explicitly set an AsyncHttpClient instance on the component or \"\n                         + \"endpoint, but this endpoint URI contains client configuration parameters.  \"\n                         + \"Are you sure that this is what was intended?  The AsyncHttpClient will be used\"\n                         + \" and the URI parameters will be ignored.\");\n            } else if (endpoint.getClientConfig() != null) {\n                log.warn(\"The user explicitly set an AsyncHttpClientConfig instance on the component or \"\n                         + \"endpoint, but this endpoint URI contains client configuration parameters.  \"\n                         + \"Are you sure that this is what was intended?  The URI parameters will be applied\"\n                         + \" to a clone of the supplied AsyncHttpClientConfig in order to prevent unintended modification\"\n                         + \" of the explicitly configured AsyncHttpClientConfig.  That is, the URI parameters override the\"\n                         + \" settings on the explicitly configured AsyncHttpClientConfig for this endpoint.\");\n            }\n\n            // special for realm builder\n            Builder realmBuilder = null;\n            if (IntrospectionSupport.hasProperties(parameters, CLIENT_REALM_CONFIG_PREFIX)) {\n\n                // set and validate additional parameters on client config\n                Map<String, Object> realmParams = IntrospectionSupport.extractProperties(parameters, CLIENT_REALM_CONFIG_PREFIX);\n\n                // copy the parameters for the endpoint to have\n                endpoint.setClientConfigRealmOptions(new LinkedHashMap<>(realmParams));\n\n                Object principal = realmParams.remove(\"principal\");\n                Object password = realmParams.remove(\"password\");\n\n                if (ObjectHelper.isEmpty(principal)) {\n                    throw new IllegalArgumentException(CLIENT_REALM_CONFIG_PREFIX + \".principal must be configured\");\n                }\n                if (password == null) {\n                    password = \"\";\n                }\n\n                realmBuilder = new Realm.Builder(principal.toString(), password.toString());\n                setProperties(realmBuilder, realmParams);\n                validateParameters(uri, realmParams, null);\n            }\n            \n            // set and validate additional parameters on client config\n            Map<String, Object> clientParams = IntrospectionSupport.extractProperties(parameters, CLIENT_CONFIG_PREFIX);\n\n            // copy the parameters for the endpoint to have\n            endpoint.setClientConfigOptions(new LinkedHashMap<>(clientParams));\n\n            setProperties(builder, clientParams);\n            validateParameters(uri, clientParams, null);\n\n            if (realmBuilder != null) {\n                builder.setRealm(realmBuilder.build());\n            }\n            endpoint.setClientConfig(builder.build());\n        }\n\n        // restructure uri to be based on the parameters left as we dont want to include the Camel internal options\n        addressUri = UnsafeUriCharactersEncoder.encodeHttpURI(addressUri);\n        URI httpUri = URISupport.createRemainingURI(new URI(addressUri), parameters);\n        endpoint.setHttpUri(httpUri);\n        \n        return endpoint;\n    }",
            "  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86 +\n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106 +\n 107  \n 108  \n 109 +\n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130 +\n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  ",
            "    @Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        String addressUri = createAddressUri(uri, remaining);\n\n        SSLContextParameters ssl = getSslContextParameters();\n        if (ssl == null) {\n            ssl = retrieveGlobalSslContextParameters();\n        }\n\n        // Do not set the HTTP URI because we still have all of the Camel internal\n        // parameters in the URI at this point.\n        AhcEndpoint endpoint = createAhcEndpoint(uri, this, null);\n        setEndpointHeaderFilterStrategy(endpoint);\n        endpoint.setClient(getClient());\n        endpoint.setClientConfig(getClientConfig());\n        endpoint.setBinding(getBinding());\n        endpoint.setSslContextParameters(ssl);\n        \n        setProperties(endpoint, parameters);\n\n        if (PropertiesHelper.hasProperties(parameters, CLIENT_CONFIG_PREFIX)) {\n            DefaultAsyncHttpClientConfig.Builder builder = endpoint.getClientConfig() == null\n                    ? new DefaultAsyncHttpClientConfig.Builder() : AhcComponent.cloneConfig(endpoint.getClientConfig());\n            \n            if (endpoint.getClient() != null) {\n                log.warn(\"The user explicitly set an AsyncHttpClient instance on the component or \"\n                         + \"endpoint, but this endpoint URI contains client configuration parameters.  \"\n                         + \"Are you sure that this is what was intended?  The AsyncHttpClient will be used\"\n                         + \" and the URI parameters will be ignored.\");\n            } else if (endpoint.getClientConfig() != null) {\n                log.warn(\"The user explicitly set an AsyncHttpClientConfig instance on the component or \"\n                         + \"endpoint, but this endpoint URI contains client configuration parameters.  \"\n                         + \"Are you sure that this is what was intended?  The URI parameters will be applied\"\n                         + \" to a clone of the supplied AsyncHttpClientConfig in order to prevent unintended modification\"\n                         + \" of the explicitly configured AsyncHttpClientConfig.  That is, the URI parameters override the\"\n                         + \" settings on the explicitly configured AsyncHttpClientConfig for this endpoint.\");\n            }\n\n            // special for realm builder\n            Builder realmBuilder = null;\n            if (PropertiesHelper.hasProperties(parameters, CLIENT_REALM_CONFIG_PREFIX)) {\n\n                // set and validate additional parameters on client config\n                Map<String, Object> realmParams = PropertiesHelper.extractProperties(parameters, CLIENT_REALM_CONFIG_PREFIX);\n\n                // copy the parameters for the endpoint to have\n                endpoint.setClientConfigRealmOptions(new LinkedHashMap<>(realmParams));\n\n                Object principal = realmParams.remove(\"principal\");\n                Object password = realmParams.remove(\"password\");\n\n                if (ObjectHelper.isEmpty(principal)) {\n                    throw new IllegalArgumentException(CLIENT_REALM_CONFIG_PREFIX + \".principal must be configured\");\n                }\n                if (password == null) {\n                    password = \"\";\n                }\n\n                realmBuilder = new Realm.Builder(principal.toString(), password.toString());\n                setProperties(realmBuilder, realmParams);\n                validateParameters(uri, realmParams, null);\n            }\n            \n            // set and validate additional parameters on client config\n            Map<String, Object> clientParams = PropertiesHelper.extractProperties(parameters, CLIENT_CONFIG_PREFIX);\n\n            // copy the parameters for the endpoint to have\n            endpoint.setClientConfigOptions(new LinkedHashMap<>(clientParams));\n\n            setProperties(builder, clientParams);\n            validateParameters(uri, clientParams, null);\n\n            if (realmBuilder != null) {\n                builder.setRealm(realmBuilder.build());\n            }\n            endpoint.setClientConfig(builder.build());\n        }\n\n        // restructure uri to be based on the parameters left as we dont want to include the Camel internal options\n        addressUri = UnsafeUriCharactersEncoder.encodeHttpURI(addressUri);\n        URI httpUri = URISupport.createRemainingURI(new URI(addressUri), parameters);\n        endpoint.setHttpUri(httpUri);\n        \n        return endpoint;\n    }"
        ],
        [
            "ElsqlComponent::createEndpoint(String,String,Map)",
            "  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66 -\n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  ",
            "    @Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        DataSource target = null;\n\n        // endpoint options overrule component configured datasource\n        DataSource ds = resolveAndRemoveReferenceParameter(parameters, \"dataSource\", DataSource.class);\n        if (ds != null) {\n            target = ds;\n        }\n        String dataSourceRef = getAndRemoveParameter(parameters, \"dataSourceRef\", String.class);\n        if (target == null && dataSourceRef != null) {\n            target = CamelContextHelper.mandatoryLookup(getCamelContext(), dataSourceRef, DataSource.class);\n        }\n        if (target == null) {\n            // fallback and use component\n            target = getDataSource();\n        }\n        if (target == null) {\n            throw new IllegalArgumentException(\"DataSource must be configured\");\n        }\n\n        NamedParameterJdbcTemplate jdbcTemplate = new NamedParameterJdbcTemplate(target);\n        Map<String, Object> params = IntrospectionSupport.extractProperties(parameters, \"template.\");\n        PropertyBindingSupport.bindProperties(getCamelContext(), jdbcTemplate, params);\n\n        String elsqlName = remaining;\n        String resUri = resourceUri;\n        String[] part = remaining.split(\":\");\n        if (part.length == 2) {\n            elsqlName = part[0];\n            resUri = part[1];\n        } else if (part.length > 2) {\n            throw new IllegalArgumentException(\"Invalid uri. Must by elsql:elsqlName:resourceUri, was: \" + uri);\n        }\n\n        String onConsume = getAndRemoveParameter(parameters, \"consumer.onConsume\", String.class);\n        if (onConsume == null) {\n            onConsume = getAndRemoveParameter(parameters, \"onConsume\", String.class);\n        }\n        String onConsumeFailed = getAndRemoveParameter(parameters, \"consumer.onConsumeFailed\", String.class);\n        if (onConsumeFailed == null) {\n            onConsumeFailed = getAndRemoveParameter(parameters, \"onConsumeFailed\", String.class);\n        }\n        String onConsumeBatchComplete = getAndRemoveParameter(parameters, \"consumer.onConsumeBatchComplete\", String.class);\n        if (onConsumeBatchComplete == null) {\n            onConsumeBatchComplete = getAndRemoveParameter(parameters, \"onConsumeBatchComplete\", String.class);\n        }\n\n        ElsqlEndpoint endpoint = new ElsqlEndpoint(uri, this, jdbcTemplate, target, elsqlName, resUri);\n        endpoint.setElSqlConfig(elSqlConfig);\n        endpoint.setDatabaseVendor(databaseVendor);\n        endpoint.setDataSource(target);\n        endpoint.setDataSourceRef(dataSourceRef);\n        endpoint.setOnConsume(onConsume);\n        endpoint.setOnConsumeFailed(onConsumeFailed);\n        endpoint.setOnConsumeBatchComplete(onConsumeBatchComplete);\n        return endpoint;\n    }",
            "  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66 +\n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  ",
            "    @Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        DataSource target = null;\n\n        // endpoint options overrule component configured datasource\n        DataSource ds = resolveAndRemoveReferenceParameter(parameters, \"dataSource\", DataSource.class);\n        if (ds != null) {\n            target = ds;\n        }\n        String dataSourceRef = getAndRemoveParameter(parameters, \"dataSourceRef\", String.class);\n        if (target == null && dataSourceRef != null) {\n            target = CamelContextHelper.mandatoryLookup(getCamelContext(), dataSourceRef, DataSource.class);\n        }\n        if (target == null) {\n            // fallback and use component\n            target = getDataSource();\n        }\n        if (target == null) {\n            throw new IllegalArgumentException(\"DataSource must be configured\");\n        }\n\n        NamedParameterJdbcTemplate jdbcTemplate = new NamedParameterJdbcTemplate(target);\n        Map<String, Object> params = PropertiesHelper.extractProperties(parameters, \"template.\");\n        PropertyBindingSupport.bindProperties(getCamelContext(), jdbcTemplate, params);\n\n        String elsqlName = remaining;\n        String resUri = resourceUri;\n        String[] part = remaining.split(\":\");\n        if (part.length == 2) {\n            elsqlName = part[0];\n            resUri = part[1];\n        } else if (part.length > 2) {\n            throw new IllegalArgumentException(\"Invalid uri. Must by elsql:elsqlName:resourceUri, was: \" + uri);\n        }\n\n        String onConsume = getAndRemoveParameter(parameters, \"consumer.onConsume\", String.class);\n        if (onConsume == null) {\n            onConsume = getAndRemoveParameter(parameters, \"onConsume\", String.class);\n        }\n        String onConsumeFailed = getAndRemoveParameter(parameters, \"consumer.onConsumeFailed\", String.class);\n        if (onConsumeFailed == null) {\n            onConsumeFailed = getAndRemoveParameter(parameters, \"onConsumeFailed\", String.class);\n        }\n        String onConsumeBatchComplete = getAndRemoveParameter(parameters, \"consumer.onConsumeBatchComplete\", String.class);\n        if (onConsumeBatchComplete == null) {\n            onConsumeBatchComplete = getAndRemoveParameter(parameters, \"onConsumeBatchComplete\", String.class);\n        }\n\n        ElsqlEndpoint endpoint = new ElsqlEndpoint(uri, this, jdbcTemplate, target, elsqlName, resUri);\n        endpoint.setElSqlConfig(elSqlConfig);\n        endpoint.setDatabaseVendor(databaseVendor);\n        endpoint.setDataSource(target);\n        endpoint.setDataSourceRef(dataSourceRef);\n        endpoint.setOnConsume(onConsume);\n        endpoint.setOnConsumeFailed(onConsumeFailed);\n        endpoint.setOnConsumeBatchComplete(onConsumeBatchComplete);\n        return endpoint;\n    }"
        ],
        [
            "FopProducer::setRenderParameters(FOUserAgent,Map)",
            " 120 -\n 121 -\n 122  \n 123  \n 124  \n 125  ",
            "    private void setRenderParameters(FOUserAgent userAgent, Map<String, Object> headers) throws Exception {\n        Map<String, Object> parameters = IntrospectionSupport.extractProperties(headers, FopConstants.CAMEL_FOP_RENDER);\n        if (!parameters.isEmpty()) {\n            PropertyBindingSupport.bindProperties(getEndpoint().getCamelContext(), userAgent, parameters);\n        }\n    }",
            " 119 +\n 120 +\n 121  \n 122  \n 123  \n 124  ",
            "    private void setRenderParameters(FOUserAgent userAgent, Map<String, Object> headers) {\n        Map<String, Object> parameters = PropertiesHelper.extractProperties(headers, FopConstants.CAMEL_FOP_RENDER);\n        if (!parameters.isEmpty()) {\n            PropertyBindingSupport.bindProperties(getEndpoint().getCamelContext(), userAgent, parameters);\n        }\n    }"
        ],
        [
            "FopProducer::setUserAgentRendererOptions(FOUserAgent,Map)",
            " 113  \n 114 -\n 115  \n 116  \n 117  \n 118  ",
            "    private void setUserAgentRendererOptions(FOUserAgent userAgent, Map<String, Object> headers) {\n        Map<String, Object> parameters = IntrospectionSupport.extractProperties(headers, FopConstants.CAMEL_FOP_RENDERER_OPTIONS);\n        if (!parameters.isEmpty()) {\n            userAgent.getRendererOptions().putAll(parameters);\n        }\n    }",
            " 112  \n 113 +\n 114  \n 115  \n 116  \n 117  ",
            "    private void setUserAgentRendererOptions(FOUserAgent userAgent, Map<String, Object> headers) {\n        Map<String, Object> parameters = PropertiesHelper.extractProperties(headers, FopConstants.CAMEL_FOP_RENDERER_OPTIONS);\n        if (!parameters.isEmpty()) {\n            userAgent.getRendererOptions().putAll(parameters);\n        }\n    }"
        ],
        [
            "SWFComponent::createEndpoint(String,String,Map)",
            "  55  \n  56  \n  57 -\n  58 -\n  59 -\n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  ",
            "    @Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        Map<String, Object> clientConfigurationParameters = IntrospectionSupport.extractProperties(parameters, \"clientConfiguration.\");\n        Map<String, Object> sWClientParameters = IntrospectionSupport.extractProperties(parameters, \"sWClient.\");\n        Map<String, Object> startWorkflowOptionsParameters = IntrospectionSupport.extractProperties(parameters, \"startWorkflowOptions.\");\n\n        SWFConfiguration configuration = this.configuration.copy();\n        configuration.setType(remaining);\n        setProperties(configuration, parameters);\n        configuration.setClientConfigurationParameters(clientConfigurationParameters);\n        configuration.setSWClientParameters(sWClientParameters);\n        configuration.setStartWorkflowOptionsParameters(startWorkflowOptionsParameters);\n        \n        if (ObjectHelper.isEmpty(configuration.getAccessKey())) {\n            setAccessKey(accessKey);\n        }\n        if (ObjectHelper.isEmpty(configuration.getSecretKey())) {\n            setSecretKey(secretKey);\n        }\n        if (ObjectHelper.isEmpty(configuration.getRegion())) {\n            setRegion(region);\n        }\n        checkAndSetRegistryClient(configuration);\n        if (configuration.getAmazonSWClient() == null && (configuration.getAccessKey() == null || configuration.getSecretKey() == null)) {\n            throw new IllegalArgumentException(\"AmazonSWClient or accessKey and secretKey must be specified.\");\n        }\n        return new SWFEndpoint(uri, this, configuration);\n    }",
            "  55  \n  56  \n  57 +\n  58 +\n  59 +\n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  ",
            "    @Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        Map<String, Object> clientConfigurationParameters = PropertiesHelper.extractProperties(parameters, \"clientConfiguration.\");\n        Map<String, Object> sWClientParameters = PropertiesHelper.extractProperties(parameters, \"sWClient.\");\n        Map<String, Object> startWorkflowOptionsParameters = PropertiesHelper.extractProperties(parameters, \"startWorkflowOptions.\");\n\n        SWFConfiguration configuration = this.configuration.copy();\n        configuration.setType(remaining);\n        setProperties(configuration, parameters);\n        configuration.setClientConfigurationParameters(clientConfigurationParameters);\n        configuration.setSWClientParameters(sWClientParameters);\n        configuration.setStartWorkflowOptionsParameters(startWorkflowOptionsParameters);\n        \n        if (ObjectHelper.isEmpty(configuration.getAccessKey())) {\n            setAccessKey(accessKey);\n        }\n        if (ObjectHelper.isEmpty(configuration.getSecretKey())) {\n            setSecretKey(secretKey);\n        }\n        if (ObjectHelper.isEmpty(configuration.getRegion())) {\n            setRegion(region);\n        }\n        checkAndSetRegistryClient(configuration);\n        if (configuration.getAmazonSWClient() == null && (configuration.getAccessKey() == null || configuration.getSecretKey() == null)) {\n            throw new IllegalArgumentException(\"AmazonSWClient or accessKey and secretKey must be specified.\");\n        }\n        return new SWFEndpoint(uri, this, configuration);\n    }"
        ]
    ]
}