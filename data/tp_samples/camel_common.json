{
    "70f618adebbafef719bcb27f965b8e10ac5c3050": [
        [
            "AmazonKMSClientMock::listKeys(ListKeysRequest)",
            " 256  \n 257  \n 258  \n 259 -\n 260  \n 261  \n 262  \n 263  \n 264  \n 265  ",
            "    @Override\n    public ListKeysResult listKeys(ListKeysRequest listKeysRequest) {\n        ListKeysResult result = new ListKeysResult();\n        List<KeyListEntry> keyList = new ArrayList<KeyListEntry>();\n        KeyListEntry kle = new KeyListEntry();\n        kle.withKeyId(\"keyId\");\n        keyList.add(kle);\n        result.setKeys(keyList);\n        return result;\n    }",
            " 256  \n 257  \n 258  \n 259 +\n 260  \n 261  \n 262  \n 263  \n 264  \n 265  ",
            "    @Override\n    public ListKeysResult listKeys(ListKeysRequest listKeysRequest) {\n        ListKeysResult result = new ListKeysResult();\n        List<KeyListEntry> keyList = new ArrayList<>();\n        KeyListEntry kle = new KeyListEntry();\n        kle.withKeyId(\"keyId\");\n        keyList.add(kle);\n        result.setKeys(keyList);\n        return result;\n    }"
        ],
        [
            "BatchGetItemsCommandTest::execute()",
            "  48  \n  49  \n  50 -\n  51  \n  52 -\n  53  \n  54 -\n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  ",
            "    @Test\n    public void execute() {\n        Map<String, AttributeValue> key = new HashMap<String, AttributeValue>();\n        key.put(\"1\", new AttributeValue(\"Key_1\"));\n        Map<String, AttributeValue> unprocessedKey = new HashMap<String, AttributeValue>();\n        unprocessedKey.put(\"1\", new AttributeValue(\"UNPROCESSED_KEY\"));\n        Map<String, KeysAndAttributes> keysAndAttributesMap = new HashMap<String, KeysAndAttributes>();\n        KeysAndAttributes keysAndAttributes = new KeysAndAttributes().withKeys(key);\n        keysAndAttributesMap.put(\"DOMAIN1\", keysAndAttributes);\n        exchange.getIn().setHeader(DdbConstants.BATCH_ITEMS, keysAndAttributesMap);\n\n        command.execute();\n\n        assertEquals(keysAndAttributesMap, ddbClient.batchGetItemRequest.getRequestItems());\n\n\n        List<Map<String, AttributeValue>> batchResponse = (List<Map<String, AttributeValue>>)exchange.getIn().getHeader(DdbConstants.BATCH_RESPONSE, Map.class).get(\"DOMAIN1\");\n        AttributeValue value = batchResponse.get(0).get(\"attrName\");\n\n        KeysAndAttributes unProcessedAttributes = (KeysAndAttributes)exchange.getIn().getHeader(\n                DdbConstants.UNPROCESSED_KEYS, Map.class).get(\"DOMAIN1\");\n        Map<String, AttributeValue> next = unProcessedAttributes.getKeys().iterator().next();\n\n        assertEquals(new AttributeValue(\"attrValue\"), value);\n        assertEquals(unprocessedKey, next);\n    }",
            "  48  \n  49  \n  50 +\n  51  \n  52 +\n  53  \n  54 +\n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  ",
            "    @Test\n    public void execute() {\n        Map<String, AttributeValue> key = new HashMap<>();\n        key.put(\"1\", new AttributeValue(\"Key_1\"));\n        Map<String, AttributeValue> unprocessedKey = new HashMap<>();\n        unprocessedKey.put(\"1\", new AttributeValue(\"UNPROCESSED_KEY\"));\n        Map<String, KeysAndAttributes> keysAndAttributesMap = new HashMap<>();\n        KeysAndAttributes keysAndAttributes = new KeysAndAttributes().withKeys(key);\n        keysAndAttributesMap.put(\"DOMAIN1\", keysAndAttributes);\n        exchange.getIn().setHeader(DdbConstants.BATCH_ITEMS, keysAndAttributesMap);\n\n        command.execute();\n\n        assertEquals(keysAndAttributesMap, ddbClient.batchGetItemRequest.getRequestItems());\n\n\n        List<Map<String, AttributeValue>> batchResponse = (List<Map<String, AttributeValue>>)exchange.getIn().getHeader(DdbConstants.BATCH_RESPONSE, Map.class).get(\"DOMAIN1\");\n        AttributeValue value = batchResponse.get(0).get(\"attrName\");\n\n        KeysAndAttributes unProcessedAttributes = (KeysAndAttributes)exchange.getIn().getHeader(\n                DdbConstants.UNPROCESSED_KEYS, Map.class).get(\"DOMAIN1\");\n        Map<String, AttributeValue> next = unProcessedAttributes.getKeys().iterator().next();\n\n        assertEquals(new AttributeValue(\"attrValue\"), value);\n        assertEquals(unprocessedKey, next);\n    }"
        ],
        [
            "AhcProducerTwoParametersWithSameKeyTest::testTwoHeadersWithSameKeyHeader()",
            "  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48 -\n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  ",
            "    @Test\n    public void testTwoHeadersWithSameKeyHeader() throws Exception {\n        Exchange out = template.request(\"ahc:http://localhost:{{port}}/myapp\", new Processor() {\n            public void process(Exchange exchange) throws Exception {\n                exchange.getIn().setBody(null);\n                exchange.getIn().setHeader(\"from\", \"me\");\n                List<String> list = new ArrayList<String>();\n                list.add(\"foo\");\n                list.add(\"bar\");\n                exchange.getIn().setHeader(\"to\", list);\n            }\n        });\n\n        assertNotNull(out);\n        assertFalse(\"Should not fail\", out.isFailed());\n        assertEquals(\"OK\", out.getOut().getBody(String.class));\n        assertEquals(\"yes\", out.getOut().getHeader(\"bar\"));\n\n\n    }",
            "  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48 +\n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  ",
            "    @Test\n    public void testTwoHeadersWithSameKeyHeader() throws Exception {\n        Exchange out = template.request(\"ahc:http://localhost:{{port}}/myapp\", new Processor() {\n            public void process(Exchange exchange) throws Exception {\n                exchange.getIn().setBody(null);\n                exchange.getIn().setHeader(\"from\", \"me\");\n                List<String> list = new ArrayList<>();\n                list.add(\"foo\");\n                list.add(\"bar\");\n                exchange.getIn().setHeader(\"to\", list);\n            }\n        });\n\n        assertNotNull(out);\n        assertFalse(\"Should not fail\", out.isFailed());\n        assertEquals(\"OK\", out.getOut().getBody(String.class));\n        assertEquals(\"yes\", out.getOut().getHeader(\"bar\"));\n\n\n    }"
        ],
        [
            "ApnsProducer::constructNotificationAndNotify(Exchange,MessageType)",
            "  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85 -\n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  ",
            "    private void constructNotificationAndNotify(Exchange exchange, MessageType messageType) {\n        String payload;\n        Collection<String> tokens;\n        if (isTokensConfiguredUsingUri()) {\n            if (hasTokensHeader(exchange)) {\n                throw new IllegalArgumentException(\"Tokens already configured on endpoint \" + ApnsConstants.HEADER_TOKENS);\n            }\n            tokens = new ArrayList<String>(tokenList);\n        } else {\n            String tokensHeader = getHeaderTokens(exchange);\n            tokens = extractTokensFromString(tokensHeader);\n        }\n        if (messageType == MessageType.STRING) {\n            String message = exchange.getIn().getBody(String.class);\n            payload = APNS.newPayload().alertBody(message).build();\n        } else {\n            String message = exchange.getIn().getBody(String.class);\n            payload = message;\n        }\n        Date expiry = exchange.getIn().getHeader(ApnsConstants.HEADER_EXPIRY, Date.class);\n        if (expiry != null) {\n            getEndpoint().getApnsService().push(tokens, payload, expiry);\n        } else {\n            getEndpoint().getApnsService().push(tokens, payload);\n        }\n    }",
            "  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85 +\n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  ",
            "    private void constructNotificationAndNotify(Exchange exchange, MessageType messageType) {\n        String payload;\n        Collection<String> tokens;\n        if (isTokensConfiguredUsingUri()) {\n            if (hasTokensHeader(exchange)) {\n                throw new IllegalArgumentException(\"Tokens already configured on endpoint \" + ApnsConstants.HEADER_TOKENS);\n            }\n            tokens = new ArrayList<>(tokenList);\n        } else {\n            String tokensHeader = getHeaderTokens(exchange);\n            tokens = extractTokensFromString(tokensHeader);\n        }\n        if (messageType == MessageType.STRING) {\n            String message = exchange.getIn().getBody(String.class);\n            payload = APNS.newPayload().alertBody(message).build();\n        } else {\n            String message = exchange.getIn().getBody(String.class);\n            payload = message;\n        }\n        Date expiry = exchange.getIn().getHeader(ApnsConstants.HEADER_EXPIRY, Date.class);\n        if (expiry != null) {\n            getEndpoint().getApnsService().push(tokens, payload, expiry);\n        } else {\n            getEndpoint().getApnsService().push(tokens, payload);\n        }\n    }"
        ],
        [
            "DefaultAhcBinding::extractResponseHeaders(Exchange)",
            " 334  \n 335 -\n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344  ",
            "    private Map<String, String> extractResponseHeaders(Exchange exchange) {\n        Map<String, String> answer = new LinkedHashMap<String, String>();\n        for (Map.Entry<String, Object> entry : exchange.getOut().getHeaders().entrySet()) {\n            String key = entry.getKey();\n            String value = exchange.getContext().getTypeConverter().convertTo(String.class, entry.getValue());\n            if (value != null) {\n                answer.put(key, value);\n            }\n        }\n        return answer;\n    }",
            " 334  \n 335 +\n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344  ",
            "    private Map<String, String> extractResponseHeaders(Exchange exchange) {\n        Map<String, String> answer = new LinkedHashMap<>();\n        for (Map.Entry<String, Object> entry : exchange.getOut().getHeaders().entrySet()) {\n            String key = entry.getKey();\n            String value = exchange.getContext().getTypeConverter().convertTo(String.class, entry.getValue());\n            if (value != null) {\n                answer.put(key, value);\n            }\n        }\n        return answer;\n    }"
        ],
        [
            "CwComponentTest::setsMeticDimensions()",
            " 106  \n 107  \n 108  \n 109  \n 110  \n 111 -\n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  ",
            "    @Test\n    public void setsMeticDimensions() throws Exception {\n        template.send(\"direct:start\", ExchangePattern.InOnly, new Processor() {\n            public void process(Exchange exchange) throws Exception {\n                exchange.getIn().setHeader(CwConstants.METRIC_NAME, \"errorCount\");\n                Map<String, String> dimensionsMap = new LinkedHashMap<String, String>();\n                dimensionsMap.put(\"keyOne\", \"valueOne\");\n                dimensionsMap.put(\"keyTwo\", \"valueTwo\");\n                exchange.getIn().setHeader(CwConstants.METRIC_DIMENSIONS, dimensionsMap);\n            }\n        });\n\n        ArgumentCaptor<PutMetricDataRequest> argument = ArgumentCaptor.forClass(PutMetricDataRequest.class);\n        verify(cloudWatchClient).putMetricData(argument.capture());\n\n        List<Dimension> dimensions = argument.getValue().getMetricData().get(0).getDimensions();\n        Dimension dimension = dimensions.get(0);\n        assertThat(dimensions.size(), is(2));\n        assertEquals(\"keyOne\", dimension.getName());\n        assertEquals(\"valueOne\", dimension.getValue());\n    }",
            " 106  \n 107  \n 108  \n 109  \n 110  \n 111 +\n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  ",
            "    @Test\n    public void setsMeticDimensions() throws Exception {\n        template.send(\"direct:start\", ExchangePattern.InOnly, new Processor() {\n            public void process(Exchange exchange) throws Exception {\n                exchange.getIn().setHeader(CwConstants.METRIC_NAME, \"errorCount\");\n                Map<String, String> dimensionsMap = new LinkedHashMap<>();\n                dimensionsMap.put(\"keyOne\", \"valueOne\");\n                dimensionsMap.put(\"keyTwo\", \"valueTwo\");\n                exchange.getIn().setHeader(CwConstants.METRIC_DIMENSIONS, dimensionsMap);\n            }\n        });\n\n        ArgumentCaptor<PutMetricDataRequest> argument = ArgumentCaptor.forClass(PutMetricDataRequest.class);\n        verify(cloudWatchClient).putMetricData(argument.capture());\n\n        List<Dimension> dimensions = argument.getValue().getMetricData().get(0).getDimensions();\n        Dimension dimension = dimensions.get(0);\n        assertThat(dimensions.size(), is(2));\n        assertEquals(\"keyOne\", dimension.getName());\n        assertEquals(\"valueOne\", dimension.getValue());\n    }"
        ],
        [
            "QueueServiceUtil::createQueueClient(QueueServiceConfiguration)",
            "  43  \n  44  \n  45 -\n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  ",
            "    public static CloudQueue createQueueClient(QueueServiceConfiguration cfg)\n        throws Exception {\n        CloudQueue client = (CloudQueue) getConfiguredClient(cfg);\n        if (client == null) {\n            URI uri = prepareStorageQueueUri(cfg);\n            StorageCredentials creds = getAccountCredentials(cfg);\n            client = new CloudQueue(uri, creds);\n        }\n        return client;\n    }",
            "  43  \n  44  \n  45 +\n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  ",
            "    public static CloudQueue createQueueClient(QueueServiceConfiguration cfg)\n        throws Exception {\n        CloudQueue client = getConfiguredClient(cfg);\n        if (client == null) {\n            URI uri = prepareStorageQueueUri(cfg);\n            StorageCredentials creds = getAccountCredentials(cfg);\n            client = new CloudQueue(uri, creds);\n        }\n        return client;\n    }"
        ],
        [
            "DescribeTableCommandTest::testExecute()",
            "  48  \n  49  \n  50  \n  51 -\n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  ",
            "    @Test\n    public void testExecute() {\n        command.execute();\n        List<KeySchemaElement> keySchema = new ArrayList<KeySchemaElement>();\n        keySchema.add(new KeySchemaElement().withAttributeName(\"name\"));\n        assertEquals(\"FULL_DESCRIBE_TABLE\", ddbClient.describeTableRequest.getTableName());\n        assertEquals(\"FULL_DESCRIBE_TABLE\", exchange.getIn().getHeader(DdbConstants.TABLE_NAME));\n        assertEquals(\"ACTIVE\", exchange.getIn().getHeader(DdbConstants.TABLE_STATUS));\n        assertEquals(new Date(AmazonDDBClientMock.NOW), exchange.getIn().getHeader(DdbConstants.CREATION_DATE));\n        assertEquals(100L, exchange.getIn().getHeader(DdbConstants.ITEM_COUNT));\n        assertEquals(keySchema,\n                exchange.getIn().getHeader(DdbConstants.KEY_SCHEMA));\n        assertEquals(20L, exchange.getIn().getHeader(DdbConstants.READ_CAPACITY));\n        assertEquals(10L, exchange.getIn().getHeader(DdbConstants.WRITE_CAPACITY));\n        assertEquals(1000L, exchange.getIn().getHeader(DdbConstants.TABLE_SIZE));\n    }",
            "  48  \n  49  \n  50  \n  51 +\n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  ",
            "    @Test\n    public void testExecute() {\n        command.execute();\n        List<KeySchemaElement> keySchema = new ArrayList<>();\n        keySchema.add(new KeySchemaElement().withAttributeName(\"name\"));\n        assertEquals(\"FULL_DESCRIBE_TABLE\", ddbClient.describeTableRequest.getTableName());\n        assertEquals(\"FULL_DESCRIBE_TABLE\", exchange.getIn().getHeader(DdbConstants.TABLE_NAME));\n        assertEquals(\"ACTIVE\", exchange.getIn().getHeader(DdbConstants.TABLE_STATUS));\n        assertEquals(new Date(AmazonDDBClientMock.NOW), exchange.getIn().getHeader(DdbConstants.CREATION_DATE));\n        assertEquals(100L, exchange.getIn().getHeader(DdbConstants.ITEM_COUNT));\n        assertEquals(keySchema,\n                exchange.getIn().getHeader(DdbConstants.KEY_SCHEMA));\n        assertEquals(20L, exchange.getIn().getHeader(DdbConstants.READ_CAPACITY));\n        assertEquals(10L, exchange.getIn().getHeader(DdbConstants.WRITE_CAPACITY));\n        assertEquals(1000L, exchange.getIn().getHeader(DdbConstants.TABLE_SIZE));\n    }"
        ],
        [
            "DeleteAttributesCommandTest::determineAttributes()",
            "  79  \n  80  \n  81  \n  82  \n  83 -\n  84  \n  85  \n  86  \n  87  \n  88  ",
            "    @Test\n    public void determineAttributes() {\n        assertNull(this.command.determineAttributes());\n        \n        List<Attribute> attributes = new ArrayList<Attribute>();\n        attributes.add(new Attribute(\"NAME1\", \"VALUE1\"));\n        exchange.getIn().setHeader(SdbConstants.ATTRIBUTES, attributes);\n        \n        assertEquals(attributes, this.command.determineAttributes());\n    }",
            "  79  \n  80  \n  81  \n  82  \n  83 +\n  84  \n  85  \n  86  \n  87  \n  88  ",
            "    @Test\n    public void determineAttributes() {\n        assertNull(this.command.determineAttributes());\n        \n        List<Attribute> attributes = new ArrayList<>();\n        attributes.add(new Attribute(\"NAME1\", \"VALUE1\"));\n        exchange.getIn().setHeader(SdbConstants.ATTRIBUTES, attributes);\n        \n        assertEquals(attributes, this.command.determineAttributes());\n    }"
        ],
        [
            "EC2ProducerTest::ec2CreateAndRunTestWithSecurityGroups()",
            "  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85 -\n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  ",
            "    @Test\n    public void ec2CreateAndRunTestWithSecurityGroups() throws Exception {\n\n        mock.expectedMessageCount(1);\n        Exchange exchange = template.request(\"direct:createAndRun\", new Processor() {\n            @Override\n            public void process(Exchange exchange) throws Exception {\n                exchange.getIn().setHeader(EC2Constants.OPERATION, EC2Operations.createAndRunInstances);\n                exchange.getIn().setHeader(EC2Constants.IMAGE_ID, \"test-1\");\n                exchange.getIn().setHeader(EC2Constants.INSTANCE_TYPE, InstanceType.T2Micro);\n                exchange.getIn().setHeader(EC2Constants.INSTANCE_MIN_COUNT, 1);\n                exchange.getIn().setHeader(EC2Constants.INSTANCE_MAX_COUNT, 1);\n                Collection<String> secGroups = new ArrayList<String>();\n                secGroups.add(\"secgroup-1\");\n                secGroups.add(\"secgroup-2\");\n                exchange.getIn().setHeader(EC2Constants.INSTANCE_SECURITY_GROUPS, secGroups);\n            }\n        });\n        \n        assertMockEndpointsSatisfied();\n        \n        RunInstancesResult resultGet = (RunInstancesResult) exchange.getIn().getBody();\n        assertEquals(resultGet.getReservation().getInstances().get(0).getImageId(), \"test-1\");\n        assertEquals(resultGet.getReservation().getInstances().get(0).getInstanceType(), InstanceType.T2Micro.toString());\n        assertEquals(resultGet.getReservation().getInstances().get(0).getInstanceId(), \"instance-1\");\n        assertEquals(resultGet.getReservation().getInstances().get(0).getSecurityGroups().size(), 2);\n        assertEquals(resultGet.getReservation().getInstances().get(0).getSecurityGroups().get(0).getGroupId(), \"id-1\");\n        assertEquals(resultGet.getReservation().getInstances().get(0).getSecurityGroups().get(1).getGroupId(), \"id-2\");\n    }",
            "  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85 +\n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  ",
            "    @Test\n    public void ec2CreateAndRunTestWithSecurityGroups() throws Exception {\n\n        mock.expectedMessageCount(1);\n        Exchange exchange = template.request(\"direct:createAndRun\", new Processor() {\n            @Override\n            public void process(Exchange exchange) throws Exception {\n                exchange.getIn().setHeader(EC2Constants.OPERATION, EC2Operations.createAndRunInstances);\n                exchange.getIn().setHeader(EC2Constants.IMAGE_ID, \"test-1\");\n                exchange.getIn().setHeader(EC2Constants.INSTANCE_TYPE, InstanceType.T2Micro);\n                exchange.getIn().setHeader(EC2Constants.INSTANCE_MIN_COUNT, 1);\n                exchange.getIn().setHeader(EC2Constants.INSTANCE_MAX_COUNT, 1);\n                Collection<String> secGroups = new ArrayList<>();\n                secGroups.add(\"secgroup-1\");\n                secGroups.add(\"secgroup-2\");\n                exchange.getIn().setHeader(EC2Constants.INSTANCE_SECURITY_GROUPS, secGroups);\n            }\n        });\n        \n        assertMockEndpointsSatisfied();\n        \n        RunInstancesResult resultGet = (RunInstancesResult) exchange.getIn().getBody();\n        assertEquals(resultGet.getReservation().getInstances().get(0).getImageId(), \"test-1\");\n        assertEquals(resultGet.getReservation().getInstances().get(0).getInstanceType(), InstanceType.T2Micro.toString());\n        assertEquals(resultGet.getReservation().getInstances().get(0).getInstanceId(), \"instance-1\");\n        assertEquals(resultGet.getReservation().getInstances().get(0).getSecurityGroups().size(), 2);\n        assertEquals(resultGet.getReservation().getInstances().get(0).getSecurityGroups().get(0).getGroupId(), \"id-1\");\n        assertEquals(resultGet.getReservation().getInstances().get(0).getSecurityGroups().get(1).getGroupId(), \"id-2\");\n    }"
        ],
        [
            "AhcProducerConnectionCloseHeadersTest::testAhcProduce()",
            "  28  \n  29  \n  30  \n  31  \n  32  \n  33  \n  34  \n  35  \n  36  \n  37  \n  38 -\n  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  ",
            "    @Test\n    public void testAhcProduce() throws Exception {\n        getMockEndpoint(\"mock:result\").expectedBodiesReceived(\"Bye World\");\n        getMockEndpoint(\"mock:result\").expectedHeaderReceived(\"foo\", 123);\n        getMockEndpoint(\"mock:result\").expectedHeaderReceived(\"bar\", \"cool\");\n        getMockEndpoint(\"mock:result\").expectedHeaderReceived(Exchange.HTTP_RESPONSE_CODE, 200);\n        getMockEndpoint(\"mock:result\").expectedHeaderReceived(Exchange.HTTP_RESPONSE_TEXT, \"OK\");\n        getMockEndpoint(\"mock:result\").expectedHeaderReceived(Exchange.CONTENT_LENGTH, 9);\n        getMockEndpoint(\"mock:result\").expectedHeaderReceived(\"Connection\", \"close\");\n\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(\"foo\", 123);\n        headers.put(\"bar\", \"cool\");\n\n        template.sendBodyAndHeaders(\"direct:start\", null, headers);\n\n        assertMockEndpointsSatisfied();\n    }",
            "  28  \n  29  \n  30  \n  31  \n  32  \n  33  \n  34  \n  35  \n  36  \n  37  \n  38 +\n  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  ",
            "    @Test\n    public void testAhcProduce() throws Exception {\n        getMockEndpoint(\"mock:result\").expectedBodiesReceived(\"Bye World\");\n        getMockEndpoint(\"mock:result\").expectedHeaderReceived(\"foo\", 123);\n        getMockEndpoint(\"mock:result\").expectedHeaderReceived(\"bar\", \"cool\");\n        getMockEndpoint(\"mock:result\").expectedHeaderReceived(Exchange.HTTP_RESPONSE_CODE, 200);\n        getMockEndpoint(\"mock:result\").expectedHeaderReceived(Exchange.HTTP_RESPONSE_TEXT, \"OK\");\n        getMockEndpoint(\"mock:result\").expectedHeaderReceived(Exchange.CONTENT_LENGTH, 9);\n        getMockEndpoint(\"mock:result\").expectedHeaderReceived(\"Connection\", \"close\");\n\n        Map<String, Object> headers = new HashMap<>();\n        headers.put(\"foo\", 123);\n        headers.put(\"bar\", \"cool\");\n\n        template.sendBodyAndHeaders(\"direct:start\", null, headers);\n\n        assertMockEndpointsSatisfied();\n    }"
        ],
        [
            "S3Consumer::createExchanges(List)",
            " 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120 -\n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  ",
            "    protected Queue<Exchange> createExchanges(List<S3ObjectSummary> s3ObjectSummaries) {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Received {} messages in this poll\", s3ObjectSummaries.size());\n        }\n\n        Collection<S3Object> s3Objects = new ArrayList<>();\n        Queue<Exchange> answer = new LinkedList<Exchange>();\n        try {\n            for (S3ObjectSummary s3ObjectSummary : s3ObjectSummaries) {\n                S3Object s3Object = getAmazonS3Client().getObject(s3ObjectSummary.getBucketName(), s3ObjectSummary.getKey());\n                s3Objects.add(s3Object);\n\n                Exchange exchange = getEndpoint().createExchange(s3Object);\n                answer.add(exchange);\n            }\n        } catch (Throwable e) {\n            LOG.warn(\"Error getting S3Object due: \" + e.getMessage(), e);\n            // ensure all previous gathered s3 objects are closed\n            // if there was an exception creating the exchanges in this batch\n            s3Objects.forEach(IOHelper::close);\n            throw e;\n        }\n\n        return answer;\n    }",
            " 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120 +\n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  ",
            "    protected Queue<Exchange> createExchanges(List<S3ObjectSummary> s3ObjectSummaries) {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Received {} messages in this poll\", s3ObjectSummaries.size());\n        }\n\n        Collection<S3Object> s3Objects = new ArrayList<>();\n        Queue<Exchange> answer = new LinkedList<>();\n        try {\n            for (S3ObjectSummary s3ObjectSummary : s3ObjectSummaries) {\n                S3Object s3Object = getAmazonS3Client().getObject(s3ObjectSummary.getBucketName(), s3ObjectSummary.getKey());\n                s3Objects.add(s3Object);\n\n                Exchange exchange = getEndpoint().createExchange(s3Object);\n                answer.add(exchange);\n            }\n        } catch (Throwable e) {\n            LOG.warn(\"Error getting S3Object due: \" + e.getMessage(), e);\n            // ensure all previous gathered s3 objects are closed\n            // if there was an exception creating the exchanges in this batch\n            s3Objects.forEach(IOHelper::close);\n            throw e;\n        }\n\n        return answer;\n    }"
        ],
        [
            "AmazonSQSClientMock::receiveMessage(ReceiveMessageRequest)",
            "  97  \n  98  \n  99  \n 100  \n 101 -\n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  ",
            "    @Override\n    public ReceiveMessageResult receiveMessage(ReceiveMessageRequest receiveMessageRequest) throws AmazonServiceException, AmazonClientException {\n        Integer maxNumberOfMessages = receiveMessageRequest.getMaxNumberOfMessages() != null ? receiveMessageRequest.getMaxNumberOfMessages() : Integer.MAX_VALUE;\n        ReceiveMessageResult result = new ReceiveMessageResult();\n        Collection<Message> resultMessages = new ArrayList<Message>();\n        \n        synchronized (messages) {\n            int fetchSize = 0;\n            for (Iterator<Message> iterator = messages.iterator(); iterator.hasNext() && fetchSize < maxNumberOfMessages; fetchSize++) {\n                Message rc = iterator.next();\n                resultMessages.add(rc);\n                iterator.remove();\n                scheduleCancelInflight(receiveMessageRequest.getQueueUrl(), rc);\n            }\n        }\n        \n        result.setMessages(resultMessages);\n        return result;\n    }",
            "  97  \n  98  \n  99  \n 100  \n 101 +\n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  ",
            "    @Override\n    public ReceiveMessageResult receiveMessage(ReceiveMessageRequest receiveMessageRequest) throws AmazonServiceException, AmazonClientException {\n        Integer maxNumberOfMessages = receiveMessageRequest.getMaxNumberOfMessages() != null ? receiveMessageRequest.getMaxNumberOfMessages() : Integer.MAX_VALUE;\n        ReceiveMessageResult result = new ReceiveMessageResult();\n        Collection<Message> resultMessages = new ArrayList<>();\n        \n        synchronized (messages) {\n            int fetchSize = 0;\n            for (Iterator<Message> iterator = messages.iterator(); iterator.hasNext() && fetchSize < maxNumberOfMessages; fetchSize++) {\n                Message rc = iterator.next();\n                resultMessages.add(rc);\n                iterator.remove();\n                scheduleCancelInflight(receiveMessageRequest.getQueueUrl(), rc);\n            }\n        }\n        \n        result.setMessages(resultMessages);\n        return result;\n    }"
        ],
        [
            "MemoryWebSocketStore::MemoryWebSocketStore()",
            "  36  \n  37 -\n  38 -\n  39  ",
            "    public MemoryWebSocketStore() {\n        values = new ConcurrentHashMap<String, WebSocket>();\n        keys = new ConcurrentHashMap<WebSocket, String>();\n    }",
            "  36  \n  37 +\n  38 +\n  39  ",
            "    public MemoryWebSocketStore() {\n        values = new ConcurrentHashMap<>();\n        keys = new ConcurrentHashMap<>();\n    }"
        ],
        [
            "S3Producer::processMultiPart(Exchange)",
            " 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170 -\n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  ",
            "    public void processMultiPart(final Exchange exchange) throws Exception {\n        File filePayload = null;\n        Object obj = exchange.getIn().getMandatoryBody();\n        // Need to check if the message body is WrappedFile\n        if (obj instanceof WrappedFile) {\n            obj = ((WrappedFile<?>)obj).getFile();\n        }\n        if (obj instanceof File) {\n            filePayload = (File)obj;\n        } else {\n            throw new InvalidArgumentException(\"aws-s3: MultiPart upload requires a File input.\");\n        }\n\n        ObjectMetadata objectMetadata = determineMetadata(exchange);\n        if (objectMetadata.getContentLength() == 0) {\n            objectMetadata.setContentLength(filePayload.length());\n        }\n\n        final String keyName = determineKey(exchange);\n        final InitiateMultipartUploadRequest initRequest = new InitiateMultipartUploadRequest(getConfiguration().getBucketName(), keyName, objectMetadata);\n\n        String storageClass = determineStorageClass(exchange);\n        if (storageClass != null) {\n            initRequest.setStorageClass(StorageClass.fromValue(storageClass));\n        }\n\n        String cannedAcl = exchange.getIn().getHeader(S3Constants.CANNED_ACL, String.class);\n        if (cannedAcl != null) {\n            CannedAccessControlList objectAcl = CannedAccessControlList.valueOf(cannedAcl);\n            initRequest.setCannedACL(objectAcl);\n        }\n\n        AccessControlList acl = exchange.getIn().getHeader(S3Constants.ACL, AccessControlList.class);\n        if (acl != null) {\n            // note: if cannedacl and acl are both specified the last one will\n            // be used. refer to\n            // PutObjectRequest#setAccessControlList for more details\n            initRequest.setAccessControlList(acl);\n        }\n        \n        if (getConfiguration().isUseAwsKMS()) {\n            SSEAwsKeyManagementParams keyManagementParams;\n            if (ObjectHelper.isNotEmpty(getConfiguration().getAwsKMSKeyId())) {\n                keyManagementParams = new SSEAwsKeyManagementParams(getConfiguration().getAwsKMSKeyId());\n            } else {\n                keyManagementParams = new SSEAwsKeyManagementParams();\n            }\n            initRequest.setSSEAwsKeyManagementParams(keyManagementParams);\n        }\n\n        LOG.trace(\"Initiating multipart upload [{}] from exchange [{}]...\", initRequest, exchange);\n\n        final InitiateMultipartUploadResult initResponse = getEndpoint().getS3Client().initiateMultipartUpload(initRequest);\n        final long contentLength = objectMetadata.getContentLength();\n        final List<PartETag> partETags = new ArrayList<PartETag>();\n        long partSize = getConfiguration().getPartSize();\n        CompleteMultipartUploadResult uploadResult = null;\n\n        long filePosition = 0;\n\n        try {\n            for (int part = 1; filePosition < contentLength; part++) {\n                partSize = Math.min(partSize, contentLength - filePosition);\n\n                UploadPartRequest uploadRequest = new UploadPartRequest().withBucketName(getConfiguration().getBucketName()).withKey(keyName)\n                    .withUploadId(initResponse.getUploadId()).withPartNumber(part).withFileOffset(filePosition).withFile(filePayload).withPartSize(partSize);\n\n                LOG.trace(\"Uploading part [{}] for {}\", part, keyName);\n                partETags.add(getEndpoint().getS3Client().uploadPart(uploadRequest).getPartETag());\n\n                filePosition += partSize;\n            }\n            CompleteMultipartUploadRequest compRequest = new CompleteMultipartUploadRequest(getConfiguration().getBucketName(), keyName, initResponse.getUploadId(), partETags);\n\n            uploadResult = getEndpoint().getS3Client().completeMultipartUpload(compRequest);\n\n        } catch (Exception e) {\n            getEndpoint().getS3Client().abortMultipartUpload(new AbortMultipartUploadRequest(getConfiguration().getBucketName(), keyName, initResponse.getUploadId()));\n            throw e;\n        }\n\n        Message message = getMessageForResponse(exchange);\n        message.setHeader(S3Constants.E_TAG, uploadResult.getETag());\n        if (uploadResult.getVersionId() != null) {\n            message.setHeader(S3Constants.VERSION_ID, uploadResult.getVersionId());\n        }\n\n        if (getConfiguration().isDeleteAfterWrite() && filePayload != null) {\n            FileUtil.deleteFile(filePayload);\n        }\n    }",
            " 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170 +\n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  ",
            "    public void processMultiPart(final Exchange exchange) throws Exception {\n        File filePayload = null;\n        Object obj = exchange.getIn().getMandatoryBody();\n        // Need to check if the message body is WrappedFile\n        if (obj instanceof WrappedFile) {\n            obj = ((WrappedFile<?>)obj).getFile();\n        }\n        if (obj instanceof File) {\n            filePayload = (File)obj;\n        } else {\n            throw new InvalidArgumentException(\"aws-s3: MultiPart upload requires a File input.\");\n        }\n\n        ObjectMetadata objectMetadata = determineMetadata(exchange);\n        if (objectMetadata.getContentLength() == 0) {\n            objectMetadata.setContentLength(filePayload.length());\n        }\n\n        final String keyName = determineKey(exchange);\n        final InitiateMultipartUploadRequest initRequest = new InitiateMultipartUploadRequest(getConfiguration().getBucketName(), keyName, objectMetadata);\n\n        String storageClass = determineStorageClass(exchange);\n        if (storageClass != null) {\n            initRequest.setStorageClass(StorageClass.fromValue(storageClass));\n        }\n\n        String cannedAcl = exchange.getIn().getHeader(S3Constants.CANNED_ACL, String.class);\n        if (cannedAcl != null) {\n            CannedAccessControlList objectAcl = CannedAccessControlList.valueOf(cannedAcl);\n            initRequest.setCannedACL(objectAcl);\n        }\n\n        AccessControlList acl = exchange.getIn().getHeader(S3Constants.ACL, AccessControlList.class);\n        if (acl != null) {\n            // note: if cannedacl and acl are both specified the last one will\n            // be used. refer to\n            // PutObjectRequest#setAccessControlList for more details\n            initRequest.setAccessControlList(acl);\n        }\n        \n        if (getConfiguration().isUseAwsKMS()) {\n            SSEAwsKeyManagementParams keyManagementParams;\n            if (ObjectHelper.isNotEmpty(getConfiguration().getAwsKMSKeyId())) {\n                keyManagementParams = new SSEAwsKeyManagementParams(getConfiguration().getAwsKMSKeyId());\n            } else {\n                keyManagementParams = new SSEAwsKeyManagementParams();\n            }\n            initRequest.setSSEAwsKeyManagementParams(keyManagementParams);\n        }\n\n        LOG.trace(\"Initiating multipart upload [{}] from exchange [{}]...\", initRequest, exchange);\n\n        final InitiateMultipartUploadResult initResponse = getEndpoint().getS3Client().initiateMultipartUpload(initRequest);\n        final long contentLength = objectMetadata.getContentLength();\n        final List<PartETag> partETags = new ArrayList<>();\n        long partSize = getConfiguration().getPartSize();\n        CompleteMultipartUploadResult uploadResult = null;\n\n        long filePosition = 0;\n\n        try {\n            for (int part = 1; filePosition < contentLength; part++) {\n                partSize = Math.min(partSize, contentLength - filePosition);\n\n                UploadPartRequest uploadRequest = new UploadPartRequest().withBucketName(getConfiguration().getBucketName()).withKey(keyName)\n                    .withUploadId(initResponse.getUploadId()).withPartNumber(part).withFileOffset(filePosition).withFile(filePayload).withPartSize(partSize);\n\n                LOG.trace(\"Uploading part [{}] for {}\", part, keyName);\n                partETags.add(getEndpoint().getS3Client().uploadPart(uploadRequest).getPartETag());\n\n                filePosition += partSize;\n            }\n            CompleteMultipartUploadRequest compRequest = new CompleteMultipartUploadRequest(getConfiguration().getBucketName(), keyName, initResponse.getUploadId(), partETags);\n\n            uploadResult = getEndpoint().getS3Client().completeMultipartUpload(compRequest);\n\n        } catch (Exception e) {\n            getEndpoint().getS3Client().abortMultipartUpload(new AbortMultipartUploadRequest(getConfiguration().getBucketName(), keyName, initResponse.getUploadId()));\n            throw e;\n        }\n\n        Message message = getMessageForResponse(exchange);\n        message.setHeader(S3Constants.E_TAG, uploadResult.getETag());\n        if (uploadResult.getVersionId() != null) {\n            message.setHeader(S3Constants.VERSION_ID, uploadResult.getVersionId());\n        }\n\n        if (getConfiguration().isDeleteAfterWrite() && filePayload != null) {\n            FileUtil.deleteFile(filePayload);\n        }\n    }"
        ],
        [
            "CamelSWFWorkflowClient::describeWorkflowInstance(String,String)",
            "  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97 -\n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  ",
            "    public Map<String, Object> describeWorkflowInstance(String workflowId, String runId) {\n        DescribeWorkflowExecutionRequest describeRequest = new DescribeWorkflowExecutionRequest();\n        describeRequest.setDomain(configuration.getDomainName());\n        describeRequest.setExecution(new WorkflowExecution().withWorkflowId(workflowId).withRunId(runId));\n        WorkflowExecutionDetail executionDetail = endpoint.getSWClient().describeWorkflowExecution(describeRequest);\n        WorkflowExecutionInfo instanceMetadata = executionDetail.getExecutionInfo();\n\n        Map<String, Object> info = new HashMap<String, Object>();\n        info.put(\"closeStatus\", instanceMetadata.getCloseStatus());\n        info.put(\"closeTimestamp\", instanceMetadata.getCloseTimestamp());\n        info.put(\"executionStatus\", instanceMetadata.getExecutionStatus());\n        info.put(\"tagList\", instanceMetadata.getTagList());\n        info.put(\"executionDetail\", executionDetail);\n        return info;\n    }",
            "  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97 +\n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  ",
            "    public Map<String, Object> describeWorkflowInstance(String workflowId, String runId) {\n        DescribeWorkflowExecutionRequest describeRequest = new DescribeWorkflowExecutionRequest();\n        describeRequest.setDomain(configuration.getDomainName());\n        describeRequest.setExecution(new WorkflowExecution().withWorkflowId(workflowId).withRunId(runId));\n        WorkflowExecutionDetail executionDetail = endpoint.getSWClient().describeWorkflowExecution(describeRequest);\n        WorkflowExecutionInfo instanceMetadata = executionDetail.getExecutionInfo();\n\n        Map<String, Object> info = new HashMap<>();\n        info.put(\"closeStatus\", instanceMetadata.getCloseStatus());\n        info.put(\"closeTimestamp\", instanceMetadata.getCloseTimestamp());\n        info.put(\"executionStatus\", instanceMetadata.getExecutionStatus());\n        info.put(\"tagList\", instanceMetadata.getTagList());\n        info.put(\"executionDetail\", executionDetail);\n        return info;\n    }"
        ],
        [
            "UpdateItemCommandTest::execute()",
            "  50  \n  51  \n  52 -\n  53  \n  54  \n  55  \n  56 -\n  57  \n  58  \n  59  \n  60  \n  61  \n  62 -\n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  ",
            "    @Test\n    public void execute() {\n        Map<String, AttributeValue> key = new HashMap<String, AttributeValue>();\n        key.put(\"1\", new AttributeValue(\"Key_1\"));\n        exchange.getIn().setHeader(DdbConstants.KEY, key);\n\n        Map<String, AttributeValueUpdate> attributeMap = new HashMap<String, AttributeValueUpdate>();\n        AttributeValueUpdate attributeValue = new AttributeValueUpdate(\n                new AttributeValue(\"new value\"), AttributeAction.ADD);\n        attributeMap.put(\"name\", attributeValue);\n        exchange.getIn().setHeader(DdbConstants.UPDATE_VALUES, attributeMap);\n\n        Map<String, ExpectedAttributeValue> expectedAttributeValueMap = new HashMap<String, ExpectedAttributeValue>();\n        expectedAttributeValueMap\n                .put(\"name\", new ExpectedAttributeValue(new AttributeValue(\"expected value\")));\n        exchange.getIn().setHeader(DdbConstants.UPDATE_CONDITION, expectedAttributeValueMap);\n        exchange.getIn().setHeader(DdbConstants.RETURN_VALUES, \"ALL_OLD\");\n\n        command.execute();\n\n        assertEquals(\"DOMAIN1\", ddbClient.updateItemRequest.getTableName());\n        assertEquals(attributeMap, ddbClient.updateItemRequest.getAttributeUpdates());\n        assertEquals(key, ddbClient.updateItemRequest.getKey());\n        assertEquals(expectedAttributeValueMap, ddbClient.updateItemRequest.getExpected());\n        assertEquals(\"ALL_OLD\", ddbClient.updateItemRequest.getReturnValues());\n        assertEquals(new AttributeValue(\"attrValue\"),\n                exchange.getIn().getHeader(DdbConstants.ATTRIBUTES, Map.class).get(\n                        \"attrName\"));\n    }",
            "  50  \n  51  \n  52 +\n  53  \n  54  \n  55  \n  56 +\n  57  \n  58  \n  59  \n  60  \n  61  \n  62 +\n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  ",
            "    @Test\n    public void execute() {\n        Map<String, AttributeValue> key = new HashMap<>();\n        key.put(\"1\", new AttributeValue(\"Key_1\"));\n        exchange.getIn().setHeader(DdbConstants.KEY, key);\n\n        Map<String, AttributeValueUpdate> attributeMap = new HashMap<>();\n        AttributeValueUpdate attributeValue = new AttributeValueUpdate(\n                new AttributeValue(\"new value\"), AttributeAction.ADD);\n        attributeMap.put(\"name\", attributeValue);\n        exchange.getIn().setHeader(DdbConstants.UPDATE_VALUES, attributeMap);\n\n        Map<String, ExpectedAttributeValue> expectedAttributeValueMap = new HashMap<>();\n        expectedAttributeValueMap\n                .put(\"name\", new ExpectedAttributeValue(new AttributeValue(\"expected value\")));\n        exchange.getIn().setHeader(DdbConstants.UPDATE_CONDITION, expectedAttributeValueMap);\n        exchange.getIn().setHeader(DdbConstants.RETURN_VALUES, \"ALL_OLD\");\n\n        command.execute();\n\n        assertEquals(\"DOMAIN1\", ddbClient.updateItemRequest.getTableName());\n        assertEquals(attributeMap, ddbClient.updateItemRequest.getAttributeUpdates());\n        assertEquals(key, ddbClient.updateItemRequest.getKey());\n        assertEquals(expectedAttributeValueMap, ddbClient.updateItemRequest.getExpected());\n        assertEquals(\"ALL_OLD\", ddbClient.updateItemRequest.getReturnValues());\n        assertEquals(new AttributeValue(\"attrValue\"),\n                exchange.getIn().getHeader(DdbConstants.ATTRIBUTES, Map.class).get(\n                        \"attrName\"));\n    }"
        ],
        [
            "AmazonDDBClientMock::query(QueryRequest)",
            " 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200 -\n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  ",
            "    @SuppressWarnings(\"unchecked\")\n    @Override\n    public QueryResult query(QueryRequest queryRequest) {\n        this.queryRequest = queryRequest;\n        ConsumedCapacity consumed = new ConsumedCapacity();\n        consumed.setCapacityUnits(1.0);\n        Map<String, AttributeValue> lastEvaluatedKey = new HashMap<String, AttributeValue>();\n        lastEvaluatedKey.put(\"1\", new AttributeValue(\"LAST_KEY\"));\n        return new QueryResult()\n                .withConsumedCapacity(consumed)\n                .withCount(1)\n                .withItems(getAttributes())\n                .withLastEvaluatedKey(lastEvaluatedKey);\n    }",
            " 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200 +\n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  ",
            "    @SuppressWarnings(\"unchecked\")\n    @Override\n    public QueryResult query(QueryRequest queryRequest) {\n        this.queryRequest = queryRequest;\n        ConsumedCapacity consumed = new ConsumedCapacity();\n        consumed.setCapacityUnits(1.0);\n        Map<String, AttributeValue> lastEvaluatedKey = new HashMap<>();\n        lastEvaluatedKey.put(\"1\", new AttributeValue(\"LAST_KEY\"));\n        return new QueryResult()\n                .withConsumedCapacity(consumed)\n                .withCount(1)\n                .withItems(getAttributes())\n                .withLastEvaluatedKey(lastEvaluatedKey);\n    }"
        ],
        [
            "AhcProducerTwoParametersWithSameKeyTest::createRouteBuilder()",
            "  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82 -\n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  ",
            "    @Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                from(\"jetty://http://localhost:{{port}}/myapp\").process(new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        String from = exchange.getIn().getHeader(\"from\", String.class);\n                        assertEquals(\"me\", from);\n\n                        List<?> to = exchange.getIn().getHeader(\"to\", List.class);\n                        assertNotNull(to);\n                        assertEquals(2, to.size());\n                        assertEquals(\"foo\", to.get(0));\n                        assertEquals(\"bar\", to.get(1));\n\n                        // response\n                        exchange.getOut().setBody(\"OK\");\n                        // use multiple values for the foo header in the reply\n                        List<Integer> list = new ArrayList<Integer>();\n                        list.add(123);\n                        list.add(456);\n                        exchange.getOut().setHeader(\"foo\", list);\n                        exchange.getOut().setHeader(\"bar\", \"yes\");\n                    }\n                });\n            }\n        };\n    }",
            "  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82 +\n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  ",
            "    @Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                from(\"jetty://http://localhost:{{port}}/myapp\").process(new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        String from = exchange.getIn().getHeader(\"from\", String.class);\n                        assertEquals(\"me\", from);\n\n                        List<?> to = exchange.getIn().getHeader(\"to\", List.class);\n                        assertNotNull(to);\n                        assertEquals(2, to.size());\n                        assertEquals(\"foo\", to.get(0));\n                        assertEquals(\"bar\", to.get(1));\n\n                        // response\n                        exchange.getOut().setBody(\"OK\");\n                        // use multiple values for the foo header in the reply\n                        List<Integer> list = new ArrayList<>();\n                        list.add(123);\n                        list.add(456);\n                        exchange.getOut().setHeader(\"foo\", list);\n                        exchange.getOut().setHeader(\"bar\", \"yes\");\n                    }\n                });\n            }\n        };\n    }"
        ],
        [
            "CwProducer::setDimension(MetricDatum,Exchange)",
            "  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86 -\n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  ",
            "    private void setDimension(MetricDatum metricDatum, Exchange exchange) {\n        String name = exchange.getIn().getHeader(CwConstants.METRIC_DIMENSION_NAME, String.class);\n        String value = exchange.getIn().getHeader(CwConstants.METRIC_DIMENSION_VALUE, String.class);\n        if (name != null && value != null) {\n            metricDatum.withDimensions(new Dimension().withName(name).withValue(value));\n        } else {\n            Map<String, String> dimensions = exchange.getIn().getHeader(CwConstants.METRIC_DIMENSIONS, Map.class);\n            if (dimensions != null) {\n                Collection<Dimension> dimensionCollection = new ArrayList<Dimension>();\n                for (Map.Entry<String, String> dimensionEntry : dimensions.entrySet()) {\n                    Dimension dimension = new Dimension().withName(dimensionEntry.getKey()).withValue(dimensionEntry.getValue());\n                    dimensionCollection.add(dimension);\n                }\n                metricDatum.withDimensions(dimensionCollection);\n            }\n        }\n    }",
            "  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86 +\n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  ",
            "    private void setDimension(MetricDatum metricDatum, Exchange exchange) {\n        String name = exchange.getIn().getHeader(CwConstants.METRIC_DIMENSION_NAME, String.class);\n        String value = exchange.getIn().getHeader(CwConstants.METRIC_DIMENSION_VALUE, String.class);\n        if (name != null && value != null) {\n            metricDatum.withDimensions(new Dimension().withName(name).withValue(value));\n        } else {\n            Map<String, String> dimensions = exchange.getIn().getHeader(CwConstants.METRIC_DIMENSIONS, Map.class);\n            if (dimensions != null) {\n                Collection<Dimension> dimensionCollection = new ArrayList<>();\n                for (Map.Entry<String, String> dimensionEntry : dimensions.entrySet()) {\n                    Dimension dimension = new Dimension().withName(dimensionEntry.getKey()).withValue(dimensionEntry.getValue());\n                    dimensionCollection.add(dimension);\n                }\n                metricDatum.withDimensions(dimensionCollection);\n            }\n        }\n    }"
        ],
        [
            "AvroDataFormat::marshal(Exchange,Object,OutputStream)",
            " 125  \n 126  \n 127  \n 128  \n 129 -\n 130  \n 131  \n 132  \n 133  ",
            "    public void marshal(Exchange exchange, Object graph, OutputStream outputStream) throws Exception {\n        // the schema should be from the graph class name\n        Schema useSchema = actualSchema != null ? actualSchema : loadSchema(graph.getClass().getName());\n\n        DatumWriter<Object> datum = new SpecificDatumWriter<Object>(useSchema);\n        Encoder encoder = EncoderFactory.get().binaryEncoder(outputStream, null);\n        datum.write(graph, encoder);\n        encoder.flush();\n    }",
            " 125  \n 126  \n 127  \n 128  \n 129 +\n 130  \n 131  \n 132  \n 133  ",
            "    public void marshal(Exchange exchange, Object graph, OutputStream outputStream) throws Exception {\n        // the schema should be from the graph class name\n        Schema useSchema = actualSchema != null ? actualSchema : loadSchema(graph.getClass().getName());\n\n        DatumWriter<Object> datum = new SpecificDatumWriter<>(useSchema);\n        Encoder encoder = EncoderFactory.get().binaryEncoder(outputStream, null);\n        datum.write(graph, encoder);\n        encoder.flush();\n    }"
        ],
        [
            "ApnsConsumer::getInactiveDevices()",
            "  61  \n  62  \n  63  \n  64  \n  65  \n  66 -\n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  ",
            "    private List<InactiveDevice> getInactiveDevices() {\n        ApnsEndpoint ae = getEndpoint();\n\n        Map<String, Date> inactiveDeviceMap = ae.getApnsService().getInactiveDevices();\n\n        List<InactiveDevice> inactiveDeviceList = new ArrayList<InactiveDevice>();\n        for (Entry<String, Date> inactiveDeviceEntry : inactiveDeviceMap.entrySet()) {\n            String deviceToken = inactiveDeviceEntry.getKey();\n            Date date = inactiveDeviceEntry.getValue();\n\n            InactiveDevice inactiveDevice = new InactiveDevice(deviceToken, date);\n            inactiveDeviceList.add(inactiveDevice);\n        }\n\n        return inactiveDeviceList;\n    }",
            "  61  \n  62  \n  63  \n  64  \n  65  \n  66 +\n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  ",
            "    private List<InactiveDevice> getInactiveDevices() {\n        ApnsEndpoint ae = getEndpoint();\n\n        Map<String, Date> inactiveDeviceMap = ae.getApnsService().getInactiveDevices();\n\n        List<InactiveDevice> inactiveDeviceList = new ArrayList<>();\n        for (Entry<String, Date> inactiveDeviceEntry : inactiveDeviceMap.entrySet()) {\n            String deviceToken = inactiveDeviceEntry.getKey();\n            Date date = inactiveDeviceEntry.getValue();\n\n            InactiveDevice inactiveDevice = new InactiveDevice(deviceToken, date);\n            inactiveDeviceList.add(inactiveDevice);\n        }\n\n        return inactiveDeviceList;\n    }"
        ],
        [
            "QueryCommandTest::execute()",
            "  52  \n  53  \n  54  \n  55 -\n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65 -\n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76 -\n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  ",
            "    @Test\n    public void execute() {\n\n        Map<String, AttributeValue> startKey = new HashMap<String, AttributeValue>();\n        startKey.put(\"1\", new AttributeValue(\"startKey\"));\n\n        List<String> attributeNames = Arrays.asList(\"attrNameOne\", \"attrNameTwo\");\n        exchange.getIn().setHeader(DdbConstants.ATTRIBUTE_NAMES, attributeNames);\n        exchange.getIn().setHeader(DdbConstants.CONSISTENT_READ, true);\n        exchange.getIn().setHeader(DdbConstants.START_KEY, startKey);\n        exchange.getIn().setHeader(DdbConstants.LIMIT, 10);\n        exchange.getIn().setHeader(DdbConstants.SCAN_INDEX_FORWARD, true);\n        \n        Map<String, Condition> keyConditions = new HashMap<String, Condition>();\n        Condition condition = new Condition()\n            .withComparisonOperator(ComparisonOperator.GT.toString())\n            .withAttributeValueList(new AttributeValue().withN(\"1985\"));\n        \n        keyConditions.put(\"1\", condition);\n        \n        exchange.getIn().setHeader(DdbConstants.KEY_CONDITIONS, keyConditions);\n\n        command.execute();\n\n        Map<String, AttributeValue> mapAssert = new HashMap<String, AttributeValue>();\n        mapAssert.put(\"1\", new AttributeValue(\"LAST_KEY\"));\n        ConsumedCapacity consumed = (ConsumedCapacity) exchange.getIn().getHeader(DdbConstants.CONSUMED_CAPACITY);\n        assertEquals(Integer.valueOf(1), exchange.getIn().getHeader(DdbConstants.COUNT, Integer.class));\n        assertEquals(Double.valueOf(1.0), consumed.getCapacityUnits());\n        assertEquals(mapAssert, exchange.getIn().getHeader(DdbConstants.LAST_EVALUATED_KEY, Map.class));\n        assertEquals(keyConditions, exchange.getIn().getHeader(DdbConstants.KEY_CONDITIONS, Map.class));\n\n        Map<?, ?> items = (Map<?, ?>) exchange.getIn().getHeader(DdbConstants.ITEMS, List.class).get(0);\n        assertEquals(new AttributeValue(\"attrValue\"), items.get(\"attrName\"));\n    }",
            "  52  \n  53  \n  54  \n  55 +\n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65 +\n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76 +\n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  ",
            "    @Test\n    public void execute() {\n\n        Map<String, AttributeValue> startKey = new HashMap<>();\n        startKey.put(\"1\", new AttributeValue(\"startKey\"));\n\n        List<String> attributeNames = Arrays.asList(\"attrNameOne\", \"attrNameTwo\");\n        exchange.getIn().setHeader(DdbConstants.ATTRIBUTE_NAMES, attributeNames);\n        exchange.getIn().setHeader(DdbConstants.CONSISTENT_READ, true);\n        exchange.getIn().setHeader(DdbConstants.START_KEY, startKey);\n        exchange.getIn().setHeader(DdbConstants.LIMIT, 10);\n        exchange.getIn().setHeader(DdbConstants.SCAN_INDEX_FORWARD, true);\n        \n        Map<String, Condition> keyConditions = new HashMap<>();\n        Condition condition = new Condition()\n            .withComparisonOperator(ComparisonOperator.GT.toString())\n            .withAttributeValueList(new AttributeValue().withN(\"1985\"));\n        \n        keyConditions.put(\"1\", condition);\n        \n        exchange.getIn().setHeader(DdbConstants.KEY_CONDITIONS, keyConditions);\n\n        command.execute();\n\n        Map<String, AttributeValue> mapAssert = new HashMap<>();\n        mapAssert.put(\"1\", new AttributeValue(\"LAST_KEY\"));\n        ConsumedCapacity consumed = (ConsumedCapacity) exchange.getIn().getHeader(DdbConstants.CONSUMED_CAPACITY);\n        assertEquals(Integer.valueOf(1), exchange.getIn().getHeader(DdbConstants.COUNT, Integer.class));\n        assertEquals(Double.valueOf(1.0), consumed.getCapacityUnits());\n        assertEquals(mapAssert, exchange.getIn().getHeader(DdbConstants.LAST_EVALUATED_KEY, Map.class));\n        assertEquals(keyConditions, exchange.getIn().getHeader(DdbConstants.KEY_CONDITIONS, Map.class));\n\n        Map<?, ?> items = (Map<?, ?>) exchange.getIn().getHeader(DdbConstants.ITEMS, List.class).get(0);\n        assertEquals(new AttributeValue(\"attrValue\"), items.get(\"attrName\"));\n    }"
        ],
        [
            "SqsEndpointTest::createQueueShouldCreateFifoQueueWithContentBasedDeduplication()",
            "  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86 -\n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  ",
            "    @Test\n    public void createQueueShouldCreateFifoQueueWithContentBasedDeduplication() {\n        config.setQueueName(\"test-queue.fifo\");\n        config.setMessageDeduplicationIdStrategy(\"useContentBasedDeduplication\");\n\n        CreateQueueRequest expectedCreateQueueRequest = new CreateQueueRequest(\"test-queue.fifo\")\n                .addAttributesEntry(QueueAttributeName.FifoQueue.name(), \"true\")\n                .addAttributesEntry(QueueAttributeName.ContentBasedDeduplication.name(), \"true\");\n        Mockito.when(amazonSQSClient.createQueue(Mockito.any(CreateQueueRequest.class)))\n                .thenReturn(new CreateQueueResult()\n                                .withQueueUrl(\"https://sqs.us-east-1.amazonaws.com/111222333/test-queue.fifo\"));\n\n        endpoint.createQueue(amazonSQSClient);\n\n        Mockito.verify(amazonSQSClient).createQueue(expectedCreateQueueRequest);\n        assertEquals(\"https://sqs.us-east-1.amazonaws.com/111222333/test-queue.fifo\", endpoint.getQueueUrl());\n    }",
            "  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87 +\n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  ",
            "    @Test\n    public void createQueueShouldCreateFifoQueueWithContentBasedDeduplication() {\n        config.setQueueName(\"test-queue.fifo\");\n        config.setMessageDeduplicationIdStrategy(\"useContentBasedDeduplication\");\n\n        CreateQueueRequest expectedCreateQueueRequest = new CreateQueueRequest(\"test-queue.fifo\")\n                .addAttributesEntry(QueueAttributeName.FifoQueue.name(), \"true\")\n                .addAttributesEntry(QueueAttributeName.ContentBasedDeduplication.name(), \"true\");\n        Mockito.when(amazonSQSClient.createQueue(ArgumentMatchers.any(CreateQueueRequest.class)))\n                .thenReturn(new CreateQueueResult()\n                                .withQueueUrl(\"https://sqs.us-east-1.amazonaws.com/111222333/test-queue.fifo\"));\n\n        endpoint.createQueue(amazonSQSClient);\n\n        Mockito.verify(amazonSQSClient).createQueue(expectedCreateQueueRequest);\n        assertEquals(\"https://sqs.us-east-1.amazonaws.com/111222333/test-queue.fifo\", endpoint.getQueueUrl());\n    }"
        ],
        [
            "AmazonEC2ClientMock::startInstances(StartInstancesRequest)",
            " 118  \n 119  \n 120  \n 121  \n 122 -\n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  ",
            "    @Override\n    public StartInstancesResult startInstances(StartInstancesRequest startInstancesRequest) {\n        StartInstancesResult result = new StartInstancesResult();\n        if (startInstancesRequest.getInstanceIds().get(0).equals(\"test-1\")) {\n            Collection<InstanceStateChange> coll = new ArrayList<InstanceStateChange>();\n            InstanceStateChange sc = new InstanceStateChange();\n            InstanceState previousState = new InstanceState();\n            previousState.setCode(80);\n            previousState.setName(InstanceStateName.Stopped);\n            InstanceState newState = new InstanceState();\n            newState.setCode(16);\n            newState.setName(InstanceStateName.Running);\n            sc.setPreviousState(previousState);\n            sc.setCurrentState(newState);\n            sc.setInstanceId(\"test-1\");\n            coll.add(sc);\n            result.setStartingInstances(coll);\n        } else {\n            throw new AmazonServiceException(\"The image-id doesn't exists\");\n        }\n        return result;       \n    }",
            " 118  \n 119  \n 120  \n 121  \n 122 +\n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  ",
            "    @Override\n    public StartInstancesResult startInstances(StartInstancesRequest startInstancesRequest) {\n        StartInstancesResult result = new StartInstancesResult();\n        if (startInstancesRequest.getInstanceIds().get(0).equals(\"test-1\")) {\n            Collection<InstanceStateChange> coll = new ArrayList<>();\n            InstanceStateChange sc = new InstanceStateChange();\n            InstanceState previousState = new InstanceState();\n            previousState.setCode(80);\n            previousState.setName(InstanceStateName.Stopped);\n            InstanceState newState = new InstanceState();\n            newState.setCode(16);\n            newState.setName(InstanceStateName.Running);\n            sc.setPreviousState(previousState);\n            sc.setCurrentState(newState);\n            sc.setInstanceId(\"test-1\");\n            coll.add(sc);\n            result.setStartingInstances(coll);\n        } else {\n            throw new AmazonServiceException(\"The image-id doesn't exists\");\n        }\n        return result;       \n    }"
        ],
        [
            "AmazonDDBClientMock::getAttributes()",
            " 136  \n 137 -\n 138  \n 139  \n 140  ",
            "    private Map<String, AttributeValue> getAttributes() {\n        Map<String, AttributeValue> attributes = new HashMap<String, AttributeValue>();\n        attributes.put(\"attrName\", new AttributeValue(\"attrValue\"));\n        return attributes;\n    }",
            " 136  \n 137 +\n 138  \n 139  \n 140  ",
            "    private Map<String, AttributeValue> getAttributes() {\n        Map<String, AttributeValue> attributes = new HashMap<>();\n        attributes.put(\"attrName\", new AttributeValue(\"attrValue\"));\n        return attributes;\n    }"
        ],
        [
            "DeleteAttributesCommandTest::executeWithoutItemName()",
            "  68  \n  69  \n  70 -\n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  ",
            "    @Test(expected = IllegalArgumentException.class)\n    public void executeWithoutItemName() {\n        List<Attribute> attributes = new ArrayList<Attribute>();\n        attributes.add(new Attribute(\"NAME1\", \"VALUE1\"));\n        exchange.getIn().setHeader(SdbConstants.ATTRIBUTES, attributes);\n        UpdateCondition condition = new UpdateCondition(\"Key1\", \"Value1\", true);\n        exchange.getIn().setHeader(SdbConstants.UPDATE_CONDITION, condition);\n        \n        command.execute();\n    }",
            "  68  \n  69  \n  70 +\n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  ",
            "    @Test(expected = IllegalArgumentException.class)\n    public void executeWithoutItemName() {\n        List<Attribute> attributes = new ArrayList<>();\n        attributes.add(new Attribute(\"NAME1\", \"VALUE1\"));\n        exchange.getIn().setHeader(SdbConstants.ATTRIBUTES, attributes);\n        UpdateCondition condition = new UpdateCondition(\"Key1\", \"Value1\", true);\n        exchange.getIn().setHeader(SdbConstants.UPDATE_CONDITION, condition);\n        \n        command.execute();\n    }"
        ],
        [
            "SqsProducerTest::isAttributeMessageStringHeaderOnTheRequest()",
            " 161  \n 162  \n 163 -\n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  ",
            "    @Test\n    public void isAttributeMessageStringHeaderOnTheRequest() throws Exception {\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(SAMPLE_MESSAGE_HEADER_NAME_1, SAMPLE_MESSAGE_HEADER_VALUE_1);\n        when(inMessage.getHeaders()).thenReturn(headers);\n        underTest.process(exchange);\n        \n        ArgumentCaptor<SendMessageRequest> capture = ArgumentCaptor.forClass(SendMessageRequest.class);\n        verify(amazonSQSClient).sendMessage(capture.capture());\n        \n        assertEquals(SAMPLE_MESSAGE_HEADER_VALUE_1, capture.getValue().getMessageAttributes().get(SAMPLE_MESSAGE_HEADER_NAME_1).getStringValue());\n        assertNull(capture.getValue().getMessageAttributes().get(SAMPLE_MESSAGE_HEADER_NAME_1).getBinaryValue());\n    }",
            " 161  \n 162  \n 163 +\n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  ",
            "    @Test\n    public void isAttributeMessageStringHeaderOnTheRequest() throws Exception {\n        Map<String, Object> headers = new HashMap<>();\n        headers.put(SAMPLE_MESSAGE_HEADER_NAME_1, SAMPLE_MESSAGE_HEADER_VALUE_1);\n        when(inMessage.getHeaders()).thenReturn(headers);\n        underTest.process(exchange);\n        \n        ArgumentCaptor<SendMessageRequest> capture = ArgumentCaptor.forClass(SendMessageRequest.class);\n        verify(amazonSQSClient).sendMessage(capture.capture());\n        \n        assertEquals(SAMPLE_MESSAGE_HEADER_VALUE_1, capture.getValue().getMessageAttributes().get(SAMPLE_MESSAGE_HEADER_NAME_1).getStringValue());\n        assertNull(capture.getValue().getMessageAttributes().get(SAMPLE_MESSAGE_HEADER_NAME_1).getBinaryValue());\n    }"
        ],
        [
            "AmazonEC2ClientMock::describeInstances(DescribeInstancesRequest)",
            " 187  \n 188  \n 189  \n 190  \n 191 -\n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212 -\n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  ",
            "    @Override\n    public DescribeInstancesResult describeInstances(DescribeInstancesRequest describeInstancesRequest) {\n        DescribeInstancesResult result = new DescribeInstancesResult();\n        if (describeInstancesRequest.getInstanceIds().isEmpty()) {\n            Collection<Reservation> list = new ArrayList<Reservation>();\n            Reservation res = new Reservation();\n            res.setOwnerId(\"1\");\n            res.setRequesterId(\"user-test\");\n            res.setReservationId(\"res-1\");\n            Collection<Instance> instances = new ArrayList<>();\n            Instance ins = new Instance();\n            ins.setImageId(\"id-1\");\n            ins.setInstanceType(InstanceType.T2Micro);\n            ins.setInstanceId(\"instance-1\");\n            instances.add(ins);\n            Instance ins1 = new Instance();\n            ins1.setImageId(\"id-2\");\n            ins1.setInstanceType(InstanceType.T2Micro);\n            ins1.setInstanceId(\"instance-2\");\n            instances.add(ins1);\n            res.setInstances(instances);\n            list.add(res);\n            result.setReservations(list); \n        } else {\n            if (describeInstancesRequest.getInstanceIds().contains(\"instance-1\")) {\n                Collection<Reservation> list = new ArrayList<Reservation>();\n                Reservation res = new Reservation();\n                res.setOwnerId(\"1\");\n                res.setRequesterId(\"user-test\");\n                res.setReservationId(\"res-1\");\n                Collection<Instance> instances = new ArrayList<>();\n                Instance ins = new Instance();\n                ins.setImageId(\"id-1\");\n                ins.setInstanceType(InstanceType.T2Micro);\n                ins.setInstanceId(\"instance-1\");\n                instances.add(ins);\n                res.setInstances(instances);\n                list.add(res);\n                result.setReservations(list); \n            }\n        }\n        return result;\n    }",
            " 187  \n 188  \n 189  \n 190  \n 191 +\n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212 +\n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  ",
            "    @Override\n    public DescribeInstancesResult describeInstances(DescribeInstancesRequest describeInstancesRequest) {\n        DescribeInstancesResult result = new DescribeInstancesResult();\n        if (describeInstancesRequest.getInstanceIds().isEmpty()) {\n            Collection<Reservation> list = new ArrayList<>();\n            Reservation res = new Reservation();\n            res.setOwnerId(\"1\");\n            res.setRequesterId(\"user-test\");\n            res.setReservationId(\"res-1\");\n            Collection<Instance> instances = new ArrayList<>();\n            Instance ins = new Instance();\n            ins.setImageId(\"id-1\");\n            ins.setInstanceType(InstanceType.T2Micro);\n            ins.setInstanceId(\"instance-1\");\n            instances.add(ins);\n            Instance ins1 = new Instance();\n            ins1.setImageId(\"id-2\");\n            ins1.setInstanceType(InstanceType.T2Micro);\n            ins1.setInstanceId(\"instance-2\");\n            instances.add(ins1);\n            res.setInstances(instances);\n            list.add(res);\n            result.setReservations(list); \n        } else {\n            if (describeInstancesRequest.getInstanceIds().contains(\"instance-1\")) {\n                Collection<Reservation> list = new ArrayList<>();\n                Reservation res = new Reservation();\n                res.setOwnerId(\"1\");\n                res.setRequesterId(\"user-test\");\n                res.setReservationId(\"res-1\");\n                Collection<Instance> instances = new ArrayList<>();\n                Instance ins = new Instance();\n                ins.setImageId(\"id-1\");\n                ins.setInstanceType(InstanceType.T2Micro);\n                ins.setInstanceId(\"instance-1\");\n                instances.add(ins);\n                res.setInstances(instances);\n                list.add(res);\n                result.setReservations(list); \n            }\n        }\n        return result;\n    }"
        ],
        [
            "BlobServiceProducer::uploadBlobBlocks(Exchange)",
            " 155  \n 156  \n 157  \n 158  \n 159  \n 160 -\n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173 -\n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  ",
            "    private void uploadBlobBlocks(Exchange exchange) throws Exception {\n        Object object = exchange.getIn().getMandatoryBody();\n        \n        List<BlobBlock> blobBlocks = null;\n        if (object instanceof List) {\n            blobBlocks = (List<BlobBlock>)blobBlocks;\n        } else if (object instanceof BlobBlock) {\n            blobBlocks = Collections.singletonList((BlobBlock)object);\n        } \n        if (blobBlocks == null || blobBlocks.isEmpty()) {\n            throw new IllegalArgumentException(\"Illegal storageBlocks payload\");\n        }\n        \n        CloudBlockBlob client = BlobServiceUtil.createBlockBlobClient(getConfiguration());\n        configureCloudBlobForWrite(client);\n        BlobServiceRequestOptions opts = BlobServiceUtil.getRequestOptions(exchange);\n        \n        LOG.trace(\"Putting a blob [{}] from blocks from exchange [{}]...\", getConfiguration().getBlobName(), exchange);\n        List<BlockEntry> blockEntries = new LinkedList<BlockEntry>();\n        for (BlobBlock blobBlock : blobBlocks) {\n            blockEntries.add(blobBlock.getBlockEntry());\n            client.uploadBlock(blobBlock.getBlockEntry().getId(), blobBlock.getBlockStream(), -1, \n                               opts.getAccessCond(), opts.getRequestOpts(), opts.getOpContext());\n        }\n        Boolean commitBlockListLater = exchange.getIn().getHeader(BlobServiceConstants.COMMIT_BLOCK_LIST_LATER, \n                                                                  Boolean.class);\n        if (Boolean.TRUE != commitBlockListLater) {\n            client.commitBlockList(blockEntries, \n                                   opts.getAccessCond(), opts.getRequestOpts(), opts.getOpContext());\n        }\n    }",
            " 155  \n 156  \n 157  \n 158  \n 159  \n 160 +\n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173 +\n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  ",
            "    private void uploadBlobBlocks(Exchange exchange) throws Exception {\n        Object object = exchange.getIn().getMandatoryBody();\n        \n        List<BlobBlock> blobBlocks = null;\n        if (object instanceof List) {\n            blobBlocks = blobBlocks;\n        } else if (object instanceof BlobBlock) {\n            blobBlocks = Collections.singletonList((BlobBlock)object);\n        } \n        if (blobBlocks == null || blobBlocks.isEmpty()) {\n            throw new IllegalArgumentException(\"Illegal storageBlocks payload\");\n        }\n        \n        CloudBlockBlob client = BlobServiceUtil.createBlockBlobClient(getConfiguration());\n        configureCloudBlobForWrite(client);\n        BlobServiceRequestOptions opts = BlobServiceUtil.getRequestOptions(exchange);\n        \n        LOG.trace(\"Putting a blob [{}] from blocks from exchange [{}]...\", getConfiguration().getBlobName(), exchange);\n        List<BlockEntry> blockEntries = new LinkedList<>();\n        for (BlobBlock blobBlock : blobBlocks) {\n            blockEntries.add(blobBlock.getBlockEntry());\n            client.uploadBlock(blobBlock.getBlockEntry().getId(), blobBlock.getBlockStream(), -1, \n                               opts.getAccessCond(), opts.getRequestOpts(), opts.getOpContext());\n        }\n        Boolean commitBlockListLater = exchange.getIn().getHeader(BlobServiceConstants.COMMIT_BLOCK_LIST_LATER, \n                                                                  Boolean.class);\n        if (Boolean.TRUE != commitBlockListLater) {\n            client.commitBlockList(blockEntries, \n                                   opts.getAccessCond(), opts.getRequestOpts(), opts.getOpContext());\n        }\n    }"
        ],
        [
            "SqsProducerTest::isAllAttributeMessagesOnTheRequest()",
            " 189  \n 190  \n 191 -\n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  ",
            "    @Test\n    public void isAllAttributeMessagesOnTheRequest() throws Exception {\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(SAMPLE_MESSAGE_HEADER_NAME_1, SAMPLE_MESSAGE_HEADER_VALUE_1);\n        headers.put(SAMPLE_MESSAGE_HEADER_NAME_2, SAMPLE_MESSAGE_HEADER_VALUE_2);\n        headers.put(SAMPLE_MESSAGE_HEADER_NAME_3, SAMPLE_MESSAGE_HEADER_VALUE_3);\n        headers.put(SAMPLE_MESSAGE_HEADER_NAME_4, SAMPLE_MESSAGE_HEADER_VALUE_4);\n        when(inMessage.getHeaders()).thenReturn(headers);\n        underTest.process(exchange);\n        \n        ArgumentCaptor<SendMessageRequest> capture = ArgumentCaptor.forClass(SendMessageRequest.class);\n        verify(amazonSQSClient).sendMessage(capture.capture());\n        \n        assertEquals(SAMPLE_MESSAGE_HEADER_VALUE_1, capture.getValue().getMessageAttributes().get(SAMPLE_MESSAGE_HEADER_NAME_1).getStringValue());\n        assertEquals(SAMPLE_MESSAGE_HEADER_VALUE_2, capture.getValue().getMessageAttributes().get(SAMPLE_MESSAGE_HEADER_NAME_2).getBinaryValue());\n        assertEquals(SAMPLE_MESSAGE_HEADER_VALUE_3, capture.getValue().getMessageAttributes().get(SAMPLE_MESSAGE_HEADER_NAME_3).getStringValue());\n        assertEquals(3, capture.getValue().getMessageAttributes().size());\n    }",
            " 189  \n 190  \n 191 +\n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  ",
            "    @Test\n    public void isAllAttributeMessagesOnTheRequest() throws Exception {\n        Map<String, Object> headers = new HashMap<>();\n        headers.put(SAMPLE_MESSAGE_HEADER_NAME_1, SAMPLE_MESSAGE_HEADER_VALUE_1);\n        headers.put(SAMPLE_MESSAGE_HEADER_NAME_2, SAMPLE_MESSAGE_HEADER_VALUE_2);\n        headers.put(SAMPLE_MESSAGE_HEADER_NAME_3, SAMPLE_MESSAGE_HEADER_VALUE_3);\n        headers.put(SAMPLE_MESSAGE_HEADER_NAME_4, SAMPLE_MESSAGE_HEADER_VALUE_4);\n        when(inMessage.getHeaders()).thenReturn(headers);\n        underTest.process(exchange);\n        \n        ArgumentCaptor<SendMessageRequest> capture = ArgumentCaptor.forClass(SendMessageRequest.class);\n        verify(amazonSQSClient).sendMessage(capture.capture());\n        \n        assertEquals(SAMPLE_MESSAGE_HEADER_VALUE_1, capture.getValue().getMessageAttributes().get(SAMPLE_MESSAGE_HEADER_NAME_1).getStringValue());\n        assertEquals(SAMPLE_MESSAGE_HEADER_VALUE_2, capture.getValue().getMessageAttributes().get(SAMPLE_MESSAGE_HEADER_NAME_2).getBinaryValue());\n        assertEquals(SAMPLE_MESSAGE_HEADER_VALUE_3, capture.getValue().getMessageAttributes().get(SAMPLE_MESSAGE_HEADER_NAME_3).getStringValue());\n        assertEquals(3, capture.getValue().getMessageAttributes().size());\n    }"
        ],
        [
            "CamelActivityImplementationFactory::getActivityTypesToRegister()",
            "  38  \n  39  \n  40 -\n  41  \n  42  \n  43  \n  44  \n  45  \n  46  ",
            "    @Override\n    public Iterable<ActivityType> getActivityTypesToRegister() {\n        ArrayList<ActivityType> activityTypes = new ArrayList<ActivityType>(1);\n        ActivityType activityType = new ActivityType();\n        activityType.setName(configuration.getEventName());\n        activityType.setVersion(configuration.getVersion());\n        activityTypes.add(activityType);\n        return activityTypes;\n    }",
            "  38  \n  39  \n  40 +\n  41  \n  42  \n  43  \n  44  \n  45  \n  46  ",
            "    @Override\n    public Iterable<ActivityType> getActivityTypesToRegister() {\n        ArrayList<ActivityType> activityTypes = new ArrayList<>(1);\n        ActivityType activityType = new ActivityType();\n        activityType.setName(configuration.getEventName());\n        activityType.setVersion(configuration.getVersion());\n        activityTypes.add(activityType);\n        return activityTypes;\n    }"
        ],
        [
            "ApnsUtils::getAlgorithm()",
            "  79  \n  80 -\n  81 -\n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  ",
            "    public static String getAlgorithm() {\n        List<String> keys = new LinkedList<String>();\n        List<String> trusts = new LinkedList<String>();\n        for (Provider p : Security.getProviders()) {\n            for (Service s : p.getServices()) {\n                if (\"KeyManagerFactory\".equals(s.getType())\n                    && s.getAlgorithm().endsWith(\"509\")) {\n                    keys.add(s.getAlgorithm());\n                } else if (\"TrustManagerFactory\".equals(s.getType())\n                    && s.getAlgorithm().endsWith(\"509\")) {\n                    trusts.add(s.getAlgorithm());\n                }\n            }\n        }\n        keys.retainAll(trusts);\n        return keys.get(0);\n    }",
            "  79  \n  80 +\n  81 +\n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  ",
            "    public static String getAlgorithm() {\n        List<String> keys = new LinkedList<>();\n        List<String> trusts = new LinkedList<>();\n        for (Provider p : Security.getProviders()) {\n            for (Service s : p.getServices()) {\n                if (\"KeyManagerFactory\".equals(s.getType())\n                    && s.getAlgorithm().endsWith(\"509\")) {\n                    keys.add(s.getAlgorithm());\n                } else if (\"TrustManagerFactory\".equals(s.getType())\n                    && s.getAlgorithm().endsWith(\"509\")) {\n                    trusts.add(s.getAlgorithm());\n                }\n            }\n        }\n        keys.retainAll(trusts);\n        return keys.get(0);\n    }"
        ],
        [
            "AmazonLambdaClientMock::listFunctions()",
            " 246  \n 247  \n 248  \n 249  \n 250 -\n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  ",
            "    @Override\n    public ListFunctionsResult listFunctions() {\n\n        ListFunctionsResult result = new ListFunctionsResult();\n        Collection<FunctionConfiguration> listFunctions = new ArrayList<FunctionConfiguration>();\n        FunctionConfiguration configuration = new FunctionConfiguration();\n        configuration.setFunctionName(\"GetHelloWithName\");\n        configuration.setFunctionArn(\"arn:aws:lambda:eu-central-1:643534317684:function:GetHelloWithName\");\n        configuration.setRuntime(\"nodejs6.10\");\n        configuration.setRole(\"arn:aws:iam::643534317684:role/lambda-execution-role\");\n        configuration.setHandler(\"GetHelloWithName.handler\");\n        configuration.setCodeSize(640L);\n        configuration.setCodeSha256(\"PKt5ygvZ6G8vWJASlWIypsBmKzAdmRrvTO/eBH06mBA=\");\n        configuration.setMemorySize(128);\n        configuration.setTimeout(3);\n        configuration.setLastModified(DateTime.now().toString());\n        configuration.setVersion(\"$LATEST\");\n        configuration.setTracingConfig(new TracingConfigResponse().withMode(TracingMode.PassThrough));\n        listFunctions.add(configuration);\n        result.setFunctions(listFunctions);\n        return result;\n    }",
            " 246  \n 247  \n 248  \n 249  \n 250 +\n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  ",
            "    @Override\n    public ListFunctionsResult listFunctions() {\n\n        ListFunctionsResult result = new ListFunctionsResult();\n        Collection<FunctionConfiguration> listFunctions = new ArrayList<>();\n        FunctionConfiguration configuration = new FunctionConfiguration();\n        configuration.setFunctionName(\"GetHelloWithName\");\n        configuration.setFunctionArn(\"arn:aws:lambda:eu-central-1:643534317684:function:GetHelloWithName\");\n        configuration.setRuntime(\"nodejs6.10\");\n        configuration.setRole(\"arn:aws:iam::643534317684:role/lambda-execution-role\");\n        configuration.setHandler(\"GetHelloWithName.handler\");\n        configuration.setCodeSize(640L);\n        configuration.setCodeSha256(\"PKt5ygvZ6G8vWJASlWIypsBmKzAdmRrvTO/eBH06mBA=\");\n        configuration.setMemorySize(128);\n        configuration.setTimeout(3);\n        configuration.setLastModified(DateTime.now().toString());\n        configuration.setVersion(\"$LATEST\");\n        configuration.setTracingConfig(new TracingConfigResponse().withMode(TracingMode.PassThrough));\n        listFunctions.add(configuration);\n        result.setFunctions(listFunctions);\n        return result;\n    }"
        ],
        [
            "DeleteAttributesCommandTest::execute()",
            "  51  \n  52  \n  53 -\n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  ",
            "    @Test\n    public void execute() {\n        List<Attribute> attributes = new ArrayList<Attribute>();\n        attributes.add(new Attribute(\"NAME1\", \"VALUE1\"));\n        exchange.getIn().setHeader(SdbConstants.ATTRIBUTES, attributes);\n        exchange.getIn().setHeader(SdbConstants.ITEM_NAME, \"ITEM1\");\n        UpdateCondition condition = new UpdateCondition(\"Key1\", \"Value1\", true);\n        exchange.getIn().setHeader(SdbConstants.UPDATE_CONDITION, condition);\n        \n        command.execute();\n        \n        assertEquals(\"DOMAIN1\", sdbClient.deleteAttributesRequest.getDomainName());\n        assertEquals(\"ITEM1\", sdbClient.deleteAttributesRequest.getItemName());\n        assertEquals(condition, sdbClient.deleteAttributesRequest.getExpected());\n        assertEquals(attributes, sdbClient.deleteAttributesRequest.getAttributes());\n    }",
            "  51  \n  52  \n  53 +\n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  ",
            "    @Test\n    public void execute() {\n        List<Attribute> attributes = new ArrayList<>();\n        attributes.add(new Attribute(\"NAME1\", \"VALUE1\"));\n        exchange.getIn().setHeader(SdbConstants.ATTRIBUTES, attributes);\n        exchange.getIn().setHeader(SdbConstants.ITEM_NAME, \"ITEM1\");\n        UpdateCondition condition = new UpdateCondition(\"Key1\", \"Value1\", true);\n        exchange.getIn().setHeader(SdbConstants.UPDATE_CONDITION, condition);\n        \n        command.execute();\n        \n        assertEquals(\"DOMAIN1\", sdbClient.deleteAttributesRequest.getDomainName());\n        assertEquals(\"ITEM1\", sdbClient.deleteAttributesRequest.getItemName());\n        assertEquals(condition, sdbClient.deleteAttributesRequest.getExpected());\n        assertEquals(attributes, sdbClient.deleteAttributesRequest.getAttributes());\n    }"
        ],
        [
            "S3ComponentNonExistingBucketTest::sendCustomHeaderValues()",
            "  92  \n  93  \n  94  \n  95  \n  96 -\n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  ",
            "    @Test\n    public void sendCustomHeaderValues() throws Exception {\n        result.expectedMessageCount(1);\n        final Date now = new Date();\n        final Map<String, String> s3Headers = new HashMap<String, String>();\n        s3Headers.put(\"x-aws-s3-header\", \"extra\");\n\n        Exchange exchange = template.send(\"direct:start\", ExchangePattern.InOnly, new Processor() {\n            public void process(Exchange exchange) throws Exception {\n                exchange.getIn().setHeader(S3Constants.STORAGE_CLASS, \"STANDARD\");\n                exchange.getIn().setHeader(S3Constants.KEY, \"CamelUnitTest\");\n                exchange.getIn().setHeader(S3Constants.CONTENT_LENGTH, 26L);\n                exchange.getIn().setHeader(S3Constants.CONTENT_TYPE, \"text/html\");\n                exchange.getIn().setHeader(S3Constants.CACHE_CONTROL, \"no-cache\");\n                exchange.getIn().setHeader(S3Constants.CONTENT_DISPOSITION, \"attachment;\");\n                exchange.getIn().setHeader(S3Constants.CONTENT_ENCODING, \"gzip\");\n                exchange.getIn().setHeader(S3Constants.CONTENT_MD5, \"TWF\");\n                exchange.getIn().setHeader(S3Constants.LAST_MODIFIED, now);\n                exchange.getIn().setHeader(S3Constants.S3_HEADERS, s3Headers);\n\n                exchange.getIn().setBody(\"This is my bucket content.\");\n            }\n        });\n        \n        assertMockEndpointsSatisfied();\n        \n        assertResultExchange(result.getExchanges().get(0));\n        \n        PutObjectRequest putObjectRequest = client.putObjectRequests.get(0);\n        assertEquals(\"STANDARD\", putObjectRequest.getStorageClass());\n        assertEquals(\"nonExistingBucket\", putObjectRequest.getBucketName());\n        assertEquals(26L, putObjectRequest.getMetadata().getContentLength());\n        assertEquals(\"text/html\", putObjectRequest.getMetadata().getContentType());\n        assertEquals(\"no-cache\", putObjectRequest.getMetadata().getCacheControl());\n        assertEquals(\"attachment;\", putObjectRequest.getMetadata().getContentDisposition());\n        assertEquals(\"gzip\", putObjectRequest.getMetadata().getContentEncoding());\n        assertEquals(\"TWF\", putObjectRequest.getMetadata().getContentMD5());\n        assertEquals(now, putObjectRequest.getMetadata().getLastModified());\n        assertEquals(\"extra\", putObjectRequest.getMetadata().getRawMetadataValue(\"x-aws-s3-header\"));\n\n        assertResponseMessage(exchange.getIn());\n    }",
            "  92  \n  93  \n  94  \n  95  \n  96 +\n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  ",
            "    @Test\n    public void sendCustomHeaderValues() throws Exception {\n        result.expectedMessageCount(1);\n        final Date now = new Date();\n        final Map<String, String> s3Headers = new HashMap<>();\n        s3Headers.put(\"x-aws-s3-header\", \"extra\");\n\n        Exchange exchange = template.send(\"direct:start\", ExchangePattern.InOnly, new Processor() {\n            public void process(Exchange exchange) throws Exception {\n                exchange.getIn().setHeader(S3Constants.STORAGE_CLASS, \"STANDARD\");\n                exchange.getIn().setHeader(S3Constants.KEY, \"CamelUnitTest\");\n                exchange.getIn().setHeader(S3Constants.CONTENT_LENGTH, 26L);\n                exchange.getIn().setHeader(S3Constants.CONTENT_TYPE, \"text/html\");\n                exchange.getIn().setHeader(S3Constants.CACHE_CONTROL, \"no-cache\");\n                exchange.getIn().setHeader(S3Constants.CONTENT_DISPOSITION, \"attachment;\");\n                exchange.getIn().setHeader(S3Constants.CONTENT_ENCODING, \"gzip\");\n                exchange.getIn().setHeader(S3Constants.CONTENT_MD5, \"TWF\");\n                exchange.getIn().setHeader(S3Constants.LAST_MODIFIED, now);\n                exchange.getIn().setHeader(S3Constants.S3_HEADERS, s3Headers);\n\n                exchange.getIn().setBody(\"This is my bucket content.\");\n            }\n        });\n        \n        assertMockEndpointsSatisfied();\n        \n        assertResultExchange(result.getExchanges().get(0));\n        \n        PutObjectRequest putObjectRequest = client.putObjectRequests.get(0);\n        assertEquals(\"STANDARD\", putObjectRequest.getStorageClass());\n        assertEquals(\"nonExistingBucket\", putObjectRequest.getBucketName());\n        assertEquals(26L, putObjectRequest.getMetadata().getContentLength());\n        assertEquals(\"text/html\", putObjectRequest.getMetadata().getContentType());\n        assertEquals(\"no-cache\", putObjectRequest.getMetadata().getCacheControl());\n        assertEquals(\"attachment;\", putObjectRequest.getMetadata().getContentDisposition());\n        assertEquals(\"gzip\", putObjectRequest.getMetadata().getContentEncoding());\n        assertEquals(\"TWF\", putObjectRequest.getMetadata().getContentMD5());\n        assertEquals(now, putObjectRequest.getMetadata().getLastModified());\n        assertEquals(\"extra\", putObjectRequest.getMetadata().getRawMetadataValue(\"x-aws-s3-header\"));\n\n        assertResponseMessage(exchange.getIn());\n    }"
        ],
        [
            "CamelWorkflowDefinition::execute(String)",
            "  53  \n  54  \n  55 -\n  56 -\n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70 -\n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  ",
            "    @Override\n    public Promise<String> execute(final String input) throws WorkflowException {\n        final Settable<String> result = new Settable<String>();\n        final AtomicReference<Promise<?>> methodResult = new AtomicReference<Promise<?>>();\n        new TryCatchFinally() {\n\n            @Override\n            protected void doTry() throws Throwable {\n                Object[] parameters = dataConverter.fromData(input, Object[].class);\n                long startTime = workflowClock.currentTimeMillis();\n                boolean replaying = contextProvider.getDecisionContext().getWorkflowClock().isReplaying();\n                LOGGER.debug(\"Processing workflow execute\");\n\n                Object r = swfWorkflowConsumer.processWorkflow(parameters, startTime, replaying);\n                if (r instanceof Promise) {\n                    methodResult.set((Promise<?>) r);\n                } else if (r != null) {\n                    methodResult.set(new Settable<Object>(r));\n                }\n            }\n\n            @Override\n            protected void doCatch(Throwable e) throws Throwable {\n                if (!(e instanceof CancellationException) || !decisionContext.getWorkflowContext().isCancelRequested()) {\n                    throwWorkflowException(dataConverter, e);\n                }\n            }\n\n            @Override\n            protected void doFinally() throws Throwable {\n                Promise<?> r = methodResult.get();\n                if (r == null || r.isReady()) {\n                    Object workflowResult = r == null ? null : r.get();\n                    String convertedResult = dataConverter.toData(workflowResult);\n                    result.set(convertedResult);\n                }\n            }\n        };\n\n        return result;\n    }",
            "  53  \n  54  \n  55 +\n  56 +\n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70 +\n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  ",
            "    @Override\n    public Promise<String> execute(final String input) throws WorkflowException {\n        final Settable<String> result = new Settable<>();\n        final AtomicReference<Promise<?>> methodResult = new AtomicReference<>();\n        new TryCatchFinally() {\n\n            @Override\n            protected void doTry() throws Throwable {\n                Object[] parameters = dataConverter.fromData(input, Object[].class);\n                long startTime = workflowClock.currentTimeMillis();\n                boolean replaying = contextProvider.getDecisionContext().getWorkflowClock().isReplaying();\n                LOGGER.debug(\"Processing workflow execute\");\n\n                Object r = swfWorkflowConsumer.processWorkflow(parameters, startTime, replaying);\n                if (r instanceof Promise) {\n                    methodResult.set((Promise<?>) r);\n                } else if (r != null) {\n                    methodResult.set(new Settable<>(r));\n                }\n            }\n\n            @Override\n            protected void doCatch(Throwable e) throws Throwable {\n                if (!(e instanceof CancellationException) || !decisionContext.getWorkflowContext().isCancelRequested()) {\n                    throwWorkflowException(dataConverter, e);\n                }\n            }\n\n            @Override\n            protected void doFinally() throws Throwable {\n                Promise<?> r = methodResult.get();\n                if (r == null || r.isReady()) {\n                    Object workflowResult = r == null ? null : r.get();\n                    String convertedResult = dataConverter.toData(workflowResult);\n                    result.set(convertedResult);\n                }\n            }\n        };\n\n        return result;\n    }"
        ],
        [
            "BatchDeleteAttributesCommandTest::determineDeletableItems()",
            "  62  \n  63  \n  64  \n  65  \n  66 -\n  67  \n  68  \n  69  \n  70  \n  71  ",
            "    @Test\n    public void determineDeletableItems() {\n        assertNull(this.command.determineDeletableItems());\n        \n        List<Item> deletableItems = new ArrayList<Item>();\n        deletableItems.add(new Item());\n        exchange.getIn().setHeader(SdbConstants.DELETABLE_ITEMS, deletableItems);\n        \n        assertEquals(deletableItems, this.command.determineDeletableItems());\n    }",
            "  62  \n  63  \n  64  \n  65  \n  66 +\n  67  \n  68  \n  69  \n  70  \n  71  ",
            "    @Test\n    public void determineDeletableItems() {\n        assertNull(this.command.determineDeletableItems());\n        \n        List<Item> deletableItems = new ArrayList<>();\n        deletableItems.add(new Item());\n        exchange.getIn().setHeader(SdbConstants.DELETABLE_ITEMS, deletableItems);\n        \n        assertEquals(deletableItems, this.command.determineDeletableItems());\n    }"
        ],
        [
            "PutItemCommandTest::execute()",
            "  48  \n  49  \n  50 -\n  51  \n  52  \n  53  \n  54  \n  55 -\n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  ",
            "    @Test\n    public void execute() {\n        Map<String, AttributeValue> attributeMap = new HashMap<String, AttributeValue>();\n        AttributeValue attributeValue = new AttributeValue(\"test value\");\n        attributeMap.put(\"name\", attributeValue);\n        exchange.getIn().setHeader(DdbConstants.ITEM, attributeMap);\n\n        Map<String, ExpectedAttributeValue> expectedAttributeValueMap = new HashMap<String, ExpectedAttributeValue>();\n        expectedAttributeValueMap.put(\"name\", new ExpectedAttributeValue(attributeValue));\n        exchange.getIn().setHeader(DdbConstants.UPDATE_CONDITION, expectedAttributeValueMap);\n\n        command.execute();\n\n        assertEquals(\"DOMAIN1\", ddbClient.putItemRequest.getTableName());\n        assertEquals(attributeMap, ddbClient.putItemRequest.getItem());\n        assertEquals(expectedAttributeValueMap, ddbClient.putItemRequest.getExpected());\n        assertEquals(new AttributeValue(\"attrValue\"),\n                exchange.getIn().getHeader(DdbConstants.ATTRIBUTES, Map.class).get(\"attrName\"));\n    }",
            "  48  \n  49  \n  50 +\n  51  \n  52  \n  53  \n  54  \n  55 +\n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  ",
            "    @Test\n    public void execute() {\n        Map<String, AttributeValue> attributeMap = new HashMap<>();\n        AttributeValue attributeValue = new AttributeValue(\"test value\");\n        attributeMap.put(\"name\", attributeValue);\n        exchange.getIn().setHeader(DdbConstants.ITEM, attributeMap);\n\n        Map<String, ExpectedAttributeValue> expectedAttributeValueMap = new HashMap<>();\n        expectedAttributeValueMap.put(\"name\", new ExpectedAttributeValue(attributeValue));\n        exchange.getIn().setHeader(DdbConstants.UPDATE_CONDITION, expectedAttributeValueMap);\n\n        command.execute();\n\n        assertEquals(\"DOMAIN1\", ddbClient.putItemRequest.getTableName());\n        assertEquals(attributeMap, ddbClient.putItemRequest.getItem());\n        assertEquals(expectedAttributeValueMap, ddbClient.putItemRequest.getExpected());\n        assertEquals(new AttributeValue(\"attrValue\"),\n                exchange.getIn().getHeader(DdbConstants.ATTRIBUTES, Map.class).get(\"attrName\"));\n    }"
        ],
        [
            "ScanCommandTest::execute()",
            "  51  \n  52  \n  53 -\n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62 -\n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  ",
            "    @Test\n    public void execute() {\n        Map<String, Condition> scanFilter = new HashMap<String, Condition>();\n        Condition condition = new Condition()\n                .withComparisonOperator(ComparisonOperator.GT.toString())\n                .withAttributeValueList(new AttributeValue().withN(\"1985\"));\n        scanFilter.put(\"year\", condition);\n        exchange.getIn().setHeader(DdbConstants.SCAN_FILTER, scanFilter);\n\n        command.execute();\n\n        Map<String, AttributeValue> mapAssert = new HashMap<String, AttributeValue>();\n        mapAssert.put(\"1\", new AttributeValue(\"LAST_KEY\"));\n\n        ConsumedCapacity consumed = (ConsumedCapacity) exchange.getIn().getHeader(DdbConstants.CONSUMED_CAPACITY);\n        assertEquals(scanFilter, ddbClient.scanRequest.getScanFilter());\n        assertEquals(Integer.valueOf(10), exchange.getIn().getHeader(DdbConstants.SCANNED_COUNT, Integer.class));\n        assertEquals(Integer.valueOf(1), exchange.getIn().getHeader(DdbConstants.COUNT, Integer.class));\n        assertEquals(Double.valueOf(1.0), consumed.getCapacityUnits());\n        assertEquals(mapAssert, exchange.getIn().getHeader(DdbConstants.LAST_EVALUATED_KEY, Map.class));\n\n        Map<?, ?> items = (Map<?, ?>) exchange.getIn().getHeader(DdbConstants.ITEMS, List.class).get(0);\n        assertEquals(new AttributeValue(\"attrValue\"), items.get(\"attrName\"));\n    }",
            "  51  \n  52  \n  53 +\n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62 +\n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  ",
            "    @Test\n    public void execute() {\n        Map<String, Condition> scanFilter = new HashMap<>();\n        Condition condition = new Condition()\n                .withComparisonOperator(ComparisonOperator.GT.toString())\n                .withAttributeValueList(new AttributeValue().withN(\"1985\"));\n        scanFilter.put(\"year\", condition);\n        exchange.getIn().setHeader(DdbConstants.SCAN_FILTER, scanFilter);\n\n        command.execute();\n\n        Map<String, AttributeValue> mapAssert = new HashMap<>();\n        mapAssert.put(\"1\", new AttributeValue(\"LAST_KEY\"));\n\n        ConsumedCapacity consumed = (ConsumedCapacity) exchange.getIn().getHeader(DdbConstants.CONSUMED_CAPACITY);\n        assertEquals(scanFilter, ddbClient.scanRequest.getScanFilter());\n        assertEquals(Integer.valueOf(10), exchange.getIn().getHeader(DdbConstants.SCANNED_COUNT, Integer.class));\n        assertEquals(Integer.valueOf(1), exchange.getIn().getHeader(DdbConstants.COUNT, Integer.class));\n        assertEquals(Double.valueOf(1.0), consumed.getCapacityUnits());\n        assertEquals(mapAssert, exchange.getIn().getHeader(DdbConstants.LAST_EVALUATED_KEY, Map.class));\n\n        Map<?, ?> items = (Map<?, ?>) exchange.getIn().getHeader(DdbConstants.ITEMS, List.class).get(0);\n        assertEquals(new AttributeValue(\"attrValue\"), items.get(\"attrName\"));\n    }"
        ],
        [
            "CamelWorkflowDefinitionFactoryFactory::getWorkflowTypesToRegister()",
            "  46  \n  47  \n  48 -\n  49  \n  50  \n  51  \n  52  \n  53  \n  54  ",
            "    @Override\n    public Iterable<WorkflowType> getWorkflowTypesToRegister() {\n        ArrayList<WorkflowType> workflowTypes = new ArrayList<WorkflowType>(1);\n        WorkflowType workflowType = new WorkflowType();\n        workflowType.setName(configuration.getEventName());\n        workflowType.setVersion(configuration.getVersion());\n        workflowTypes.add(workflowType);\n        return workflowTypes;\n    }",
            "  46  \n  47  \n  48 +\n  49  \n  50  \n  51  \n  52  \n  53  \n  54  ",
            "    @Override\n    public Iterable<WorkflowType> getWorkflowTypesToRegister() {\n        ArrayList<WorkflowType> workflowTypes = new ArrayList<>(1);\n        WorkflowType workflowType = new WorkflowType();\n        workflowType.setName(configuration.getEventName());\n        workflowType.setVersion(configuration.getVersion());\n        workflowTypes.add(workflowType);\n        return workflowTypes;\n    }"
        ],
        [
            "DdbComponentIntegrationTest::select()",
            "  42  \n  43  \n  44 -\n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  ",
            "    @Test\n    public void select() {\n        final Map<String, AttributeValue> attributeMap = new HashMap<String, AttributeValue>();\n        AttributeValue attributeValue = new AttributeValue(\"test value\");\n        attributeMap.put(\"name\", attributeValue);\n\n        Exchange exchange = template.send(\"direct:start\", new Processor() {\n            public void process(Exchange exchange) throws Exception {\n                exchange.getIn().setHeader(DdbConstants.OPERATION, DdbOperations.PutItem);\n                exchange.getIn().setHeader(DdbConstants.RETURN_VALUES, \"ALL_OLD\");\n                exchange.getIn().setHeader(DdbConstants.ITEM, attributeMap);\n            }\n        });\n\n        assertNotNull(exchange.getIn().getHeader(DdbConstants.ITEMS, List.class));\n    }",
            "  42  \n  43  \n  44 +\n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  ",
            "    @Test\n    public void select() {\n        final Map<String, AttributeValue> attributeMap = new HashMap<>();\n        AttributeValue attributeValue = new AttributeValue(\"test value\");\n        attributeMap.put(\"name\", attributeValue);\n\n        Exchange exchange = template.send(\"direct:start\", new Processor() {\n            public void process(Exchange exchange) throws Exception {\n                exchange.getIn().setHeader(DdbConstants.OPERATION, DdbOperations.PutItem);\n                exchange.getIn().setHeader(DdbConstants.RETURN_VALUES, \"ALL_OLD\");\n                exchange.getIn().setHeader(DdbConstants.ITEM, attributeMap);\n            }\n        });\n\n        assertNotNull(exchange.getIn().getHeader(DdbConstants.ITEMS, List.class));\n    }"
        ],
        [
            "GetAttributesCommandTest::determineAttributeNames()",
            "  83  \n  84  \n  85  \n  86  \n  87 -\n  88  \n  89  \n  90  \n  91  \n  92  ",
            "    @Test\n    public void determineAttributeNames() {\n        assertNull(this.command.determineAttributeNames());\n        \n        List<String> attributeNames = new ArrayList<String>();\n        attributeNames.add(\"ATTRIBUTE1\");\n        exchange.getIn().setHeader(SdbConstants.ATTRIBUTE_NAMES, attributeNames);\n        \n        assertEquals(attributeNames, this.command.determineAttributeNames());\n    }",
            "  83  \n  84  \n  85  \n  86  \n  87 +\n  88  \n  89  \n  90  \n  91  \n  92  ",
            "    @Test\n    public void determineAttributeNames() {\n        assertNull(this.command.determineAttributeNames());\n        \n        List<String> attributeNames = new ArrayList<>();\n        attributeNames.add(\"ATTRIBUTE1\");\n        exchange.getIn().setHeader(SdbConstants.ATTRIBUTE_NAMES, attributeNames);\n        \n        assertEquals(attributeNames, this.command.determineAttributeNames());\n    }"
        ],
        [
            "WebsocketComponent::WebsocketComponent()",
            "  32  \n  33  \n  34  \n  35  \n  36  \n  37 -\n  38  ",
            "    public WebsocketComponent() {\n        // override the default servlet name of ServletComponent\n        super(WebsocketEndpoint.class);\n        setServletName(\"CamelWsServlet\");\n        \n        this.stores = new HashMap<String, WebSocketStore>();\n    }",
            "  32  \n  33  \n  34  \n  35  \n  36  \n  37 +\n  38  ",
            "    public WebsocketComponent() {\n        // override the default servlet name of ServletComponent\n        super(WebsocketEndpoint.class);\n        setServletName(\"CamelWsServlet\");\n        \n        this.stores = new HashMap<>();\n    }"
        ],
        [
            "DeleteItemCommandTest::execute()",
            "  48  \n  49  \n  50 -\n  51  \n  52  \n  53  \n  54  \n  55 -\n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  ",
            "    @Test\n    public void execute() {\n        Map<String, AttributeValue> key = new HashMap<String, AttributeValue>();\n        key.put(\"1\", new AttributeValue(\"Key_1\"));\n        exchange.getIn().setHeader(DdbConstants.KEY, key);\n\n\n        Map<String, ExpectedAttributeValue> updateCondition = new HashMap<String, ExpectedAttributeValue>();\n        updateCondition\n                .put(\"name\", new ExpectedAttributeValue(new AttributeValue(\"expected value\")));\n        exchange.getIn().setHeader(DdbConstants.UPDATE_CONDITION, updateCondition);\n        exchange.getIn().setHeader(DdbConstants.RETURN_VALUES, \"ALL_OLD\");\n\n        command.execute();\n\n        assertEquals(\"DOMAIN1\", ddbClient.deleteItemRequest.getTableName());\n        assertEquals(key, ddbClient.deleteItemRequest.getKey());\n        assertEquals(updateCondition, ddbClient.deleteItemRequest.getExpected());\n        assertEquals(\"ALL_OLD\", ddbClient.deleteItemRequest.getReturnValues());\n        assertEquals(new AttributeValue(\"attrValue\"),\n                exchange.getIn().getHeader(DdbConstants.ATTRIBUTES, Map.class).get(\n                        \"attrName\"));\n    }",
            "  48  \n  49  \n  50 +\n  51  \n  52  \n  53  \n  54  \n  55 +\n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  ",
            "    @Test\n    public void execute() {\n        Map<String, AttributeValue> key = new HashMap<>();\n        key.put(\"1\", new AttributeValue(\"Key_1\"));\n        exchange.getIn().setHeader(DdbConstants.KEY, key);\n\n\n        Map<String, ExpectedAttributeValue> updateCondition = new HashMap<>();\n        updateCondition\n                .put(\"name\", new ExpectedAttributeValue(new AttributeValue(\"expected value\")));\n        exchange.getIn().setHeader(DdbConstants.UPDATE_CONDITION, updateCondition);\n        exchange.getIn().setHeader(DdbConstants.RETURN_VALUES, \"ALL_OLD\");\n\n        command.execute();\n\n        assertEquals(\"DOMAIN1\", ddbClient.deleteItemRequest.getTableName());\n        assertEquals(key, ddbClient.deleteItemRequest.getKey());\n        assertEquals(updateCondition, ddbClient.deleteItemRequest.getExpected());\n        assertEquals(\"ALL_OLD\", ddbClient.deleteItemRequest.getReturnValues());\n        assertEquals(new AttributeValue(\"attrValue\"),\n                exchange.getIn().getHeader(DdbConstants.ATTRIBUTES, Map.class).get(\n                        \"attrName\"));\n    }"
        ],
        [
            "QueueServiceProducerTest::createJndiContext()",
            " 106  \n 107  \n 108  \n 109 -\n 110  ",
            "    private Context createJndiContext() throws Exception {\n        Properties properties = new Properties();\n        properties.put(\"java.naming.factory.initial\", \"org.apache.camel.util.jndi.CamelInitialContextFactory\");\n        return new InitialContext(new Hashtable<Object, Object>(properties));\n    }",
            " 106  \n 107  \n 108  \n 109 +\n 110  ",
            "    private Context createJndiContext() throws Exception {\n        Properties properties = new Properties();\n        properties.put(\"java.naming.factory.initial\", \"org.apache.camel.util.jndi.CamelInitialContextFactory\");\n        return new InitialContext(new Hashtable<>(properties));\n    }"
        ],
        [
            "AmazonDDBClientMock::scan(ScanRequest)",
            " 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184 -\n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  ",
            "    @SuppressWarnings(\"unchecked\")\n    @Override\n    public ScanResult scan(ScanRequest scanRequest) {\n        this.scanRequest = scanRequest;\n        ConsumedCapacity consumed = new ConsumedCapacity();\n        consumed.setCapacityUnits(1.0);\n        Map<String, AttributeValue> lastEvaluatedKey = new HashMap<String, AttributeValue>();\n        lastEvaluatedKey.put(\"1\", new AttributeValue(\"LAST_KEY\"));\n        return new ScanResult()\n                .withConsumedCapacity(consumed)\n                .withCount(1)\n                .withItems(getAttributes())\n                .withScannedCount(10)\n                .withLastEvaluatedKey(lastEvaluatedKey);\n    }",
            " 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184 +\n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  ",
            "    @SuppressWarnings(\"unchecked\")\n    @Override\n    public ScanResult scan(ScanRequest scanRequest) {\n        this.scanRequest = scanRequest;\n        ConsumedCapacity consumed = new ConsumedCapacity();\n        consumed.setCapacityUnits(1.0);\n        Map<String, AttributeValue> lastEvaluatedKey = new HashMap<>();\n        lastEvaluatedKey.put(\"1\", new AttributeValue(\"LAST_KEY\"));\n        return new ScanResult()\n                .withConsumedCapacity(consumed)\n                .withCount(1)\n                .withItems(getAttributes())\n                .withScannedCount(10)\n                .withLastEvaluatedKey(lastEvaluatedKey);\n    }"
        ],
        [
            "AtmosAPIFacade::put(String,String)",
            "  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106 -\n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134 -\n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  ",
            "    /**\n     * Put or upload a new file or an entire directory to atmos\n     *\n     * @param localPath the file path or the dir path on the local filesystem\n     * @param remotePath the remote path destination on atmos\n     * the file already existing with the same name\n     * will be overridden.\n     * @return a AtmosResult object reporting for each remote path the result of\n     * the operation.\n     * @throws AtmosException\n     */\n    public AtmosResult put(String localPath, String remotePath) throws AtmosException {\n        AtmosResult result = new AtmosFileUploadResult();\n        //a map representing for each path the result of the put operation\n        Map<String, AtmosResultCode> resultEntries = null;\n        //in case the remote path is not specified, the remotePath = localPath\n        String atmosPath = remotePath == null ? localPath : remotePath;\n        if (!atmosPath.endsWith(ATMOS_FILE_SEPARATOR)) {\n            atmosPath += ATMOS_FILE_SEPARATOR;\n        }\n        ObjectPath atmosEntry = new ObjectPath(atmosPath);\n\n        if (!atmosPath.equals(ATMOS_FILE_SEPARATOR)) {\n            if (AtmosAPIFacade.client.getSystemMetadata(atmosEntry) == null) {\n                throw new AtmosException(atmosPath + \" does not exist or cannot obtain metadata\");\n            }\n        }\n\n        File fileLocalPath = new File(localPath);\n        //verify uploading of a single file\n        if (fileLocalPath.isFile()) {\n            //check if atmos file exists\n            if (atmosEntry != null && !atmosEntry.isDirectory()) {\n                throw new AtmosException(atmosPath + \" exists on atmos and is not a folder!\");\n            }\n            atmosPath = atmosPath + fileLocalPath.getName();\n            resultEntries = new HashMap<String, AtmosResultCode>(1);\n            try {\n                ObjectId uploadedFile = putSingleFile(fileLocalPath, atmosPath);\n                if (uploadedFile == null) {\n                    resultEntries.put(atmosPath, AtmosResultCode.KO);\n                } else {\n                    resultEntries.put(atmosPath, AtmosResultCode.OK);\n                }\n\n            } catch (Exception ex) {\n                resultEntries.put(atmosPath, AtmosResultCode.KO);\n            } finally {\n                result.setResultEntries(resultEntries);\n            }\n            return result;\n        } else {       //verify uploading of a list of files inside a dir\n            LOG.info(\"uploading a dir...\");\n            //check if atmos folder exists\n            if (atmosEntry != null && !atmosEntry.isDirectory()) {\n                throw new AtmosException(atmosPath + \" exists on atmos and is not a folder!\");\n            }\n            //revert to old path\n            String oldAtmosPath = atmosPath;\n            //list all files in a dir\n            Collection<File> listFiles = FileUtils.listFiles(fileLocalPath, null, true);\n            if (listFiles == null || listFiles.isEmpty()) {\n                throw new AtmosException(localPath + \" does not contain any files\");\n            }\n            resultEntries = new HashMap<String, AtmosResultCode>(listFiles.size());\n            for (File file : listFiles) {\n                String absPath = file.getAbsolutePath();\n                int indexRemainingPath = localPath.length();\n                if (!localPath.endsWith(\"/\")) {\n                    indexRemainingPath += 1;\n                }\n                String remainingPath = absPath.substring(indexRemainingPath);\n                atmosPath = atmosPath + remainingPath;\n                try {\n                    LOG.debug(\"uploading: {} to {}\", fileLocalPath, atmosPath);\n                    ObjectId uploadedFile = putSingleFile(file, atmosPath);\n                    if (uploadedFile == null) {\n                        resultEntries.put(atmosPath, AtmosResultCode.KO);\n                    } else {\n                        resultEntries.put(atmosPath, AtmosResultCode.OK);\n                    }\n                } catch (Exception ex) {\n                    resultEntries.put(atmosPath, AtmosResultCode.KO);\n                }\n                atmosPath = oldAtmosPath;\n            }\n            result.setResultEntries(resultEntries);\n            return result;\n        }\n    }",
            "  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106 +\n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134 +\n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  ",
            "    /**\n     * Put or upload a new file or an entire directory to atmos\n     *\n     * @param localPath the file path or the dir path on the local filesystem\n     * @param remotePath the remote path destination on atmos\n     * the file already existing with the same name\n     * will be overridden.\n     * @return a AtmosResult object reporting for each remote path the result of\n     * the operation.\n     * @throws AtmosException\n     */\n    public AtmosResult put(String localPath, String remotePath) throws AtmosException {\n        AtmosResult result = new AtmosFileUploadResult();\n        //a map representing for each path the result of the put operation\n        Map<String, AtmosResultCode> resultEntries = null;\n        //in case the remote path is not specified, the remotePath = localPath\n        String atmosPath = remotePath == null ? localPath : remotePath;\n        if (!atmosPath.endsWith(ATMOS_FILE_SEPARATOR)) {\n            atmosPath += ATMOS_FILE_SEPARATOR;\n        }\n        ObjectPath atmosEntry = new ObjectPath(atmosPath);\n\n        if (!atmosPath.equals(ATMOS_FILE_SEPARATOR)) {\n            if (AtmosAPIFacade.client.getSystemMetadata(atmosEntry) == null) {\n                throw new AtmosException(atmosPath + \" does not exist or cannot obtain metadata\");\n            }\n        }\n\n        File fileLocalPath = new File(localPath);\n        //verify uploading of a single file\n        if (fileLocalPath.isFile()) {\n            //check if atmos file exists\n            if (atmosEntry != null && !atmosEntry.isDirectory()) {\n                throw new AtmosException(atmosPath + \" exists on atmos and is not a folder!\");\n            }\n            atmosPath = atmosPath + fileLocalPath.getName();\n            resultEntries = new HashMap<>(1);\n            try {\n                ObjectId uploadedFile = putSingleFile(fileLocalPath, atmosPath);\n                if (uploadedFile == null) {\n                    resultEntries.put(atmosPath, AtmosResultCode.KO);\n                } else {\n                    resultEntries.put(atmosPath, AtmosResultCode.OK);\n                }\n\n            } catch (Exception ex) {\n                resultEntries.put(atmosPath, AtmosResultCode.KO);\n            } finally {\n                result.setResultEntries(resultEntries);\n            }\n            return result;\n        } else {       //verify uploading of a list of files inside a dir\n            LOG.info(\"uploading a dir...\");\n            //check if atmos folder exists\n            if (atmosEntry != null && !atmosEntry.isDirectory()) {\n                throw new AtmosException(atmosPath + \" exists on atmos and is not a folder!\");\n            }\n            //revert to old path\n            String oldAtmosPath = atmosPath;\n            //list all files in a dir\n            Collection<File> listFiles = FileUtils.listFiles(fileLocalPath, null, true);\n            if (listFiles == null || listFiles.isEmpty()) {\n                throw new AtmosException(localPath + \" does not contain any files\");\n            }\n            resultEntries = new HashMap<>(listFiles.size());\n            for (File file : listFiles) {\n                String absPath = file.getAbsolutePath();\n                int indexRemainingPath = localPath.length();\n                if (!localPath.endsWith(\"/\")) {\n                    indexRemainingPath += 1;\n                }\n                String remainingPath = absPath.substring(indexRemainingPath);\n                atmosPath = atmosPath + remainingPath;\n                try {\n                    LOG.debug(\"uploading: {} to {}\", fileLocalPath, atmosPath);\n                    ObjectId uploadedFile = putSingleFile(file, atmosPath);\n                    if (uploadedFile == null) {\n                        resultEntries.put(atmosPath, AtmosResultCode.KO);\n                    } else {\n                        resultEntries.put(atmosPath, AtmosResultCode.OK);\n                    }\n                } catch (Exception ex) {\n                    resultEntries.put(atmosPath, AtmosResultCode.KO);\n                }\n                atmosPath = oldAtmosPath;\n            }\n            result.setResultEntries(resultEntries);\n            return result;\n        }\n    }"
        ],
        [
            "AmazonEC2ClientMock::monitorInstances(MonitorInstancesRequest)",
            " 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273 -\n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  ",
            "    @Override\n    public MonitorInstancesResult monitorInstances(MonitorInstancesRequest monitorInstancesRequest) {\n        MonitorInstancesResult result = new MonitorInstancesResult();\n        if (!monitorInstancesRequest.getInstanceIds().isEmpty()) {\n            Collection<InstanceMonitoring> coll = new ArrayList<>();\n            Iterator<String> it = monitorInstancesRequest.getInstanceIds().iterator();\n            while (it.hasNext()) {\n                String id = (String) it.next();\n                InstanceMonitoring mon = new InstanceMonitoring();\n                mon.setInstanceId(id);\n                Monitoring monitoring = new Monitoring();\n                monitoring.setState(MonitoringState.Enabled);\n                mon.setMonitoring(monitoring); \n                coll.add(mon);\n            }\n            result.setInstanceMonitorings(coll);\n        }\n        return result;\n    }",
            " 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273 +\n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  ",
            "    @Override\n    public MonitorInstancesResult monitorInstances(MonitorInstancesRequest monitorInstancesRequest) {\n        MonitorInstancesResult result = new MonitorInstancesResult();\n        if (!monitorInstancesRequest.getInstanceIds().isEmpty()) {\n            Collection<InstanceMonitoring> coll = new ArrayList<>();\n            Iterator<String> it = monitorInstancesRequest.getInstanceIds().iterator();\n            while (it.hasNext()) {\n                String id = it.next();\n                InstanceMonitoring mon = new InstanceMonitoring();\n                mon.setInstanceId(id);\n                Monitoring monitoring = new Monitoring();\n                monitoring.setState(MonitoringState.Enabled);\n                mon.setMonitoring(monitoring); \n                coll.add(mon);\n            }\n            result.setInstanceMonitorings(coll);\n        }\n        return result;\n    }"
        ],
        [
            "AmazonEC2ClientMock::stopInstances(StopInstancesRequest)",
            " 141  \n 142  \n 143  \n 144  \n 145 -\n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  ",
            "    @Override\n    public StopInstancesResult stopInstances(StopInstancesRequest stopInstancesRequest) {\n        StopInstancesResult result = new StopInstancesResult();\n        if (stopInstancesRequest.getInstanceIds().get(0).equals(\"test-1\")) {\n            Collection<InstanceStateChange> coll = new ArrayList<InstanceStateChange>();\n            InstanceStateChange sc = new InstanceStateChange();\n            InstanceState previousState = new InstanceState();\n            previousState.setCode(80);\n            previousState.setName(InstanceStateName.Running);\n            InstanceState newState = new InstanceState();\n            newState.setCode(16);\n            newState.setName(InstanceStateName.Stopped);\n            sc.setPreviousState(previousState);\n            sc.setCurrentState(newState);\n            sc.setInstanceId(\"test-1\");\n            coll.add(sc);\n            result.setStoppingInstances(coll);\n        } else {\n            throw new AmazonServiceException(\"The image-id doesn't exists\");\n        }\n        return result;        \n    }",
            " 141  \n 142  \n 143  \n 144  \n 145 +\n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  ",
            "    @Override\n    public StopInstancesResult stopInstances(StopInstancesRequest stopInstancesRequest) {\n        StopInstancesResult result = new StopInstancesResult();\n        if (stopInstancesRequest.getInstanceIds().get(0).equals(\"test-1\")) {\n            Collection<InstanceStateChange> coll = new ArrayList<>();\n            InstanceStateChange sc = new InstanceStateChange();\n            InstanceState previousState = new InstanceState();\n            previousState.setCode(80);\n            previousState.setName(InstanceStateName.Running);\n            InstanceState newState = new InstanceState();\n            newState.setCode(16);\n            newState.setName(InstanceStateName.Stopped);\n            sc.setPreviousState(previousState);\n            sc.setCurrentState(newState);\n            sc.setInstanceId(\"test-1\");\n            coll.add(sc);\n            result.setStoppingInstances(coll);\n        } else {\n            throw new AmazonServiceException(\"The image-id doesn't exists\");\n        }\n        return result;        \n    }"
        ],
        [
            "AmazonSNSClientMock::listTopics(String)",
            " 158  \n 159  \n 160  \n 161  \n 162  \n 163 -\n 164  \n 165  \n 166  \n 167  ",
            "    @Override\n    public ListTopicsResult listTopics(String nextToken) {\n        ListTopicsResult res = new ListTopicsResult();\n        Topic topic = new Topic();\n        topic.setTopicArn(DEFAULT_TOPIC_ARN);\n        List<Topic> list = new ArrayList<Topic>();\n        list.add(topic);\n        res.setTopics(list);\n        return res;\n    }",
            " 158  \n 159  \n 160  \n 161  \n 162  \n 163 +\n 164  \n 165  \n 166  \n 167  ",
            "    @Override\n    public ListTopicsResult listTopics(String nextToken) {\n        ListTopicsResult res = new ListTopicsResult();\n        Topic topic = new Topic();\n        topic.setTopicArn(DEFAULT_TOPIC_ARN);\n        List<Topic> list = new ArrayList<>();\n        list.add(topic);\n        res.setTopics(list);\n        return res;\n    }"
        ],
        [
            "S3ComponentExistingBucketTest::sendCustomHeaderValues()",
            "  92  \n  93  \n  94  \n  95  \n  96 -\n  97  \n  98 -\n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  ",
            "    @Test\n    public void sendCustomHeaderValues() throws Exception {\n        result.expectedMessageCount(1);\n        final Date now = new Date();\n        final Map<String, String> userMetadata = new HashMap<String, String>();\n        userMetadata.put(\"CamelName\", \"Camel\");\n        final Map<String, String> s3Headers = new HashMap<String, String>();\n        s3Headers.put(\"x-aws-s3-header\", \"extra\");\n\n        Exchange exchange = template.send(\"direct:start\", ExchangePattern.InOnly, new Processor() {\n            public void process(Exchange exchange) throws Exception {\n                exchange.getIn().setHeader(S3Constants.STORAGE_CLASS, \"STANDARD\");\n                exchange.getIn().setHeader(S3Constants.KEY, \"CamelUnitTest\");\n                exchange.getIn().setHeader(S3Constants.CONTENT_LENGTH, 26L);\n                exchange.getIn().setHeader(S3Constants.CONTENT_TYPE, \"text/html\");\n                exchange.getIn().setHeader(S3Constants.CACHE_CONTROL, \"no-cache\");\n                exchange.getIn().setHeader(S3Constants.CONTENT_DISPOSITION, \"attachment;\");\n                exchange.getIn().setHeader(S3Constants.CONTENT_ENCODING, \"gzip\");\n                exchange.getIn().setHeader(S3Constants.CONTENT_MD5, \"TWF\");\n                exchange.getIn().setHeader(S3Constants.LAST_MODIFIED, now);\n                exchange.getIn().setHeader(S3Constants.USER_METADATA, userMetadata);\n                exchange.getIn().setHeader(S3Constants.S3_HEADERS, s3Headers);\n\n                exchange.getIn().setBody(\"This is my bucket content.\");\n            }\n        });\n        \n        assertMockEndpointsSatisfied();\n        \n        assertResultExchange(result.getExchanges().get(0));\n        \n        PutObjectRequest putObjectRequest = client.putObjectRequests.get(0);\n        assertEquals(\"STANDARD\", putObjectRequest.getStorageClass());\n        assertEquals(\"mycamelbucket\", putObjectRequest.getBucketName());\n        assertEquals(26L, putObjectRequest.getMetadata().getContentLength());\n        assertEquals(\"text/html\", putObjectRequest.getMetadata().getContentType());\n        assertEquals(\"no-cache\", putObjectRequest.getMetadata().getCacheControl());\n        assertEquals(\"attachment;\", putObjectRequest.getMetadata().getContentDisposition());\n        assertEquals(\"gzip\", putObjectRequest.getMetadata().getContentEncoding());\n        assertEquals(\"TWF\", putObjectRequest.getMetadata().getContentMD5());\n        assertEquals(now, putObjectRequest.getMetadata().getLastModified());\n        assertEquals(userMetadata, putObjectRequest.getMetadata().getUserMetadata());\n        assertEquals(\"extra\", putObjectRequest.getMetadata().getRawMetadataValue(\"x-aws-s3-header\"));\n\n        assertResponseMessage(exchange.getIn());\n    }",
            "  92  \n  93  \n  94  \n  95  \n  96 +\n  97  \n  98 +\n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  ",
            "    @Test\n    public void sendCustomHeaderValues() throws Exception {\n        result.expectedMessageCount(1);\n        final Date now = new Date();\n        final Map<String, String> userMetadata = new HashMap<>();\n        userMetadata.put(\"CamelName\", \"Camel\");\n        final Map<String, String> s3Headers = new HashMap<>();\n        s3Headers.put(\"x-aws-s3-header\", \"extra\");\n\n        Exchange exchange = template.send(\"direct:start\", ExchangePattern.InOnly, new Processor() {\n            public void process(Exchange exchange) throws Exception {\n                exchange.getIn().setHeader(S3Constants.STORAGE_CLASS, \"STANDARD\");\n                exchange.getIn().setHeader(S3Constants.KEY, \"CamelUnitTest\");\n                exchange.getIn().setHeader(S3Constants.CONTENT_LENGTH, 26L);\n                exchange.getIn().setHeader(S3Constants.CONTENT_TYPE, \"text/html\");\n                exchange.getIn().setHeader(S3Constants.CACHE_CONTROL, \"no-cache\");\n                exchange.getIn().setHeader(S3Constants.CONTENT_DISPOSITION, \"attachment;\");\n                exchange.getIn().setHeader(S3Constants.CONTENT_ENCODING, \"gzip\");\n                exchange.getIn().setHeader(S3Constants.CONTENT_MD5, \"TWF\");\n                exchange.getIn().setHeader(S3Constants.LAST_MODIFIED, now);\n                exchange.getIn().setHeader(S3Constants.USER_METADATA, userMetadata);\n                exchange.getIn().setHeader(S3Constants.S3_HEADERS, s3Headers);\n\n                exchange.getIn().setBody(\"This is my bucket content.\");\n            }\n        });\n        \n        assertMockEndpointsSatisfied();\n        \n        assertResultExchange(result.getExchanges().get(0));\n        \n        PutObjectRequest putObjectRequest = client.putObjectRequests.get(0);\n        assertEquals(\"STANDARD\", putObjectRequest.getStorageClass());\n        assertEquals(\"mycamelbucket\", putObjectRequest.getBucketName());\n        assertEquals(26L, putObjectRequest.getMetadata().getContentLength());\n        assertEquals(\"text/html\", putObjectRequest.getMetadata().getContentType());\n        assertEquals(\"no-cache\", putObjectRequest.getMetadata().getCacheControl());\n        assertEquals(\"attachment;\", putObjectRequest.getMetadata().getContentDisposition());\n        assertEquals(\"gzip\", putObjectRequest.getMetadata().getContentEncoding());\n        assertEquals(\"TWF\", putObjectRequest.getMetadata().getContentMD5());\n        assertEquals(now, putObjectRequest.getMetadata().getLastModified());\n        assertEquals(userMetadata, putObjectRequest.getMetadata().getUserMetadata());\n        assertEquals(\"extra\", putObjectRequest.getMetadata().getRawMetadataValue(\"x-aws-s3-header\"));\n\n        assertResponseMessage(exchange.getIn());\n    }"
        ],
        [
            "AhcProducePostHeadersTest::testAhcProduce()",
            "  28  \n  29  \n  30  \n  31  \n  32  \n  33  \n  34  \n  35  \n  36 -\n  37  \n  38  \n  39  \n  40  \n  41  \n  42  \n  43  ",
            "    @Test\n    public void testAhcProduce() throws Exception {\n        getMockEndpoint(\"mock:result\").expectedBodiesReceived(\"Bye World\");\n        getMockEndpoint(\"mock:result\").expectedHeaderReceived(\"foo\", 123);\n        getMockEndpoint(\"mock:result\").expectedHeaderReceived(\"bar\", \"cool\");\n        getMockEndpoint(\"mock:result\").expectedHeaderReceived(Exchange.HTTP_RESPONSE_CODE, 200);\n        getMockEndpoint(\"mock:result\").expectedHeaderReceived(Exchange.CONTENT_LENGTH, 9);\n\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(\"foo\", 123);\n        headers.put(\"bar\", \"cool\");\n\n        template.sendBodyAndHeaders(\"direct:start\", \"World\", headers);\n\n        assertMockEndpointsSatisfied();\n    }",
            "  28  \n  29  \n  30  \n  31  \n  32  \n  33  \n  34  \n  35  \n  36 +\n  37  \n  38  \n  39  \n  40  \n  41  \n  42  \n  43  ",
            "    @Test\n    public void testAhcProduce() throws Exception {\n        getMockEndpoint(\"mock:result\").expectedBodiesReceived(\"Bye World\");\n        getMockEndpoint(\"mock:result\").expectedHeaderReceived(\"foo\", 123);\n        getMockEndpoint(\"mock:result\").expectedHeaderReceived(\"bar\", \"cool\");\n        getMockEndpoint(\"mock:result\").expectedHeaderReceived(Exchange.HTTP_RESPONSE_CODE, 200);\n        getMockEndpoint(\"mock:result\").expectedHeaderReceived(Exchange.CONTENT_LENGTH, 9);\n\n        Map<String, Object> headers = new HashMap<>();\n        headers.put(\"foo\", 123);\n        headers.put(\"bar\", \"cool\");\n\n        template.sendBodyAndHeaders(\"direct:start\", \"World\", headers);\n\n        assertMockEndpointsSatisfied();\n    }"
        ],
        [
            "AmazonLambdaClientMock::invoke(InvokeRequest)",
            " 209  \n 210  \n 211  \n 212  \n 213 -\n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  ",
            "    @Override\n    public InvokeResult invoke(InvokeRequest invokeRequest) {\n        InvokeResult result = new InvokeResult();\n\n        Map<String, Object> payload = new HashMap<String, Object>();\n        try {\n            ObjectMapper mapper = new ObjectMapper();\n            payload = mapper.readValue(StandardCharsets.UTF_8.decode(invokeRequest.getPayload()).toString(), new TypeReference<Map<String, String>>() {\n            });\n        } catch (Exception e) {\n\n        }\n        String responsePayload = \"{\\\"Hello\\\":\\\"\" + payload.get(\"name\") + \"\\\"}\";\n        result.setPayload(ByteBuffer.wrap(responsePayload.getBytes()));\n        return result;\n    }",
            " 209  \n 210  \n 211  \n 212  \n 213 +\n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  ",
            "    @Override\n    public InvokeResult invoke(InvokeRequest invokeRequest) {\n        InvokeResult result = new InvokeResult();\n\n        Map<String, Object> payload = new HashMap<>();\n        try {\n            ObjectMapper mapper = new ObjectMapper();\n            payload = mapper.readValue(StandardCharsets.UTF_8.decode(invokeRequest.getPayload()).toString(), new TypeReference<Map<String, String>>() {\n            });\n        } catch (Exception e) {\n\n        }\n        String responsePayload = \"{\\\"Hello\\\":\\\"\" + payload.get(\"name\") + \"\\\"}\";\n        result.setPayload(ByteBuffer.wrap(responsePayload.getBytes()));\n        return result;\n    }"
        ],
        [
            "AmazonEC2ClientMock::unmonitorInstances(UnmonitorInstancesRequest)",
            " 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293 -\n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  ",
            "    @Override\n    public UnmonitorInstancesResult unmonitorInstances(UnmonitorInstancesRequest unmonitorInstancesRequest) {\n        UnmonitorInstancesResult result = new UnmonitorInstancesResult();\n        if (!unmonitorInstancesRequest.getInstanceIds().isEmpty()) {\n            Collection<InstanceMonitoring> coll = new ArrayList<>();\n            Iterator<String> it = unmonitorInstancesRequest.getInstanceIds().iterator();\n            while (it.hasNext()) {\n                String id = (String) it.next();\n                InstanceMonitoring mon = new InstanceMonitoring();\n                mon.setInstanceId(id);\n                Monitoring monitoring = new Monitoring();\n                monitoring.setState(MonitoringState.Disabled);\n                mon.setMonitoring(monitoring); \n                coll.add(mon);\n            }\n            result.setInstanceMonitorings(coll);\n        }\n        return result;\n    }",
            " 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293 +\n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  ",
            "    @Override\n    public UnmonitorInstancesResult unmonitorInstances(UnmonitorInstancesRequest unmonitorInstancesRequest) {\n        UnmonitorInstancesResult result = new UnmonitorInstancesResult();\n        if (!unmonitorInstancesRequest.getInstanceIds().isEmpty()) {\n            Collection<InstanceMonitoring> coll = new ArrayList<>();\n            Iterator<String> it = unmonitorInstancesRequest.getInstanceIds().iterator();\n            while (it.hasNext()) {\n                String id = it.next();\n                InstanceMonitoring mon = new InstanceMonitoring();\n                mon.setInstanceId(id);\n                Monitoring monitoring = new Monitoring();\n                monitoring.setState(MonitoringState.Disabled);\n                mon.setMonitoring(monitoring); \n                coll.add(mon);\n            }\n            result.setInstanceMonitorings(coll);\n        }\n        return result;\n    }"
        ],
        [
            "AtmosConfigurationValidator::validateCommonProperties(AtmosConfiguration)",
            "  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68 -\n  69  \n  70  \n  71  \n  72  \n  73  ",
            "    private static void validateCommonProperties(AtmosConfiguration configuration) throws AtmosException {\n        if (configuration.getFullTokenId() == null || configuration.getFullTokenId().equals(\"\")) {\n            throw new AtmosException(\"option <fullTokenId> is not present or not valid!\");\n        }\n        if (configuration.getSecretKey() == null || configuration.getSecretKey().equals(\"\")) {\n            throw new AtmosException(\"option <secretKey> is not present or not valid!\");\n        }\n        if (configuration.getUri() == null || configuration.getUri().equals(\"\")) {\n            throw new AtmosException(\"option <uri> is not present!\");\n        } else {\n            try {\n                URI uri = new URI(configuration.getUri());\n            } catch (URISyntaxException use) {\n                throw new AtmosException(\"option <uri> is not valid!\", use);\n            }\n        }\n    }",
            "  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68 +\n  69  \n  70  \n  71  \n  72  \n  73  ",
            "    private static void validateCommonProperties(AtmosConfiguration configuration) throws AtmosException {\n        if (configuration.getFullTokenId() == null || configuration.getFullTokenId().equals(\"\")) {\n            throw new AtmosException(\"option <fullTokenId> is not present or not valid!\");\n        }\n        if (configuration.getSecretKey() == null || configuration.getSecretKey().equals(\"\")) {\n            throw new AtmosException(\"option <secretKey> is not present or not valid!\");\n        }\n        if (configuration.getUri() == null || configuration.getUri().equals(\"\")) {\n            throw new AtmosException(\"option <uri> is not present!\");\n        } else {\n            try {\n                new URI(configuration.getUri());\n            } catch (URISyntaxException use) {\n                throw new AtmosException(\"option <uri> is not valid!\", use);\n            }\n        }\n    }"
        ],
        [
            "AmazonDDBClientMock::batchGetItem(BatchGetItemRequest)",
            " 160  \n 161  \n 162  \n 163  \n 164 -\n 165 -\n 166  \n 167  \n 168 -\n 169  \n 170 -\n 171  \n 172  \n 173  \n 174  \n 175  \n 176  ",
            "    @SuppressWarnings(\"unchecked\")\n    @Override\n    public BatchGetItemResult batchGetItem(BatchGetItemRequest batchGetItemRequest) {\n        this.batchGetItemRequest = batchGetItemRequest;\n        Map<String, List<Map<String, AttributeValue>>> responseMap = new HashMap<String, List<Map<String, AttributeValue>>>();\n        List<Map<String, AttributeValue>> p = new ArrayList<Map<String, AttributeValue>>();\n        p.add(getAttributes());\n        responseMap.put(\"DOMAIN1\", p);\n        Map<String, AttributeValue> keysMap = new HashMap<String, AttributeValue>();\n        keysMap.put(\"1\", new AttributeValue(\"UNPROCESSED_KEY\"));\n        Map<String, KeysAndAttributes> unprocessedKeys = new HashMap<String, KeysAndAttributes>();\n        unprocessedKeys.put(\"DOMAIN1\", new KeysAndAttributes().withKeys(keysMap));\n\n        return new BatchGetItemResult()\n                .withResponses(responseMap)\n                .withUnprocessedKeys(unprocessedKeys);\n    }",
            " 160  \n 161  \n 162  \n 163  \n 164 +\n 165 +\n 166  \n 167  \n 168 +\n 169  \n 170 +\n 171  \n 172  \n 173  \n 174  \n 175  \n 176  ",
            "    @SuppressWarnings(\"unchecked\")\n    @Override\n    public BatchGetItemResult batchGetItem(BatchGetItemRequest batchGetItemRequest) {\n        this.batchGetItemRequest = batchGetItemRequest;\n        Map<String, List<Map<String, AttributeValue>>> responseMap = new HashMap<>();\n        List<Map<String, AttributeValue>> p = new ArrayList<>();\n        p.add(getAttributes());\n        responseMap.put(\"DOMAIN1\", p);\n        Map<String, AttributeValue> keysMap = new HashMap<>();\n        keysMap.put(\"1\", new AttributeValue(\"UNPROCESSED_KEY\"));\n        Map<String, KeysAndAttributes> unprocessedKeys = new HashMap<>();\n        unprocessedKeys.put(\"DOMAIN1\", new KeysAndAttributes().withKeys(keysMap));\n\n        return new BatchGetItemResult()\n                .withResponses(responseMap)\n                .withUnprocessedKeys(unprocessedKeys);\n    }"
        ],
        [
            "AmazonEC2ClientMock::terminateInstances(TerminateInstancesRequest)",
            " 164  \n 165  \n 166  \n 167  \n 168 -\n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  ",
            "    @Override\n    public TerminateInstancesResult terminateInstances(TerminateInstancesRequest terminateInstancesRequest) {\n        TerminateInstancesResult result = new TerminateInstancesResult();\n        if (terminateInstancesRequest.getInstanceIds().contains(\"test-1\")) {\n            Collection<InstanceStateChange> coll = new ArrayList<InstanceStateChange>();\n            InstanceStateChange sc = new InstanceStateChange();\n            InstanceState previousState = new InstanceState();\n            previousState.setCode(80);\n            previousState.setName(InstanceStateName.Running);\n            InstanceState newState = new InstanceState();\n            newState.setCode(16);\n            newState.setName(InstanceStateName.Terminated);\n            sc.setPreviousState(previousState);\n            sc.setCurrentState(newState);\n            sc.setInstanceId(\"test-1\");\n            coll.add(sc);\n            result.setTerminatingInstances(coll);\n        } else {\n            throw new AmazonServiceException(\"The image-id doesn't exists\");\n        }\n        return result;    \n    }",
            " 164  \n 165  \n 166  \n 167  \n 168 +\n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  ",
            "    @Override\n    public TerminateInstancesResult terminateInstances(TerminateInstancesRequest terminateInstancesRequest) {\n        TerminateInstancesResult result = new TerminateInstancesResult();\n        if (terminateInstancesRequest.getInstanceIds().contains(\"test-1\")) {\n            Collection<InstanceStateChange> coll = new ArrayList<>();\n            InstanceStateChange sc = new InstanceStateChange();\n            InstanceState previousState = new InstanceState();\n            previousState.setCode(80);\n            previousState.setName(InstanceStateName.Running);\n            InstanceState newState = new InstanceState();\n            newState.setCode(16);\n            newState.setName(InstanceStateName.Terminated);\n            sc.setPreviousState(previousState);\n            sc.setCurrentState(newState);\n            sc.setInstanceId(\"test-1\");\n            coll.add(sc);\n            result.setTerminatingInstances(coll);\n        } else {\n            throw new AmazonServiceException(\"The image-id doesn't exists\");\n        }\n        return result;    \n    }"
        ],
        [
            "BlobServiceProducer::commitBlobBlockList(Exchange)",
            " 187  \n 188  \n 189  \n 190  \n 191  \n 192 -\n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  ",
            "    private void commitBlobBlockList(Exchange exchange) throws Exception {\n        Object object = exchange.getIn().getMandatoryBody();\n        \n        List<BlockEntry> blockEntries = null;\n        if (object instanceof List) {\n            blockEntries = (List<BlockEntry>)blockEntries;\n        } else if (object instanceof BlockEntry) {\n            blockEntries = Collections.singletonList((BlockEntry)object);\n        } \n        if (blockEntries == null || blockEntries.isEmpty()) {\n            throw new IllegalArgumentException(\"Illegal commit block list payload\");\n        }\n        \n        CloudBlockBlob client = BlobServiceUtil.createBlockBlobClient(getConfiguration());\n        BlobServiceRequestOptions opts = BlobServiceUtil.getRequestOptions(exchange);\n        \n        LOG.trace(\"Putting a blob [{}] block list from exchange [{}]...\", getConfiguration().getBlobName(), exchange);\n        client.commitBlockList(blockEntries, \n                               opts.getAccessCond(), opts.getRequestOpts(), opts.getOpContext());\n    }",
            " 187  \n 188  \n 189  \n 190  \n 191  \n 192 +\n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  ",
            "    private void commitBlobBlockList(Exchange exchange) throws Exception {\n        Object object = exchange.getIn().getMandatoryBody();\n        \n        List<BlockEntry> blockEntries = null;\n        if (object instanceof List) {\n            blockEntries = blockEntries;\n        } else if (object instanceof BlockEntry) {\n            blockEntries = Collections.singletonList((BlockEntry)object);\n        } \n        if (blockEntries == null || blockEntries.isEmpty()) {\n            throw new IllegalArgumentException(\"Illegal commit block list payload\");\n        }\n        \n        CloudBlockBlob client = BlobServiceUtil.createBlockBlobClient(getConfiguration());\n        BlobServiceRequestOptions opts = BlobServiceUtil.getRequestOptions(exchange);\n        \n        LOG.trace(\"Putting a blob [{}] block list from exchange [{}]...\", getConfiguration().getBlobName(), exchange);\n        client.commitBlockList(blockEntries, \n                               opts.getAccessCond(), opts.getRequestOpts(), opts.getOpContext());\n    }"
        ],
        [
            "EC2ComponentIntegrationTest::createAndRunInstancesWithSecurityGroupsTest()",
            "  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58 -\n  59  \n  60  \n  61  \n  62  \n  63  \n  64  ",
            "    @Test\n    public void createAndRunInstancesWithSecurityGroupsTest() {\n        \n        template.send(\"direct:createAndRun\", new Processor() {\n            public void process(Exchange exchange) throws Exception {\n                exchange.getIn().setHeader(EC2Constants.IMAGE_ID, \"ami-fd65ba94\");\n                exchange.getIn().setHeader(EC2Constants.INSTANCE_TYPE, InstanceType.T2Micro);\n                exchange.getIn().setHeader(EC2Constants.INSTANCE_MIN_COUNT, 1); \n                exchange.getIn().setHeader(EC2Constants.INSTANCE_MAX_COUNT, 1);  \n                Collection<String> secGroups = new ArrayList<String>();\n                secGroups.add(\"secgroup-1\");\n                secGroups.add(\"secgroup-2\");\n                exchange.getIn().setHeader(EC2Constants.INSTANCE_SECURITY_GROUPS, secGroups);\n            }\n        });\n    }",
            "  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58 +\n  59  \n  60  \n  61  \n  62  \n  63  \n  64  ",
            "    @Test\n    public void createAndRunInstancesWithSecurityGroupsTest() {\n        \n        template.send(\"direct:createAndRun\", new Processor() {\n            public void process(Exchange exchange) throws Exception {\n                exchange.getIn().setHeader(EC2Constants.IMAGE_ID, \"ami-fd65ba94\");\n                exchange.getIn().setHeader(EC2Constants.INSTANCE_TYPE, InstanceType.T2Micro);\n                exchange.getIn().setHeader(EC2Constants.INSTANCE_MIN_COUNT, 1); \n                exchange.getIn().setHeader(EC2Constants.INSTANCE_MAX_COUNT, 1);  \n                Collection<String> secGroups = new ArrayList<>();\n                secGroups.add(\"secgroup-1\");\n                secGroups.add(\"secgroup-2\");\n                exchange.getIn().setHeader(EC2Constants.INSTANCE_SECURITY_GROUPS, secGroups);\n            }\n        });\n    }"
        ],
        [
            "SqsConsumer::createExchanges(List)",
            " 130  \n 131  \n 132  \n 133  \n 134  \n 135 -\n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  ",
            "    protected Queue<Exchange> createExchanges(List<Message> messages) {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Received {} messages in this poll\", messages.size());\n        }\n        \n        Queue<Exchange> answer = new LinkedList<Exchange>();\n        for (Message message : messages) {\n            Exchange exchange = getEndpoint().createExchange(message);\n            answer.add(exchange);\n        }\n\n        return answer;\n    }",
            " 130  \n 131  \n 132  \n 133  \n 134  \n 135 +\n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  ",
            "    protected Queue<Exchange> createExchanges(List<Message> messages) {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Received {} messages in this poll\", messages.size());\n        }\n        \n        Queue<Exchange> answer = new LinkedList<>();\n        for (Message message : messages) {\n            Exchange exchange = getEndpoint().createExchange(message);\n            answer.add(exchange);\n        }\n\n        return answer;\n    }"
        ],
        [
            "PutAttributesCommandTest::executeWithoutItemName()",
            "  68  \n  69  \n  70 -\n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  ",
            "    @Test(expected = IllegalArgumentException.class)\n    public void executeWithoutItemName() {\n        List<ReplaceableAttribute> replaceableAttributes = new ArrayList<ReplaceableAttribute>();\n        replaceableAttributes.add(new ReplaceableAttribute(\"NAME1\", \"VALUE1\", true));\n        exchange.getIn().setHeader(SdbConstants.REPLACEABLE_ATTRIBUTES, replaceableAttributes);\n        UpdateCondition updateCondition = new UpdateCondition(\"NAME1\", \"VALUE1\", true);\n        exchange.getIn().setHeader(SdbConstants.UPDATE_CONDITION, updateCondition);\n        \n        command.execute();\n    }",
            "  68  \n  69  \n  70 +\n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  ",
            "    @Test(expected = IllegalArgumentException.class)\n    public void executeWithoutItemName() {\n        List<ReplaceableAttribute> replaceableAttributes = new ArrayList<>();\n        replaceableAttributes.add(new ReplaceableAttribute(\"NAME1\", \"VALUE1\", true));\n        exchange.getIn().setHeader(SdbConstants.REPLACEABLE_ATTRIBUTES, replaceableAttributes);\n        UpdateCondition updateCondition = new UpdateCondition(\"NAME1\", \"VALUE1\", true);\n        exchange.getIn().setHeader(SdbConstants.UPDATE_CONDITION, updateCondition);\n        \n        command.execute();\n    }"
        ],
        [
            "PutAttributesCommandTest::determineReplaceableAttributes()",
            "  79  \n  80  \n  81  \n  82  \n  83 -\n  84  \n  85  \n  86  \n  87  \n  88  ",
            "    @Test\n    public void determineReplaceableAttributes() {\n        assertNull(this.command.determineReplaceableAttributes());\n\n        List<ReplaceableAttribute> replaceableAttributes = new ArrayList<ReplaceableAttribute>();\n        replaceableAttributes.add(new ReplaceableAttribute(\"NAME1\", \"VALUE1\", true));\n        exchange.getIn().setHeader(SdbConstants.REPLACEABLE_ATTRIBUTES, replaceableAttributes);\n\n        assertEquals(replaceableAttributes, this.command.determineReplaceableAttributes());\n    }",
            "  79  \n  80  \n  81  \n  82  \n  83 +\n  84  \n  85  \n  86  \n  87  \n  88  ",
            "    @Test\n    public void determineReplaceableAttributes() {\n        assertNull(this.command.determineReplaceableAttributes());\n\n        List<ReplaceableAttribute> replaceableAttributes = new ArrayList<>();\n        replaceableAttributes.add(new ReplaceableAttribute(\"NAME1\", \"VALUE1\", true));\n        exchange.getIn().setHeader(SdbConstants.REPLACEABLE_ATTRIBUTES, replaceableAttributes);\n\n        assertEquals(replaceableAttributes, this.command.determineReplaceableAttributes());\n    }"
        ],
        [
            "BlobServiceProducer::configureCloudBlobForWrite(CloudBlob)",
            " 433  \n 434  \n 435  \n 436  \n 437  \n 438 -\n 439  \n 440  ",
            "    private void configureCloudBlobForWrite(CloudBlob client) {\n        if (getConfiguration().getStreamWriteSize() > 0) {\n            client.setStreamWriteSizeInBytes(getConfiguration().getStreamWriteSize());\n        }\n        if (getConfiguration().getBlobMetadata() != null) {\n            client.setMetadata(new HashMap<String, String>(getConfiguration().getBlobMetadata()));\n        }\n    }",
            " 433  \n 434  \n 435  \n 436  \n 437  \n 438 +\n 439  \n 440  ",
            "    private void configureCloudBlobForWrite(CloudBlob client) {\n        if (getConfiguration().getStreamWriteSize() > 0) {\n            client.setStreamWriteSizeInBytes(getConfiguration().getStreamWriteSize());\n        }\n        if (getConfiguration().getBlobMetadata() != null) {\n            client.setMetadata(new HashMap<>(getConfiguration().getBlobMetadata()));\n        }\n    }"
        ],
        [
            "BatchDeleteAttributesCommandTest::execute()",
            "  50  \n  51  \n  52 -\n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  ",
            "    @Test\n    public void execute() {\n        List<Item> deletableItems = new ArrayList<Item>();\n        deletableItems.add(new Item());\n        exchange.getIn().setHeader(SdbConstants.DELETABLE_ITEMS, deletableItems);\n        \n        command.execute();\n        \n        assertEquals(\"DOMAIN1\", sdbClient.batchDeleteAttributesRequest.getDomainName());\n        assertEquals(deletableItems, sdbClient.batchDeleteAttributesRequest.getItems());\n    }",
            "  50  \n  51  \n  52 +\n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  ",
            "    @Test\n    public void execute() {\n        List<Item> deletableItems = new ArrayList<>();\n        deletableItems.add(new Item());\n        exchange.getIn().setHeader(SdbConstants.DELETABLE_ITEMS, deletableItems);\n        \n        command.execute();\n        \n        assertEquals(\"DOMAIN1\", sdbClient.batchDeleteAttributesRequest.getDomainName());\n        assertEquals(deletableItems, sdbClient.batchDeleteAttributesRequest.getItems());\n    }"
        ],
        [
            "BatchPutAttributesCommandTest::determineReplaceableItems()",
            "  62  \n  63  \n  64  \n  65  \n  66 -\n  67  \n  68  \n  69  \n  70  \n  71  ",
            "    @Test\n    public void determineReplaceableItems() {\n        assertNull(this.command.determineReplaceableItems());\n        \n        List<ReplaceableItem> replaceableItems = new ArrayList<ReplaceableItem>();\n        replaceableItems.add(new ReplaceableItem(\"ITEM1\"));\n        exchange.getIn().setHeader(SdbConstants.REPLACEABLE_ITEMS, replaceableItems);\n        \n        assertEquals(replaceableItems, this.command.determineReplaceableItems());\n    }",
            "  62  \n  63  \n  64  \n  65  \n  66 +\n  67  \n  68  \n  69  \n  70  \n  71  ",
            "    @Test\n    public void determineReplaceableItems() {\n        assertNull(this.command.determineReplaceableItems());\n        \n        List<ReplaceableItem> replaceableItems = new ArrayList<>();\n        replaceableItems.add(new ReplaceableItem(\"ITEM1\"));\n        exchange.getIn().setHeader(SdbConstants.REPLACEABLE_ITEMS, replaceableItems);\n        \n        assertEquals(replaceableItems, this.command.determineReplaceableItems());\n    }"
        ],
        [
            "TestClient::getReceived(Class)",
            "  91  \n  92 -\n  93  \n  94  \n  95  \n  96  \n  97  ",
            "    public <T> List<T> getReceived(Class<T> cls) {\n        List<T> list = new ArrayList<T>();\n        for (Object o : received) {\n            list.add(getValue(o, cls));\n        }\n        return list;\n    }",
            "  91  \n  92 +\n  93  \n  94  \n  95  \n  96  \n  97  ",
            "    public <T> List<T> getReceived(Class<T> cls) {\n        List<T> list = new ArrayList<>();\n        for (Object o : received) {\n            list.add(getValue(o, cls));\n        }\n        return list;\n    }"
        ],
        [
            "AvroDataFormat::unmarshal(Exchange,InputStream)",
            " 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145 -\n 146  \n 147  \n 148  \n 149  \n 150  ",
            "    public Object unmarshal(Exchange exchange, InputStream inputStream) throws Exception {\n        ObjectHelper.notNull(actualSchema, \"schema\", this);\n\n        ClassLoader classLoader = null;\n        Class<?> clazz = camelContext.getClassResolver().resolveClass(actualSchema.getFullName());\n\n        if (clazz != null) {\n            classLoader = clazz.getClassLoader();\n        }\n        SpecificData specificData = new SpecificDataNoCache(classLoader);\n        DatumReader<GenericRecord> reader = new SpecificDatumReader<GenericRecord>(null, null, specificData);\n        reader.setSchema(actualSchema);\n        Decoder decoder = DecoderFactory.get().binaryDecoder(inputStream, null);\n        Object result = reader.read(null, decoder);\n        return result;\n    }",
            " 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145 +\n 146  \n 147  \n 148  \n 149  \n 150  ",
            "    public Object unmarshal(Exchange exchange, InputStream inputStream) throws Exception {\n        ObjectHelper.notNull(actualSchema, \"schema\", this);\n\n        ClassLoader classLoader = null;\n        Class<?> clazz = camelContext.getClassResolver().resolveClass(actualSchema.getFullName());\n\n        if (clazz != null) {\n            classLoader = clazz.getClassLoader();\n        }\n        SpecificData specificData = new SpecificDataNoCache(classLoader);\n        DatumReader<GenericRecord> reader = new SpecificDatumReader<>(null, null, specificData);\n        reader.setSchema(actualSchema);\n        Decoder decoder = DecoderFactory.get().binaryDecoder(inputStream, null);\n        Object result = reader.read(null, decoder);\n        return result;\n    }"
        ],
        [
            "FakeAWSDaemon::UDPSocketListener::addAnnotationsIfAvailable(TestEntity,JsonObject)",
            " 195  \n 196  \n 197  \n 198  \n 199 -\n 200  \n 201  \n 202  ",
            "        private void addAnnotationsIfAvailable(TestEntity<?> entity, JsonObject json) {\n            if (json.has(\"annotations\")) {\n                JsonObject annotations = (JsonObject) json.get(\"annotations\");\n                for (String key : annotations.getKeys()) {\n                    entity.withAnnotation((String)key, annotations.get(key));\n                }\n            }\n        }",
            " 195  \n 196  \n 197  \n 198  \n 199 +\n 200  \n 201  \n 202  ",
            "        private void addAnnotationsIfAvailable(TestEntity<?> entity, JsonObject json) {\n            if (json.has(\"annotations\")) {\n                JsonObject annotations = (JsonObject) json.get(\"annotations\");\n                for (String key : annotations.getKeys()) {\n                    entity.withAnnotation(key, annotations.get(key));\n                }\n            }\n        }"
        ],
        [
            "DefaultAhcBinding::onHeadersReceived(AhcEndpoint,Exchange,HttpHeaders)",
            " 232  \n 233  \n 234 -\n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  ",
            "    @Override\n    public void onHeadersReceived(AhcEndpoint endpoint, Exchange exchange, HttpHeaders headers) throws Exception {\n        Map<String, List<String>> m = new TreeMap<String, List<String>>(String.CASE_INSENSITIVE_ORDER);\n        for (String name:headers.names()) {\n            List<String> values = headers.getAll(name);\n            if (values.size() == 1) {\n                exchange.getOut().getHeaders().put(name, values.get(0));\n            } else {\n                exchange.getOut().getHeaders().put(name, values);\n            }\n            m.put(name, values);\n        }\n        // handle cookies\n        if (endpoint.getCookieHandler() != null) {\n            try {\n                // creating the url to use takes 2-steps\n                String url = AhcHelper.createURL(exchange, endpoint);\n                URI uri = AhcHelper.createURI(exchange, url, endpoint);\n                endpoint.getCookieHandler().storeCookies(exchange, uri, m);\n            } catch (Exception e) {\n                throw new CamelExchangeException(\"Error storing cookies\", exchange, e);\n            }\n        }\n    }",
            " 232  \n 233  \n 234 +\n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  ",
            "    @Override\n    public void onHeadersReceived(AhcEndpoint endpoint, Exchange exchange, HttpHeaders headers) throws Exception {\n        Map<String, List<String>> m = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n        for (String name:headers.names()) {\n            List<String> values = headers.getAll(name);\n            if (values.size() == 1) {\n                exchange.getOut().getHeaders().put(name, values.get(0));\n            } else {\n                exchange.getOut().getHeaders().put(name, values);\n            }\n            m.put(name, values);\n        }\n        // handle cookies\n        if (endpoint.getCookieHandler() != null) {\n            try {\n                // creating the url to use takes 2-steps\n                String url = AhcHelper.createURL(exchange, endpoint);\n                URI uri = AhcHelper.createURI(exchange, url, endpoint);\n                endpoint.getCookieHandler().storeCookies(exchange, uri, m);\n            } catch (Exception e) {\n                throw new CamelExchangeException(\"Error storing cookies\", exchange, e);\n            }\n        }\n    }"
        ],
        [
            "AmazonS3ClientMock::listBuckets()",
            " 168  \n 169  \n 170 -\n 171  \n 172  \n 173  \n 174  \n 175  \n 176  ",
            "    @Override\n    public List<Bucket> listBuckets() throws AmazonClientException, AmazonServiceException {\n        ArrayList<Bucket> list = new ArrayList<Bucket>();\n        Bucket bucket = new Bucket(\"camel-bucket\");\n        bucket.setOwner(new Owner(\"Camel\", \"camel\"));\n        bucket.setCreationDate(new Date());\n        list.add(bucket);\n        return list;\n    }",
            " 168  \n 169  \n 170 +\n 171  \n 172  \n 173  \n 174  \n 175  \n 176  ",
            "    @Override\n    public List<Bucket> listBuckets() throws AmazonClientException, AmazonServiceException {\n        ArrayList<Bucket> list = new ArrayList<>();\n        Bucket bucket = new Bucket(\"camel-bucket\");\n        bucket.setOwner(new Owner(\"Camel\", \"camel\"));\n        bucket.setCreationDate(new Date());\n        list.add(bucket);\n        return list;\n    }"
        ],
        [
            "AtmosAPIFacade::get(String)",
            " 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219 -\n 220  \n 221  \n 222  \n 223  \n 224  \n 225  ",
            "    /**\n     * Get the content of every file inside the remote path.\n     *\n     * @param remotePath the remote path where to download from\n     * @return a AtmosResult object with the content (ByteArrayOutputStream) of\n     * every files inside the remote path.\n     * @throws AtmosException\n     */\n    public AtmosResult get(String remotePath) throws AtmosException {\n        AtmosResult result = new AtmosFileDownloadResult();\n        //a map representing for each path the result of the baos\n        Map<String, ByteArrayOutputStream> resultEntries = new HashMap<String, ByteArrayOutputStream>();\n        //iterate from the remotePath\n        downloadFilesInFolder(remotePath, resultEntries);\n        //put the map of baos as result\n        result.setResultEntries(resultEntries);\n        return result;\n    }",
            " 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219 +\n 220  \n 221  \n 222  \n 223  \n 224  \n 225  ",
            "    /**\n     * Get the content of every file inside the remote path.\n     *\n     * @param remotePath the remote path where to download from\n     * @return a AtmosResult object with the content (ByteArrayOutputStream) of\n     * every files inside the remote path.\n     * @throws AtmosException\n     */\n    public AtmosResult get(String remotePath) throws AtmosException {\n        AtmosResult result = new AtmosFileDownloadResult();\n        //a map representing for each path the result of the baos\n        Map<String, ByteArrayOutputStream> resultEntries = new HashMap<>();\n        //iterate from the remotePath\n        downloadFilesInFolder(remotePath, resultEntries);\n        //put the map of baos as result\n        result.setResultEntries(resultEntries);\n        return result;\n    }"
        ],
        [
            "GetItemCommandTest::execute()",
            "  48  \n  49  \n  50 -\n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  ",
            "    @Test\n    public void execute() {\n        Map<String, AttributeValue> key = new HashMap<String, AttributeValue>();\n        key.put(\"1\", new AttributeValue(\"Key_1\"));\n        exchange.getIn().setHeader(DdbConstants.KEY, key);\n\n        List<String> attrNames = Arrays.asList(\"attrName\");\n        exchange.getIn().setHeader(DdbConstants.ATTRIBUTE_NAMES, attrNames);\n        exchange.getIn().setHeader(DdbConstants.CONSISTENT_READ, true);\n\n        command.execute();\n\n        assertEquals(\"DOMAIN1\", ddbClient.getItemRequest.getTableName());\n        assertEquals(attrNames, ddbClient.getItemRequest.getAttributesToGet());\n        assertEquals(true, ddbClient.getItemRequest.getConsistentRead());\n        assertEquals(key, ddbClient.getItemRequest.getKey());\n        assertEquals(new AttributeValue(\"attrValue\"),\n                exchange.getIn().getHeader(DdbConstants.ATTRIBUTES, Map.class).get(\n                        \"attrName\"));\n    }",
            "  48  \n  49  \n  50 +\n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  ",
            "    @Test\n    public void execute() {\n        Map<String, AttributeValue> key = new HashMap<>();\n        key.put(\"1\", new AttributeValue(\"Key_1\"));\n        exchange.getIn().setHeader(DdbConstants.KEY, key);\n\n        List<String> attrNames = Arrays.asList(\"attrName\");\n        exchange.getIn().setHeader(DdbConstants.ATTRIBUTE_NAMES, attrNames);\n        exchange.getIn().setHeader(DdbConstants.CONSISTENT_READ, true);\n\n        command.execute();\n\n        assertEquals(\"DOMAIN1\", ddbClient.getItemRequest.getTableName());\n        assertEquals(attrNames, ddbClient.getItemRequest.getAttributesToGet());\n        assertEquals(true, ddbClient.getItemRequest.getConsistentRead());\n        assertEquals(key, ddbClient.getItemRequest.getKey());\n        assertEquals(new AttributeValue(\"attrValue\"),\n                exchange.getIn().getHeader(DdbConstants.ATTRIBUTES, Map.class).get(\n                        \"attrName\"));\n    }"
        ],
        [
            "PutAttributesCommandTest::execute()",
            "  51  \n  52  \n  53 -\n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  ",
            "    @Test\n    public void execute() {\n        List<ReplaceableAttribute> replaceableAttributes = new ArrayList<ReplaceableAttribute>();\n        replaceableAttributes.add(new ReplaceableAttribute(\"NAME1\", \"VALUE1\", true));\n        exchange.getIn().setHeader(SdbConstants.REPLACEABLE_ATTRIBUTES, replaceableAttributes);\n        exchange.getIn().setHeader(SdbConstants.ITEM_NAME, \"ITEM1\");\n        UpdateCondition updateCondition = new UpdateCondition(\"NAME1\", \"VALUE1\", true);\n        exchange.getIn().setHeader(SdbConstants.UPDATE_CONDITION, updateCondition);\n        \n        command.execute();\n        \n        assertEquals(\"DOMAIN1\", sdbClient.putAttributesRequest.getDomainName());\n        assertEquals(\"ITEM1\", sdbClient.putAttributesRequest.getItemName());\n        assertEquals(updateCondition, sdbClient.putAttributesRequest.getExpected());\n        assertEquals(replaceableAttributes, sdbClient.putAttributesRequest.getAttributes());\n    }",
            "  51  \n  52  \n  53 +\n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  ",
            "    @Test\n    public void execute() {\n        List<ReplaceableAttribute> replaceableAttributes = new ArrayList<>();\n        replaceableAttributes.add(new ReplaceableAttribute(\"NAME1\", \"VALUE1\", true));\n        exchange.getIn().setHeader(SdbConstants.REPLACEABLE_ATTRIBUTES, replaceableAttributes);\n        exchange.getIn().setHeader(SdbConstants.ITEM_NAME, \"ITEM1\");\n        UpdateCondition updateCondition = new UpdateCondition(\"NAME1\", \"VALUE1\", true);\n        exchange.getIn().setHeader(SdbConstants.UPDATE_CONDITION, updateCondition);\n        \n        command.execute();\n        \n        assertEquals(\"DOMAIN1\", sdbClient.putAttributesRequest.getDomainName());\n        assertEquals(\"ITEM1\", sdbClient.putAttributesRequest.getItemName());\n        assertEquals(updateCondition, sdbClient.putAttributesRequest.getExpected());\n        assertEquals(replaceableAttributes, sdbClient.putAttributesRequest.getAttributes());\n    }"
        ],
        [
            "TestClient::TestClient(String,AsyncHttpClientConfig,int)",
            "  57  \n  58 -\n  59  \n  60  \n  61  \n  62  ",
            "    public TestClient(String url, AsyncHttpClientConfig conf, int count) {\n        this.received = new ArrayList<Object>();\n        this.latch = new CountDownLatch(count);\n        this.client = conf == null ? new DefaultAsyncHttpClient() : new DefaultAsyncHttpClient(conf);\n        this.url = url;\n    }",
            "  57  \n  58 +\n  59  \n  60  \n  61  \n  62  ",
            "    public TestClient(String url, AsyncHttpClientConfig conf, int count) {\n        this.received = new ArrayList<>();\n        this.latch = new CountDownLatch(count);\n        this.client = conf == null ? new DefaultAsyncHttpClient() : new DefaultAsyncHttpClient(conf);\n        this.url = url;\n    }"
        ],
        [
            "AhcProduceGetHeadersTest::testAhcProduce()",
            "  28  \n  29  \n  30  \n  31  \n  32  \n  33  \n  34  \n  35  \n  36  \n  37 -\n  38  \n  39  \n  40  \n  41  \n  42  \n  43  \n  44  ",
            "    @Test\n    public void testAhcProduce() throws Exception {\n        getMockEndpoint(\"mock:result\").expectedBodiesReceived(\"Bye World\");\n        getMockEndpoint(\"mock:result\").expectedHeaderReceived(\"foo\", 123);\n        getMockEndpoint(\"mock:result\").expectedHeaderReceived(\"bar\", \"cool\");\n        getMockEndpoint(\"mock:result\").expectedHeaderReceived(Exchange.HTTP_RESPONSE_CODE, 200);\n        getMockEndpoint(\"mock:result\").expectedHeaderReceived(Exchange.HTTP_RESPONSE_TEXT, \"OK\");\n        getMockEndpoint(\"mock:result\").expectedHeaderReceived(Exchange.CONTENT_LENGTH, 9);\n\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(\"foo\", 123);\n        headers.put(\"bar\", \"cool\");\n\n        template.sendBodyAndHeaders(\"direct:start\", null, headers);\n\n        assertMockEndpointsSatisfied();\n    }",
            "  28  \n  29  \n  30  \n  31  \n  32  \n  33  \n  34  \n  35  \n  36  \n  37 +\n  38  \n  39  \n  40  \n  41  \n  42  \n  43  \n  44  ",
            "    @Test\n    public void testAhcProduce() throws Exception {\n        getMockEndpoint(\"mock:result\").expectedBodiesReceived(\"Bye World\");\n        getMockEndpoint(\"mock:result\").expectedHeaderReceived(\"foo\", 123);\n        getMockEndpoint(\"mock:result\").expectedHeaderReceived(\"bar\", \"cool\");\n        getMockEndpoint(\"mock:result\").expectedHeaderReceived(Exchange.HTTP_RESPONSE_CODE, 200);\n        getMockEndpoint(\"mock:result\").expectedHeaderReceived(Exchange.HTTP_RESPONSE_TEXT, \"OK\");\n        getMockEndpoint(\"mock:result\").expectedHeaderReceived(Exchange.CONTENT_LENGTH, 9);\n\n        Map<String, Object> headers = new HashMap<>();\n        headers.put(\"foo\", 123);\n        headers.put(\"bar\", \"cool\");\n\n        template.sendBodyAndHeaders(\"direct:start\", null, headers);\n\n        assertMockEndpointsSatisfied();\n    }"
        ],
        [
            "SnsProducer::translateAttributes(Map,Exchange)",
            "  90  \n  91 -\n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  ",
            "    Map<String, MessageAttributeValue> translateAttributes(Map<String, Object> headers, Exchange exchange) {\n        Map<String, MessageAttributeValue> result = new HashMap<String, MessageAttributeValue>();\n        HeaderFilterStrategy headerFilterStrategy = getEndpoint().getHeaderFilterStrategy();\n        for (Entry<String, Object> entry : headers.entrySet()) {\n            // only put the message header which is not filtered into the message attribute\n            if (!headerFilterStrategy.applyFilterToCamelHeaders(entry.getKey(), entry.getValue(), exchange)) {\n                Object value = entry.getValue();\n                if (value instanceof String && !((String)value).isEmpty()) {\n                    MessageAttributeValue mav = new MessageAttributeValue();\n                    mav.setDataType(\"String\");\n                    mav.withStringValue((String)value);\n                    result.put(entry.getKey(), mav);\n                } else if (value instanceof ByteBuffer) {\n                    MessageAttributeValue mav = new MessageAttributeValue();\n                    mav.setDataType(\"Binary\");\n                    mav.withBinaryValue((ByteBuffer)value);\n                    result.put(entry.getKey(), mav);\n                } else {\n                    // cannot translate the message header to message attribute value\n                    LOG.warn(\"Cannot put the message header key={}, value={} into Sns MessageAttribute\", entry.getKey(), entry.getValue());\n                }\n            }\n        }\n        return result;\n    }",
            "  90  \n  91 +\n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  ",
            "    Map<String, MessageAttributeValue> translateAttributes(Map<String, Object> headers, Exchange exchange) {\n        Map<String, MessageAttributeValue> result = new HashMap<>();\n        HeaderFilterStrategy headerFilterStrategy = getEndpoint().getHeaderFilterStrategy();\n        for (Entry<String, Object> entry : headers.entrySet()) {\n            // only put the message header which is not filtered into the message attribute\n            if (!headerFilterStrategy.applyFilterToCamelHeaders(entry.getKey(), entry.getValue(), exchange)) {\n                Object value = entry.getValue();\n                if (value instanceof String && !((String)value).isEmpty()) {\n                    MessageAttributeValue mav = new MessageAttributeValue();\n                    mav.setDataType(\"String\");\n                    mav.withStringValue((String)value);\n                    result.put(entry.getKey(), mav);\n                } else if (value instanceof ByteBuffer) {\n                    MessageAttributeValue mav = new MessageAttributeValue();\n                    mav.setDataType(\"Binary\");\n                    mav.withBinaryValue((ByteBuffer)value);\n                    result.put(entry.getKey(), mav);\n                } else {\n                    // cannot translate the message header to message attribute value\n                    LOG.warn(\"Cannot put the message header key={}, value={} into Sns MessageAttribute\", entry.getKey(), entry.getValue());\n                }\n            }\n        }\n        return result;\n    }"
        ],
        [
            "SqsEndpointTest::createQueueShouldCreateFifoQueueWithoutContentBasedDeduplication()",
            "  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104 -\n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  ",
            "    @Test\n    public void createQueueShouldCreateFifoQueueWithoutContentBasedDeduplication() {\n        config.setQueueName(\"test-queue.fifo\");\n        config.setMessageDeduplicationIdStrategy(\"useExchangeId\");\n\n        CreateQueueRequest expectedCreateQueueRequest = new CreateQueueRequest(\"test-queue.fifo\")\n                .addAttributesEntry(QueueAttributeName.FifoQueue.name(), \"true\")\n                .addAttributesEntry(QueueAttributeName.ContentBasedDeduplication.name(), \"false\");\n        Mockito.when(amazonSQSClient.createQueue(Mockito.any(CreateQueueRequest.class)))\n                .thenReturn(new CreateQueueResult()\n                                .withQueueUrl(\"https://sqs.us-east-1.amazonaws.com/111222333/test-queue.fifo\"));\n\n        endpoint.createQueue(amazonSQSClient);\n\n        Mockito.verify(amazonSQSClient).createQueue(expectedCreateQueueRequest);\n        assertEquals(\"https://sqs.us-east-1.amazonaws.com/111222333/test-queue.fifo\", endpoint.getQueueUrl());\n    }",
            "  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105 +\n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  ",
            "    @Test\n    public void createQueueShouldCreateFifoQueueWithoutContentBasedDeduplication() {\n        config.setQueueName(\"test-queue.fifo\");\n        config.setMessageDeduplicationIdStrategy(\"useExchangeId\");\n\n        CreateQueueRequest expectedCreateQueueRequest = new CreateQueueRequest(\"test-queue.fifo\")\n                .addAttributesEntry(QueueAttributeName.FifoQueue.name(), \"true\")\n                .addAttributesEntry(QueueAttributeName.ContentBasedDeduplication.name(), \"false\");\n        Mockito.when(amazonSQSClient.createQueue(ArgumentMatchers.any(CreateQueueRequest.class)))\n                .thenReturn(new CreateQueueResult()\n                                .withQueueUrl(\"https://sqs.us-east-1.amazonaws.com/111222333/test-queue.fifo\"));\n\n        endpoint.createQueue(amazonSQSClient);\n\n        Mockito.verify(amazonSQSClient).createQueue(expectedCreateQueueRequest);\n        assertEquals(\"https://sqs.us-east-1.amazonaws.com/111222333/test-queue.fifo\", endpoint.getQueueUrl());\n    }"
        ],
        [
            "AmazonS3EncryptionClientMock::listBuckets()",
            " 169  \n 170  \n 171 -\n 172  \n 173  \n 174  \n 175  \n 176  \n 177  ",
            "    @Override\n    public List<Bucket> listBuckets() throws AmazonClientException, AmazonServiceException {\n        ArrayList<Bucket> list = new ArrayList<Bucket>();\n        Bucket bucket = new Bucket(\"camel-bucket\");\n        bucket.setOwner(new Owner(\"Camel\", \"camel\"));\n        bucket.setCreationDate(new Date());\n        list.add(bucket);\n        return list;\n    }",
            " 169  \n 170  \n 171 +\n 172  \n 173  \n 174  \n 175  \n 176  \n 177  ",
            "    @Override\n    public List<Bucket> listBuckets() throws AmazonClientException, AmazonServiceException {\n        ArrayList<Bucket> list = new ArrayList<>();\n        Bucket bucket = new Bucket(\"camel-bucket\");\n        bucket.setOwner(new Owner(\"Camel\", \"camel\"));\n        bucket.setCreationDate(new Date());\n        list.add(bucket);\n        return list;\n    }"
        ],
        [
            "SqsProducer::translateAttributes(Map,Exchange)",
            " 121  \n 122 -\n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  ",
            "    Map<String, MessageAttributeValue> translateAttributes(Map<String, Object> headers, Exchange exchange) {\n        Map<String, MessageAttributeValue> result = new HashMap<String, MessageAttributeValue>();\n        HeaderFilterStrategy headerFilterStrategy = getEndpoint().getHeaderFilterStrategy();\n        for (Entry<String, Object> entry : headers.entrySet()) {\n            // only put the message header which is not filtered into the message attribute\n            if (!headerFilterStrategy.applyFilterToCamelHeaders(entry.getKey(), entry.getValue(), exchange)) {\n                Object value = entry.getValue();\n                if (value instanceof String && !((String)value).isEmpty()) {\n                    MessageAttributeValue mav = new MessageAttributeValue();\n                    mav.setDataType(\"String\");\n                    mav.withStringValue((String)value);\n                    result.put(entry.getKey(), mav);\n                } else if (value instanceof ByteBuffer) {\n                    MessageAttributeValue mav = new MessageAttributeValue();\n                    mav.setDataType(\"Binary\");\n                    mav.withBinaryValue((ByteBuffer)value);\n                    result.put(entry.getKey(), mav);\n                } else if (value instanceof Number) {\n                    MessageAttributeValue mav = new MessageAttributeValue();\n                    mav.setDataType(\"Number\");\n                    mav.withStringValue(((Number)value).toString());\n                    result.put(entry.getKey(), mav);\n                } else {\n                    // cannot translate the message header to message attribute value\n                    LOG.warn(\"Cannot put the message header key={}, value={} into Sqs MessageAttribute\", entry.getKey(), entry.getValue());\n                }\n            }\n        }\n        return result;\n    }",
            " 121  \n 122 +\n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  ",
            "    Map<String, MessageAttributeValue> translateAttributes(Map<String, Object> headers, Exchange exchange) {\n        Map<String, MessageAttributeValue> result = new HashMap<>();\n        HeaderFilterStrategy headerFilterStrategy = getEndpoint().getHeaderFilterStrategy();\n        for (Entry<String, Object> entry : headers.entrySet()) {\n            // only put the message header which is not filtered into the message attribute\n            if (!headerFilterStrategy.applyFilterToCamelHeaders(entry.getKey(), entry.getValue(), exchange)) {\n                Object value = entry.getValue();\n                if (value instanceof String && !((String)value).isEmpty()) {\n                    MessageAttributeValue mav = new MessageAttributeValue();\n                    mav.setDataType(\"String\");\n                    mav.withStringValue((String)value);\n                    result.put(entry.getKey(), mav);\n                } else if (value instanceof ByteBuffer) {\n                    MessageAttributeValue mav = new MessageAttributeValue();\n                    mav.setDataType(\"Binary\");\n                    mav.withBinaryValue((ByteBuffer)value);\n                    result.put(entry.getKey(), mav);\n                } else if (value instanceof Number) {\n                    MessageAttributeValue mav = new MessageAttributeValue();\n                    mav.setDataType(\"Number\");\n                    mav.withStringValue(((Number)value).toString());\n                    result.put(entry.getKey(), mav);\n                } else {\n                    // cannot translate the message header to message attribute value\n                    LOG.warn(\"Cannot put the message header key={}, value={} into Sqs MessageAttribute\", entry.getKey(), entry.getValue());\n                }\n            }\n        }\n        return result;\n    }"
        ],
        [
            "SqsProducerTest::isAttributeMessageByteBufferHeaderOnTheRequest()",
            " 175  \n 176  \n 177 -\n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  ",
            "    @Test\n    public void isAttributeMessageByteBufferHeaderOnTheRequest() throws Exception {\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(SAMPLE_MESSAGE_HEADER_NAME_2, SAMPLE_MESSAGE_HEADER_VALUE_2);\n        when(inMessage.getHeaders()).thenReturn(headers);\n        underTest.process(exchange);\n        \n        ArgumentCaptor<SendMessageRequest> capture = ArgumentCaptor.forClass(SendMessageRequest.class);\n        verify(amazonSQSClient).sendMessage(capture.capture());\n        \n        assertEquals(SAMPLE_MESSAGE_HEADER_VALUE_2, capture.getValue().getMessageAttributes().get(SAMPLE_MESSAGE_HEADER_NAME_2).getBinaryValue());\n        assertNull(capture.getValue().getMessageAttributes().get(SAMPLE_MESSAGE_HEADER_NAME_2).getStringValue());\n    }",
            " 175  \n 176  \n 177 +\n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  ",
            "    @Test\n    public void isAttributeMessageByteBufferHeaderOnTheRequest() throws Exception {\n        Map<String, Object> headers = new HashMap<>();\n        headers.put(SAMPLE_MESSAGE_HEADER_NAME_2, SAMPLE_MESSAGE_HEADER_VALUE_2);\n        when(inMessage.getHeaders()).thenReturn(headers);\n        underTest.process(exchange);\n        \n        ArgumentCaptor<SendMessageRequest> capture = ArgumentCaptor.forClass(SendMessageRequest.class);\n        verify(amazonSQSClient).sendMessage(capture.capture());\n        \n        assertEquals(SAMPLE_MESSAGE_HEADER_VALUE_2, capture.getValue().getMessageAttributes().get(SAMPLE_MESSAGE_HEADER_NAME_2).getBinaryValue());\n        assertNull(capture.getValue().getMessageAttributes().get(SAMPLE_MESSAGE_HEADER_NAME_2).getStringValue());\n    }"
        ],
        [
            "BatchPutAttributesCommandTest::execute()",
            "  50  \n  51  \n  52 -\n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  ",
            "    @Test\n    public void execute() {\n        List<ReplaceableItem> replaceableItems = new ArrayList<ReplaceableItem>();\n        replaceableItems.add(new ReplaceableItem(\"ITEM1\"));\n        exchange.getIn().setHeader(SdbConstants.REPLACEABLE_ITEMS, replaceableItems);\n        \n        command.execute();\n        \n        assertEquals(\"DOMAIN1\", sdbClient.batchPutAttributesRequest.getDomainName());\n        assertEquals(replaceableItems, sdbClient.batchPutAttributesRequest.getItems());\n    }",
            "  50  \n  51  \n  52 +\n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  ",
            "    @Test\n    public void execute() {\n        List<ReplaceableItem> replaceableItems = new ArrayList<>();\n        replaceableItems.add(new ReplaceableItem(\"ITEM1\"));\n        exchange.getIn().setHeader(SdbConstants.REPLACEABLE_ITEMS, replaceableItems);\n        \n        command.execute();\n        \n        assertEquals(\"DOMAIN1\", sdbClient.batchPutAttributesRequest.getDomainName());\n        assertEquals(replaceableItems, sdbClient.batchPutAttributesRequest.getItems());\n    }"
        ],
        [
            "S3Consumer::createExchanges(S3Object)",
            " 107  \n 108 -\n 109  \n 110  \n 111  \n 112  ",
            "    protected Queue<Exchange> createExchanges(S3Object s3Object) {\n        Queue<Exchange> answer = new LinkedList<Exchange>();\n        Exchange exchange = getEndpoint().createExchange(s3Object);\n        answer.add(exchange);\n        return answer;\n    }",
            " 107  \n 108 +\n 109  \n 110  \n 111  \n 112  ",
            "    protected Queue<Exchange> createExchanges(S3Object s3Object) {\n        Queue<Exchange> answer = new LinkedList<>();\n        Exchange exchange = getEndpoint().createExchange(s3Object);\n        answer.add(exchange);\n        return answer;\n    }"
        ],
        [
            "GetAttributesCommandTest::executeWithoutItemName()",
            "  74  \n  75  \n  76 -\n  77  \n  78  \n  79  \n  80  \n  81  ",
            "    @Test(expected = IllegalArgumentException.class)\n    public void executeWithoutItemName() {\n        List<String> attributeNames = new ArrayList<String>();\n        attributeNames.add(\"ATTRIBUTE1\");\n        exchange.getIn().setHeader(SdbConstants.ATTRIBUTE_NAMES, attributeNames);\n        \n        command.execute();\n    }",
            "  74  \n  75  \n  76 +\n  77  \n  78  \n  79  \n  80  \n  81  ",
            "    @Test(expected = IllegalArgumentException.class)\n    public void executeWithoutItemName() {\n        List<String> attributeNames = new ArrayList<>();\n        attributeNames.add(\"ATTRIBUTE1\");\n        exchange.getIn().setHeader(SdbConstants.ATTRIBUTE_NAMES, attributeNames);\n        \n        command.execute();\n    }"
        ],
        [
            "GetAttributesCommandTest::execute()",
            "  51  \n  52  \n  53  \n  54 -\n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  ",
            "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void execute() {\n        List<String> attributeNames = new ArrayList<String>();\n        attributeNames.add(\"ATTRIBUTE1\");\n        exchange.getIn().setHeader(SdbConstants.ATTRIBUTE_NAMES, attributeNames);\n        exchange.getIn().setHeader(SdbConstants.ITEM_NAME, \"ITEM1\");\n        \n        command.execute();\n        \n        assertEquals(\"DOMAIN1\", sdbClient.getAttributesRequest.getDomainName());\n        assertEquals(\"ITEM1\", sdbClient.getAttributesRequest.getItemName());\n        assertEquals(Boolean.TRUE, sdbClient.getAttributesRequest.getConsistentRead());\n        assertEquals(attributeNames, sdbClient.getAttributesRequest.getAttributeNames());\n        \n        List<Attribute> attributes = exchange.getIn().getHeader(SdbConstants.ATTRIBUTES, List.class);\n        assertEquals(2, attributes.size());\n        assertEquals(\"AttributeOne\", attributes.get(0).getName());\n        assertEquals(\"Value One\", attributes.get(0).getValue());\n        assertEquals(\"AttributeTwo\", attributes.get(1).getName());\n        assertEquals(\"Value Two\", attributes.get(1).getValue());\n    }",
            "  51  \n  52  \n  53  \n  54 +\n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  ",
            "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void execute() {\n        List<String> attributeNames = new ArrayList<>();\n        attributeNames.add(\"ATTRIBUTE1\");\n        exchange.getIn().setHeader(SdbConstants.ATTRIBUTE_NAMES, attributeNames);\n        exchange.getIn().setHeader(SdbConstants.ITEM_NAME, \"ITEM1\");\n        \n        command.execute();\n        \n        assertEquals(\"DOMAIN1\", sdbClient.getAttributesRequest.getDomainName());\n        assertEquals(\"ITEM1\", sdbClient.getAttributesRequest.getItemName());\n        assertEquals(Boolean.TRUE, sdbClient.getAttributesRequest.getConsistentRead());\n        assertEquals(attributeNames, sdbClient.getAttributesRequest.getAttributeNames());\n        \n        List<Attribute> attributes = exchange.getIn().getHeader(SdbConstants.ATTRIBUTES, List.class);\n        assertEquals(2, attributes.size());\n        assertEquals(\"AttributeOne\", attributes.get(0).getName());\n        assertEquals(\"Value One\", attributes.get(0).getValue());\n        assertEquals(\"AttributeTwo\", attributes.get(1).getName());\n        assertEquals(\"Value Two\", attributes.get(1).getValue());\n    }"
        ],
        [
            "SqsEndpointTest::createQueueShouldCreateStandardQueueWithCorrectAttributes()",
            " 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130 -\n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  ",
            "    @Test\n    public void createQueueShouldCreateStandardQueueWithCorrectAttributes() {\n        config.setDefaultVisibilityTimeout(1000);\n        config.setMaximumMessageSize(128);\n        config.setMessageRetentionPeriod(1000);\n        config.setPolicy(\"{\\\"Version\\\": \\\"2012-10-17\\\"}\");\n        config.setReceiveMessageWaitTimeSeconds(5);\n        config.setRedrivePolicy(\"{ \\\"deadLetterTargetArn\\\" : String, \\\"maxReceiveCount\\\" : Integer }\");\n\n        CreateQueueRequest expectedCreateQueueRequest = new CreateQueueRequest(\"test-queue\")\n                .addAttributesEntry(QueueAttributeName.VisibilityTimeout.name(), \"1000\")\n                .addAttributesEntry(QueueAttributeName.MaximumMessageSize.name(), \"128\")\n                .addAttributesEntry(QueueAttributeName.MessageRetentionPeriod.name(), \"1000\")\n                .addAttributesEntry(QueueAttributeName.Policy.name(), \"{\\\"Version\\\": \\\"2012-10-17\\\"}\")\n                .addAttributesEntry(QueueAttributeName.ReceiveMessageWaitTimeSeconds.name(), \"5\")\n                .addAttributesEntry(QueueAttributeName.RedrivePolicy.name(), \"{ \\\"deadLetterTargetArn\\\" : String, \\\"maxReceiveCount\\\" : Integer }\");\n        Mockito.when(amazonSQSClient.createQueue(Mockito.any(CreateQueueRequest.class)))\n                .thenReturn(new CreateQueueResult()\n                                .withQueueUrl(\"https://sqs.us-east-1.amazonaws.com/111222333/test-queue\"));\n\n        endpoint.createQueue(amazonSQSClient);\n\n        Mockito.verify(amazonSQSClient).createQueue(expectedCreateQueueRequest);\n        assertEquals(\"https://sqs.us-east-1.amazonaws.com/111222333/test-queue\", endpoint.getQueueUrl());\n    }",
            " 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131 +\n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  ",
            "    @Test\n    public void createQueueShouldCreateStandardQueueWithCorrectAttributes() {\n        config.setDefaultVisibilityTimeout(1000);\n        config.setMaximumMessageSize(128);\n        config.setMessageRetentionPeriod(1000);\n        config.setPolicy(\"{\\\"Version\\\": \\\"2012-10-17\\\"}\");\n        config.setReceiveMessageWaitTimeSeconds(5);\n        config.setRedrivePolicy(\"{ \\\"deadLetterTargetArn\\\" : String, \\\"maxReceiveCount\\\" : Integer }\");\n\n        CreateQueueRequest expectedCreateQueueRequest = new CreateQueueRequest(\"test-queue\")\n                .addAttributesEntry(QueueAttributeName.VisibilityTimeout.name(), \"1000\")\n                .addAttributesEntry(QueueAttributeName.MaximumMessageSize.name(), \"128\")\n                .addAttributesEntry(QueueAttributeName.MessageRetentionPeriod.name(), \"1000\")\n                .addAttributesEntry(QueueAttributeName.Policy.name(), \"{\\\"Version\\\": \\\"2012-10-17\\\"}\")\n                .addAttributesEntry(QueueAttributeName.ReceiveMessageWaitTimeSeconds.name(), \"5\")\n                .addAttributesEntry(QueueAttributeName.RedrivePolicy.name(), \"{ \\\"deadLetterTargetArn\\\" : String, \\\"maxReceiveCount\\\" : Integer }\");\n        Mockito.when(amazonSQSClient.createQueue(ArgumentMatchers.any(CreateQueueRequest.class)))\n                .thenReturn(new CreateQueueResult()\n                                .withQueueUrl(\"https://sqs.us-east-1.amazonaws.com/111222333/test-queue\"));\n\n        endpoint.createQueue(amazonSQSClient);\n\n        Mockito.verify(amazonSQSClient).createQueue(expectedCreateQueueRequest);\n        assertEquals(\"https://sqs.us-east-1.amazonaws.com/111222333/test-queue\", endpoint.getQueueUrl());\n    }"
        ]
    ],
    "18a110cc4e78968b623564fe02484d54af7f906f": [
        [
            "CxfEndpoint::setupClientFactoryBean(ClientFactoryBean,Class)",
            " 476  \n 477  \n 478  \n 479  \n 480  \n 481  \n 482  \n 483  \n 484  \n 485  \n 486  \n 487  \n 488  \n 489  \n 490  \n 491  \n 492  \n 493  \n 494  \n 495  \n 496  \n 497  \n 498  \n 499  \n 500  \n 501  \n 502  \n 503  \n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512  \n 513  \n 514  \n 515  \n 516  \n 517  \n 518  \n 519  \n 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528  \n 529  \n 530  \n 531  \n 532  \n 533 -\n 534 -\n 535 -\n 536 -\n 537  \n 538  \n 539  \n 540  \n 541  \n 542  \n 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564  \n 565  \n 566  \n 567  \n 568  \n 569  \n 570  \n 571  \n 572  \n 573  \n 574  \n 575  \n 576  \n 577  \n 578  \n 579  \n 580  \n 581  \n 582  \n 583  \n 584  ",
            "    protected void setupClientFactoryBean(ClientFactoryBean factoryBean, Class<?> cls) {\n        if (cls != null) {\n            factoryBean.setServiceClass(cls);\n        }\n        factoryBean.setInInterceptors(in);\n        factoryBean.setOutInterceptors(out);\n        factoryBean.setOutFaultInterceptors(outFault);\n        factoryBean.setInFaultInterceptors(inFault);\n        factoryBean.setFeatures(features);\n        factoryBean.setTransportId(transportId);\n        factoryBean.setBindingId(bindingId);\n\n        if (bindingConfig != null) {\n            factoryBean.setBindingConfig(bindingConfig);\n        }\n\n        if (dataBinding != null) {\n            factoryBean.setDataBinding(dataBinding);\n        }\n\n        if (serviceFactoryBean != null) {\n            setServiceFactory(factoryBean, serviceFactoryBean);\n        }\n\n        // address\n        factoryBean.setAddress(getAddress());\n\n        // wsdl url\n        if (getWsdlURL() != null) {\n            factoryBean.setWsdlURL(getWsdlURL());\n        }\n\n        // service name qname\n        if (getServiceName() != null) {\n            factoryBean.setServiceName(getServiceName());\n        }\n\n        // port name qname\n        if (getPortName() != null) {\n            factoryBean.setEndpointName(getPortName());\n        }\n\n        // apply feature here\n        if (getDataFormat().dealias() == DataFormat.RAW) {\n            RAWDataFormatFeature feature = new RAWDataFormatFeature();\n            feature.addInIntercepters(getInInterceptors());\n            feature.addOutInterceptors(getOutInterceptors());\n            factoryBean.getFeatures().add(feature);\n        } else if (getDataFormat().dealias() == DataFormat.CXF_MESSAGE) {\n            factoryBean.getFeatures().add(new CXFMessageDataFormatFeature());\n            factoryBean.setDataBinding(new SourceDataBinding());\n        } else if (getDataFormat() == DataFormat.PAYLOAD) {\n            factoryBean.getFeatures().add(new PayLoadDataFormatFeature(allowStreaming));\n            factoryBean.setDataBinding(new HybridSourceDataBinding());\n        }\n\n        if (isLoggingFeatureEnabled()) {\n            if (getLoggingSizeLimit() != 0) {\n                factoryBean.getFeatures().add(new LoggingFeature(getLoggingSizeLimit()));\n            } else {\n                factoryBean.getFeatures().add(new LoggingFeature());\n            }\n        }\n\n        // set the document-literal wrapped style\n        if (getWrappedStyle() != null) {\n            setWrapped(factoryBean, getWrappedStyle());\n        }\n\n        // any optional properties\n        if (getProperties() != null) {\n            if (factoryBean.getProperties() != null) {\n                // add to existing properties\n                factoryBean.getProperties().putAll(getProperties());\n            } else {\n                factoryBean.setProperties(getProperties());\n            }\n            LOG.debug(\"ClientFactoryBean: {} added properties: {}\", factoryBean, getProperties());\n        }\n\n        // setup the basic authentication property\n        if (ObjectHelper.isNotEmpty(username)) {\n            AuthorizationPolicy authPolicy = new AuthorizationPolicy();\n            authPolicy.setUserName(username);\n            authPolicy.setPassword(password);\n            if (factoryBean.getProperties() == null) {\n                factoryBean.setProperties(new HashMap<String, Object>());\n            }\n            factoryBean.getProperties().put(AuthorizationPolicy.class.getName(), authPolicy);\n        }\n\n        if (this.isSkipPayloadMessagePartCheck()) {\n            if (factoryBean.getProperties() == null) {\n                factoryBean.setProperties(new HashMap<String, Object>());\n            }\n            factoryBean.getProperties().put(\"soap.no.validate.parts\", Boolean.TRUE);\n        }\n\n        if (this.isSkipFaultLogging()) {\n            if (factoryBean.getProperties() == null) {\n                factoryBean.setProperties(new HashMap<String, Object>());\n            }\n            factoryBean.getProperties().put(FaultListener.class.getName(), new NullFaultListener());\n        }\n\n        factoryBean.setBus(getBus());\n\n        getNullSafeCxfEndpointConfigurer().configure(factoryBean);\n    }",
            " 476  \n 477  \n 478  \n 479  \n 480  \n 481  \n 482  \n 483  \n 484  \n 485  \n 486  \n 487  \n 488  \n 489  \n 490  \n 491  \n 492  \n 493  \n 494  \n 495  \n 496  \n 497  \n 498  \n 499  \n 500  \n 501  \n 502  \n 503  \n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512  \n 513  \n 514  \n 515  \n 516  \n 517  \n 518  \n 519  \n 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528  \n 529  \n 530  \n 531  \n 532  \n 533 +\n 534 +\n 535 +\n 536 +\n 537  \n 538 +\n 539  \n 540  \n 541  \n 542  \n 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564  \n 565  \n 566  \n 567  \n 568  \n 569  \n 570  \n 571  \n 572  \n 573  \n 574  \n 575  \n 576  \n 577  \n 578  \n 579  \n 580  \n 581  \n 582  \n 583  \n 584  \n 585  ",
            "    protected void setupClientFactoryBean(ClientFactoryBean factoryBean, Class<?> cls) {\n        if (cls != null) {\n            factoryBean.setServiceClass(cls);\n        }\n        factoryBean.setInInterceptors(in);\n        factoryBean.setOutInterceptors(out);\n        factoryBean.setOutFaultInterceptors(outFault);\n        factoryBean.setInFaultInterceptors(inFault);\n        factoryBean.setFeatures(features);\n        factoryBean.setTransportId(transportId);\n        factoryBean.setBindingId(bindingId);\n\n        if (bindingConfig != null) {\n            factoryBean.setBindingConfig(bindingConfig);\n        }\n\n        if (dataBinding != null) {\n            factoryBean.setDataBinding(dataBinding);\n        }\n\n        if (serviceFactoryBean != null) {\n            setServiceFactory(factoryBean, serviceFactoryBean);\n        }\n\n        // address\n        factoryBean.setAddress(getAddress());\n\n        // wsdl url\n        if (getWsdlURL() != null) {\n            factoryBean.setWsdlURL(getWsdlURL());\n        }\n\n        // service name qname\n        if (getServiceName() != null) {\n            factoryBean.setServiceName(getServiceName());\n        }\n\n        // port name qname\n        if (getPortName() != null) {\n            factoryBean.setEndpointName(getPortName());\n        }\n\n        // apply feature here\n        if (getDataFormat().dealias() == DataFormat.RAW) {\n            RAWDataFormatFeature feature = new RAWDataFormatFeature();\n            feature.addInIntercepters(getInInterceptors());\n            feature.addOutInterceptors(getOutInterceptors());\n            factoryBean.getFeatures().add(feature);\n        } else if (getDataFormat().dealias() == DataFormat.CXF_MESSAGE) {\n            factoryBean.getFeatures().add(new CXFMessageDataFormatFeature());\n            factoryBean.setDataBinding(new SourceDataBinding());\n        } else if (getDataFormat() == DataFormat.PAYLOAD) {\n            factoryBean.getFeatures().add(new PayLoadDataFormatFeature(allowStreaming));\n            factoryBean.setDataBinding(new HybridSourceDataBinding());\n        }\n\n        if (isLoggingFeatureEnabled()) {\n            LoggingFeature loggingFeature = new LoggingFeature();\n            if (getLoggingSizeLimit() > 0) {\n                loggingFeature.setLimit(getLoggingSizeLimit());\n\n            }\n            factoryBean.getFeatures().add(loggingFeature);\n        }\n\n        // set the document-literal wrapped style\n        if (getWrappedStyle() != null) {\n            setWrapped(factoryBean, getWrappedStyle());\n        }\n\n        // any optional properties\n        if (getProperties() != null) {\n            if (factoryBean.getProperties() != null) {\n                // add to existing properties\n                factoryBean.getProperties().putAll(getProperties());\n            } else {\n                factoryBean.setProperties(getProperties());\n            }\n            LOG.debug(\"ClientFactoryBean: {} added properties: {}\", factoryBean, getProperties());\n        }\n\n        // setup the basic authentication property\n        if (ObjectHelper.isNotEmpty(username)) {\n            AuthorizationPolicy authPolicy = new AuthorizationPolicy();\n            authPolicy.setUserName(username);\n            authPolicy.setPassword(password);\n            if (factoryBean.getProperties() == null) {\n                factoryBean.setProperties(new HashMap<String, Object>());\n            }\n            factoryBean.getProperties().put(AuthorizationPolicy.class.getName(), authPolicy);\n        }\n\n        if (this.isSkipPayloadMessagePartCheck()) {\n            if (factoryBean.getProperties() == null) {\n                factoryBean.setProperties(new HashMap<String, Object>());\n            }\n            factoryBean.getProperties().put(\"soap.no.validate.parts\", Boolean.TRUE);\n        }\n\n        if (this.isSkipFaultLogging()) {\n            if (factoryBean.getProperties() == null) {\n                factoryBean.setProperties(new HashMap<String, Object>());\n            }\n            factoryBean.getProperties().put(FaultListener.class.getName(), new NullFaultListener());\n        }\n\n        factoryBean.setBus(getBus());\n\n        getNullSafeCxfEndpointConfigurer().configure(factoryBean);\n    }"
        ],
        [
            "RsClientBlueprintBean::setLoggingFeatureEnabled(boolean)",
            "  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61 -\n  62 -\n  63 -\n  64  \n  65  \n  66  \n  67  \n  68  ",
            "    public void setLoggingFeatureEnabled(boolean loggingFeatureEnabled) {\n        if (loggingFeature != null) {\n            getFeatures().remove(loggingFeature);\n            loggingFeature = null;\n        }\n        if (loggingFeatureEnabled) {\n            if (getLoggingSizeLimit() > 0) {\n                loggingFeature = new LoggingFeature(getLoggingSizeLimit());\n            } else {\n                loggingFeature = new LoggingFeature();\n            }\n            getFeatures().add(loggingFeature);\n        }\n        \n    }",
            "  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60 +\n  61  \n  62 +\n  63  \n  64  \n  65  \n  66  \n  67  ",
            "    public void setLoggingFeatureEnabled(boolean loggingFeatureEnabled) {\n        if (loggingFeature != null) {\n            getFeatures().remove(loggingFeature);\n            loggingFeature = null;\n        }\n        if (loggingFeatureEnabled) {\n            loggingFeature = new LoggingFeature();\n            if (getLoggingSizeLimit() > 0) {\n                loggingFeature.setLimit(getLoggingSizeLimit());\n            }\n            getFeatures().add(loggingFeature);\n        }\n        \n    }"
        ],
        [
            "CxfEndpoint::setupServerFactoryBean(ServerFactoryBean,Class)",
            " 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344 -\n 345 -\n 346 -\n 347 -\n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  ",
            "    /**\n     * Populate server factory bean\n     */\n    protected void setupServerFactoryBean(ServerFactoryBean sfb, Class<?> cls) {\n\n        // address\n        sfb.setAddress(getAddress());\n\n        sfb.setServiceClass(cls);\n\n        sfb.setInInterceptors(in);\n        sfb.setOutInterceptors(out);\n        sfb.setOutFaultInterceptors(outFault);\n        sfb.setInFaultInterceptors(inFault);\n        sfb.setFeatures(features);\n        if (schemaLocations != null) {\n            sfb.setSchemaLocations(schemaLocations);\n        }\n        if (bindingConfig != null) {\n            sfb.setBindingConfig(bindingConfig);\n        }\n\n        if (dataBinding != null) {\n            sfb.setDataBinding(dataBinding);\n        }\n\n        if (serviceFactoryBean != null) {\n            setServiceFactory(sfb, serviceFactoryBean);\n        }\n\n        if (sfb instanceof JaxWsServerFactoryBean && handlers != null) {\n            ((JaxWsServerFactoryBean)sfb).setHandlers(handlers);\n        }\n        if (getTransportId() != null) {\n            sfb.setTransportId(getTransportId());\n        }\n        if (getBindingId() != null) {\n            sfb.setBindingId(getBindingId());\n        }\n\n        // wsdl url\n        if (getWsdlURL() != null) {\n            sfb.setWsdlURL(getWsdlURL());\n        }\n\n        // service  name qname\n        if (getServiceName() != null) {\n            sfb.setServiceName(getServiceName());\n        }\n\n        // port qname\n        if (getPortName() != null) {\n            sfb.setEndpointName(getPortName());\n        }\n\n        // apply feature here\n        if (!CxfEndpointUtils.hasAnnotation(cls, WebServiceProvider.class)) {\n            if (getDataFormat() == DataFormat.PAYLOAD) {\n                sfb.getFeatures().add(new PayLoadDataFormatFeature(allowStreaming));\n            } else if (getDataFormat().dealias() == DataFormat.CXF_MESSAGE) {\n                sfb.getFeatures().add(new CXFMessageDataFormatFeature());\n                sfb.setDataBinding(new SourceDataBinding());\n            } else if (getDataFormat().dealias() == DataFormat.RAW) {\n                RAWDataFormatFeature feature = new RAWDataFormatFeature();\n                if (this.getExchangePattern().equals(ExchangePattern.InOnly)) {\n                    //if DataFormat is RAW|MESSAGE, can't read message so can't\n                    //determine it's oneway so need get the MEP from URI explicitly\n                    feature.setOneway(true);\n                }\n                feature.addInIntercepters(getInInterceptors());\n                feature.addOutInterceptors(getOutInterceptors());\n                sfb.getFeatures().add(feature);\n            }\n        } else {\n            LOG.debug(\"Ignore DataFormat mode {} since SEI class is annotated with WebServiceProvider\", getDataFormat());\n        }\n\n        if (isLoggingFeatureEnabled()) {\n            if (getLoggingSizeLimit() != 0) {\n                sfb.getFeatures().add(new LoggingFeature(getLoggingSizeLimit()));\n            } else {\n                sfb.getFeatures().add(new LoggingFeature());\n            }\n        }\n\n        if (getDataFormat() == DataFormat.PAYLOAD) {\n            sfb.setDataBinding(new HybridSourceDataBinding());\n        }\n\n        // set the document-literal wrapped style\n        if (getWrappedStyle() != null && getDataFormat().dealias() != DataFormat.CXF_MESSAGE) {\n            setWrapped(sfb, getWrappedStyle());\n        }\n\n        // any optional properties\n        if (getProperties() != null) {\n            if (sfb.getProperties() != null) {\n                // add to existing properties\n                sfb.getProperties().putAll(getProperties());\n            } else {\n                sfb.setProperties(getProperties());\n            }\n            LOG.debug(\"ServerFactoryBean: {} added properties: {}\", sfb, getProperties());\n        }\n        if (this.isSkipPayloadMessagePartCheck()) {\n            if (sfb.getProperties() == null) {\n                sfb.setProperties(new HashMap<String, Object>());\n            }\n            sfb.getProperties().put(\"soap.no.validate.parts\", Boolean.TRUE);\n        }\n\n        if (this.isSkipFaultLogging()) {\n            if (sfb.getProperties() == null) {\n                sfb.setProperties(new HashMap<String, Object>());\n            }\n            sfb.getProperties().put(FaultListener.class.getName(), new NullFaultListener());\n        }\n\n        sfb.setBus(getBus());\n        sfb.setStart(false);\n        getNullSafeCxfEndpointConfigurer().configure(sfb);\n    }",
            " 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344 +\n 345 +\n 346 +\n 347  \n 348 +\n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  ",
            "    /**\n     * Populate server factory bean\n     */\n    protected void setupServerFactoryBean(ServerFactoryBean sfb, Class<?> cls) {\n\n        // address\n        sfb.setAddress(getAddress());\n\n        sfb.setServiceClass(cls);\n\n        sfb.setInInterceptors(in);\n        sfb.setOutInterceptors(out);\n        sfb.setOutFaultInterceptors(outFault);\n        sfb.setInFaultInterceptors(inFault);\n        sfb.setFeatures(features);\n        if (schemaLocations != null) {\n            sfb.setSchemaLocations(schemaLocations);\n        }\n        if (bindingConfig != null) {\n            sfb.setBindingConfig(bindingConfig);\n        }\n\n        if (dataBinding != null) {\n            sfb.setDataBinding(dataBinding);\n        }\n\n        if (serviceFactoryBean != null) {\n            setServiceFactory(sfb, serviceFactoryBean);\n        }\n\n        if (sfb instanceof JaxWsServerFactoryBean && handlers != null) {\n            ((JaxWsServerFactoryBean)sfb).setHandlers(handlers);\n        }\n        if (getTransportId() != null) {\n            sfb.setTransportId(getTransportId());\n        }\n        if (getBindingId() != null) {\n            sfb.setBindingId(getBindingId());\n        }\n\n        // wsdl url\n        if (getWsdlURL() != null) {\n            sfb.setWsdlURL(getWsdlURL());\n        }\n\n        // service  name qname\n        if (getServiceName() != null) {\n            sfb.setServiceName(getServiceName());\n        }\n\n        // port qname\n        if (getPortName() != null) {\n            sfb.setEndpointName(getPortName());\n        }\n\n        // apply feature here\n        if (!CxfEndpointUtils.hasAnnotation(cls, WebServiceProvider.class)) {\n            if (getDataFormat() == DataFormat.PAYLOAD) {\n                sfb.getFeatures().add(new PayLoadDataFormatFeature(allowStreaming));\n            } else if (getDataFormat().dealias() == DataFormat.CXF_MESSAGE) {\n                sfb.getFeatures().add(new CXFMessageDataFormatFeature());\n                sfb.setDataBinding(new SourceDataBinding());\n            } else if (getDataFormat().dealias() == DataFormat.RAW) {\n                RAWDataFormatFeature feature = new RAWDataFormatFeature();\n                if (this.getExchangePattern().equals(ExchangePattern.InOnly)) {\n                    //if DataFormat is RAW|MESSAGE, can't read message so can't\n                    //determine it's oneway so need get the MEP from URI explicitly\n                    feature.setOneway(true);\n                }\n                feature.addInIntercepters(getInInterceptors());\n                feature.addOutInterceptors(getOutInterceptors());\n                sfb.getFeatures().add(feature);\n            }\n        } else {\n            LOG.debug(\"Ignore DataFormat mode {} since SEI class is annotated with WebServiceProvider\", getDataFormat());\n        }\n\n        if (isLoggingFeatureEnabled()) {\n            LoggingFeature loggingFeature = new LoggingFeature();\n            if (getLoggingSizeLimit() > 0) {\n                loggingFeature.setLimit(getLoggingSizeLimit());\n            }\n            sfb.getFeatures().add(loggingFeature);\n        }\n\n        if (getDataFormat() == DataFormat.PAYLOAD) {\n            sfb.setDataBinding(new HybridSourceDataBinding());\n        }\n\n        // set the document-literal wrapped style\n        if (getWrappedStyle() != null && getDataFormat().dealias() != DataFormat.CXF_MESSAGE) {\n            setWrapped(sfb, getWrappedStyle());\n        }\n\n        // any optional properties\n        if (getProperties() != null) {\n            if (sfb.getProperties() != null) {\n                // add to existing properties\n                sfb.getProperties().putAll(getProperties());\n            } else {\n                sfb.setProperties(getProperties());\n            }\n            LOG.debug(\"ServerFactoryBean: {} added properties: {}\", sfb, getProperties());\n        }\n        if (this.isSkipPayloadMessagePartCheck()) {\n            if (sfb.getProperties() == null) {\n                sfb.setProperties(new HashMap<String, Object>());\n            }\n            sfb.getProperties().put(\"soap.no.validate.parts\", Boolean.TRUE);\n        }\n\n        if (this.isSkipFaultLogging()) {\n            if (sfb.getProperties() == null) {\n                sfb.setProperties(new HashMap<String, Object>());\n            }\n            sfb.getProperties().put(FaultListener.class.getName(), new NullFaultListener());\n        }\n\n        sfb.setBus(getBus());\n        sfb.setStart(false);\n        getNullSafeCxfEndpointConfigurer().configure(sfb);\n    }"
        ],
        [
            "RsClientBlueprintBean::setLoggingSizeLimit(int)",
            "  74  \n  75  \n  76  \n  77 -\n  78  \n  79 -\n  80 -\n  81 -\n  82  \n  83 -\n  84  \n  85  ",
            "    public void setLoggingSizeLimit(int loggingSizeLimit) {\n        this.loggingSizeLimit = loggingSizeLimit;\n        if (loggingFeature != null) {\n            getFeatures().remove(loggingFeature);\n            if (loggingSizeLimit > 0) {\n                loggingFeature = new LoggingFeature(loggingSizeLimit);\n            } else {\n                loggingFeature = new LoggingFeature();\n            }\n            getFeatures().add(loggingFeature);\n        }\n    }",
            "  73  \n  74  \n  75  \n  76  \n  77 +\n  78  \n  79  \n  80  ",
            "    public void setLoggingSizeLimit(int loggingSizeLimit) {\n        this.loggingSizeLimit = loggingSizeLimit;\n        if (loggingFeature != null) {\n            if (loggingSizeLimit > 0) {\n                loggingFeature.setLimit(loggingSizeLimit);\n            }\n        }\n    }"
        ],
        [
            "CxfRsEndpoint::setupCommonFactoryProperties(AbstractJAXRSFactoryBean)",
            " 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344  \n 345  \n 346  \n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363 -\n 364 -\n 365 -\n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  ",
            "    protected void setupCommonFactoryProperties(AbstractJAXRSFactoryBean factory) {\n        // let customer to override the default setting of provider\n        if (!getProviders().isEmpty()) {\n            factory.setProviders(getProviders());\n        }\n        // setup the features\n        if (!getFeatures().isEmpty()) {\n            factory.getFeatures().addAll(getFeatures());\n        }\n\n        if (publishedEndpointUrl != null) {\n            factory.setPublishedEndpointUrl(publishedEndpointUrl);\n        }\n\n        // we need to avoid flushing the setting from spring or blueprint\n        if (!interceptorHolder.getInInterceptors().isEmpty()) {\n            factory.setInInterceptors(interceptorHolder.getInInterceptors());\n        }\n        if (!interceptorHolder.getOutInterceptors().isEmpty()) {\n            factory.setOutInterceptors(interceptorHolder.getOutInterceptors());\n        }\n        if (!interceptorHolder.getOutFaultInterceptors().isEmpty()) {\n            factory.setOutFaultInterceptors(interceptorHolder.getOutFaultInterceptors());\n        }\n        if (!interceptorHolder.getInFaultInterceptors().isEmpty()) {\n            factory.setInFaultInterceptors(interceptorHolder.getInFaultInterceptors());\n        }\n\n        if (getProperties() != null) {\n            if (factory.getProperties() != null) {\n                // add to existing properties\n                factory.getProperties().putAll(getProperties());\n            } else {\n                factory.setProperties(getProperties());\n            }\n            LOG.debug(\"JAXRS FactoryBean: {} added properties: {}\", factory, getProperties());\n        }\n\n        if (isLoggingFeatureEnabled()) {\n            if (getLoggingSizeLimit() > 0) {\n                factory.getFeatures().add(new LoggingFeature(getLoggingSizeLimit()));\n            } else {\n                factory.getFeatures().add(new LoggingFeature());\n            }\n        }\n        if (this.isSkipFaultLogging()) {\n            if (factory.getProperties() == null) {\n                factory.setProperties(new HashMap<String, Object>());\n            }\n            factory.getProperties().put(FaultListener.class.getName(), new NullFaultListener());\n        }\n    }",
            " 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344  \n 345  \n 346  \n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362 +\n 363  \n 364 +\n 365  \n 366 +\n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  ",
            "    protected void setupCommonFactoryProperties(AbstractJAXRSFactoryBean factory) {\n        // let customer to override the default setting of provider\n        if (!getProviders().isEmpty()) {\n            factory.setProviders(getProviders());\n        }\n        // setup the features\n        if (!getFeatures().isEmpty()) {\n            factory.getFeatures().addAll(getFeatures());\n        }\n\n        if (publishedEndpointUrl != null) {\n            factory.setPublishedEndpointUrl(publishedEndpointUrl);\n        }\n\n        // we need to avoid flushing the setting from spring or blueprint\n        if (!interceptorHolder.getInInterceptors().isEmpty()) {\n            factory.setInInterceptors(interceptorHolder.getInInterceptors());\n        }\n        if (!interceptorHolder.getOutInterceptors().isEmpty()) {\n            factory.setOutInterceptors(interceptorHolder.getOutInterceptors());\n        }\n        if (!interceptorHolder.getOutFaultInterceptors().isEmpty()) {\n            factory.setOutFaultInterceptors(interceptorHolder.getOutFaultInterceptors());\n        }\n        if (!interceptorHolder.getInFaultInterceptors().isEmpty()) {\n            factory.setInFaultInterceptors(interceptorHolder.getInFaultInterceptors());\n        }\n\n        if (getProperties() != null) {\n            if (factory.getProperties() != null) {\n                // add to existing properties\n                factory.getProperties().putAll(getProperties());\n            } else {\n                factory.setProperties(getProperties());\n            }\n            LOG.debug(\"JAXRS FactoryBean: {} added properties: {}\", factory, getProperties());\n        }\n\n        if (isLoggingFeatureEnabled()) {\n            LoggingFeature loggingFeature = new LoggingFeature();\n            if (getLoggingSizeLimit() > 0) {\n                loggingFeature.setLimit(getLoggingSizeLimit());\n            }\n            factory.getFeatures().add(loggingFeature);\n        }\n        if (this.isSkipFaultLogging()) {\n            if (factory.getProperties() == null) {\n                factory.setProperties(new HashMap<String, Object>());\n            }\n            factory.getProperties().put(FaultListener.class.getName(), new NullFaultListener());\n        }\n    }"
        ]
    ],
    "726bd103a6749409a33a61a724305fe85a344bc8": [
        [
            "ScheduledRoutePolicy::scheduleRoute(Action,Route)",
            "  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117 -\n 118  \n 119  ",
            "    public void scheduleRoute(Action action, Route route) throws Exception {\n        JobDetail jobDetail = createJobDetail(action, route);\n        Trigger trigger = createTrigger(action, route);\n        updateScheduledRouteDetails(action, jobDetail, trigger, route);\n        \n        loadCallbackDataIntoSchedulerContext(jobDetail, action, route);\n\n        boolean isClustered = route.getRouteContext().getCamelContext().getComponent(\"quartz\", QuartzComponent.class).isClustered();\n        if (isClustered) {\n            // check to see if the same job has already been setup through another node of the cluster\n            JobDetail existingJobDetail = getScheduler().getJobDetail(jobDetail.getName(), jobDetail.getGroup());\n            if (jobDetail.equals(existingJobDetail)) {\n                if (LOG.isInfoEnabled()) {\n                    LOG.info(\"Skipping to schedule the job: {} for action: {} on route {} as the job: {} already existing inside the cluster\",\n                             new Object[] {jobDetail.getFullName(), action, route.getId(), existingJobDetail.getFullName()});\n                }\n\n                // skip scheduling the same job again as one is already existing for the same routeId and action\n                return;\n            }\n        }\n\n        getScheduler().scheduleJob(jobDetail, trigger);\n\n        if (LOG.isInfoEnabled()) {\n            LOG.info(\"Scheduled trigger: {} for action: {} on route {}\", new Object[]{trigger.getFullName(), action, route.getId()});\n        }\n    }",
            "  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117 +\n 118  \n 119  ",
            "    public void scheduleRoute(Action action, Route route) throws Exception {\n        JobDetail jobDetail = createJobDetail(action, route);\n        Trigger trigger = createTrigger(action, route);\n        updateScheduledRouteDetails(action, jobDetail, trigger, route);\n        \n        loadCallbackDataIntoSchedulerContext(jobDetail, action, route);\n\n        boolean isClustered = route.getRouteContext().getCamelContext().getComponent(\"quartz\", QuartzComponent.class).isClustered();\n        if (isClustered) {\n            // check to see if the same job has already been setup through another node of the cluster\n            JobDetail existingJobDetail = getScheduler().getJobDetail(jobDetail.getName(), jobDetail.getGroup());\n            if (jobDetail.equals(existingJobDetail)) {\n                if (LOG.isInfoEnabled()) {\n                    LOG.info(\"Skipping to schedule the job: {} for action: {} on route {} as the job: {} already existing inside the cluster\",\n                             new Object[] {jobDetail.getFullName(), action, route.getId(), existingJobDetail.getFullName()});\n                }\n\n                // skip scheduling the same job again as one is already existing for the same routeId and action\n                return;\n            }\n        }\n\n        getScheduler().scheduleJob(jobDetail, trigger);\n\n        if (LOG.isInfoEnabled()) {\n            LOG.info(\"Scheduled trigger: {} for action: {} on route {}\", trigger.getFullName(), action, route.getId());\n        }\n    }"
        ],
        [
            "BindyFixedLengthFactory::generateFixedLengthPositionMap(Class,Object,Map)",
            " 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  \n 423  \n 424  \n 425  \n 426  \n 427  \n 428  \n 429  \n 430  \n 431  \n 432  \n 433  \n 434  \n 435  \n 436  \n 437  \n 438  \n 439  \n 440  \n 441  \n 442  \n 443  \n 444  \n 445  \n 446  \n 447  \n 448  \n 449  \n 450  \n 451  \n 452  \n 453  \n 454  \n 455  \n 456  \n 457  \n 458  \n 459  \n 460  \n 461  \n 462  \n 463  \n 464  \n 465  \n 466  \n 467  \n 468  \n 469  \n 470  \n 471  \n 472  \n 473  \n 474  \n 475  \n 476  \n 477  \n 478  \n 479  \n 480  \n 481  \n 482  \n 483  \n 484  \n 485  \n 486  \n 487  \n 488  \n 489  \n 490  \n 491  \n 492  \n 493  \n 494  \n 495  \n 496  \n 497  \n 498  \n 499  \n 500  \n 501  \n 502  \n 503  \n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510 -\n 511  \n 512  \n 513  \n 514  \n 515  \n 516  \n 517  \n 518  \n 519  \n 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528  \n 529  \n 530  \n 531  \n 532  \n 533  ",
            "    /**\n     *\n     * Generate a table containing the data formatted and sorted with their position/offset\n     * The result is placed in the Map<Integer, List> results\n     */\n    private void generateFixedLengthPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {\n\n        String result = \"\";\n\n        for (Field field : clazz.getDeclaredFields()) {\n\n            field.setAccessible(true);\n\n            DataField datafield = field.getAnnotation(DataField.class);\n\n            if (datafield != null) {\n\n                if (obj != null) {\n\n                    // Create format\n                    FormattingOptions formattingOptions = ConverterUtils.convert(datafield,\n                            field.getType(),\n                            field.getAnnotation(BindyConverter.class),\n                            getLocale());\n                    Format<?> format = formatFactory.getFormat(formattingOptions);\n\n                    // Get field value\n                    Object value = field.get(obj);\n\n                    // If the field value is empty, populate it with the default value\n                    if (ObjectHelper.isNotEmpty(datafield.defaultValue()) && ObjectHelper.isEmpty(value)) {\n                        value = datafield.defaultValue();\n                    }\n\n                    result = formatString(format, value);\n\n                    // trim if enabled\n                    if (datafield.trim()) {\n                        result = result.trim();\n                    }\n\n                    int fieldLength = datafield.length();\n\n                    if (fieldLength == 0 && (datafield.lengthPos() > 0)) {\n                        List<String> resultVals = results.get(datafield.lengthPos());\n                        fieldLength = Integer.valueOf(resultVals.get(0));\n                    }\n\n                    if (fieldLength <= 0 && datafield.delimiter().equals(\"\") && datafield.lengthPos() == 0) {\n                        throw new IllegalArgumentException(\"Either a delimiter value or length for the field: \"\n                                + field.getName() + \" is mandatory.\");\n                    }\n\n                    if (!datafield.delimiter().equals(\"\")) {\n                        result = result + datafield.delimiter();\n                    } else {\n                        // Get length of the field, alignment (LEFT or RIGHT), pad\n                        String align = datafield.align();\n                        char padCharField = datafield.paddingChar();\n                        char padChar;\n\n                        StringBuilder temp = new StringBuilder();\n\n                        // Check if we must pad\n                        if (result.length() < fieldLength) {\n\n                            // No padding defined for the field\n                            if (padCharField == 0) {\n                                // We use the padding defined for the Record\n                                padChar = paddingChar;\n                            } else {\n                                padChar = padCharField;\n                            }\n\n                            if (align.contains(\"R\")) {\n                                temp.append(generatePaddingChars(padChar, fieldLength, result.length()));\n                                temp.append(result);\n                            } else if (align.contains(\"L\")) {\n                                temp.append(result);\n                                temp.append(generatePaddingChars(padChar, fieldLength, result.length()));\n                            } else if (align.contains(\"B\")) {\n                                temp.append(generatePaddingChars(padChar, fieldLength, result.length()));\n                                temp.append(result);\n                            } else {\n                                throw new IllegalArgumentException(\"Alignment for the field: \" + field.getName()\n                                        + \" must be equal to R for RIGHT or L for LEFT or B for trimming both ends\");\n                            }\n\n                            result = temp.toString();\n                        } else if (result.length() > fieldLength) {\n                            // we are bigger than allowed\n\n                            // is clipped enabled? if so clip the field\n                            if (datafield.clip()) {\n                                result = result.substring(0, fieldLength);\n                            } else {\n                                throw new IllegalArgumentException(\"Length for the \" + field.getName()\n                                        + \" must not be larger than allowed, was: \" + result.length() + \", allowed: \" + fieldLength);\n                            }\n                        }\n                    }\n\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Value to be formatted: {}, position: {}, and its formatted value: {}\", new Object[]{value, datafield.pos(), result});\n                    }\n\n                } else {\n                    result = \"\";\n                }\n\n                Integer key;\n                key = datafield.pos();\n\n                if (!results.containsKey(key)) {\n                    List<String> list = new LinkedList<>();\n                    list.add(result);\n                    results.put(key, list);\n                } else {\n                    List<String> list = results.get(key);\n                    list.add(result);\n                }\n\n            }\n\n        }\n\n    }",
            " 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  \n 423  \n 424  \n 425  \n 426  \n 427  \n 428  \n 429  \n 430  \n 431  \n 432  \n 433  \n 434  \n 435  \n 436  \n 437  \n 438  \n 439  \n 440  \n 441  \n 442  \n 443  \n 444  \n 445  \n 446  \n 447  \n 448  \n 449  \n 450  \n 451  \n 452  \n 453  \n 454  \n 455  \n 456  \n 457  \n 458  \n 459  \n 460  \n 461  \n 462  \n 463  \n 464  \n 465  \n 466  \n 467  \n 468  \n 469  \n 470  \n 471  \n 472  \n 473  \n 474  \n 475  \n 476  \n 477  \n 478  \n 479  \n 480  \n 481  \n 482  \n 483  \n 484  \n 485  \n 486  \n 487  \n 488  \n 489  \n 490  \n 491  \n 492  \n 493  \n 494  \n 495  \n 496  \n 497  \n 498  \n 499  \n 500  \n 501  \n 502  \n 503  \n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510 +\n 511  \n 512  \n 513  \n 514  \n 515  \n 516  \n 517  \n 518  \n 519  \n 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528  \n 529  \n 530  \n 531  \n 532  \n 533  ",
            "    /**\n     *\n     * Generate a table containing the data formatted and sorted with their position/offset\n     * The result is placed in the Map<Integer, List> results\n     */\n    private void generateFixedLengthPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {\n\n        String result = \"\";\n\n        for (Field field : clazz.getDeclaredFields()) {\n\n            field.setAccessible(true);\n\n            DataField datafield = field.getAnnotation(DataField.class);\n\n            if (datafield != null) {\n\n                if (obj != null) {\n\n                    // Create format\n                    FormattingOptions formattingOptions = ConverterUtils.convert(datafield,\n                            field.getType(),\n                            field.getAnnotation(BindyConverter.class),\n                            getLocale());\n                    Format<?> format = formatFactory.getFormat(formattingOptions);\n\n                    // Get field value\n                    Object value = field.get(obj);\n\n                    // If the field value is empty, populate it with the default value\n                    if (ObjectHelper.isNotEmpty(datafield.defaultValue()) && ObjectHelper.isEmpty(value)) {\n                        value = datafield.defaultValue();\n                    }\n\n                    result = formatString(format, value);\n\n                    // trim if enabled\n                    if (datafield.trim()) {\n                        result = result.trim();\n                    }\n\n                    int fieldLength = datafield.length();\n\n                    if (fieldLength == 0 && (datafield.lengthPos() > 0)) {\n                        List<String> resultVals = results.get(datafield.lengthPos());\n                        fieldLength = Integer.valueOf(resultVals.get(0));\n                    }\n\n                    if (fieldLength <= 0 && datafield.delimiter().equals(\"\") && datafield.lengthPos() == 0) {\n                        throw new IllegalArgumentException(\"Either a delimiter value or length for the field: \"\n                                + field.getName() + \" is mandatory.\");\n                    }\n\n                    if (!datafield.delimiter().equals(\"\")) {\n                        result = result + datafield.delimiter();\n                    } else {\n                        // Get length of the field, alignment (LEFT or RIGHT), pad\n                        String align = datafield.align();\n                        char padCharField = datafield.paddingChar();\n                        char padChar;\n\n                        StringBuilder temp = new StringBuilder();\n\n                        // Check if we must pad\n                        if (result.length() < fieldLength) {\n\n                            // No padding defined for the field\n                            if (padCharField == 0) {\n                                // We use the padding defined for the Record\n                                padChar = paddingChar;\n                            } else {\n                                padChar = padCharField;\n                            }\n\n                            if (align.contains(\"R\")) {\n                                temp.append(generatePaddingChars(padChar, fieldLength, result.length()));\n                                temp.append(result);\n                            } else if (align.contains(\"L\")) {\n                                temp.append(result);\n                                temp.append(generatePaddingChars(padChar, fieldLength, result.length()));\n                            } else if (align.contains(\"B\")) {\n                                temp.append(generatePaddingChars(padChar, fieldLength, result.length()));\n                                temp.append(result);\n                            } else {\n                                throw new IllegalArgumentException(\"Alignment for the field: \" + field.getName()\n                                        + \" must be equal to R for RIGHT or L for LEFT or B for trimming both ends\");\n                            }\n\n                            result = temp.toString();\n                        } else if (result.length() > fieldLength) {\n                            // we are bigger than allowed\n\n                            // is clipped enabled? if so clip the field\n                            if (datafield.clip()) {\n                                result = result.substring(0, fieldLength);\n                            } else {\n                                throw new IllegalArgumentException(\"Length for the \" + field.getName()\n                                        + \" must not be larger than allowed, was: \" + result.length() + \", allowed: \" + fieldLength);\n                            }\n                        }\n                    }\n\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Value to be formatted: {}, position: {}, and its formatted value: {}\", value, datafield.pos(), result);\n                    }\n\n                } else {\n                    result = \"\";\n                }\n\n                Integer key;\n                key = datafield.pos();\n\n                if (!results.containsKey(key)) {\n                    List<String> list = new LinkedList<>();\n                    list.add(result);\n                    results.put(key, list);\n                } else {\n                    List<String> list = results.get(key);\n                    list.add(result);\n                }\n\n            }\n\n        }\n\n    }"
        ],
        [
            "TransactionErrorHandler::logTransactionBegin(String,String)",
            " 246  \n 247  \n 248  \n 249  \n 250  \n 251 -\n 252  \n 253  ",
            "    /**\n     * Logs the transaction begin\n     */\n    private void logTransactionBegin(String redelivered, String ids) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Transaction begin ({}) redelivered({}) for {})\", new Object[]{transactionKey, redelivered, ids});\n        }\n    }",
            " 246  \n 247  \n 248  \n 249  \n 250  \n 251 +\n 252  \n 253  ",
            "    /**\n     * Logs the transaction begin\n     */\n    private void logTransactionBegin(String redelivered, String ids) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Transaction begin ({}) redelivered({}) for {})\", transactionKey, redelivered, ids);\n        }\n    }"
        ],
        [
            "CamelAnnotationsHandler::handleShutdownTimeout(ConfigurableApplicationContext,Class)",
            " 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200 -\n 201  \n 202  \n 203  \n 204  \n 205  ",
            "    /**\n     * Handles updating shutdown timeouts on Camel contexts based on {@link ShutdownTimeout}.\n     *\n     * @param context the initialized Spring context\n     * @param testClass the test class being executed\n     */\n    public static void handleShutdownTimeout(ConfigurableApplicationContext context, Class<?> testClass) throws Exception {\n        final int shutdownTimeout;\n        final TimeUnit shutdownTimeUnit;\n        if (testClass.isAnnotationPresent(ShutdownTimeout.class)) {\n            shutdownTimeout = testClass.getAnnotation(ShutdownTimeout.class).value();\n            shutdownTimeUnit = testClass.getAnnotation(ShutdownTimeout.class).timeUnit();\n        } else {\n            shutdownTimeout = 10;\n            shutdownTimeUnit = TimeUnit.SECONDS;\n        }\n\n        CamelSpringTestHelper.doToSpringCamelContexts(context, new CamelSpringTestHelper.DoToSpringCamelContextsStrategy() {\n\n            public void execute(String contextName, SpringCamelContext camelContext)\n                    throws Exception {\n                LOGGER.info(\"Setting shutdown timeout to [{} {}] on CamelContext with name [{}].\", new Object[]{shutdownTimeout, shutdownTimeUnit, contextName});\n                camelContext.getShutdownStrategy().setTimeout(shutdownTimeout);\n                camelContext.getShutdownStrategy().setTimeUnit(shutdownTimeUnit);\n            }\n        });\n    }",
            " 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200 +\n 201  \n 202  \n 203  \n 204  \n 205  ",
            "    /**\n     * Handles updating shutdown timeouts on Camel contexts based on {@link ShutdownTimeout}.\n     *\n     * @param context the initialized Spring context\n     * @param testClass the test class being executed\n     */\n    public static void handleShutdownTimeout(ConfigurableApplicationContext context, Class<?> testClass) throws Exception {\n        final int shutdownTimeout;\n        final TimeUnit shutdownTimeUnit;\n        if (testClass.isAnnotationPresent(ShutdownTimeout.class)) {\n            shutdownTimeout = testClass.getAnnotation(ShutdownTimeout.class).value();\n            shutdownTimeUnit = testClass.getAnnotation(ShutdownTimeout.class).timeUnit();\n        } else {\n            shutdownTimeout = 10;\n            shutdownTimeUnit = TimeUnit.SECONDS;\n        }\n\n        CamelSpringTestHelper.doToSpringCamelContexts(context, new CamelSpringTestHelper.DoToSpringCamelContextsStrategy() {\n\n            public void execute(String contextName, SpringCamelContext camelContext)\n                    throws Exception {\n                LOGGER.info(\"Setting shutdown timeout to [{} {}] on CamelContext with name [{}].\", shutdownTimeout, shutdownTimeUnit, contextName);\n                camelContext.getShutdownStrategy().setTimeout(shutdownTimeout);\n                camelContext.getShutdownStrategy().setTimeUnit(shutdownTimeUnit);\n            }\n        });\n    }"
        ],
        [
            "CamelNamespaceHandler::autoRegisterBeanDefinition(String,BeanDefinition,ParserContext,String)",
            " 667  \n 668  \n 669  \n 670  \n 671  \n 672  \n 673  \n 674  \n 675  \n 676  \n 677  \n 678  \n 679  \n 680 -\n 681  \n 682  \n 683  \n 684  \n 685  \n 686  \n 687  \n 688  \n 689  \n 690  \n 691  \n 692  ",
            "    private void autoRegisterBeanDefinition(String id, BeanDefinition definition, ParserContext parserContext, String contextId) {\n        // it is a bit cumbersome to work with the spring bean definition parser\n        // as we kinda need to eagerly register the bean definition on the parser context\n        // and then later we might find out that we should not have done that in case we have multiple camel contexts\n        // that would have a id clash by auto registering the same bean definition with the same id such as a producer template\n\n        // see if we have already auto registered this id\n        BeanDefinition existing = autoRegisterMap.get(id);\n        if (existing == null) {\n            // no then add it to the map and register it\n            autoRegisterMap.put(id, definition);\n            parserContext.registerComponent(new BeanComponentDefinition(definition, id));\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Registered default: {} with id: {} on camel context: {}\", new Object[]{definition.getBeanClassName(), id, contextId});\n            }\n        } else {\n            // ups we have already registered it before with same id, but on another camel context\n            // this is not good so we need to remove all traces of this auto registering.\n            // end user must manually add the needed XML elements and provide unique ids access all camel context himself.\n            LOG.debug(\"Unregistered default: {} with id: {} as we have multiple camel contexts and they must use unique ids.\"\n                    + \" You must define the definition in the XML file manually to avoid id clashes when using multiple camel contexts\",\n                    definition.getBeanClassName(), id);\n\n            parserContext.getRegistry().removeBeanDefinition(id);\n        }\n    }",
            " 667  \n 668  \n 669  \n 670  \n 671  \n 672  \n 673  \n 674  \n 675  \n 676  \n 677  \n 678  \n 679  \n 680 +\n 681  \n 682  \n 683  \n 684  \n 685  \n 686  \n 687  \n 688  \n 689  \n 690  \n 691  \n 692  ",
            "    private void autoRegisterBeanDefinition(String id, BeanDefinition definition, ParserContext parserContext, String contextId) {\n        // it is a bit cumbersome to work with the spring bean definition parser\n        // as we kinda need to eagerly register the bean definition on the parser context\n        // and then later we might find out that we should not have done that in case we have multiple camel contexts\n        // that would have a id clash by auto registering the same bean definition with the same id such as a producer template\n\n        // see if we have already auto registered this id\n        BeanDefinition existing = autoRegisterMap.get(id);\n        if (existing == null) {\n            // no then add it to the map and register it\n            autoRegisterMap.put(id, definition);\n            parserContext.registerComponent(new BeanComponentDefinition(definition, id));\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Registered default: {} with id: {} on camel context: {}\", definition.getBeanClassName(), id, contextId);\n            }\n        } else {\n            // ups we have already registered it before with same id, but on another camel context\n            // this is not good so we need to remove all traces of this auto registering.\n            // end user must manually add the needed XML elements and provide unique ids access all camel context himself.\n            LOG.debug(\"Unregistered default: {} with id: {} as we have multiple camel contexts and they must use unique ids.\"\n                    + \" You must define the definition in the XML file manually to avoid id clashes when using multiple camel contexts\",\n                    definition.getBeanClassName(), id);\n\n            parserContext.getRegistry().removeBeanDefinition(id);\n        }\n    }"
        ],
        [
            "TransactionErrorHandler::logTransactionCommit(String,String)",
            " 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263 -\n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270 -\n 271  ",
            "    /**\n     * Logs the transaction commit\n     */\n    private void logTransactionCommit(String redelivered, String ids) {\n        if (\"true\".equals(redelivered)) {\n            // okay its a redelivered message so log at INFO level if rollbackLoggingLevel is INFO or higher\n            // this allows people to know that the redelivered message was committed this time\n            if (rollbackLoggingLevel == LoggingLevel.INFO || rollbackLoggingLevel == LoggingLevel.WARN || rollbackLoggingLevel == LoggingLevel.ERROR) {\n                log.info(\"Transaction commit ({}) redelivered({}) for {})\", new Object[]{transactionKey, redelivered, ids});\n                // return after we have logged\n                return;\n            }\n        }\n\n        // log non redelivered by default at DEBUG level\n        log.debug(\"Transaction commit ({}) redelivered({}) for {})\", new Object[]{transactionKey, redelivered, ids});\n    }",
            " 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263 +\n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270 +\n 271  ",
            "    /**\n     * Logs the transaction commit\n     */\n    private void logTransactionCommit(String redelivered, String ids) {\n        if (\"true\".equals(redelivered)) {\n            // okay its a redelivered message so log at INFO level if rollbackLoggingLevel is INFO or higher\n            // this allows people to know that the redelivered message was committed this time\n            if (rollbackLoggingLevel == LoggingLevel.INFO || rollbackLoggingLevel == LoggingLevel.WARN || rollbackLoggingLevel == LoggingLevel.ERROR) {\n                log.info(\"Transaction commit ({}) redelivered({}) for {})\", transactionKey, redelivered, ids);\n                // return after we have logged\n                return;\n            }\n        }\n\n        // log non redelivered by default at DEBUG level\n        log.debug(\"Transaction commit ({}) redelivered({}) for {})\", transactionKey, redelivered, ids);\n    }"
        ],
        [
            "MailConsumer::createExchanges(List)",
            " 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344  \n 345  \n 346 -\n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  ",
            "    protected Queue<Exchange> createExchanges(List<KeyValueHolder<String, Message>> messages) throws MessagingException {\n        Queue<Exchange> answer = new LinkedList<>();\n\n        int fetchSize = getEndpoint().getConfiguration().getFetchSize();\n        int count = fetchSize == -1 ? messages.size() : Math.min(fetchSize, messages.size());\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Fetching {} messages. Total {} messages.\", count, messages.size());\n        }\n\n        for (int i = 0; i < count; i++) {\n            try {\n                KeyValueHolder<String, Message> holder = messages.get(i);\n                String key = holder.getKey();\n                Message message = holder.getValue();\n\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"Mail #{} is of type: {} - {}\", new Object[]{i, ObjectHelper.classCanonicalName(message), message});\n                }\n\n                if (!message.getFlags().contains(Flags.Flag.DELETED)) {\n                    Exchange exchange = getEndpoint().createExchange(message);\n                    if (getEndpoint().getConfiguration().isMapMailMessage()) {\n                        // ensure the mail message is mapped, which can be ensured by touching the body/header/attachment\n                        LOG.trace(\"Mapping #{} from javax.mail.Message to Camel MailMessage\", i);\n                        exchange.getIn().getBody();\n                        exchange.getIn().getHeaders();\n                        exchange.getIn().getAttachments();\n                    }\n\n                    // If the protocol is POP3 we need to remember the uid on the exchange\n                    // so we can find the mail message again later to be able to delete it\n                    // we also need to remember the UUID for idempotent repository\n                    exchange.setProperty(MAIL_MESSAGE_UID, key);\n\n                    answer.add(exchange);\n                } else {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Skipping message as it was flagged as deleted: {}\", MailUtils.dumpMessage(message));\n                    }\n                }\n            } catch (Exception e) {\n                if (skipFailedMessage) {\n                    LOG.debug(\"Skipping failed message at index \" + i + \" due \" + e.getMessage(), e);\n                } else if (handleFailedMessage) {\n                    handleException(e);\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        return answer;\n    }",
            " 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344  \n 345  \n 346 +\n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  ",
            "    protected Queue<Exchange> createExchanges(List<KeyValueHolder<String, Message>> messages) throws MessagingException {\n        Queue<Exchange> answer = new LinkedList<>();\n\n        int fetchSize = getEndpoint().getConfiguration().getFetchSize();\n        int count = fetchSize == -1 ? messages.size() : Math.min(fetchSize, messages.size());\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Fetching {} messages. Total {} messages.\", count, messages.size());\n        }\n\n        for (int i = 0; i < count; i++) {\n            try {\n                KeyValueHolder<String, Message> holder = messages.get(i);\n                String key = holder.getKey();\n                Message message = holder.getValue();\n\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"Mail #{} is of type: {} - {}\", i, ObjectHelper.classCanonicalName(message), message);\n                }\n\n                if (!message.getFlags().contains(Flags.Flag.DELETED)) {\n                    Exchange exchange = getEndpoint().createExchange(message);\n                    if (getEndpoint().getConfiguration().isMapMailMessage()) {\n                        // ensure the mail message is mapped, which can be ensured by touching the body/header/attachment\n                        LOG.trace(\"Mapping #{} from javax.mail.Message to Camel MailMessage\", i);\n                        exchange.getIn().getBody();\n                        exchange.getIn().getHeaders();\n                        exchange.getIn().getAttachments();\n                    }\n\n                    // If the protocol is POP3 we need to remember the uid on the exchange\n                    // so we can find the mail message again later to be able to delete it\n                    // we also need to remember the UUID for idempotent repository\n                    exchange.setProperty(MAIL_MESSAGE_UID, key);\n\n                    answer.add(exchange);\n                } else {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Skipping message as it was flagged as deleted: {}\", MailUtils.dumpMessage(message));\n                    }\n                }\n            } catch (Exception e) {\n                if (skipFailedMessage) {\n                    LOG.debug(\"Skipping failed message at index \" + i + \" due \" + e.getMessage(), e);\n                } else if (handleFailedMessage) {\n                    handleException(e);\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        return answer;\n    }"
        ],
        [
            "SftpOperations::changeCurrentDirectory(String)",
            " 584  \n 585  \n 586  \n 587  \n 588  \n 589  \n 590  \n 591  \n 592  \n 593  \n 594  \n 595  \n 596 -\n 597  \n 598  \n 599  \n 600  \n 601  \n 602  \n 603  \n 604  \n 605  \n 606  \n 607  \n 608  \n 609  \n 610  \n 611  \n 612  \n 613  \n 614  \n 615  \n 616  \n 617  \n 618  \n 619  \n 620  \n 621  \n 622  \n 623  \n 624  \n 625  \n 626  \n 627  \n 628  \n 629  \n 630  \n 631  \n 632  \n 633  \n 634  ",
            "    public synchronized void changeCurrentDirectory(String path) throws GenericFileOperationFailedException {\n        LOG.trace(\"changeCurrentDirectory({})\", path);\n        if (ObjectHelper.isEmpty(path)) {\n            return;\n        }\n\n        // must compact path so SFTP server can traverse correctly, make use of the '/'\n        // separator because JSch expects this as the file separator even on Windows\n        String before = path;\n        char separatorChar = '/';\n        path = FileUtil.compactPath(path, separatorChar);\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Compacted path: {} -> {} using separator: {}\", new Object[]{before, path, separatorChar});\n        }\n\n        // not stepwise should change directory in one operation\n        if (!endpoint.getConfiguration().isStepwise()) {\n            doChangeDirectory(path);\n            return;\n        }\n        if (getCurrentDirectory().startsWith(path)) {\n            // extract the path segment relative to the target path and make sure it keeps the preceding '/' for the regex op\n            String p = getCurrentDirectory().substring(path.length() - (path.endsWith(\"/\") ?  1 : 0));\n            if (p.length() == 0) {\n                return;\n            }\n            // the first character must be '/' and hence removed\n            path = UP_DIR_PATTERN.matcher(p).replaceAll(\"/..\").substring(1);\n        }\n\n        // if it starts with the root path then a little special handling for that\n        if (FileUtil.hasLeadingSeparator(path)) {\n            // change to root path\n            doChangeDirectory(path.substring(0, 1));\n            path = path.substring(1);\n        }\n\n        // split into multiple dirs\n        final String[] dirs = path.split(\"/|\\\\\\\\\");\n\n        if (dirs == null || dirs.length == 0) {\n            // path was just a relative single path\n            doChangeDirectory(path);\n            return;\n        }\n\n        // there are multiple dirs so do this in chunks\n        for (String dir : dirs) {\n            doChangeDirectory(dir);\n        }\n    }",
            " 584  \n 585  \n 586  \n 587  \n 588  \n 589  \n 590  \n 591  \n 592  \n 593  \n 594  \n 595  \n 596 +\n 597  \n 598  \n 599  \n 600  \n 601  \n 602  \n 603  \n 604  \n 605  \n 606  \n 607  \n 608  \n 609  \n 610  \n 611  \n 612  \n 613  \n 614  \n 615  \n 616  \n 617  \n 618  \n 619  \n 620  \n 621  \n 622  \n 623  \n 624  \n 625  \n 626  \n 627  \n 628  \n 629  \n 630  \n 631  \n 632  \n 633  \n 634  ",
            "    public synchronized void changeCurrentDirectory(String path) throws GenericFileOperationFailedException {\n        LOG.trace(\"changeCurrentDirectory({})\", path);\n        if (ObjectHelper.isEmpty(path)) {\n            return;\n        }\n\n        // must compact path so SFTP server can traverse correctly, make use of the '/'\n        // separator because JSch expects this as the file separator even on Windows\n        String before = path;\n        char separatorChar = '/';\n        path = FileUtil.compactPath(path, separatorChar);\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Compacted path: {} -> {} using separator: {}\", before, path, separatorChar);\n        }\n\n        // not stepwise should change directory in one operation\n        if (!endpoint.getConfiguration().isStepwise()) {\n            doChangeDirectory(path);\n            return;\n        }\n        if (getCurrentDirectory().startsWith(path)) {\n            // extract the path segment relative to the target path and make sure it keeps the preceding '/' for the regex op\n            String p = getCurrentDirectory().substring(path.length() - (path.endsWith(\"/\") ?  1 : 0));\n            if (p.length() == 0) {\n                return;\n            }\n            // the first character must be '/' and hence removed\n            path = UP_DIR_PATTERN.matcher(p).replaceAll(\"/..\").substring(1);\n        }\n\n        // if it starts with the root path then a little special handling for that\n        if (FileUtil.hasLeadingSeparator(path)) {\n            // change to root path\n            doChangeDirectory(path.substring(0, 1));\n            path = path.substring(1);\n        }\n\n        // split into multiple dirs\n        final String[] dirs = path.split(\"/|\\\\\\\\\");\n\n        if (dirs == null || dirs.length == 0) {\n            // path was just a relative single path\n            doChangeDirectory(path);\n            return;\n        }\n\n        // there are multiple dirs so do this in chunks\n        for (String dir : dirs) {\n            doChangeDirectory(dir);\n        }\n    }"
        ],
        [
            "MvelEndpoint::onExchange(Exchange)",
            "  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108 -\n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  ",
            "    @Override\n    protected void onExchange(Exchange exchange) throws Exception {\n        String path = getResourceUri();\n        ObjectHelper.notNull(path, \"resourceUri\");\n\n        String newResourceUri = exchange.getIn().getHeader(MvelConstants.MVEL_RESOURCE_URI, String.class);\n        if (newResourceUri != null) {\n            exchange.getIn().removeHeader(MvelConstants.MVEL_RESOURCE_URI);\n\n            log.debug(\"{} set to {} creating new endpoint to handle exchange\", MvelConstants.MVEL_RESOURCE_URI, newResourceUri);\n            MvelEndpoint newEndpoint = findOrCreateEndpoint(getEndpointUri(), newResourceUri);\n            newEndpoint.onExchange(exchange);\n            return;\n        }\n\n        CompiledTemplate compiled;\n        ParserContext mvelContext = ParserContext.create();\n        Map<String, Object> variableMap = ExchangeHelper.createVariableMap(exchange);\n\n        String content = exchange.getIn().getHeader(MvelConstants.MVEL_TEMPLATE, String.class);\n        if (content != null) {\n            // use content from header\n            if (log.isDebugEnabled()) {\n                log.debug(\"Mvel content read from header {} for endpoint {}\", MvelConstants.MVEL_TEMPLATE, getEndpointUri());\n            }\n            // remove the header to avoid it being propagated in the routing\n            exchange.getIn().removeHeader(MvelConstants.MVEL_TEMPLATE);\n            compiled = TemplateCompiler.compileTemplate(content, mvelContext);\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Mvel content read from resource {} with resourceUri: {} for endpoint {}\", new Object[]{getResourceUri(), path, getEndpointUri()});\n            }\n            // getResourceAsInputStream also considers the content cache\n            Reader reader = getEncoding() != null ? new InputStreamReader(getResourceAsInputStream(), getEncoding()) : new InputStreamReader(getResourceAsInputStream());\n            String template = IOConverter.toString(reader);\n            if (!template.equals(this.template)) {\n                this.template = template;\n                this.compiled = TemplateCompiler.compileTemplate(template, mvelContext);\n            }\n            compiled = this.compiled;\n        }\n\n        // let mvel parse and execute the template\n        log.debug(\"Mvel is evaluating using mvel context: {}\", variableMap);\n        Object result = TemplateRuntime.execute(compiled, mvelContext, variableMap);\n\n        // now lets output the results to the exchange\n        Message out = exchange.getOut();\n        out.setBody(result.toString());\n        out.setHeaders(exchange.getIn().getHeaders());\n        out.setAttachments(exchange.getIn().getAttachments());\n    }",
            "  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108 +\n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  ",
            "    @Override\n    protected void onExchange(Exchange exchange) throws Exception {\n        String path = getResourceUri();\n        ObjectHelper.notNull(path, \"resourceUri\");\n\n        String newResourceUri = exchange.getIn().getHeader(MvelConstants.MVEL_RESOURCE_URI, String.class);\n        if (newResourceUri != null) {\n            exchange.getIn().removeHeader(MvelConstants.MVEL_RESOURCE_URI);\n\n            log.debug(\"{} set to {} creating new endpoint to handle exchange\", MvelConstants.MVEL_RESOURCE_URI, newResourceUri);\n            MvelEndpoint newEndpoint = findOrCreateEndpoint(getEndpointUri(), newResourceUri);\n            newEndpoint.onExchange(exchange);\n            return;\n        }\n\n        CompiledTemplate compiled;\n        ParserContext mvelContext = ParserContext.create();\n        Map<String, Object> variableMap = ExchangeHelper.createVariableMap(exchange);\n\n        String content = exchange.getIn().getHeader(MvelConstants.MVEL_TEMPLATE, String.class);\n        if (content != null) {\n            // use content from header\n            if (log.isDebugEnabled()) {\n                log.debug(\"Mvel content read from header {} for endpoint {}\", MvelConstants.MVEL_TEMPLATE, getEndpointUri());\n            }\n            // remove the header to avoid it being propagated in the routing\n            exchange.getIn().removeHeader(MvelConstants.MVEL_TEMPLATE);\n            compiled = TemplateCompiler.compileTemplate(content, mvelContext);\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Mvel content read from resource {} with resourceUri: {} for endpoint {}\", getResourceUri(), path, getEndpointUri());\n            }\n            // getResourceAsInputStream also considers the content cache\n            Reader reader = getEncoding() != null ? new InputStreamReader(getResourceAsInputStream(), getEncoding()) : new InputStreamReader(getResourceAsInputStream());\n            String template = IOConverter.toString(reader);\n            if (!template.equals(this.template)) {\n                this.template = template;\n                this.compiled = TemplateCompiler.compileTemplate(template, mvelContext);\n            }\n            compiled = this.compiled;\n        }\n\n        // let mvel parse and execute the template\n        log.debug(\"Mvel is evaluating using mvel context: {}\", variableMap);\n        Object result = TemplateRuntime.execute(compiled, mvelContext, variableMap);\n\n        // now lets output the results to the exchange\n        Message out = exchange.getOut();\n        out.setBody(result.toString());\n        out.setHeaders(exchange.getIn().getHeaders());\n        out.setAttachments(exchange.getIn().getAttachments());\n    }"
        ],
        [
            "Jt400PgmProducer::process(Exchange)",
            "  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75 -\n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  ",
            "    public void process(Exchange exchange) throws Exception {\n\n        String commandStr = getISeriesEndpoint().getObjectPath();\n        ProgramParameter[] parameterList = getParameterList(exchange);\n\n        ProgramCall pgmCall;\n        if (getISeriesEndpoint().getType() == Jt400Type.PGM) {\n            pgmCall = new ProgramCall(iSeries);\n        } else {\n            pgmCall = new ServiceProgramCall(iSeries);\n            ((ServiceProgramCall)pgmCall).setProcedureName(getISeriesEndpoint().getProcedureName());\n            ((ServiceProgramCall)pgmCall).setReturnValueFormat(ServiceProgramCall.NO_RETURN_VALUE);\n        }\n        pgmCall.setProgram(commandStr);\n        pgmCall.setParameterList(parameterList);\n\n        if (LOG.isDebugEnabled()) {\n            LOG.trace(\"Starting to call PGM '{}' in host '{}' authentication with the user '{}'\",\n                    new Object[]{commandStr, iSeries.getSystemName(), iSeries.getUserId()});\n        }\n\n        boolean result = pgmCall.run();\n\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Executed PGM '{}' in host '{}'. Success? {}\", new Object[]{commandStr, iSeries.getSystemName(), result});\n        }\n\n        if (result) {\n            handlePGMOutput(exchange, pgmCall, parameterList);\n        } else {\n            throw new Jt400PgmCallException(getOutputMessages(pgmCall));\n        }\n    }",
            "  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75 +\n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  ",
            "    public void process(Exchange exchange) throws Exception {\n\n        String commandStr = getISeriesEndpoint().getObjectPath();\n        ProgramParameter[] parameterList = getParameterList(exchange);\n\n        ProgramCall pgmCall;\n        if (getISeriesEndpoint().getType() == Jt400Type.PGM) {\n            pgmCall = new ProgramCall(iSeries);\n        } else {\n            pgmCall = new ServiceProgramCall(iSeries);\n            ((ServiceProgramCall)pgmCall).setProcedureName(getISeriesEndpoint().getProcedureName());\n            ((ServiceProgramCall)pgmCall).setReturnValueFormat(ServiceProgramCall.NO_RETURN_VALUE);\n        }\n        pgmCall.setProgram(commandStr);\n        pgmCall.setParameterList(parameterList);\n\n        if (LOG.isDebugEnabled()) {\n            LOG.trace(\"Starting to call PGM '{}' in host '{}' authentication with the user '{}'\",\n                    new Object[]{commandStr, iSeries.getSystemName(), iSeries.getUserId()});\n        }\n\n        boolean result = pgmCall.run();\n\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Executed PGM '{}' in host '{}'. Success? {}\", commandStr, iSeries.getSystemName(), result);\n        }\n\n        if (result) {\n            handlePGMOutput(exchange, pgmCall, parameterList);\n        } else {\n            throw new Jt400PgmCallException(getOutputMessages(pgmCall));\n        }\n    }"
        ],
        [
            "CamelSpringTestContextLoader::handleShutdownTimeout(GenericApplicationContext,Class)",
            " 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385 -\n 386  \n 387  \n 388  \n 389  \n 390  ",
            "    /**\n     * Handles updating shutdown timeouts on Camel contexts based on {@link ShutdownTimeout}.\n     *\n     * @param context the initialized Spring context\n     * @param testClass the test class being executed\n     */\n    protected void handleShutdownTimeout(GenericApplicationContext context, Class<?> testClass) throws Exception {\n        final int shutdownTimeout;\n        final TimeUnit shutdownTimeUnit;\n        if (testClass.isAnnotationPresent(ShutdownTimeout.class)) {\n            shutdownTimeout = testClass.getAnnotation(ShutdownTimeout.class).value();\n            shutdownTimeUnit = testClass.getAnnotation(ShutdownTimeout.class).timeUnit();\n        } else {\n            shutdownTimeout = 10;\n            shutdownTimeUnit = TimeUnit.SECONDS;\n        }\n        \n        CamelSpringTestHelper.doToSpringCamelContexts(context, new DoToSpringCamelContextsStrategy() {\n            \n            @Override\n            public void execute(String contextName, SpringCamelContext camelContext)\n                throws Exception {\n                LOG.info(\"Setting shutdown timeout to [{} {}] on CamelContext with name [{}].\", new Object[]{shutdownTimeout, shutdownTimeUnit, contextName});\n                camelContext.getShutdownStrategy().setTimeout(shutdownTimeout);\n                camelContext.getShutdownStrategy().setTimeUnit(shutdownTimeUnit);\n            }\n        });\n    }",
            " 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385 +\n 386  \n 387  \n 388  \n 389  \n 390  ",
            "    /**\n     * Handles updating shutdown timeouts on Camel contexts based on {@link ShutdownTimeout}.\n     *\n     * @param context the initialized Spring context\n     * @param testClass the test class being executed\n     */\n    protected void handleShutdownTimeout(GenericApplicationContext context, Class<?> testClass) throws Exception {\n        final int shutdownTimeout;\n        final TimeUnit shutdownTimeUnit;\n        if (testClass.isAnnotationPresent(ShutdownTimeout.class)) {\n            shutdownTimeout = testClass.getAnnotation(ShutdownTimeout.class).value();\n            shutdownTimeUnit = testClass.getAnnotation(ShutdownTimeout.class).timeUnit();\n        } else {\n            shutdownTimeout = 10;\n            shutdownTimeUnit = TimeUnit.SECONDS;\n        }\n        \n        CamelSpringTestHelper.doToSpringCamelContexts(context, new DoToSpringCamelContextsStrategy() {\n            \n            @Override\n            public void execute(String contextName, SpringCamelContext camelContext)\n                throws Exception {\n                LOG.info(\"Setting shutdown timeout to [{} {}] on CamelContext with name [{}].\", shutdownTimeout, shutdownTimeUnit, contextName);\n                camelContext.getShutdownStrategy().setTimeout(shutdownTimeout);\n                camelContext.getShutdownStrategy().setTimeUnit(shutdownTimeUnit);\n            }\n        });\n    }"
        ],
        [
            "FtpOperations::doConnect(RemoteFileConfiguration)",
            "  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187 -\n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  ",
            "    protected boolean doConnect(RemoteFileConfiguration configuration) throws GenericFileOperationFailedException {\n        log.trace(\"Connecting using FTPClient: {}\", client);\n\n        String host = configuration.getHost();\n        int port = configuration.getPort();\n        String username = configuration.getUsername();\n        String account = ((FtpConfiguration) configuration).getAccount();\n\n        if (clientConfig != null) {\n            log.trace(\"Configuring FTPClient with config: {}\", clientConfig);\n            client.configure(clientConfig);\n        }\n\n        if (log.isTraceEnabled()) {\n            log.trace(\"Connecting to {} using connection timeout: {}\",\n                    configuration.remoteServerInformation(), client.getConnectTimeout());\n        }\n\n        boolean connected = false;\n        int attempt = 0;\n\n        while (!connected) {\n            try {\n                if (log.isTraceEnabled() && attempt > 0) {\n                    log.trace(\"Reconnect attempt #{} connecting to {}\", attempt, configuration.remoteServerInformation());\n                }\n                clientActivityListener.onConnecting(host);\n                client.connect(host, port);\n                // must check reply code if we are connected\n                int reply = client.getReplyCode();\n\n                if (FTPReply.isPositiveCompletion(reply)) {\n                    // yes we could connect\n                    connected = true;\n                } else {\n                    // throw an exception to force the retry logic in the catch exception block\n                    throw new GenericFileOperationFailedException(client.getReplyCode(), client.getReplyString(), \"Server refused connection\");\n                }\n            } catch (Exception e) {\n                // check if we are interrupted so we can break out\n                if (Thread.currentThread().isInterrupted()) {\n                    throw new GenericFileOperationFailedException(\"Interrupted during connecting\", new InterruptedException(\"Interrupted during connecting\"));\n                }\n\n                GenericFileOperationFailedException failed;\n                if (e instanceof GenericFileOperationFailedException) {\n                    failed = (GenericFileOperationFailedException) e;\n                } else {\n                    failed = new GenericFileOperationFailedException(client.getReplyCode(), client.getReplyString(), e.getMessage(), e);\n                }\n\n                log.trace(\"Cannot connect due: {}\", failed.getMessage());\n                attempt++;\n                if (attempt > endpoint.getMaximumReconnectAttempts()) {\n                    throw failed;\n                }\n                if (endpoint.getReconnectDelay() > 0) {\n                    try {\n                        Thread.sleep(endpoint.getReconnectDelay());\n                    } catch (InterruptedException ie) {\n                        // we could potentially also be interrupted during sleep\n                        Thread.currentThread().interrupt();\n                        throw new GenericFileOperationFailedException(\"Interrupted during sleeping\", ie);\n                    }\n                }\n            }\n        }\n\n        // we are now connected\n        clientActivityListener.onConnected(host);\n\n        // must enter passive mode directly after connect\n        if (configuration.isPassiveMode()) {\n            log.trace(\"Using passive mode connections\");\n            client.enterLocalPassiveMode();\n        }\n\n        // must set soTimeout after connect\n        if (endpoint instanceof FtpEndpoint) {\n            FtpEndpoint<?> ftpEndpoint = endpoint;\n            if (ftpEndpoint.getSoTimeout() > 0) {\n                log.trace(\"Using SoTimeout={}\", ftpEndpoint.getSoTimeout());\n                try {\n                    client.setSoTimeout(ftpEndpoint.getSoTimeout());\n                } catch (IOException e) {\n                    throw new GenericFileOperationFailedException(client.getReplyCode(), client.getReplyString(), e.getMessage(), e);\n                }\n            }\n        }\n\n        try {\n            clientActivityListener.onLogin(host);\n            boolean login;\n            if (username != null) {\n                if (account != null) {\n                    log.trace(\"Attempting to login user: {} using password: ******** and account: {}\", new Object[]{username, account});\n                    login = client.login(username, configuration.getPassword(), account);\n                } else {\n                    log.trace(\"Attempting to login user: {} using password: ********\", username);\n                    login = client.login(username, configuration.getPassword());\n                }\n            } else {\n                if (account != null) {\n                    // not sure if it makes sense to login anonymous with account?\n                    log.trace(\"Attempting to login anonymous using account: {}\", account);\n                    login = client.login(\"anonymous\", \"\", account);\n                } else {\n                    log.trace(\"Attempting to login anonymous\");\n                    login = client.login(\"anonymous\", \"\");\n                }\n            }\n            log.trace(\"User {} logged in: {}\", username != null ? username : \"anonymous\", login);\n            if (!login) {\n                // store replyString, because disconnect() will reset it\n                String replyString = client.getReplyString();\n                int replyCode = client.getReplyCode();\n                clientActivityListener.onLoginFailed(replyCode, replyString);\n                // disconnect to prevent connection leaks\n                client.disconnect();\n                throw new GenericFileOperationFailedException(replyCode, replyString);\n            }\n            clientActivityListener.onLoginComplete(host);\n            client.setFileType(configuration.isBinary() ? FTP.BINARY_FILE_TYPE : FTP.ASCII_FILE_TYPE);\n        } catch (IOException e) {\n            throw new GenericFileOperationFailedException(client.getReplyCode(), client.getReplyString(), e.getMessage(), e);\n        }\n\n        // site commands\n        if (endpoint.getConfiguration().getSiteCommand() != null) {\n            // commands can be separated using new line\n            Iterator<?> it = ObjectHelper.createIterator(endpoint.getConfiguration().getSiteCommand(), \"\\n\");\n            while (it.hasNext()) {\n                Object next = it.next();\n                String command = endpoint.getCamelContext().getTypeConverter().convertTo(String.class, next);\n                log.trace(\"Site command to send: {}\", command);\n                if (command != null) {\n                    boolean result = sendSiteCommand(command);\n                    if (!result) {\n                        throw new GenericFileOperationFailedException(\"Site command: \" + command + \" returned false\");\n                    }\n                }\n            }\n        }\n\n        return true;\n    }",
            "  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187 +\n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  ",
            "    protected boolean doConnect(RemoteFileConfiguration configuration) throws GenericFileOperationFailedException {\n        log.trace(\"Connecting using FTPClient: {}\", client);\n\n        String host = configuration.getHost();\n        int port = configuration.getPort();\n        String username = configuration.getUsername();\n        String account = ((FtpConfiguration) configuration).getAccount();\n\n        if (clientConfig != null) {\n            log.trace(\"Configuring FTPClient with config: {}\", clientConfig);\n            client.configure(clientConfig);\n        }\n\n        if (log.isTraceEnabled()) {\n            log.trace(\"Connecting to {} using connection timeout: {}\",\n                    configuration.remoteServerInformation(), client.getConnectTimeout());\n        }\n\n        boolean connected = false;\n        int attempt = 0;\n\n        while (!connected) {\n            try {\n                if (log.isTraceEnabled() && attempt > 0) {\n                    log.trace(\"Reconnect attempt #{} connecting to {}\", attempt, configuration.remoteServerInformation());\n                }\n                clientActivityListener.onConnecting(host);\n                client.connect(host, port);\n                // must check reply code if we are connected\n                int reply = client.getReplyCode();\n\n                if (FTPReply.isPositiveCompletion(reply)) {\n                    // yes we could connect\n                    connected = true;\n                } else {\n                    // throw an exception to force the retry logic in the catch exception block\n                    throw new GenericFileOperationFailedException(client.getReplyCode(), client.getReplyString(), \"Server refused connection\");\n                }\n            } catch (Exception e) {\n                // check if we are interrupted so we can break out\n                if (Thread.currentThread().isInterrupted()) {\n                    throw new GenericFileOperationFailedException(\"Interrupted during connecting\", new InterruptedException(\"Interrupted during connecting\"));\n                }\n\n                GenericFileOperationFailedException failed;\n                if (e instanceof GenericFileOperationFailedException) {\n                    failed = (GenericFileOperationFailedException) e;\n                } else {\n                    failed = new GenericFileOperationFailedException(client.getReplyCode(), client.getReplyString(), e.getMessage(), e);\n                }\n\n                log.trace(\"Cannot connect due: {}\", failed.getMessage());\n                attempt++;\n                if (attempt > endpoint.getMaximumReconnectAttempts()) {\n                    throw failed;\n                }\n                if (endpoint.getReconnectDelay() > 0) {\n                    try {\n                        Thread.sleep(endpoint.getReconnectDelay());\n                    } catch (InterruptedException ie) {\n                        // we could potentially also be interrupted during sleep\n                        Thread.currentThread().interrupt();\n                        throw new GenericFileOperationFailedException(\"Interrupted during sleeping\", ie);\n                    }\n                }\n            }\n        }\n\n        // we are now connected\n        clientActivityListener.onConnected(host);\n\n        // must enter passive mode directly after connect\n        if (configuration.isPassiveMode()) {\n            log.trace(\"Using passive mode connections\");\n            client.enterLocalPassiveMode();\n        }\n\n        // must set soTimeout after connect\n        if (endpoint instanceof FtpEndpoint) {\n            FtpEndpoint<?> ftpEndpoint = endpoint;\n            if (ftpEndpoint.getSoTimeout() > 0) {\n                log.trace(\"Using SoTimeout={}\", ftpEndpoint.getSoTimeout());\n                try {\n                    client.setSoTimeout(ftpEndpoint.getSoTimeout());\n                } catch (IOException e) {\n                    throw new GenericFileOperationFailedException(client.getReplyCode(), client.getReplyString(), e.getMessage(), e);\n                }\n            }\n        }\n\n        try {\n            clientActivityListener.onLogin(host);\n            boolean login;\n            if (username != null) {\n                if (account != null) {\n                    log.trace(\"Attempting to login user: {} using password: ******** and account: {}\", username, account);\n                    login = client.login(username, configuration.getPassword(), account);\n                } else {\n                    log.trace(\"Attempting to login user: {} using password: ********\", username);\n                    login = client.login(username, configuration.getPassword());\n                }\n            } else {\n                if (account != null) {\n                    // not sure if it makes sense to login anonymous with account?\n                    log.trace(\"Attempting to login anonymous using account: {}\", account);\n                    login = client.login(\"anonymous\", \"\", account);\n                } else {\n                    log.trace(\"Attempting to login anonymous\");\n                    login = client.login(\"anonymous\", \"\");\n                }\n            }\n            log.trace(\"User {} logged in: {}\", username != null ? username : \"anonymous\", login);\n            if (!login) {\n                // store replyString, because disconnect() will reset it\n                String replyString = client.getReplyString();\n                int replyCode = client.getReplyCode();\n                clientActivityListener.onLoginFailed(replyCode, replyString);\n                // disconnect to prevent connection leaks\n                client.disconnect();\n                throw new GenericFileOperationFailedException(replyCode, replyString);\n            }\n            clientActivityListener.onLoginComplete(host);\n            client.setFileType(configuration.isBinary() ? FTP.BINARY_FILE_TYPE : FTP.ASCII_FILE_TYPE);\n        } catch (IOException e) {\n            throw new GenericFileOperationFailedException(client.getReplyCode(), client.getReplyString(), e.getMessage(), e);\n        }\n\n        // site commands\n        if (endpoint.getConfiguration().getSiteCommand() != null) {\n            // commands can be separated using new line\n            Iterator<?> it = ObjectHelper.createIterator(endpoint.getConfiguration().getSiteCommand(), \"\\n\");\n            while (it.hasNext()) {\n                Object next = it.next();\n                String command = endpoint.getCamelContext().getTypeConverter().convertTo(String.class, next);\n                log.trace(\"Site command to send: {}\", command);\n                if (command != null) {\n                    boolean result = sendSiteCommand(command);\n                    if (!result) {\n                        throw new GenericFileOperationFailedException(\"Site command: \" + command + \" returned false\");\n                    }\n                }\n            }\n        }\n\n        return true;\n    }"
        ],
        [
            "OsgiClassResolver::resolveClass(String)",
            "  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60 -\n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67 -\n  68  \n  69  \n  70  \n  71  ",
            "    @Override\n    public Class<?> resolveClass(String name) {\n        LOG.trace(\"Resolve class {}\", name);\n        name = ObjectHelper.normalizeClassName(name);\n        if (ObjectHelper.isEmpty(name)) {\n            return null;\n        }\n        // we need to avoid the NPE issue of loading the class\n        Class<?> clazz = ObjectHelper.loadSimpleType(name);\n        if (clazz == null) {\n            clazz = doLoadClass(name, bundleContext.getBundle());\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Loading class {} using BundleContext {} -> {}\", new Object[]{name, bundleContext.getBundle(), clazz});\n            }\n        }\n        if (clazz == null && camelContext != null) {\n            // fallback and load class using the application context classloader\n            clazz = super.loadClass(name, camelContext.getApplicationContextClassLoader());\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Loading class {} using CamelContext {} -> {}\", new Object[]{name, camelContext, clazz});\n            }\n        }\n        return clazz;\n    }",
            "  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60 +\n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67 +\n  68  \n  69  \n  70  \n  71  ",
            "    @Override\n    public Class<?> resolveClass(String name) {\n        LOG.trace(\"Resolve class {}\", name);\n        name = ObjectHelper.normalizeClassName(name);\n        if (ObjectHelper.isEmpty(name)) {\n            return null;\n        }\n        // we need to avoid the NPE issue of loading the class\n        Class<?> clazz = ObjectHelper.loadSimpleType(name);\n        if (clazz == null) {\n            clazz = doLoadClass(name, bundleContext.getBundle());\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Loading class {} using BundleContext {} -> {}\", name, bundleContext.getBundle(), clazz);\n            }\n        }\n        if (clazz == null && camelContext != null) {\n            // fallback and load class using the application context classloader\n            clazz = super.loadClass(name, camelContext.getApplicationContextClassLoader());\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Loading class {} using CamelContext {} -> {}\", name, camelContext, clazz);\n            }\n        }\n        return clazz;\n    }"
        ],
        [
            "OsgiNamingHelper::findFreeCamelContextName(BundleContext,String,String,AtomicInteger,boolean)",
            "  38  \n  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82 -\n  83  \n  84  ",
            "    /**\n     * Checks the OSGi service registry for a free name (uses the counter if there is a clash to find next free name)\n     *\n     * @param context the bundle context\n     * @param prefix  the prefix for the name\n     * @param key     the key to use in the OSGi filter; either {@link OsgiCamelContextPublisher#CONTEXT_NAME_PROPERTY}\n     *                or {@link OsgiCamelContextPublisher#CONTEXT_MANAGEMENT_NAME_PROPERTY}.\n     * @param counter the counter\n     * @param checkFirst <tt>true</tt> to check the prefix name as-is before using the counter, <tt>false</tt> the counter is used immediately\n     * @return the free name, is never <tt>null</tt>\n     */\n    public static String findFreeCamelContextName(BundleContext context, String prefix, String key, AtomicInteger counter, boolean checkFirst) {\n        String candidate = null;\n        boolean clash = false;\n\n        do {\n            try {\n                clash = false;\n\n                if (candidate == null && checkFirst) {\n                    // try candidate as-is\n                    candidate = prefix;\n                } else {\n                    // generate new candidate\n                    candidate = prefix + \"-\" + getNextCounter(counter);\n                }\n                LOG.trace(\"Checking OSGi Service Registry for existence of existing CamelContext with name: {}\", candidate);\n\n                ServiceReference<?>[] refs = context.getServiceReferences(CamelContext.class.getName(), \"(\" + key + \"=\" + candidate + \")\");\n                if (refs != null && refs.length > 0) {\n                    for (ServiceReference<?> ref : refs) {\n                        Object id = ref.getProperty(key);\n                        if (id != null && candidate.equals(id)) {\n                            clash = true;\n                            break;\n                        }\n                    }\n                }\n            } catch (InvalidSyntaxException e) {\n                LOG.debug(\"Error finding free Camel name in OSGi Service Registry due \" + e.getMessage() + \". This exception is ignored.\", e);\n                break;\n            }\n        } while (clash);\n\n        LOG.debug(\"Generated free name for bundle id: {}, clash: {} -> {}\", new Object[]{context.getBundle().getBundleId(), clash, candidate});\n        return candidate;\n    }",
            "  38  \n  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82 +\n  83  \n  84  ",
            "    /**\n     * Checks the OSGi service registry for a free name (uses the counter if there is a clash to find next free name)\n     *\n     * @param context the bundle context\n     * @param prefix  the prefix for the name\n     * @param key     the key to use in the OSGi filter; either {@link OsgiCamelContextPublisher#CONTEXT_NAME_PROPERTY}\n     *                or {@link OsgiCamelContextPublisher#CONTEXT_MANAGEMENT_NAME_PROPERTY}.\n     * @param counter the counter\n     * @param checkFirst <tt>true</tt> to check the prefix name as-is before using the counter, <tt>false</tt> the counter is used immediately\n     * @return the free name, is never <tt>null</tt>\n     */\n    public static String findFreeCamelContextName(BundleContext context, String prefix, String key, AtomicInteger counter, boolean checkFirst) {\n        String candidate = null;\n        boolean clash = false;\n\n        do {\n            try {\n                clash = false;\n\n                if (candidate == null && checkFirst) {\n                    // try candidate as-is\n                    candidate = prefix;\n                } else {\n                    // generate new candidate\n                    candidate = prefix + \"-\" + getNextCounter(counter);\n                }\n                LOG.trace(\"Checking OSGi Service Registry for existence of existing CamelContext with name: {}\", candidate);\n\n                ServiceReference<?>[] refs = context.getServiceReferences(CamelContext.class.getName(), \"(\" + key + \"=\" + candidate + \")\");\n                if (refs != null && refs.length > 0) {\n                    for (ServiceReference<?> ref : refs) {\n                        Object id = ref.getProperty(key);\n                        if (id != null && candidate.equals(id)) {\n                            clash = true;\n                            break;\n                        }\n                    }\n                }\n            } catch (InvalidSyntaxException e) {\n                LOG.debug(\"Error finding free Camel name in OSGi Service Registry due \" + e.getMessage() + \". This exception is ignored.\", e);\n                break;\n            }\n        } while (clash);\n\n        LOG.debug(\"Generated free name for bundle id: {}, clash: {} -> {}\", context.getBundle().getBundleId(), clash, candidate);\n        return candidate;\n    }"
        ],
        [
            "ClientChannelHandler::getResponseMessage(Exchange,ChannelHandlerContext,Object)",
            " 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236 -\n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  ",
            "    /**\n     * Gets the Camel {@link Message} to use as the message to be set on the current {@link Exchange} when\n     * we have received a reply message.\n     * <p/>\n     *\n     * @param exchange      the current exchange\n     * @param ctx       the channel handler context\n     * @param message  the incoming event which has the response message from Netty.\n     * @return the Camel {@link Message} to set on the current {@link Exchange} as the response message.\n     * @throws Exception is thrown if error getting the response message\n     */\n    protected Message getResponseMessage(Exchange exchange, ChannelHandlerContext ctx, Object message) throws Exception {\n        Object body = message;\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Channel: {} received body: {}\", new Object[]{ctx.channel(), body});\n        }\n\n        // if textline enabled then covert to a String which must be used for textline\n        if (producer.getConfiguration().isTextline()) {\n            body = producer.getContext().getTypeConverter().mandatoryConvertTo(String.class, exchange, message);\n        }\n\n        // set the result on either IN or OUT on the original exchange depending on its pattern\n        if (ExchangeHelper.isOutCapable(exchange)) {\n            NettyPayloadHelper.setOut(exchange, body);\n            return exchange.getOut();\n        } else {\n            NettyPayloadHelper.setIn(exchange, body);\n            return exchange.getIn();\n        }\n    }",
            " 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236 +\n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  ",
            "    /**\n     * Gets the Camel {@link Message} to use as the message to be set on the current {@link Exchange} when\n     * we have received a reply message.\n     * <p/>\n     *\n     * @param exchange      the current exchange\n     * @param ctx       the channel handler context\n     * @param message  the incoming event which has the response message from Netty.\n     * @return the Camel {@link Message} to set on the current {@link Exchange} as the response message.\n     * @throws Exception is thrown if error getting the response message\n     */\n    protected Message getResponseMessage(Exchange exchange, ChannelHandlerContext ctx, Object message) throws Exception {\n        Object body = message;\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Channel: {} received body: {}\", ctx.channel(), body);\n        }\n\n        // if textline enabled then covert to a String which must be used for textline\n        if (producer.getConfiguration().isTextline()) {\n            body = producer.getContext().getTypeConverter().mandatoryConvertTo(String.class, exchange, message);\n        }\n\n        // set the result on either IN or OUT on the original exchange depending on its pattern\n        if (ExchangeHelper.isOutCapable(exchange)) {\n            NettyPayloadHelper.setOut(exchange, body);\n            return exchange.getOut();\n        } else {\n            NettyPayloadHelper.setIn(exchange, body);\n            return exchange.getIn();\n        }\n    }"
        ],
        [
            "EndpointMessageListener::sendReply(Destination,Message,Exchange,org,Exception)",
            " 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377 -\n 378  \n 379  \n 380  \n 381  \n 382  ",
            "    protected void sendReply(Destination replyDestination, final Message message, final Exchange exchange,\n                             final org.apache.camel.Message out, final Exception cause) {\n        if (replyDestination == null) {\n            LOG.debug(\"Cannot send reply message as there is no replyDestination for: {}\", out);\n            return;\n        }\n        getTemplate().send(replyDestination, new MessageCreator() {\n            public Message createMessage(Session session) throws JMSException {\n                Message reply = endpoint.getBinding().makeJmsMessage(exchange, out, session, cause);\n                final String correlationID = determineCorrelationId(message);\n                reply.setJMSCorrelationID(correlationID);\n\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"{} sending reply JMS message [correlationId:{}]: {}\", new Object[]{endpoint, correlationID, reply});\n                }\n                return reply;\n            }\n        });\n    }",
            " 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377 +\n 378  \n 379  \n 380  \n 381  \n 382  ",
            "    protected void sendReply(Destination replyDestination, final Message message, final Exchange exchange,\n                             final org.apache.camel.Message out, final Exception cause) {\n        if (replyDestination == null) {\n            LOG.debug(\"Cannot send reply message as there is no replyDestination for: {}\", out);\n            return;\n        }\n        getTemplate().send(replyDestination, new MessageCreator() {\n            public Message createMessage(Session session) throws JMSException {\n                Message reply = endpoint.getBinding().makeJmsMessage(exchange, out, session, cause);\n                final String correlationID = determineCorrelationId(message);\n                reply.setJMSCorrelationID(correlationID);\n\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"{} sending reply JMS message [correlationId:{}]: {}\", endpoint, correlationID, reply);\n                }\n                return reply;\n            }\n        });\n    }"
        ],
        [
            "WebsocketComponent::doStop()",
            " 796  \n 797  \n 798  \n 799  \n 800  \n 801  \n 802  \n 803  \n 804  \n 805  \n 806  \n 807  \n 808  \n 809  \n 810  \n 811  \n 812  \n 813  \n 814  \n 815 -\n 816  \n 817  \n 818  \n 819  \n 820  \n 821  \n 822  ",
            "    @Override\n    public void doStop() throws Exception {\n        super.doStop();\n        if (CONNECTORS.size() > 0) {\n            for (String connectorKey : CONNECTORS.keySet()) {\n                ConnectorRef connectorRef = CONNECTORS.get(connectorKey);\n                if (connectorRef != null && connectorRef.getRefCount() == 0) {\n                    connectorRef.server.removeConnector(connectorRef.connector);\n                    connectorRef.connector.stop();\n                    connectorRef.server.stop();\n                    connectorRef.memoryStore.stop();\n                    connectorRef.servlet = null;\n                }\n                CONNECTORS.remove(connectorKey);\n            }\n        }\n        CONNECTORS.clear();\n\n        if (staticResourcesServer != null) {\n            LOG.info(\"Stopping static resources server {}:{} with static resource: {}\", new Object[]{host, port, staticResources});\n            staticResourcesServer.stop();\n            staticResourcesServer.destroy();\n            staticResourcesServer = null;\n        }\n\n        servlets.clear();\n    }",
            " 796  \n 797  \n 798  \n 799  \n 800  \n 801  \n 802  \n 803  \n 804  \n 805  \n 806  \n 807  \n 808  \n 809  \n 810  \n 811  \n 812  \n 813  \n 814  \n 815 +\n 816  \n 817  \n 818  \n 819  \n 820  \n 821  \n 822  ",
            "    @Override\n    public void doStop() throws Exception {\n        super.doStop();\n        if (CONNECTORS.size() > 0) {\n            for (String connectorKey : CONNECTORS.keySet()) {\n                ConnectorRef connectorRef = CONNECTORS.get(connectorKey);\n                if (connectorRef != null && connectorRef.getRefCount() == 0) {\n                    connectorRef.server.removeConnector(connectorRef.connector);\n                    connectorRef.connector.stop();\n                    connectorRef.server.stop();\n                    connectorRef.memoryStore.stop();\n                    connectorRef.servlet = null;\n                }\n                CONNECTORS.remove(connectorKey);\n            }\n        }\n        CONNECTORS.clear();\n\n        if (staticResourcesServer != null) {\n            LOG.info(\"Stopping static resources server {}:{} with static resource: {}\", host, port, staticResources);\n            staticResourcesServer.stop();\n            staticResourcesServer.destroy();\n            staticResourcesServer = null;\n        }\n\n        servlets.clear();\n    }"
        ],
        [
            "BindyCsvFactory::generateCsvPositionMap(Class,Object,Map)",
            " 443  \n 444  \n 445  \n 446  \n 447  \n 448  \n 449  \n 450  \n 451  \n 452  \n 453  \n 454  \n 455  \n 456  \n 457  \n 458  \n 459  \n 460  \n 461  \n 462  \n 463  \n 464  \n 465  \n 466  \n 467  \n 468  \n 469  \n 470  \n 471  \n 472  \n 473  \n 474  \n 475  \n 476  \n 477  \n 478  \n 479  \n 480  \n 481  \n 482  \n 483  \n 484  \n 485  \n 486  \n 487  \n 488  \n 489 -\n 490  \n 491  \n 492  \n 493  \n 494  \n 495  \n 496  \n 497  \n 498  \n 499  \n 500  \n 501  \n 502  \n 503  \n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512  \n 513  \n 514  \n 515  \n 516  \n 517  \n 518  \n 519  \n 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528  \n 529  \n 530  \n 531  \n 532  \n 533  \n 534  \n 535  \n 536  \n 537  \n 538  \n 539  \n 540  \n 541  \n 542  \n 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  ",
            "    /**\n     * Generate a table containing the data formatted and sorted with their position/offset\n     * If the model is Ordered than a key is created combining the annotation @Section and Position of the field\n     * If a relation @OneToMany is defined, than we iterate recursively through this function\n     * The result is placed in the Map<Integer, List> results\n     */\n    private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {\n\n        String result = \"\";\n\n        for (Field field : clazz.getDeclaredFields()) {\n\n            field.setAccessible(true);\n\n            DataField datafield = field.getAnnotation(DataField.class);\n\n            if (datafield != null) {\n\n                if (obj != null) {\n\n                    // Create format\n                    FormattingOptions formattingOptions = ConverterUtils.convert(datafield,\n                            field.getType(),\n                            field.getAnnotation(BindyConverter.class),\n                            getLocale());\n                    Format<?> format = formatFactory.getFormat(formattingOptions);\n\n                    // Get field value\n                    Object value = field.get(obj);\n\n                    // If the field value is empty, populate it with the default value\n                    if (ObjectHelper.isNotEmpty(datafield.defaultValue()) && ObjectHelper.isEmpty(value)) {\n                        value = datafield.defaultValue();\n                    }\n\n                    result = formatString(format, value);\n\n                    if (datafield.trim()) {\n                        result = result.trim();\n                    }\n\n                    if (datafield.clip() && result.length() > datafield.length()) {\n                        result = result.substring(0, datafield.length());\n                    }\n\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Value to be formatted: {}, position: {}, and its formatted value: {}\", new Object[]{value, datafield.pos(), result});\n                    }\n\n                } else {\n                    result = \"\";\n                }\n\n                Integer key;\n\n                if (isMessageOrdered() && obj != null) {\n\n                    // Generate a key using the number of the section\n                    // and the position of the field\n                    Integer key1 = sections.get(obj.getClass().getName());\n                    Integer key2 = datafield.position();\n                    Integer keyGenerated = generateKey(key1, key2);\n\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Key generated: {}, for section: {}\", String.valueOf(keyGenerated), key1);\n                    }\n\n                    key = keyGenerated;\n\n                } else {\n                    key = datafield.pos();\n                }\n\n                if (!results.containsKey(key)) {\n                    List<String> list = new LinkedList<>();\n                    list.add(result);\n                    results.put(key, list);\n                } else {\n                    List<String> list = results.get(key);\n                    list.add(result);\n                }\n\n            }\n\n            OneToMany oneToMany = field.getAnnotation(OneToMany.class);\n            if (oneToMany != null) {\n\n                // Set global variable\n                // Will be used during generation of CSV\n                isOneToMany = true;\n\n                List<?> list = (List<?>)field.get(obj);\n                if (list != null) {\n\n                    Iterator<?> it = list.iterator();\n                    while (it.hasNext()) {\n                        Object target = it.next();\n                        generateCsvPositionMap(target.getClass(), target, results);\n                    }\n\n                } else {\n\n                    // Call this function to add empty value\n                    // in the table\n                    generateCsvPositionMap(field.getClass(), null, results);\n                }\n\n            }\n        }\n\n    }",
            " 443  \n 444  \n 445  \n 446  \n 447  \n 448  \n 449  \n 450  \n 451  \n 452  \n 453  \n 454  \n 455  \n 456  \n 457  \n 458  \n 459  \n 460  \n 461  \n 462  \n 463  \n 464  \n 465  \n 466  \n 467  \n 468  \n 469  \n 470  \n 471  \n 472  \n 473  \n 474  \n 475  \n 476  \n 477  \n 478  \n 479  \n 480  \n 481  \n 482  \n 483  \n 484  \n 485  \n 486  \n 487  \n 488  \n 489 +\n 490  \n 491  \n 492  \n 493  \n 494  \n 495  \n 496  \n 497  \n 498  \n 499  \n 500  \n 501  \n 502  \n 503  \n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512  \n 513  \n 514  \n 515  \n 516  \n 517  \n 518  \n 519  \n 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528  \n 529  \n 530  \n 531  \n 532  \n 533  \n 534  \n 535  \n 536  \n 537  \n 538  \n 539  \n 540  \n 541  \n 542  \n 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  ",
            "    /**\n     * Generate a table containing the data formatted and sorted with their position/offset\n     * If the model is Ordered than a key is created combining the annotation @Section and Position of the field\n     * If a relation @OneToMany is defined, than we iterate recursively through this function\n     * The result is placed in the Map<Integer, List> results\n     */\n    private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {\n\n        String result = \"\";\n\n        for (Field field : clazz.getDeclaredFields()) {\n\n            field.setAccessible(true);\n\n            DataField datafield = field.getAnnotation(DataField.class);\n\n            if (datafield != null) {\n\n                if (obj != null) {\n\n                    // Create format\n                    FormattingOptions formattingOptions = ConverterUtils.convert(datafield,\n                            field.getType(),\n                            field.getAnnotation(BindyConverter.class),\n                            getLocale());\n                    Format<?> format = formatFactory.getFormat(formattingOptions);\n\n                    // Get field value\n                    Object value = field.get(obj);\n\n                    // If the field value is empty, populate it with the default value\n                    if (ObjectHelper.isNotEmpty(datafield.defaultValue()) && ObjectHelper.isEmpty(value)) {\n                        value = datafield.defaultValue();\n                    }\n\n                    result = formatString(format, value);\n\n                    if (datafield.trim()) {\n                        result = result.trim();\n                    }\n\n                    if (datafield.clip() && result.length() > datafield.length()) {\n                        result = result.substring(0, datafield.length());\n                    }\n\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Value to be formatted: {}, position: {}, and its formatted value: {}\", value, datafield.pos(), result);\n                    }\n\n                } else {\n                    result = \"\";\n                }\n\n                Integer key;\n\n                if (isMessageOrdered() && obj != null) {\n\n                    // Generate a key using the number of the section\n                    // and the position of the field\n                    Integer key1 = sections.get(obj.getClass().getName());\n                    Integer key2 = datafield.position();\n                    Integer keyGenerated = generateKey(key1, key2);\n\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Key generated: {}, for section: {}\", String.valueOf(keyGenerated), key1);\n                    }\n\n                    key = keyGenerated;\n\n                } else {\n                    key = datafield.pos();\n                }\n\n                if (!results.containsKey(key)) {\n                    List<String> list = new LinkedList<>();\n                    list.add(result);\n                    results.put(key, list);\n                } else {\n                    List<String> list = results.get(key);\n                    list.add(result);\n                }\n\n            }\n\n            OneToMany oneToMany = field.getAnnotation(OneToMany.class);\n            if (oneToMany != null) {\n\n                // Set global variable\n                // Will be used during generation of CSV\n                isOneToMany = true;\n\n                List<?> list = (List<?>)field.get(obj);\n                if (list != null) {\n\n                    Iterator<?> it = list.iterator();\n                    while (it.hasNext()) {\n                        Object target = it.next();\n                        generateCsvPositionMap(target.getClass(), target, results);\n                    }\n\n                } else {\n\n                    // Call this function to add empty value\n                    // in the table\n                    generateCsvPositionMap(field.getClass(), null, results);\n                }\n\n            }\n        }\n\n    }"
        ],
        [
            "BindyFixedLengthFactory::bind(CamelContext,String,Map,int)",
            " 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253 -\n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  ",
            "    public void bind(CamelContext camelContext, String record, Map<String, Object> model, int line) throws Exception {\n\n        int pos = 1;\n        int counterMandatoryFields = 0;\n        DataField dataField;\n        String token;\n        int offset = 1;\n        int length;\n        String delimiter;\n        Field field;\n\n        // Iterate through the list of positions\n        // defined in the @DataField\n        // and grab the data from the line\n        Collection<DataField> c = dataFields.values();\n        Iterator<DataField> itr = c.iterator();\n\n        // this iterator is for a link list that was built using items in order\n        while (itr.hasNext()) {\n            dataField = itr.next();\n            length = dataField.length();\n            delimiter = dataField.delimiter();\n\n            if (length == 0 && dataField.lengthPos() != 0) {\n                Field lengthField = annotatedFields.get(dataField.lengthPos());\n                lengthField.setAccessible(true);\n                Object modelObj = model.get(lengthField.getDeclaringClass().getName());\n                Object lengthObj =  lengthField.get(modelObj);\n                length = ((Integer)lengthObj).intValue();\n            }\n            if (length < 1 && delimiter == null && dataField.lengthPos() == 0) {\n                throw new IllegalArgumentException(\"Either length or delimiter must be specified for the field : \" + dataField.toString());\n            }\n            if (offset - 1 <= -1) {\n                throw new IllegalArgumentException(\"Offset/Position of the field \" + dataField.toString()\n                                                   + \" cannot be negative\");\n            }\n\n            // skip ahead if the expected position is greater than the offset\n            if (dataField.pos() > offset) {\n                LOG.debug(\"skipping ahead [\" + (dataField.pos() - offset) + \"] chars.\");\n                offset = dataField.pos();\n            }\n\n            if (length > 0) {\n                if (record.length() < offset) {\n                    token = \"\";\n                } else {\n                    int endIndex = offset + length - 1;\n                    if (endIndex > record.length()) {\n                        endIndex = record.length();\n                    }\n                    token = record.substring(offset - 1, endIndex);\n                }\n                offset += length;\n            } else if (!delimiter.equals(\"\")) {\n                String tempToken = record.substring(offset - 1, record.length());\n                token = tempToken.substring(0, tempToken.indexOf(delimiter));\n                // include the delimiter in the offset calculation\n                offset += token.length() + 1;\n            } else {\n                // defined as a zero-length field\n                token = \"\";\n            }\n\n            if (dataField.trim()) {\n                token = trim(token, dataField, paddingChar);\n                //token = token.trim();\n            }\n\n            // Check mandatory field\n            if (dataField.required()) {\n\n                // Increment counter of mandatory fields\n                ++counterMandatoryFields;\n\n                // Check if content of the field is empty\n                // This is not possible for mandatory fields\n                if (token.equals(\"\")) {\n                    throw new IllegalArgumentException(\"The mandatory field defined at the position \" + pos\n                                                       + \" is empty for the line: \" + line);\n                }\n            }\n\n            // Get Field to be set\n            field = annotatedFields.get(dataField.pos());\n            field.setAccessible(true);\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Pos/Offset: {}, Data: {}, Field type: {}\", new Object[]{offset, token, field.getType()});\n            }\n\n            // Create format object to format the field\n            FormattingOptions formattingOptions = ConverterUtils.convert(dataField,\n                    field.getType(),\n                    field.getAnnotation(BindyConverter.class),\n                    getLocale());\n            Format<?> format = formatFactory.getFormat(formattingOptions);\n\n            // field object to be set\n            Object modelField = model.get(field.getDeclaringClass().getName());\n\n            // format the data received\n            Object value = null;\n\n            if (\"\".equals(token)) {\n                token = dataField.defaultValue();\n            }\n            if (!\"\".equals(token)) {\n                try {\n                    value = format.parse(token);\n                } catch (FormatException ie) {\n                    throw new IllegalArgumentException(ie.getMessage() + \", position: \" + offset + \", line: \" + line, ie);\n                } catch (Exception e) {\n                    throw new IllegalArgumentException(\"Parsing error detected for field defined at the position/offset: \" + offset + \", line: \" + line, e);\n                }\n            } else {\n                value = getDefaultValueForPrimitive(field.getType());\n            }\n            \n            if (value != null && !dataField.method().isEmpty()) {\n                Class<?> clazz;\n                if (dataField.method().contains(\".\")) {\n                    clazz = camelContext.getClassResolver().resolveMandatoryClass(dataField.method().substring(0, dataField.method().lastIndexOf(\".\")));\n                } else {\n                    clazz = field.getType();\n                }\n                \n                String methodName = dataField.method().substring(dataField.method().lastIndexOf(\".\") + 1,\n                                                                   dataField.method().length());\n                \n                Method m = ReflectionHelper.findMethod(clazz, methodName, field.getType());\n                if (m != null) {\n                    // this method must be static and return type\n                    // must be the same as the datafield and \n                    // must receive only the datafield value \n                    // as the method argument\n                    value = ObjectHelper.invokeMethod(m, null, value);\n                } else {\n                    // fallback to method without parameter, that is on the value itself\n                    m = ReflectionHelper.findMethod(clazz, methodName);\n                    value = ObjectHelper.invokeMethod(m, value);\n                }\n            }\n\n            field.set(modelField, value);\n\n            ++pos;\n\n        }\n\n        // check for unmapped non-whitespace data at the end of the line\n        if (offset <= record.length() && !(record.substring(offset - 1, record.length())).trim().equals(\"\") && !isIgnoreTrailingChars()) {\n            throw new IllegalArgumentException(\"Unexpected / unmapped characters found at the end of the fixed-length record at line : \" + line);\n        }\n\n        LOG.debug(\"Counter mandatory fields: {}\", counterMandatoryFields);\n\n        if (pos < totalFields) {\n            throw new IllegalArgumentException(\"Some fields are missing (optional or mandatory), line: \" + line);\n        }\n\n        if (counterMandatoryFields < numberMandatoryFields) {\n            throw new IllegalArgumentException(\"Some mandatory fields are missing, line: \" + line);\n        }\n\n    }",
            " 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253 +\n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  ",
            "    public void bind(CamelContext camelContext, String record, Map<String, Object> model, int line) throws Exception {\n\n        int pos = 1;\n        int counterMandatoryFields = 0;\n        DataField dataField;\n        String token;\n        int offset = 1;\n        int length;\n        String delimiter;\n        Field field;\n\n        // Iterate through the list of positions\n        // defined in the @DataField\n        // and grab the data from the line\n        Collection<DataField> c = dataFields.values();\n        Iterator<DataField> itr = c.iterator();\n\n        // this iterator is for a link list that was built using items in order\n        while (itr.hasNext()) {\n            dataField = itr.next();\n            length = dataField.length();\n            delimiter = dataField.delimiter();\n\n            if (length == 0 && dataField.lengthPos() != 0) {\n                Field lengthField = annotatedFields.get(dataField.lengthPos());\n                lengthField.setAccessible(true);\n                Object modelObj = model.get(lengthField.getDeclaringClass().getName());\n                Object lengthObj =  lengthField.get(modelObj);\n                length = ((Integer)lengthObj).intValue();\n            }\n            if (length < 1 && delimiter == null && dataField.lengthPos() == 0) {\n                throw new IllegalArgumentException(\"Either length or delimiter must be specified for the field : \" + dataField.toString());\n            }\n            if (offset - 1 <= -1) {\n                throw new IllegalArgumentException(\"Offset/Position of the field \" + dataField.toString()\n                                                   + \" cannot be negative\");\n            }\n\n            // skip ahead if the expected position is greater than the offset\n            if (dataField.pos() > offset) {\n                LOG.debug(\"skipping ahead [\" + (dataField.pos() - offset) + \"] chars.\");\n                offset = dataField.pos();\n            }\n\n            if (length > 0) {\n                if (record.length() < offset) {\n                    token = \"\";\n                } else {\n                    int endIndex = offset + length - 1;\n                    if (endIndex > record.length()) {\n                        endIndex = record.length();\n                    }\n                    token = record.substring(offset - 1, endIndex);\n                }\n                offset += length;\n            } else if (!delimiter.equals(\"\")) {\n                String tempToken = record.substring(offset - 1, record.length());\n                token = tempToken.substring(0, tempToken.indexOf(delimiter));\n                // include the delimiter in the offset calculation\n                offset += token.length() + 1;\n            } else {\n                // defined as a zero-length field\n                token = \"\";\n            }\n\n            if (dataField.trim()) {\n                token = trim(token, dataField, paddingChar);\n                //token = token.trim();\n            }\n\n            // Check mandatory field\n            if (dataField.required()) {\n\n                // Increment counter of mandatory fields\n                ++counterMandatoryFields;\n\n                // Check if content of the field is empty\n                // This is not possible for mandatory fields\n                if (token.equals(\"\")) {\n                    throw new IllegalArgumentException(\"The mandatory field defined at the position \" + pos\n                                                       + \" is empty for the line: \" + line);\n                }\n            }\n\n            // Get Field to be set\n            field = annotatedFields.get(dataField.pos());\n            field.setAccessible(true);\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Pos/Offset: {}, Data: {}, Field type: {}\", offset, token, field.getType());\n            }\n\n            // Create format object to format the field\n            FormattingOptions formattingOptions = ConverterUtils.convert(dataField,\n                    field.getType(),\n                    field.getAnnotation(BindyConverter.class),\n                    getLocale());\n            Format<?> format = formatFactory.getFormat(formattingOptions);\n\n            // field object to be set\n            Object modelField = model.get(field.getDeclaringClass().getName());\n\n            // format the data received\n            Object value = null;\n\n            if (\"\".equals(token)) {\n                token = dataField.defaultValue();\n            }\n            if (!\"\".equals(token)) {\n                try {\n                    value = format.parse(token);\n                } catch (FormatException ie) {\n                    throw new IllegalArgumentException(ie.getMessage() + \", position: \" + offset + \", line: \" + line, ie);\n                } catch (Exception e) {\n                    throw new IllegalArgumentException(\"Parsing error detected for field defined at the position/offset: \" + offset + \", line: \" + line, e);\n                }\n            } else {\n                value = getDefaultValueForPrimitive(field.getType());\n            }\n            \n            if (value != null && !dataField.method().isEmpty()) {\n                Class<?> clazz;\n                if (dataField.method().contains(\".\")) {\n                    clazz = camelContext.getClassResolver().resolveMandatoryClass(dataField.method().substring(0, dataField.method().lastIndexOf(\".\")));\n                } else {\n                    clazz = field.getType();\n                }\n                \n                String methodName = dataField.method().substring(dataField.method().lastIndexOf(\".\") + 1,\n                                                                   dataField.method().length());\n                \n                Method m = ReflectionHelper.findMethod(clazz, methodName, field.getType());\n                if (m != null) {\n                    // this method must be static and return type\n                    // must be the same as the datafield and \n                    // must receive only the datafield value \n                    // as the method argument\n                    value = ObjectHelper.invokeMethod(m, null, value);\n                } else {\n                    // fallback to method without parameter, that is on the value itself\n                    m = ReflectionHelper.findMethod(clazz, methodName);\n                    value = ObjectHelper.invokeMethod(m, value);\n                }\n            }\n\n            field.set(modelField, value);\n\n            ++pos;\n\n        }\n\n        // check for unmapped non-whitespace data at the end of the line\n        if (offset <= record.length() && !(record.substring(offset - 1, record.length())).trim().equals(\"\") && !isIgnoreTrailingChars()) {\n            throw new IllegalArgumentException(\"Unexpected / unmapped characters found at the end of the fixed-length record at line : \" + line);\n        }\n\n        LOG.debug(\"Counter mandatory fields: {}\", counterMandatoryFields);\n\n        if (pos < totalFields) {\n            throw new IllegalArgumentException(\"Some fields are missing (optional or mandatory), line: \" + line);\n        }\n\n        if (counterMandatoryFields < numberMandatoryFields) {\n            throw new IllegalArgumentException(\"Some mandatory fields are missing, line: \" + line);\n        }\n\n    }"
        ],
        [
            "BindyKeyValuePairFactory::unbind(CamelContext,Map)",
            " 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  \n 423  \n 424  \n 425  \n 426  \n 427  \n 428  \n 429  \n 430  \n 431  \n 432  \n 433  \n 434  \n 435  \n 436  \n 437  \n 438  \n 439  \n 440  \n 441  \n 442  \n 443  \n 444  \n 445  \n 446  \n 447  \n 448 -\n 449  \n 450  \n 451  \n 452  \n 453  \n 454  \n 455  \n 456  \n 457  \n 458  \n 459  \n 460  \n 461  \n 462  \n 463  \n 464  \n 465  \n 466  \n 467  \n 468  \n 469  \n 470  \n 471  \n 472  \n 473  \n 474  \n 475  \n 476  \n 477  \n 478  \n 479  \n 480  \n 481  \n 482  \n 483  \n 484  \n 485  \n 486  \n 487  \n 488  \n 489  \n 490  \n 491  \n 492  \n 493  \n 494  \n 495  \n 496 -\n 497  \n 498  \n 499  \n 500  \n 501  \n 502  \n 503  \n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512  \n 513  \n 514  \n 515  \n 516  \n 517  \n 518  \n 519  \n 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528 -\n 529  \n 530  \n 531  \n 532  \n 533  \n 534  \n 535  \n 536  \n 537  \n 538  \n 539  \n 540  \n 541  \n 542  \n 543  \n 544  \n 545 -\n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  ",
            "    /**\n     *\n     */\n    @Override\n    public String unbind(CamelContext camelContext, Map<String, Object> model) throws Exception {\n\n        StringBuilder builder = new StringBuilder();\n\n        Map<Integer, KeyValuePairField> keyValuePairFieldsSorted = new TreeMap<>(keyValuePairFields);\n        Iterator<Integer> it = keyValuePairFieldsSorted.keySet().iterator();\n\n        // Map containing the OUT position of the field\n        // The key is double and is created using the position of the field and\n        // location of the class in the message (using section)\n        Map<Integer, String> positions = new TreeMap<>();\n\n        // Check if separator exists\n        ObjectHelper.notNull(this.pairSeparator, \"The pair separator has not been instantiated or property not defined in the @Message annotation\");\n\n        char separator = ConverterUtils.getCharDelimiter(this.getPairSeparator());\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Separator converted: '0x{}', from: {}\", Integer.toHexString(separator), this.getPairSeparator());\n        }\n\n        while (it.hasNext()) {\n\n            KeyValuePairField keyValuePairField = keyValuePairFieldsSorted.get(it.next());\n            ObjectHelper.notNull(keyValuePairField, \"KeyValuePair\");\n\n            // Retrieve the field\n            Field field = annotatedFields.get(keyValuePairField.tag());\n            // Change accessibility to allow to read protected/private fields\n            field.setAccessible(true);\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Tag: {}, Field type: {}, class: {}\", new Object[]{keyValuePairField.tag(), field.getType(), field.getDeclaringClass().getName()});\n            }\n\n            // Create format\n            FormattingOptions formattingOptions = ConverterUtils.convert(keyValuePairField,\n                    field.getType(),\n                    field.getAnnotation(BindyConverter.class),\n                    getLocale());\n            Format<Object> format = (Format<Object>) formatFactory.getFormat(formattingOptions);\n\n            // Get object to be formatted\n            Object obj = model.get(field.getDeclaringClass().getName());\n\n            if (obj != null) {\n\n                // Get field value\n                Object keyValue = field.get(obj);\n\n                if (this.isMessageOrdered()) {\n                    // Generate a key using the number of the section\n                    // and the position of the field\n                    Integer key1 = sections.get(obj.getClass().getName());\n                    Integer key2 = keyValuePairField.position();\n\n                    LOG.debug(\"Key of the section: {}, and the field: {}\", key1, key2);\n\n                    Integer keyGenerated = generateKey(key1, key2);\n\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Key generated: {}, for section: {}\", String.valueOf(keyGenerated), key1);\n                    }\n\n                    // Add value to the list if not null\n                    if (keyValue != null) {\n\n                        // Format field value\n                        String valueFormatted;\n\n                        try {\n                            valueFormatted = format.format(keyValue);\n                        } catch (Exception e) {\n                            throw new IllegalArgumentException(\"Formatting error detected for the tag: \" + keyValuePairField.tag(), e);\n                        }\n\n                        // Create the key value string\n                        String value = keyValuePairField.tag() + this.getKeyValuePairSeparator() + valueFormatted;\n\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Value to be formatted: {}, for the tag: {}, and its formatted value: {}\", new Object[]{keyValue, keyValuePairField.tag(), valueFormatted});\n                        }\n\n                        // Add the content to the TreeMap according to the\n                        // position defined\n                        positions.put(keyGenerated, value);\n\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Positions size: {}\", positions.size());\n                        }\n                    }\n                } else {\n\n                    // Add value to the list if not null\n                    if (keyValue != null) {\n\n                        // Format field value\n                        String valueFormatted;\n\n                        try {\n                            valueFormatted = format.format(keyValue);\n                        } catch (Exception e) {\n                            throw new IllegalArgumentException(\"Formatting error detected for the tag: \" + keyValuePairField.tag(), e);\n                        }\n\n                        // Create the key value string\n                        String value = keyValuePairField.tag() + this.getKeyValuePairSeparator() + valueFormatted + separator;\n\n                        // Add content to the stringBuilder\n                        builder.append(value);\n\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Value added: {}{}{}{}\", new Object[]{keyValuePairField.tag(), this.getKeyValuePairSeparator(), valueFormatted, separator});\n                        }\n                    }\n                }\n            }\n        }\n\n        // Iterate through the list to generate\n        // the message according to the order/position\n        if (this.isMessageOrdered()) {\n\n            Iterator<Integer> posit = positions.keySet().iterator();\n\n            while (posit.hasNext()) {\n                String value = positions.get(posit.next());\n\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Value added at the position ({}) : {}{}\", new Object[]{posit, value, separator});\n                }\n\n                builder.append(value + separator);\n            }\n        }\n\n        return builder.toString();\n    }",
            " 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  \n 423  \n 424  \n 425  \n 426  \n 427  \n 428  \n 429  \n 430  \n 431  \n 432  \n 433  \n 434  \n 435  \n 436  \n 437  \n 438  \n 439  \n 440  \n 441  \n 442  \n 443  \n 444  \n 445  \n 446  \n 447  \n 448 +\n 449  \n 450  \n 451  \n 452  \n 453  \n 454  \n 455  \n 456  \n 457  \n 458  \n 459  \n 460  \n 461  \n 462  \n 463  \n 464  \n 465  \n 466  \n 467  \n 468  \n 469  \n 470  \n 471  \n 472  \n 473  \n 474  \n 475  \n 476  \n 477  \n 478  \n 479  \n 480  \n 481  \n 482  \n 483  \n 484  \n 485  \n 486  \n 487  \n 488  \n 489  \n 490  \n 491  \n 492  \n 493  \n 494  \n 495  \n 496 +\n 497  \n 498  \n 499  \n 500  \n 501  \n 502  \n 503  \n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512  \n 513  \n 514  \n 515  \n 516  \n 517  \n 518  \n 519  \n 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528 +\n 529  \n 530  \n 531  \n 532  \n 533  \n 534  \n 535  \n 536  \n 537  \n 538  \n 539  \n 540  \n 541  \n 542  \n 543  \n 544  \n 545 +\n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  ",
            "    /**\n     *\n     */\n    @Override\n    public String unbind(CamelContext camelContext, Map<String, Object> model) throws Exception {\n\n        StringBuilder builder = new StringBuilder();\n\n        Map<Integer, KeyValuePairField> keyValuePairFieldsSorted = new TreeMap<>(keyValuePairFields);\n        Iterator<Integer> it = keyValuePairFieldsSorted.keySet().iterator();\n\n        // Map containing the OUT position of the field\n        // The key is double and is created using the position of the field and\n        // location of the class in the message (using section)\n        Map<Integer, String> positions = new TreeMap<>();\n\n        // Check if separator exists\n        ObjectHelper.notNull(this.pairSeparator, \"The pair separator has not been instantiated or property not defined in the @Message annotation\");\n\n        char separator = ConverterUtils.getCharDelimiter(this.getPairSeparator());\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Separator converted: '0x{}', from: {}\", Integer.toHexString(separator), this.getPairSeparator());\n        }\n\n        while (it.hasNext()) {\n\n            KeyValuePairField keyValuePairField = keyValuePairFieldsSorted.get(it.next());\n            ObjectHelper.notNull(keyValuePairField, \"KeyValuePair\");\n\n            // Retrieve the field\n            Field field = annotatedFields.get(keyValuePairField.tag());\n            // Change accessibility to allow to read protected/private fields\n            field.setAccessible(true);\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Tag: {}, Field type: {}, class: {}\", keyValuePairField.tag(), field.getType(), field.getDeclaringClass().getName());\n            }\n\n            // Create format\n            FormattingOptions formattingOptions = ConverterUtils.convert(keyValuePairField,\n                    field.getType(),\n                    field.getAnnotation(BindyConverter.class),\n                    getLocale());\n            Format<Object> format = (Format<Object>) formatFactory.getFormat(formattingOptions);\n\n            // Get object to be formatted\n            Object obj = model.get(field.getDeclaringClass().getName());\n\n            if (obj != null) {\n\n                // Get field value\n                Object keyValue = field.get(obj);\n\n                if (this.isMessageOrdered()) {\n                    // Generate a key using the number of the section\n                    // and the position of the field\n                    Integer key1 = sections.get(obj.getClass().getName());\n                    Integer key2 = keyValuePairField.position();\n\n                    LOG.debug(\"Key of the section: {}, and the field: {}\", key1, key2);\n\n                    Integer keyGenerated = generateKey(key1, key2);\n\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Key generated: {}, for section: {}\", String.valueOf(keyGenerated), key1);\n                    }\n\n                    // Add value to the list if not null\n                    if (keyValue != null) {\n\n                        // Format field value\n                        String valueFormatted;\n\n                        try {\n                            valueFormatted = format.format(keyValue);\n                        } catch (Exception e) {\n                            throw new IllegalArgumentException(\"Formatting error detected for the tag: \" + keyValuePairField.tag(), e);\n                        }\n\n                        // Create the key value string\n                        String value = keyValuePairField.tag() + this.getKeyValuePairSeparator() + valueFormatted;\n\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Value to be formatted: {}, for the tag: {}, and its formatted value: {}\", keyValue, keyValuePairField.tag(), valueFormatted);\n                        }\n\n                        // Add the content to the TreeMap according to the\n                        // position defined\n                        positions.put(keyGenerated, value);\n\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Positions size: {}\", positions.size());\n                        }\n                    }\n                } else {\n\n                    // Add value to the list if not null\n                    if (keyValue != null) {\n\n                        // Format field value\n                        String valueFormatted;\n\n                        try {\n                            valueFormatted = format.format(keyValue);\n                        } catch (Exception e) {\n                            throw new IllegalArgumentException(\"Formatting error detected for the tag: \" + keyValuePairField.tag(), e);\n                        }\n\n                        // Create the key value string\n                        String value = keyValuePairField.tag() + this.getKeyValuePairSeparator() + valueFormatted + separator;\n\n                        // Add content to the stringBuilder\n                        builder.append(value);\n\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Value added: {}{}{}{}\", keyValuePairField.tag(), this.getKeyValuePairSeparator(), valueFormatted, separator);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Iterate through the list to generate\n        // the message according to the order/position\n        if (this.isMessageOrdered()) {\n\n            Iterator<Integer> posit = positions.keySet().iterator();\n\n            while (posit.hasNext()) {\n                String value = positions.get(posit.next());\n\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Value added at the position ({}) : {}{}\", posit, value, separator);\n                }\n\n                builder.append(value + separator);\n            }\n        }\n\n        return builder.toString();\n    }"
        ],
        [
            "WebsocketComponent::doStart()",
            " 772  \n 773  \n 774  \n 775  \n 776  \n 777  \n 778  \n 779  \n 780  \n 781 -\n 782  \n 783  \n 784  \n 785  \n 786  \n 787  \n 788  \n 789  \n 790  \n 791  \n 792  \n 793  \n 794  ",
            "    @Override\n    protected void doStart() throws Exception {\n        super.doStart();\n\n        if (staticResources != null) {\n            // host and port must be configured\n            StringHelper.notEmpty(host, \"host\", this);\n            ObjectHelper.notNull(port, \"port\", this);\n\n            LOG.info(\"Starting static resources server {}:{} with static resource: {}\", new Object[]{host, port, staticResources});\n            ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);\n            staticResourcesServer = createStaticResourcesServer(context, host, port, staticResources);\n            staticResourcesServer.start();\n            ServerConnector connector = (ServerConnector) staticResourcesServer.getConnectors()[0];\n\n            // must add static resource server to CONNECTORS in case the websocket producers/consumers\n            // uses the same port number, and therefore we must be part of this\n            MemoryWebsocketStore memoryStore = new MemoryWebsocketStore();\n            ConnectorRef ref = new ConnectorRef(staticResourcesServer, connector, null, memoryStore);\n            String key = \"websocket:\" + host + \":\" + port;\n            CONNECTORS.put(key, ref);\n        }\n    }",
            " 772  \n 773  \n 774  \n 775  \n 776  \n 777  \n 778  \n 779  \n 780  \n 781 +\n 782  \n 783  \n 784  \n 785  \n 786  \n 787  \n 788  \n 789  \n 790  \n 791  \n 792  \n 793  \n 794  ",
            "    @Override\n    protected void doStart() throws Exception {\n        super.doStart();\n\n        if (staticResources != null) {\n            // host and port must be configured\n            StringHelper.notEmpty(host, \"host\", this);\n            ObjectHelper.notNull(port, \"port\", this);\n\n            LOG.info(\"Starting static resources server {}:{} with static resource: {}\", host, port, staticResources);\n            ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);\n            staticResourcesServer = createStaticResourcesServer(context, host, port, staticResources);\n            staticResourcesServer.start();\n            ServerConnector connector = (ServerConnector) staticResourcesServer.getConnectors()[0];\n\n            // must add static resource server to CONNECTORS in case the websocket producers/consumers\n            // uses the same port number, and therefore we must be part of this\n            MemoryWebsocketStore memoryStore = new MemoryWebsocketStore();\n            ConnectorRef ref = new ConnectorRef(staticResourcesServer, connector, null, memoryStore);\n            String key = \"websocket:\" + host + \":\" + port;\n            CONNECTORS.put(key, ref);\n        }\n    }"
        ],
        [
            "StreamProducer::writeToStream(OutputStream,Exchange)",
            " 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153 -\n 154  \n 155  \n 156  \n 157  \n 158  ",
            "    private void writeToStream(OutputStream outputStream, Exchange exchange) throws IOException, CamelExchangeException {\n        Object body = exchange.getIn().getBody();\n\n        if (body == null) {\n            log.debug(\"Body is null, cannot write it to the stream.\");\n            return;\n        }\n\n        // if not a string then try as byte array first\n        if (!(body instanceof String)) {\n            byte[] bytes = exchange.getIn().getBody(byte[].class);\n            if (bytes != null) {\n                LOG.debug(\"Writing as byte[]: {} to {}\", bytes, outputStream);\n                outputStream.write(bytes);\n                return;\n            }\n        }\n\n        // okay now fallback to mandatory converterable to string\n        String s = exchange.getIn().getMandatoryBody(String.class);\n        Charset charset = endpoint.getCharset();\n        Writer writer = new OutputStreamWriter(outputStream, charset);\n        BufferedWriter bw = IOHelper.buffered(writer);\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Writing as text: {} to {} using encoding: {}\", new Object[]{body, outputStream, charset});\n        }\n        bw.write(s);\n        bw.write(System.lineSeparator());\n        bw.flush();\n    }",
            " 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153 +\n 154  \n 155  \n 156  \n 157  \n 158  ",
            "    private void writeToStream(OutputStream outputStream, Exchange exchange) throws IOException, CamelExchangeException {\n        Object body = exchange.getIn().getBody();\n\n        if (body == null) {\n            log.debug(\"Body is null, cannot write it to the stream.\");\n            return;\n        }\n\n        // if not a string then try as byte array first\n        if (!(body instanceof String)) {\n            byte[] bytes = exchange.getIn().getBody(byte[].class);\n            if (bytes != null) {\n                LOG.debug(\"Writing as byte[]: {} to {}\", bytes, outputStream);\n                outputStream.write(bytes);\n                return;\n            }\n        }\n\n        // okay now fallback to mandatory converterable to string\n        String s = exchange.getIn().getMandatoryBody(String.class);\n        Charset charset = endpoint.getCharset();\n        Writer writer = new OutputStreamWriter(outputStream, charset);\n        BufferedWriter bw = IOHelper.buffered(writer);\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Writing as text: {} to {} using encoding: {}\", body, outputStream, charset);\n        }\n        bw.write(s);\n        bw.write(System.lineSeparator());\n        bw.flush();\n    }"
        ],
        [
            "PGPDataFormatUtil::findPublicKeys(List,boolean,PGPPublicKeyRingCollection)",
            " 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221 -\n 222 -\n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  ",
            "    public static List<PGPPublicKey> findPublicKeys(List<String> useridParts, boolean forEncryption, PGPPublicKeyRingCollection pgpPublicKeyringCollection) {\n        List<PGPPublicKey> result = new ArrayList<>(useridParts.size());\n        for (Iterator<PGPPublicKeyRing> keyRingIter = pgpPublicKeyringCollection.getKeyRings(); keyRingIter.hasNext();) {\n            PGPPublicKeyRing keyRing = keyRingIter.next();\n            PGPPublicKey primaryKey = keyRing.getPublicKey();\n            String[] foundKeyUserIdForUserIdPart = findFirstKeyUserIdContainingOneOfTheParts(useridParts, primaryKey);\n            if (foundKeyUserIdForUserIdPart == null) {\n                LOG.debug(\"No User ID found in primary key with key ID {} containing one of the parts {}\", primaryKey.getKeyID(),\n                        useridParts);\n                continue;\n            }\n            LOG.debug(\"User ID {} found in primary key with key ID {} containing one of the parts {}\", new Object[] {\n                foundKeyUserIdForUserIdPart[0], primaryKey.getKeyID(), useridParts });\n            // add adequate keys to the result\n            for (Iterator<PGPPublicKey> keyIter = keyRing.getPublicKeys(); keyIter.hasNext();) {\n                PGPPublicKey key = keyIter.next();\n                if (forEncryption) {\n                    if (isEncryptionKey(key)) {\n                        LOG.debug(\"Public encryption key with key user ID {} and key ID {} added to the encryption keys\",\n                                foundKeyUserIdForUserIdPart[0], Long.toString(key.getKeyID()));\n                        result.add(key);\n                    }\n                } else if (!forEncryption && isSignatureKey(key)) {\n                    // not used!\n                    result.add(key);\n                    LOG.debug(\"Public key with key user ID {} and key ID {} added to the signing keys\", foundKeyUserIdForUserIdPart[0],\n                            Long.toString(key.getKeyID()));\n                }\n            }\n\n        }\n\n        return result;\n    }",
            " 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221 +\n 222 +\n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  ",
            "    public static List<PGPPublicKey> findPublicKeys(List<String> useridParts, boolean forEncryption, PGPPublicKeyRingCollection pgpPublicKeyringCollection) {\n        List<PGPPublicKey> result = new ArrayList<>(useridParts.size());\n        for (Iterator<PGPPublicKeyRing> keyRingIter = pgpPublicKeyringCollection.getKeyRings(); keyRingIter.hasNext();) {\n            PGPPublicKeyRing keyRing = keyRingIter.next();\n            PGPPublicKey primaryKey = keyRing.getPublicKey();\n            String[] foundKeyUserIdForUserIdPart = findFirstKeyUserIdContainingOneOfTheParts(useridParts, primaryKey);\n            if (foundKeyUserIdForUserIdPart == null) {\n                LOG.debug(\"No User ID found in primary key with key ID {} containing one of the parts {}\", primaryKey.getKeyID(),\n                        useridParts);\n                continue;\n            }\n            LOG.debug(\"User ID {} found in primary key with key ID {} containing one of the parts {}\",\n                foundKeyUserIdForUserIdPart[0], primaryKey.getKeyID(), useridParts);\n            // add adequate keys to the result\n            for (Iterator<PGPPublicKey> keyIter = keyRing.getPublicKeys(); keyIter.hasNext();) {\n                PGPPublicKey key = keyIter.next();\n                if (forEncryption) {\n                    if (isEncryptionKey(key)) {\n                        LOG.debug(\"Public encryption key with key user ID {} and key ID {} added to the encryption keys\",\n                                foundKeyUserIdForUserIdPart[0], Long.toString(key.getKeyID()));\n                        result.add(key);\n                    }\n                } else if (!forEncryption && isSignatureKey(key)) {\n                    // not used!\n                    result.add(key);\n                    LOG.debug(\"Public key with key user ID {} and key ID {} added to the signing keys\", foundKeyUserIdForUserIdPart[0],\n                            Long.toString(key.getKeyID()));\n                }\n            }\n\n        }\n\n        return result;\n    }"
        ],
        [
            "ClientChannelHandler::getResponseMessage(Exchange,MessageEvent)",
            " 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220 -\n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  ",
            "    /**\n     * Gets the Camel {@link Message} to use as the message to be set on the current {@link Exchange} when\n     * we have received a reply message.\n     * <p/>\n     *\n     * @param exchange      the current exchange\n     * @param messageEvent  the incoming event which has the response message from Netty.\n     * @return the Camel {@link Message} to set on the current {@link Exchange} as the response message.\n     * @throws Exception is thrown if error getting the response message\n     */\n    protected Message getResponseMessage(Exchange exchange, MessageEvent messageEvent) throws Exception {\n        Object body = messageEvent.getMessage();\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Channel: {} received body: {}\", new Object[]{messageEvent.getChannel(), body});\n        }\n\n        // if textline enabled then covert to a String which must be used for textline\n        if (producer.getConfiguration().isTextline()) {\n            body = producer.getContext().getTypeConverter().mandatoryConvertTo(String.class, exchange, body);\n        }\n\n        // set the result on either IN or OUT on the original exchange depending on its pattern\n        if (ExchangeHelper.isOutCapable(exchange)) {\n            NettyPayloadHelper.setOut(exchange, body);\n            return exchange.getOut();\n        } else {\n            NettyPayloadHelper.setIn(exchange, body);\n            return exchange.getIn();\n        }\n    }",
            " 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220 +\n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  ",
            "    /**\n     * Gets the Camel {@link Message} to use as the message to be set on the current {@link Exchange} when\n     * we have received a reply message.\n     * <p/>\n     *\n     * @param exchange      the current exchange\n     * @param messageEvent  the incoming event which has the response message from Netty.\n     * @return the Camel {@link Message} to set on the current {@link Exchange} as the response message.\n     * @throws Exception is thrown if error getting the response message\n     */\n    protected Message getResponseMessage(Exchange exchange, MessageEvent messageEvent) throws Exception {\n        Object body = messageEvent.getMessage();\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Channel: {} received body: {}\", messageEvent.getChannel(), body);\n        }\n\n        // if textline enabled then covert to a String which must be used for textline\n        if (producer.getConfiguration().isTextline()) {\n            body = producer.getContext().getTypeConverter().mandatoryConvertTo(String.class, exchange, body);\n        }\n\n        // set the result on either IN or OUT on the original exchange depending on its pattern\n        if (ExchangeHelper.isOutCapable(exchange)) {\n            NettyPayloadHelper.setOut(exchange, body);\n            return exchange.getOut();\n        } else {\n            NettyPayloadHelper.setIn(exchange, body);\n            return exchange.getIn();\n        }\n    }"
        ],
        [
            "FtpConsumer::doPollDirectory(String,String,List,int)",
            " 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176 -\n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  ",
            "    protected boolean doPollDirectory(String absolutePath, String dirName, List<GenericFile<FTPFile>> fileList, int depth) {\n        log.trace(\"doPollDirectory from absolutePath: {}, dirName: {}\", absolutePath, dirName);\n\n        depth++;\n\n        // remove trailing /\n        dirName = FileUtil.stripTrailingSeparator(dirName);\n\n        // compute dir depending on stepwise is enabled or not\n        String dir = null;\n        List<FTPFile> files = null;\n        try {\n            if (isStepwise()) {\n                dir = ObjectHelper.isNotEmpty(dirName) ? dirName : absolutePath;\n                operations.changeCurrentDirectory(dir);\n            } else {\n                dir = absolutePath;\n            }\n\n            log.trace(\"Polling directory: {}\", dir);\n            if (isUseList()) {\n                if (isStepwise()) {\n                    files = operations.listFiles();\n                } else {\n                    files = operations.listFiles(dir);\n                }\n            } else {\n                // we cannot use the LIST command(s) so we can only poll a named file\n                // so created a pseudo file with that name\n                FTPFile file = new FTPFile();\n                file.setType(FTPFile.FILE_TYPE);\n                fileExpressionResult = evaluateFileExpression();\n                if (fileExpressionResult != null) {\n                    file.setName(fileExpressionResult);\n                    files = new ArrayList<>(1);\n                    files.add(file);\n                }\n            }\n        } catch (GenericFileOperationFailedException e) {\n            if (ignoreCannotRetrieveFile(null, null, e)) {\n                log.debug(\"Cannot list files in directory {} due directory does not exists or file permission error.\", dir);\n            } else {\n                throw e;\n            }\n        }\n\n        if (files == null || files.isEmpty()) {\n            // no files in this directory to poll\n            log.trace(\"No files found in directory: {}\", dir);\n            return true;\n        } else {\n            // we found some files\n            log.trace(\"Found {} in directory: {}\", files.size(), dir);\n        }\n\n        if (getEndpoint().isPreSort()) {\n            Collections.sort(files, (a, b) -> a.getName().compareTo(b.getName()));\n        }\n\n        for (FTPFile file : files) {\n\n            if (log.isTraceEnabled()) {\n                log.trace(\"FtpFile[name={}, dir={}, file={}]\", new Object[]{file.getName(), file.isDirectory(), file.isFile()});\n            }\n\n            // check if we can continue polling in files\n            if (!canPollMoreFiles(fileList)) {\n                return false;\n            }\n\n            if (file.isDirectory()) {\n                RemoteFile<FTPFile> remote = asRemoteFile(absolutePath, file, getEndpoint().getCharset());\n                if (endpoint.isRecursive() && depth < endpoint.getMaxDepth() && isValidFile(remote, true, files)) {\n                    // recursive scan and add the sub files and folders\n                    String subDirectory = file.getName();\n                    String path = absolutePath + \"/\" + subDirectory;\n                    boolean canPollMore = pollSubDirectory(path, subDirectory, fileList, depth);\n                    if (!canPollMore) {\n                        return false;\n                    }\n                }\n            } else if (file.isFile()) {\n                RemoteFile<FTPFile> remote = asRemoteFile(absolutePath, file, getEndpoint().getCharset());\n                if (depth >= endpoint.getMinDepth() && isValidFile(remote, false, files)) {\n                    // matched file so add\n                    fileList.add(remote);\n                }\n            } else {\n                log.debug(\"Ignoring unsupported remote file type: \" + file);\n            }\n        }\n\n        return true;\n    }",
            " 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176 +\n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  ",
            "    protected boolean doPollDirectory(String absolutePath, String dirName, List<GenericFile<FTPFile>> fileList, int depth) {\n        log.trace(\"doPollDirectory from absolutePath: {}, dirName: {}\", absolutePath, dirName);\n\n        depth++;\n\n        // remove trailing /\n        dirName = FileUtil.stripTrailingSeparator(dirName);\n\n        // compute dir depending on stepwise is enabled or not\n        String dir = null;\n        List<FTPFile> files = null;\n        try {\n            if (isStepwise()) {\n                dir = ObjectHelper.isNotEmpty(dirName) ? dirName : absolutePath;\n                operations.changeCurrentDirectory(dir);\n            } else {\n                dir = absolutePath;\n            }\n\n            log.trace(\"Polling directory: {}\", dir);\n            if (isUseList()) {\n                if (isStepwise()) {\n                    files = operations.listFiles();\n                } else {\n                    files = operations.listFiles(dir);\n                }\n            } else {\n                // we cannot use the LIST command(s) so we can only poll a named file\n                // so created a pseudo file with that name\n                FTPFile file = new FTPFile();\n                file.setType(FTPFile.FILE_TYPE);\n                fileExpressionResult = evaluateFileExpression();\n                if (fileExpressionResult != null) {\n                    file.setName(fileExpressionResult);\n                    files = new ArrayList<>(1);\n                    files.add(file);\n                }\n            }\n        } catch (GenericFileOperationFailedException e) {\n            if (ignoreCannotRetrieveFile(null, null, e)) {\n                log.debug(\"Cannot list files in directory {} due directory does not exists or file permission error.\", dir);\n            } else {\n                throw e;\n            }\n        }\n\n        if (files == null || files.isEmpty()) {\n            // no files in this directory to poll\n            log.trace(\"No files found in directory: {}\", dir);\n            return true;\n        } else {\n            // we found some files\n            log.trace(\"Found {} in directory: {}\", files.size(), dir);\n        }\n\n        if (getEndpoint().isPreSort()) {\n            Collections.sort(files, (a, b) -> a.getName().compareTo(b.getName()));\n        }\n\n        for (FTPFile file : files) {\n\n            if (log.isTraceEnabled()) {\n                log.trace(\"FtpFile[name={}, dir={}, file={}]\", file.getName(), file.isDirectory(), file.isFile());\n            }\n\n            // check if we can continue polling in files\n            if (!canPollMoreFiles(fileList)) {\n                return false;\n            }\n\n            if (file.isDirectory()) {\n                RemoteFile<FTPFile> remote = asRemoteFile(absolutePath, file, getEndpoint().getCharset());\n                if (endpoint.isRecursive() && depth < endpoint.getMaxDepth() && isValidFile(remote, true, files)) {\n                    // recursive scan and add the sub files and folders\n                    String subDirectory = file.getName();\n                    String path = absolutePath + \"/\" + subDirectory;\n                    boolean canPollMore = pollSubDirectory(path, subDirectory, fileList, depth);\n                    if (!canPollMore) {\n                        return false;\n                    }\n                }\n            } else if (file.isFile()) {\n                RemoteFile<FTPFile> remote = asRemoteFile(absolutePath, file, getEndpoint().getCharset());\n                if (depth >= endpoint.getMinDepth() && isValidFile(remote, false, files)) {\n                    // matched file so add\n                    fileList.add(remote);\n                }\n            } else {\n                log.debug(\"Ignoring unsupported remote file type: \" + file);\n            }\n        }\n\n        return true;\n    }"
        ],
        [
            "Mina2Producer::configureDataGramCodecFactory(String,IoService,Mina2Configuration)",
            " 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411 -\n 412  \n 413  \n 414  \n 415  \n 416  ",
            "    /**\n     * For datagrams the entire message is available as a single IoBuffer so lets just pass those around by default\n     * and try converting whatever they payload is into IoBuffer unless some custom converter is specified\n     */\n    protected void configureDataGramCodecFactory(final String type, final IoService service, final Mina2Configuration configuration) {\n        ProtocolCodecFactory codecFactory = configuration.getCodec();\n        if (codecFactory == null) {\n            codecFactory = new Mina2UdpProtocolCodecFactory(this.getEndpoint().getCamelContext());\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"{}: Using CodecFactory: {}\", new Object[]{type, codecFactory});\n            }\n        }\n\n        addCodecFactory(service, codecFactory);\n    }",
            " 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411 +\n 412  \n 413  \n 414  \n 415  \n 416  ",
            "    /**\n     * For datagrams the entire message is available as a single IoBuffer so lets just pass those around by default\n     * and try converting whatever they payload is into IoBuffer unless some custom converter is specified\n     */\n    protected void configureDataGramCodecFactory(final String type, final IoService service, final Mina2Configuration configuration) {\n        ProtocolCodecFactory codecFactory = configuration.getCodec();\n        if (codecFactory == null) {\n            codecFactory = new Mina2UdpProtocolCodecFactory(this.getEndpoint().getCamelContext());\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"{}: Using CodecFactory: {}\", type, codecFactory);\n            }\n        }\n\n        addCodecFactory(service, codecFactory);\n    }"
        ],
        [
            "TransactionErrorHandler::logTransactionRollback(String,String,Throwable,boolean)",
            " 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281 -\n 282  \n 283 -\n 284  \n 285  \n 286  \n 287 -\n 288  \n 289 -\n 290  \n 291  \n 292  \n 293 -\n 294  \n 295 -\n 296  \n 297  \n 298  \n 299 -\n 300  \n 301 -\n 302  \n 303  \n 304  \n 305 -\n 306  \n 307 -\n 308  \n 309  \n 310  ",
            "    /**\n     * Logs the transaction rollback.\n     */\n    private void logTransactionRollback(String redelivered, String ids, Throwable e, boolean rollbackOnly) {\n        if (rollbackLoggingLevel == LoggingLevel.OFF) {\n            return;\n        } else if (rollbackLoggingLevel == LoggingLevel.ERROR && log.isErrorEnabled()) {\n            if (rollbackOnly) {\n                log.error(\"Transaction rollback ({}) redelivered({}) for {} due exchange was marked for rollbackOnly\", new Object[]{transactionKey, redelivered, ids});\n            } else {\n                log.error(\"Transaction rollback ({}) redelivered({}) for {} caught: {}\", new Object[]{transactionKey, redelivered, ids, e.getMessage()});\n            }\n        } else if (rollbackLoggingLevel == LoggingLevel.WARN && log.isWarnEnabled()) {\n            if (rollbackOnly) {\n                log.warn(\"Transaction rollback ({}) redelivered({}) for {} due exchange was marked for rollbackOnly\", new Object[]{transactionKey, redelivered, ids});\n            } else {\n                log.warn(\"Transaction rollback ({}) redelivered({}) for {} caught: {}\", new Object[]{transactionKey, redelivered, ids, e.getMessage()});\n            }\n        } else if (rollbackLoggingLevel == LoggingLevel.INFO && log.isInfoEnabled()) {\n            if (rollbackOnly) {\n                log.info(\"Transaction rollback ({}) redelivered({}) for {} due exchange was marked for rollbackOnly\", new Object[]{transactionKey, redelivered, ids});\n            } else {\n                log.info(\"Transaction rollback ({}) redelivered({}) for {} caught: {}\", new Object[]{transactionKey, redelivered, ids, e.getMessage()});\n            }\n        } else if (rollbackLoggingLevel == LoggingLevel.DEBUG && log.isDebugEnabled()) {\n            if (rollbackOnly) {\n                log.debug(\"Transaction rollback ({}) redelivered({}) for {} due exchange was marked for rollbackOnly\", new Object[]{transactionKey, redelivered, ids});\n            } else {\n                log.debug(\"Transaction rollback ({}) redelivered({}) for {} caught: {}\", new Object[]{transactionKey, redelivered, ids, e.getMessage()});\n            }\n        } else if (rollbackLoggingLevel == LoggingLevel.TRACE && log.isTraceEnabled()) {\n            if (rollbackOnly) {\n                log.trace(\"Transaction rollback ({}) redelivered({}) for {} due exchange was marked for rollbackOnly\", new Object[]{transactionKey, redelivered, ids});\n            } else {\n                log.trace(\"Transaction rollback ({}) redelivered({}) for {} caught: {}\", new Object[]{transactionKey, redelivered, ids, e.getMessage()});\n            }\n        }\n    }",
            " 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281 +\n 282  \n 283 +\n 284  \n 285  \n 286  \n 287 +\n 288  \n 289 +\n 290  \n 291  \n 292  \n 293 +\n 294  \n 295 +\n 296  \n 297  \n 298  \n 299 +\n 300  \n 301 +\n 302  \n 303  \n 304  \n 305 +\n 306  \n 307 +\n 308  \n 309  \n 310  ",
            "    /**\n     * Logs the transaction rollback.\n     */\n    private void logTransactionRollback(String redelivered, String ids, Throwable e, boolean rollbackOnly) {\n        if (rollbackLoggingLevel == LoggingLevel.OFF) {\n            return;\n        } else if (rollbackLoggingLevel == LoggingLevel.ERROR && log.isErrorEnabled()) {\n            if (rollbackOnly) {\n                log.error(\"Transaction rollback ({}) redelivered({}) for {} due exchange was marked for rollbackOnly\", transactionKey, redelivered, ids);\n            } else {\n                log.error(\"Transaction rollback ({}) redelivered({}) for {} caught: {}\", transactionKey, redelivered, ids, e.getMessage());\n            }\n        } else if (rollbackLoggingLevel == LoggingLevel.WARN && log.isWarnEnabled()) {\n            if (rollbackOnly) {\n                log.warn(\"Transaction rollback ({}) redelivered({}) for {} due exchange was marked for rollbackOnly\", transactionKey, redelivered, ids);\n            } else {\n                log.warn(\"Transaction rollback ({}) redelivered({}) for {} caught: {}\", transactionKey, redelivered, ids, e.getMessage());\n            }\n        } else if (rollbackLoggingLevel == LoggingLevel.INFO && log.isInfoEnabled()) {\n            if (rollbackOnly) {\n                log.info(\"Transaction rollback ({}) redelivered({}) for {} due exchange was marked for rollbackOnly\", transactionKey, redelivered, ids);\n            } else {\n                log.info(\"Transaction rollback ({}) redelivered({}) for {} caught: {}\", transactionKey, redelivered, ids, e.getMessage());\n            }\n        } else if (rollbackLoggingLevel == LoggingLevel.DEBUG && log.isDebugEnabled()) {\n            if (rollbackOnly) {\n                log.debug(\"Transaction rollback ({}) redelivered({}) for {} due exchange was marked for rollbackOnly\", transactionKey, redelivered, ids);\n            } else {\n                log.debug(\"Transaction rollback ({}) redelivered({}) for {} caught: {}\", transactionKey, redelivered, ids, e.getMessage());\n            }\n        } else if (rollbackLoggingLevel == LoggingLevel.TRACE && log.isTraceEnabled()) {\n            if (rollbackOnly) {\n                log.trace(\"Transaction rollback ({}) redelivered({}) for {} due exchange was marked for rollbackOnly\", transactionKey, redelivered, ids);\n            } else {\n                log.trace(\"Transaction rollback ({}) redelivered({}) for {} caught: {}\", transactionKey, redelivered, ids, e.getMessage());\n            }\n        }\n    }"
        ],
        [
            "VelocityEndpoint::onExchange(Exchange)",
            " 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195 -\n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  ",
            "    @Override\n    protected void onExchange(Exchange exchange) throws Exception {\n        String path = getResourceUri();\n        ObjectHelper.notNull(path, \"resourceUri\");\n\n        String newResourceUri = exchange.getIn().getHeader(VelocityConstants.VELOCITY_RESOURCE_URI, String.class);\n        if (newResourceUri != null) {\n            exchange.getIn().removeHeader(VelocityConstants.VELOCITY_RESOURCE_URI);\n\n            log.debug(\"{} set to {} creating new endpoint to handle exchange\", VelocityConstants.VELOCITY_RESOURCE_URI, newResourceUri);\n            VelocityEndpoint newEndpoint = findOrCreateEndpoint(getEndpointUri(), newResourceUri);\n            newEndpoint.onExchange(exchange);\n            return;\n        }\n\n        Reader reader;\n        String content = exchange.getIn().getHeader(VelocityConstants.VELOCITY_TEMPLATE, String.class);\n        if (content != null) {\n            // use content from header\n            reader = new StringReader(content);\n            if (log.isDebugEnabled()) {\n                log.debug(\"Velocity content read from header {} for endpoint {}\", VelocityConstants.VELOCITY_TEMPLATE, getEndpointUri());\n            }\n            // remove the header to avoid it being propagated in the routing\n            exchange.getIn().removeHeader(VelocityConstants.VELOCITY_TEMPLATE);\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Velocity content read from resource {} with resourceUri: {} for endpoint {}\", new Object[]{getResourceUri(), path, getEndpointUri()});\n            }\n            reader = getEncoding() != null ? new InputStreamReader(getResourceAsInputStream(), getEncoding()) : new InputStreamReader(getResourceAsInputStream());\n        }\n\n        // getResourceAsInputStream also considers the content cache\n        StringWriter buffer = new StringWriter();\n        String logTag = getClass().getName();\n        Context velocityContext = exchange.getIn().getHeader(VelocityConstants.VELOCITY_CONTEXT, Context.class);\n        if (velocityContext == null) {\n            Map<String, Object> variableMap = ExchangeHelper.createVariableMap(exchange);\n\n            @SuppressWarnings(\"unchecked\")\n            Map<String, Object> supplementalMap = exchange.getIn().getHeader(VelocityConstants.VELOCITY_SUPPLEMENTAL_CONTEXT, Map.class);\n            if (supplementalMap != null) {\n                variableMap.putAll(supplementalMap);\n            }\n\n            velocityContext = new VelocityContext(variableMap);\n        }\n\n        // let velocity parse and generate the result in buffer\n        VelocityEngine engine = getVelocityEngine();\n        log.debug(\"Velocity is evaluating using velocity context: {}\", velocityContext);\n        engine.evaluate(velocityContext, buffer, logTag, reader);\n\n        // now lets output the results to the exchange\n        Message out = exchange.getOut();\n        out.setBody(buffer.toString());\n        out.setHeaders(exchange.getIn().getHeaders());\n        out.setAttachments(exchange.getIn().getAttachments());\n    }",
            " 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195 +\n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  ",
            "    @Override\n    protected void onExchange(Exchange exchange) throws Exception {\n        String path = getResourceUri();\n        ObjectHelper.notNull(path, \"resourceUri\");\n\n        String newResourceUri = exchange.getIn().getHeader(VelocityConstants.VELOCITY_RESOURCE_URI, String.class);\n        if (newResourceUri != null) {\n            exchange.getIn().removeHeader(VelocityConstants.VELOCITY_RESOURCE_URI);\n\n            log.debug(\"{} set to {} creating new endpoint to handle exchange\", VelocityConstants.VELOCITY_RESOURCE_URI, newResourceUri);\n            VelocityEndpoint newEndpoint = findOrCreateEndpoint(getEndpointUri(), newResourceUri);\n            newEndpoint.onExchange(exchange);\n            return;\n        }\n\n        Reader reader;\n        String content = exchange.getIn().getHeader(VelocityConstants.VELOCITY_TEMPLATE, String.class);\n        if (content != null) {\n            // use content from header\n            reader = new StringReader(content);\n            if (log.isDebugEnabled()) {\n                log.debug(\"Velocity content read from header {} for endpoint {}\", VelocityConstants.VELOCITY_TEMPLATE, getEndpointUri());\n            }\n            // remove the header to avoid it being propagated in the routing\n            exchange.getIn().removeHeader(VelocityConstants.VELOCITY_TEMPLATE);\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Velocity content read from resource {} with resourceUri: {} for endpoint {}\", getResourceUri(), path, getEndpointUri());\n            }\n            reader = getEncoding() != null ? new InputStreamReader(getResourceAsInputStream(), getEncoding()) : new InputStreamReader(getResourceAsInputStream());\n        }\n\n        // getResourceAsInputStream also considers the content cache\n        StringWriter buffer = new StringWriter();\n        String logTag = getClass().getName();\n        Context velocityContext = exchange.getIn().getHeader(VelocityConstants.VELOCITY_CONTEXT, Context.class);\n        if (velocityContext == null) {\n            Map<String, Object> variableMap = ExchangeHelper.createVariableMap(exchange);\n\n            @SuppressWarnings(\"unchecked\")\n            Map<String, Object> supplementalMap = exchange.getIn().getHeader(VelocityConstants.VELOCITY_SUPPLEMENTAL_CONTEXT, Map.class);\n            if (supplementalMap != null) {\n                variableMap.putAll(supplementalMap);\n            }\n\n            velocityContext = new VelocityContext(variableMap);\n        }\n\n        // let velocity parse and generate the result in buffer\n        VelocityEngine engine = getVelocityEngine();\n        log.debug(\"Velocity is evaluating using velocity context: {}\", velocityContext);\n        engine.evaluate(velocityContext, buffer, logTag, reader);\n\n        // now lets output the results to the exchange\n        Message out = exchange.getOut();\n        out.setBody(buffer.toString());\n        out.setHeaders(exchange.getIn().getHeaders());\n        out.setAttachments(exchange.getIn().getAttachments());\n    }"
        ],
        [
            "HdfsProducer::setupHdfs(boolean)",
            " 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136 -\n 137  \n 138  \n 139 -\n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146 -\n 147  \n 148  \n 149 -\n 150  \n 151  \n 152  \n 153  \n 154  ",
            "    private synchronized HdfsOutputStream setupHdfs(boolean onStartup) throws Exception {\n        if (ostream != null) {\n            return ostream;\n        }\n\n        StringBuilder actualPath = new StringBuilder(hdfsPath);\n        if (config.getSplitStrategies().size() > 0) {\n            actualPath = newFileName();\n        }\n\n        // if we are starting up then log at info level, and if runtime then log at debug level to not flood the log\n        if (onStartup) {\n            log.info(\"Connecting to hdfs file-system {}:{}/{} (may take a while if connection is not available)\", new Object[]{config.getHostName(), config.getPort(), actualPath.toString()});\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Connecting to hdfs file-system {}:{}/{} (may take a while if connection is not available)\", new Object[]{config.getHostName(), config.getPort(), actualPath.toString()});\n            }\n        }\n\n        HdfsOutputStream answer = HdfsOutputStream.createOutputStream(actualPath.toString(), config);\n\n        if (onStartup) {\n            log.info(\"Connected to hdfs file-system {}:{}/{}\", new Object[]{config.getHostName(), config.getPort(), actualPath.toString()});\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Connected to hdfs file-system {}:{}/{}\", new Object[]{config.getHostName(), config.getPort(), actualPath.toString()});\n            }\n        }\n\n        return answer;\n    }",
            " 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136 +\n 137  \n 138  \n 139 +\n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146 +\n 147  \n 148  \n 149 +\n 150  \n 151  \n 152  \n 153  \n 154  ",
            "    private synchronized HdfsOutputStream setupHdfs(boolean onStartup) throws Exception {\n        if (ostream != null) {\n            return ostream;\n        }\n\n        StringBuilder actualPath = new StringBuilder(hdfsPath);\n        if (config.getSplitStrategies().size() > 0) {\n            actualPath = newFileName();\n        }\n\n        // if we are starting up then log at info level, and if runtime then log at debug level to not flood the log\n        if (onStartup) {\n            log.info(\"Connecting to hdfs file-system {}:{}/{} (may take a while if connection is not available)\", config.getHostName(), config.getPort(), actualPath.toString());\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Connecting to hdfs file-system {}:{}/{} (may take a while if connection is not available)\", config.getHostName(), config.getPort(), actualPath.toString());\n            }\n        }\n\n        HdfsOutputStream answer = HdfsOutputStream.createOutputStream(actualPath.toString(), config);\n\n        if (onStartup) {\n            log.info(\"Connected to hdfs file-system {}:{}/{}\", config.getHostName(), config.getPort(), actualPath.toString());\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Connected to hdfs file-system {}:{}/{}\", config.getHostName(), config.getPort(), actualPath.toString());\n            }\n        }\n\n        return answer;\n    }"
        ],
        [
            "BindyFixedLengthFactory::initAnnotatedFields()",
            " 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117 -\n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  ",
            "    @Override\n    public void initAnnotatedFields() {\n\n        for (Class<?> cl : models) {\n\n            List<Field> linkFields = new ArrayList<>();\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Class retrieved: {}\", cl.getName());\n            }\n\n            for (Field field : cl.getDeclaredFields()) {\n                DataField dataField = field.getAnnotation(DataField.class);\n                if (dataField != null) {\n\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Position defined in the class: {}, position: {}, Field: {}\", new Object[]{cl.getName(), dataField.pos(), dataField});\n                    }\n\n                    if (dataField.required()) {\n                        ++numberMandatoryFields;\n                    } else {\n                        ++numberOptionalFields;\n                    }\n\n                    dataFields.put(dataField.pos(), dataField);\n                    annotatedFields.put(dataField.pos(), field);\n                }\n\n                Link linkField = field.getAnnotation(Link.class);\n\n                if (linkField != null) {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Class linked: {}, Field: {}\", cl.getName(), field);\n                    }\n                    linkFields.add(field);\n                }\n\n            }\n\n            if (!linkFields.isEmpty()) {\n                annotatedLinkFields.put(cl.getName(), linkFields);\n            }\n\n            totalFields = numberMandatoryFields + numberOptionalFields;\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Number of optional fields: {}\", numberOptionalFields);\n                LOG.debug(\"Number of mandatory fields: {}\", numberMandatoryFields);\n                LOG.debug(\"Total: {}\", totalFields);\n            }\n\n        }\n    }",
            " 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117 +\n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  ",
            "    @Override\n    public void initAnnotatedFields() {\n\n        for (Class<?> cl : models) {\n\n            List<Field> linkFields = new ArrayList<>();\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Class retrieved: {}\", cl.getName());\n            }\n\n            for (Field field : cl.getDeclaredFields()) {\n                DataField dataField = field.getAnnotation(DataField.class);\n                if (dataField != null) {\n\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Position defined in the class: {}, position: {}, Field: {}\", cl.getName(), dataField.pos(), dataField);\n                    }\n\n                    if (dataField.required()) {\n                        ++numberMandatoryFields;\n                    } else {\n                        ++numberOptionalFields;\n                    }\n\n                    dataFields.put(dataField.pos(), dataField);\n                    annotatedFields.put(dataField.pos(), field);\n                }\n\n                Link linkField = field.getAnnotation(Link.class);\n\n                if (linkField != null) {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Class linked: {}, Field: {}\", cl.getName(), field);\n                    }\n                    linkFields.add(field);\n                }\n\n            }\n\n            if (!linkFields.isEmpty()) {\n                annotatedLinkFields.put(cl.getName(), linkFields);\n            }\n\n            totalFields = numberMandatoryFields + numberOptionalFields;\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Number of optional fields: {}\", numberOptionalFields);\n                LOG.debug(\"Number of mandatory fields: {}\", numberMandatoryFields);\n                LOG.debug(\"Total: {}\", totalFields);\n            }\n\n        }\n    }"
        ],
        [
            "PgEventConsumer::notification(int,String,String)",
            "  55  \n  56  \n  57 -\n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  ",
            "    public void notification(int processId, String channel, String payload) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Notification processId: {}, channel: {}, payload: {}\", new Object[]{processId, channel, payload});\n        }\n\n        Exchange exchange = endpoint.createExchange();\n        Message msg = exchange.getIn();\n        msg.setHeader(\"channel\", channel);\n        msg.setBody(payload);\n\n        try {\n            getProcessor().process(exchange);\n        } catch (Exception ex) {\n            String cause = \"Unable to process incoming notification from PostgreSQL: processId='\" + processId + \"', channel='\" + channel + \"', payload='\" + payload + \"'\";\n            getExceptionHandler().handleException(cause, ex);\n        }\n    }",
            "  55  \n  56  \n  57 +\n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  ",
            "    public void notification(int processId, String channel, String payload) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Notification processId: {}, channel: {}, payload: {}\", processId, channel, payload);\n        }\n\n        Exchange exchange = endpoint.createExchange();\n        Message msg = exchange.getIn();\n        msg.setHeader(\"channel\", channel);\n        msg.setBody(payload);\n\n        try {\n            getProcessor().process(exchange);\n        } catch (Exception ex) {\n            String cause = \"Unable to process incoming notification from PostgreSQL: processId='\" + processId + \"', channel='\" + channel + \"', payload='\" + payload + \"'\";\n            getExceptionHandler().handleException(cause, ex);\n        }\n    }"
        ],
        [
            "MinaProducer::openConnection()",
            " 212  \n 213  \n 214  \n 215  \n 216 -\n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  ",
            "    private void openConnection() {\n        SocketAddress address = getEndpoint().getAddress();\n        connector = getEndpoint().getConnector();\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Creating connector to address: {} using connector: {} timeout: {} millis.\", new Object[]{address, connector, timeout});\n        }\n        IoHandler ioHandler = new ResponseHandler(getEndpoint());\n        // connect and wait until the connection is established\n        ConnectFuture future = connector.connect(address, ioHandler, getEndpoint().getConnectorConfig());\n        future.join();\n        session = future.getSession();\n    }",
            " 212  \n 213  \n 214  \n 215  \n 216 +\n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  ",
            "    private void openConnection() {\n        SocketAddress address = getEndpoint().getAddress();\n        connector = getEndpoint().getConnector();\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Creating connector to address: {} using connector: {} timeout: {} millis.\", address, connector, timeout);\n        }\n        IoHandler ioHandler = new ResponseHandler(getEndpoint());\n        // connect and wait until the connection is established\n        ConnectFuture future = connector.connect(address, ioHandler, getEndpoint().getConnectorConfig());\n        future.join();\n        session = future.getSession();\n    }"
        ],
        [
            "CamelServlet::init(ServletConfig)",
            "  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70 -\n  71  ",
            "    @Override\n    public void init(ServletConfig config) throws ServletException {\n        super.init(config);\n        this.servletName = config.getServletName();\n\n        final String asyncParam = config.getInitParameter(ASYNC_PARAM);\n        this.async = asyncParam == null ? false : ObjectHelper.toBoolean(asyncParam);\n        log.trace(\"servlet '{}' initialized with: async={}\", new Object[]{servletName, async});\n    }",
            "  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70 +\n  71  ",
            "    @Override\n    public void init(ServletConfig config) throws ServletException {\n        super.init(config);\n        this.servletName = config.getServletName();\n\n        final String asyncParam = config.getInitParameter(ASYNC_PARAM);\n        this.async = asyncParam == null ? false : ObjectHelper.toBoolean(asyncParam);\n        log.trace(\"servlet '{}' initialized with: async={}\", servletName, async);\n    }"
        ],
        [
            "EndpointMessageListener::sendReply(String,Message,Exchange,org,Exception)",
            " 384  \n 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397 -\n 398  \n 399  \n 400  \n 401  \n 402  ",
            "    protected void sendReply(String replyDestination, final Message message, final Exchange exchange,\n                             final org.apache.camel.Message out, final Exception cause) {\n        if (replyDestination == null) {\n            LOG.debug(\"Cannot send reply message as there is no replyDestination for: {}\", out);\n            return;\n        }\n        getTemplate().send(replyDestination, new MessageCreator() {\n            public Message createMessage(Session session) throws JMSException {\n                Message reply = endpoint.getBinding().makeJmsMessage(exchange, out, session, cause);\n                final String correlationID = determineCorrelationId(message);\n                reply.setJMSCorrelationID(correlationID);\n\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"{} sending reply JMS message [correlationId:{}]: {}\", new Object[]{endpoint, correlationID, reply});\n                }\n                return reply;\n            }\n        });\n    }",
            " 384  \n 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397 +\n 398  \n 399  \n 400  \n 401  \n 402  ",
            "    protected void sendReply(String replyDestination, final Message message, final Exchange exchange,\n                             final org.apache.camel.Message out, final Exception cause) {\n        if (replyDestination == null) {\n            LOG.debug(\"Cannot send reply message as there is no replyDestination for: {}\", out);\n            return;\n        }\n        getTemplate().send(replyDestination, new MessageCreator() {\n            public Message createMessage(Session session) throws JMSException {\n                Message reply = endpoint.getBinding().makeJmsMessage(exchange, out, session, cause);\n                final String correlationID = determineCorrelationId(message);\n                reply.setJMSCorrelationID(correlationID);\n\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"{} sending reply JMS message [correlationId:{}]: {}\", endpoint, correlationID, reply);\n                }\n                return reply;\n            }\n        });\n    }"
        ],
        [
            "HdfsConsumer::setupHdfs(boolean)",
            "  70  \n  71  \n  72  \n  73 -\n  74  \n  75  \n  76 -\n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84 -\n  85  \n  86  \n  87 -\n  88  \n  89  \n  90  \n  91  ",
            "    private HdfsInfo setupHdfs(boolean onStartup) throws Exception {\n        // if we are starting up then log at info level, and if runtime then log at debug level to not flood the log\n        if (onStartup) {\n            log.info(\"Connecting to hdfs file-system {}:{}/{} (may take a while if connection is not available)\", new Object[]{config.getHostName(), config.getPort(), hdfsPath.toString()});\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Connecting to hdfs file-system {}:{}/{} (may take a while if connection is not available)\", new Object[]{config.getHostName(), config.getPort(), hdfsPath.toString()});\n            }\n        }\n\n        // hadoop will cache the connection by default so its faster to get in the poll method\n        HdfsInfo answer = HdfsInfoFactory.newHdfsInfo(this.hdfsPath.toString());\n\n        if (onStartup) {\n            log.info(\"Connected to hdfs file-system {}:{}/{}\", new Object[]{config.getHostName(), config.getPort(), hdfsPath.toString()});\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Connected to hdfs file-system {}:{}/{}\", new Object[]{config.getHostName(), config.getPort(), hdfsPath.toString()});\n            }\n        }\n        return answer;\n    }",
            "  70  \n  71  \n  72  \n  73 +\n  74  \n  75  \n  76 +\n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84 +\n  85  \n  86  \n  87 +\n  88  \n  89  \n  90  \n  91  ",
            "    private HdfsInfo setupHdfs(boolean onStartup) throws Exception {\n        // if we are starting up then log at info level, and if runtime then log at debug level to not flood the log\n        if (onStartup) {\n            log.info(\"Connecting to hdfs file-system {}:{}/{} (may take a while if connection is not available)\", config.getHostName(), config.getPort(), hdfsPath.toString());\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Connecting to hdfs file-system {}:{}/{} (may take a while if connection is not available)\", config.getHostName(), config.getPort(), hdfsPath.toString());\n            }\n        }\n\n        // hadoop will cache the connection by default so its faster to get in the poll method\n        HdfsInfo answer = HdfsInfoFactory.newHdfsInfo(this.hdfsPath.toString());\n\n        if (onStartup) {\n            log.info(\"Connected to hdfs file-system {}:{}/{}\", config.getHostName(), config.getPort(), hdfsPath.toString());\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Connected to hdfs file-system {}:{}/{}\", config.getHostName(), config.getPort(), hdfsPath.toString());\n            }\n        }\n        return answer;\n    }"
        ],
        [
            "ServerChannelHandler::channelRead0(ChannelHandlerContext,Object)",
            "  83  \n  84  \n  85  \n  86  \n  87 -\n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  ",
            "    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {\n        Object in = msg;\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Channel: {} received body: {}\", new Object[]{ctx.channel(), in});\n        }\n\n        // create Exchange and let the consumer process it\n        final Exchange exchange = consumer.getEndpoint().createExchange(ctx, msg);\n        if (consumer.getConfiguration().isSync()) {\n            exchange.setPattern(ExchangePattern.InOut);\n        }\n        // set the exchange charset property for converting\n        if (consumer.getConfiguration().getCharsetName() != null) {\n            exchange.setProperty(Exchange.CHARSET_NAME, IOHelper.normalizeCharset(consumer.getConfiguration().getCharsetName()));\n        }\n        if (consumer.getConfiguration().isReuseChannel()) {\n            exchange.setProperty(NettyConstants.NETTY_CHANNEL, ctx.channel());\n        }\n\n        // we want to handle the UoW\n        consumer.createUoW(exchange);\n\n        beforeProcess(exchange, ctx, msg);\n\n        // process accordingly to endpoint configuration\n        if (consumer.getEndpoint().isSynchronous()) {\n            processSynchronously(exchange, ctx, msg);\n        } else {\n            processAsynchronously(exchange, ctx, msg);\n        }\n    }",
            "  83  \n  84  \n  85  \n  86  \n  87 +\n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  ",
            "    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {\n        Object in = msg;\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Channel: {} received body: {}\", ctx.channel(), in);\n        }\n\n        // create Exchange and let the consumer process it\n        final Exchange exchange = consumer.getEndpoint().createExchange(ctx, msg);\n        if (consumer.getConfiguration().isSync()) {\n            exchange.setPattern(ExchangePattern.InOut);\n        }\n        // set the exchange charset property for converting\n        if (consumer.getConfiguration().getCharsetName() != null) {\n            exchange.setProperty(Exchange.CHARSET_NAME, IOHelper.normalizeCharset(consumer.getConfiguration().getCharsetName()));\n        }\n        if (consumer.getConfiguration().isReuseChannel()) {\n            exchange.setProperty(NettyConstants.NETTY_CHANNEL, ctx.channel());\n        }\n\n        // we want to handle the UoW\n        consumer.createUoW(exchange);\n\n        beforeProcess(exchange, ctx, msg);\n\n        // process accordingly to endpoint configuration\n        if (consumer.getEndpoint().isSynchronous()) {\n            processSynchronously(exchange, ctx, msg);\n        } else {\n            processAsynchronously(exchange, ctx, msg);\n        }\n    }"
        ],
        [
            "BindyKeyValuePairFactory::initAnnotatedFields()",
            "  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96 -\n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  ",
            "    @Override\n    public void initAnnotatedFields() {\n\n        for (Class<?> cl : models) {\n\n            List<Field> linkFields = new ArrayList<>();\n\n            for (Field field : cl.getDeclaredFields()) {\n                KeyValuePairField keyValuePairField = field.getAnnotation(KeyValuePairField.class);\n                if (keyValuePairField != null) {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Key declared in the class : {}, key : {}, Field : {}\", new Object[]{cl.getName(), keyValuePairField.tag(), keyValuePairField});\n                    }\n                    keyValuePairFields.put(keyValuePairField.tag(), keyValuePairField);\n                    annotatedFields.put(keyValuePairField.tag(), field);\n                }\n\n                Link linkField = field.getAnnotation(Link.class);\n\n                if (linkField != null) {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Class linked  : {}, Field {}\", cl.getName(), field);\n                    }\n                    linkFields.add(field);\n                }\n            }\n\n            if (!linkFields.isEmpty()) {\n                annotatedLinkFields.put(cl.getName(), linkFields);\n            }\n\n        }\n    }",
            "  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96 +\n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  ",
            "    @Override\n    public void initAnnotatedFields() {\n\n        for (Class<?> cl : models) {\n\n            List<Field> linkFields = new ArrayList<>();\n\n            for (Field field : cl.getDeclaredFields()) {\n                KeyValuePairField keyValuePairField = field.getAnnotation(KeyValuePairField.class);\n                if (keyValuePairField != null) {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Key declared in the class : {}, key : {}, Field : {}\", cl.getName(), keyValuePairField.tag(), keyValuePairField);\n                    }\n                    keyValuePairFields.put(keyValuePairField.tag(), keyValuePairField);\n                    annotatedFields.put(keyValuePairField.tag(), field);\n                }\n\n                Link linkField = field.getAnnotation(Link.class);\n\n                if (linkField != null) {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Class linked  : {}, Field {}\", cl.getName(), field);\n                    }\n                    linkFields.add(field);\n                }\n            }\n\n            if (!linkFields.isEmpty()) {\n                annotatedLinkFields.put(cl.getName(), linkFields);\n            }\n\n        }\n    }"
        ],
        [
            "JoltEndpoint::getTransform()",
            "  79  \n  80  \n  81  \n  82  \n  83 -\n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  ",
            "    private synchronized JoltTransform getTransform() throws Exception {\n        if (transform == null) {\n            if (log.isDebugEnabled()) {\n                String path = getResourceUri();\n                log.debug(\"Jolt content read from resource {} with resourceUri: {} for endpoint {}\", new Object[]{getResourceUri(), path, getEndpointUri()});\n            }\n\n            // Sortr does not require a spec\n            if (this.transformDsl == JoltTransformType.Sortr) {\n                this.transform = new Sortr();\n            } else {\n                // getResourceAsInputStream also considers the content cache\n                Object spec = JsonUtils.jsonToObject(getResourceAsInputStream());\n                switch(this.transformDsl) {\n                case Shiftr:\n                    this.transform = new Shiftr(spec);\n                    break;\n                case Defaultr:\n                    this.transform = new Defaultr(spec);\n                    break;\n                case Removr:\n                    this.transform = new Removr(spec);\n                    break;\n                case Chainr:\n                default:\n                    this.transform = Chainr.fromSpec(spec);\n                    break;\n                }\n            }\n\n        }\n        return transform;\n    }",
            "  79  \n  80  \n  81  \n  82  \n  83 +\n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  ",
            "    private synchronized JoltTransform getTransform() throws Exception {\n        if (transform == null) {\n            if (log.isDebugEnabled()) {\n                String path = getResourceUri();\n                log.debug(\"Jolt content read from resource {} with resourceUri: {} for endpoint {}\", getResourceUri(), path, getEndpointUri());\n            }\n\n            // Sortr does not require a spec\n            if (this.transformDsl == JoltTransformType.Sortr) {\n                this.transform = new Sortr();\n            } else {\n                // getResourceAsInputStream also considers the content cache\n                Object spec = JsonUtils.jsonToObject(getResourceAsInputStream());\n                switch(this.transformDsl) {\n                case Shiftr:\n                    this.transform = new Shiftr(spec);\n                    break;\n                case Defaultr:\n                    this.transform = new Defaultr(spec);\n                    break;\n                case Removr:\n                    this.transform = new Removr(spec);\n                    break;\n                case Chainr:\n                default:\n                    this.transform = Chainr.fromSpec(spec);\n                    break;\n                }\n            }\n\n        }\n        return transform;\n    }"
        ],
        [
            "BindyCsvFactory::setDataFieldValue(CamelContext,Map,int,int,int,String,DataField)",
            " 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226 -\n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  ",
            "    private int setDataFieldValue(CamelContext camelContext, Map<String, Object> model, int line, int pos, int counterMandatoryFields, String data, DataField dataField) throws Exception {\n        ObjectHelper.notNull(dataField, \"No position \" + pos + \" defined for the field: \" + data + \", line: \" + line);\n\n        if (dataField.trim()) {\n            data = data.trim();\n        }\n\n        if (dataField.required()) {\n            // Increment counter of mandatory fields\n            ++counterMandatoryFields;\n\n            // Check if content of the field is empty\n            // This is not possible for mandatory fields\n            if (data.equals(\"\")) {\n                throw new IllegalArgumentException(\"The mandatory field defined at the position \" + pos + \" is empty for the line: \" + line);\n            }\n        }\n\n        // Get Field to be setted\n        Field field = annotatedFields.get(pos);\n        field.setAccessible(true);\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Pos: {}, Data: {}, Field type: {}\", new Object[]{pos, data, field.getType()});\n        }\n\n        // Create format object to format the field\n        FormattingOptions formattingOptions = ConverterUtils.convert(dataField,\n                field.getType(),\n                field.getAnnotation(BindyConverter.class),\n                getLocale());\n        Format<?> format = formatFactory.getFormat(formattingOptions);\n\n        // field object to be set\n        Object modelField = model.get(field.getDeclaringClass().getName());\n\n        // format the data received\n        Object value = null;\n\n        if (!data.equals(\"\")) {\n            try {\n                if (quoting && quote != null && (data.contains(\"\\\\\" + quote) || data.contains(quote)) && quotingEscaped) {\n                    value = format.parse(data.replaceAll(\"\\\\\\\\\" + quote, \"\\\\\" + quote));\n                } else if (quote != null && quote.equals(DOUBLE_QUOTES_SYMBOL) && data.contains(DOUBLE_QUOTES_SYMBOL + DOUBLE_QUOTES_SYMBOL) && !quotingEscaped) {\n                    // If double-quotes are used to enclose fields, the two double \n                    // quotes character must be replaced with one according to RFC 4180 section 2.7\n                    value = format.parse(data.replaceAll(DOUBLE_QUOTES_SYMBOL + DOUBLE_QUOTES_SYMBOL, DOUBLE_QUOTES_SYMBOL));\n                } else {\n                    value = format.parse(data);\n                }\n            } catch (FormatException ie) {\n                throw new IllegalArgumentException(ie.getMessage() + \", position: \" + pos + \", line: \" + line, ie);\n            } catch (Exception e) {\n                throw new IllegalArgumentException(\"Parsing error detected for field defined at the position: \" + pos + \", line: \" + line, e);\n            }\n        } else {\n            if (!dataField.defaultValue().isEmpty()) {\n                value = format.parse(dataField.defaultValue());\n            } else {\n                value = getDefaultValueForPrimitive(field.getType());\n            }\n        }\n\n        if (value != null && !dataField.method().isEmpty()) {\n            Class<?> clazz;\n            if (dataField.method().contains(\".\")) {\n                clazz = camelContext.getClassResolver().resolveMandatoryClass(dataField.method().substring(0, dataField.method().lastIndexOf(\".\")));\n            } else {\n                clazz = field.getType();\n            }\n\n            String methodName = dataField.method().substring(dataField.method().lastIndexOf(\".\") + 1,\n                    dataField.method().length());\n\n            Method m = ReflectionHelper.findMethod(clazz, methodName, field.getType());\n            if (m != null) {\n                // this method must be static and return type\n                // must be the same as the datafield and \n                // must receive only the datafield value \n                // as the method argument\n                value = ObjectHelper.invokeMethod(m, null, value);\n            } else {\n                // fallback to method without parameter, that is on the value itself\n                m = ReflectionHelper.findMethod(clazz, methodName);\n                value = ObjectHelper.invokeMethod(m, value);\n            }\n        }\n\n        field.set(modelField, value);\n        return counterMandatoryFields;\n    }",
            " 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226 +\n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  ",
            "    private int setDataFieldValue(CamelContext camelContext, Map<String, Object> model, int line, int pos, int counterMandatoryFields, String data, DataField dataField) throws Exception {\n        ObjectHelper.notNull(dataField, \"No position \" + pos + \" defined for the field: \" + data + \", line: \" + line);\n\n        if (dataField.trim()) {\n            data = data.trim();\n        }\n\n        if (dataField.required()) {\n            // Increment counter of mandatory fields\n            ++counterMandatoryFields;\n\n            // Check if content of the field is empty\n            // This is not possible for mandatory fields\n            if (data.equals(\"\")) {\n                throw new IllegalArgumentException(\"The mandatory field defined at the position \" + pos + \" is empty for the line: \" + line);\n            }\n        }\n\n        // Get Field to be setted\n        Field field = annotatedFields.get(pos);\n        field.setAccessible(true);\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Pos: {}, Data: {}, Field type: {}\", pos, data, field.getType());\n        }\n\n        // Create format object to format the field\n        FormattingOptions formattingOptions = ConverterUtils.convert(dataField,\n                field.getType(),\n                field.getAnnotation(BindyConverter.class),\n                getLocale());\n        Format<?> format = formatFactory.getFormat(formattingOptions);\n\n        // field object to be set\n        Object modelField = model.get(field.getDeclaringClass().getName());\n\n        // format the data received\n        Object value = null;\n\n        if (!data.equals(\"\")) {\n            try {\n                if (quoting && quote != null && (data.contains(\"\\\\\" + quote) || data.contains(quote)) && quotingEscaped) {\n                    value = format.parse(data.replaceAll(\"\\\\\\\\\" + quote, \"\\\\\" + quote));\n                } else if (quote != null && quote.equals(DOUBLE_QUOTES_SYMBOL) && data.contains(DOUBLE_QUOTES_SYMBOL + DOUBLE_QUOTES_SYMBOL) && !quotingEscaped) {\n                    // If double-quotes are used to enclose fields, the two double \n                    // quotes character must be replaced with one according to RFC 4180 section 2.7\n                    value = format.parse(data.replaceAll(DOUBLE_QUOTES_SYMBOL + DOUBLE_QUOTES_SYMBOL, DOUBLE_QUOTES_SYMBOL));\n                } else {\n                    value = format.parse(data);\n                }\n            } catch (FormatException ie) {\n                throw new IllegalArgumentException(ie.getMessage() + \", position: \" + pos + \", line: \" + line, ie);\n            } catch (Exception e) {\n                throw new IllegalArgumentException(\"Parsing error detected for field defined at the position: \" + pos + \", line: \" + line, e);\n            }\n        } else {\n            if (!dataField.defaultValue().isEmpty()) {\n                value = format.parse(dataField.defaultValue());\n            } else {\n                value = getDefaultValueForPrimitive(field.getType());\n            }\n        }\n\n        if (value != null && !dataField.method().isEmpty()) {\n            Class<?> clazz;\n            if (dataField.method().contains(\".\")) {\n                clazz = camelContext.getClassResolver().resolveMandatoryClass(dataField.method().substring(0, dataField.method().lastIndexOf(\".\")));\n            } else {\n                clazz = field.getType();\n            }\n\n            String methodName = dataField.method().substring(dataField.method().lastIndexOf(\".\") + 1,\n                    dataField.method().length());\n\n            Method m = ReflectionHelper.findMethod(clazz, methodName, field.getType());\n            if (m != null) {\n                // this method must be static and return type\n                // must be the same as the datafield and \n                // must receive only the datafield value \n                // as the method argument\n                value = ObjectHelper.invokeMethod(m, null, value);\n            } else {\n                // fallback to method without parameter, that is on the value itself\n                m = ReflectionHelper.findMethod(clazz, methodName);\n                value = ObjectHelper.invokeMethod(m, value);\n            }\n        }\n\n        field.set(modelField, value);\n        return counterMandatoryFields;\n    }"
        ],
        [
            "ServerChannelHandler::messageReceived(ChannelHandlerContext,MessageEvent)",
            "  85  \n  86  \n  87  \n  88  \n  89 -\n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  ",
            "    @Override\n    public void messageReceived(final ChannelHandlerContext ctx, final MessageEvent messageEvent) throws Exception {\n        Object in = messageEvent.getMessage();\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Channel: {} received body: {}\", new Object[]{messageEvent.getChannel(), in});\n        }\n\n        // create Exchange and let the consumer process it\n        final Exchange exchange = consumer.getEndpoint().createExchange(ctx, messageEvent);\n\n        if (consumer.getConfiguration().isSync()) {\n            exchange.setPattern(ExchangePattern.InOut);\n        }\n        // set the exchange charset property for converting\n        if (consumer.getConfiguration().getCharsetName() != null) {\n            exchange.setProperty(Exchange.CHARSET_NAME, IOHelper.normalizeCharset(consumer.getConfiguration().getCharsetName()));\n        }\n\n        // we want to handle the UoW\n        consumer.createUoW(exchange);\n\n        beforeProcess(exchange, messageEvent);\n\n        // process accordingly to endpoint configuration\n        if (consumer.getEndpoint().isSynchronous()) {\n            processSynchronously(exchange, messageEvent);\n        } else {\n            processAsynchronously(exchange, messageEvent);\n        }\n    }",
            "  85  \n  86  \n  87  \n  88  \n  89 +\n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  ",
            "    @Override\n    public void messageReceived(final ChannelHandlerContext ctx, final MessageEvent messageEvent) throws Exception {\n        Object in = messageEvent.getMessage();\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Channel: {} received body: {}\", messageEvent.getChannel(), in);\n        }\n\n        // create Exchange and let the consumer process it\n        final Exchange exchange = consumer.getEndpoint().createExchange(ctx, messageEvent);\n\n        if (consumer.getConfiguration().isSync()) {\n            exchange.setPattern(ExchangePattern.InOut);\n        }\n        // set the exchange charset property for converting\n        if (consumer.getConfiguration().getCharsetName() != null) {\n            exchange.setProperty(Exchange.CHARSET_NAME, IOHelper.normalizeCharset(consumer.getConfiguration().getCharsetName()));\n        }\n\n        // we want to handle the UoW\n        consumer.createUoW(exchange);\n\n        beforeProcess(exchange, messageEvent);\n\n        // process accordingly to endpoint configuration\n        if (consumer.getEndpoint().isSynchronous()) {\n            processSynchronously(exchange, messageEvent);\n        } else {\n            processAsynchronously(exchange, messageEvent);\n        }\n    }"
        ],
        [
            "Mina2Consumer::doStart()",
            "  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105 -\n 106  \n 107  \n 108  \n 109  \n 110  \n 111  ",
            "    @Override\n    protected void doStart() throws Exception {\n        super.doStart();\n        if (configuration.isClientMode() && configuration.getProtocol().equals(\"tcp\")) {\n            connector.setHandler(new ReceiveHandler());\n            ConnectFuture future = connector.connect(address);\n            future.awaitUninterruptibly();\n            session = future.getSession();\n            LOG.info(\"Connected to server address: {} using connector: {} timeout: {} millis.\", new Object[]{address, connector, configuration.getTimeout()});\n        } else {\n            acceptor.setHandler(new ReceiveHandler());\n            acceptor.bind(address);\n            LOG.info(\"Bound to server address: {} using acceptor: {}\", address, acceptor);\n        }\n    }",
            "  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105 +\n 106  \n 107  \n 108  \n 109  \n 110  \n 111  ",
            "    @Override\n    protected void doStart() throws Exception {\n        super.doStart();\n        if (configuration.isClientMode() && configuration.getProtocol().equals(\"tcp\")) {\n            connector.setHandler(new ReceiveHandler());\n            ConnectFuture future = connector.connect(address);\n            future.awaitUninterruptibly();\n            session = future.getSession();\n            LOG.info(\"Connected to server address: {} using connector: {} timeout: {} millis.\", address, connector, configuration.getTimeout());\n        } else {\n            acceptor.setHandler(new ReceiveHandler());\n            acceptor.bind(address);\n            LOG.info(\"Bound to server address: {} using acceptor: {}\", address, acceptor);\n        }\n    }"
        ],
        [
            "XmppPrivateChatProducer::process(Exchange)",
            "  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89 -\n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  ",
            "    public void process(Exchange exchange) {\n\n        // make sure we are connected\n        try {\n            if (connection == null) {\n                connection = endpoint.createConnection();\n            }\n\n            if (!connection.isConnected()) {\n                this.reconnect();\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not connect to XMPP server.\", e);\n        }\n\n        String participant = endpoint.getParticipant();\n        String thread = endpoint.getChatId();\n        if (participant == null) {\n            participant = getParticipant();\n        } else {\n            thread = \"Chat:\" + participant + \":\" + endpoint.getUser();\n        }\n\n        Message message = new Message();\n        try {\n            message.setTo(JidCreate.from(participant));\n            message.setThread(thread);\n            message.setType(Message.Type.normal);\n\n            ChatManager chatManager = ChatManager.getInstanceFor(connection);\n            Chat chat = getOrCreateChat(chatManager, participant, thread);\n\n            endpoint.getBinding().populateXmppMessage(message, exchange);\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Sending XMPP message to {} from {} : {}\", new Object[]{participant, endpoint.getUser(), message.getBody()});\n            }\n            chat.send(message);\n        } catch (Exception e) {\n            throw new RuntimeExchangeException(\"Could not send XMPP message to \" + participant + \" from \" + endpoint.getUser() + \" : \" + message\n                    + \" to: \" + XmppEndpoint.getConnectionMessage(connection), exchange, e);\n        }\n    }",
            "  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89 +\n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  ",
            "    public void process(Exchange exchange) {\n\n        // make sure we are connected\n        try {\n            if (connection == null) {\n                connection = endpoint.createConnection();\n            }\n\n            if (!connection.isConnected()) {\n                this.reconnect();\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not connect to XMPP server.\", e);\n        }\n\n        String participant = endpoint.getParticipant();\n        String thread = endpoint.getChatId();\n        if (participant == null) {\n            participant = getParticipant();\n        } else {\n            thread = \"Chat:\" + participant + \":\" + endpoint.getUser();\n        }\n\n        Message message = new Message();\n        try {\n            message.setTo(JidCreate.from(participant));\n            message.setThread(thread);\n            message.setType(Message.Type.normal);\n\n            ChatManager chatManager = ChatManager.getInstanceFor(connection);\n            Chat chat = getOrCreateChat(chatManager, participant, thread);\n\n            endpoint.getBinding().populateXmppMessage(message, exchange);\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Sending XMPP message to {} from {} : {}\", participant, endpoint.getUser(), message.getBody());\n            }\n            chat.send(message);\n        } catch (Exception e) {\n            throw new RuntimeExchangeException(\"Could not send XMPP message to \" + participant + \" from \" + endpoint.getUser() + \" : \" + message\n                    + \" to: \" + XmppEndpoint.getConnectionMessage(connection), exchange, e);\n        }\n    }"
        ],
        [
            "NettyHelper::writeBodyAsync(Logger,Channel,SocketAddress,Object,Exchange,ChannelFutureListener)",
            "  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91 -\n  92  \n  93  \n  94  \n  95  \n  96 -\n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  ",
            "    /**\n     * Writes the given body to Netty channel. Will <b>not</b >wait until the body has been written.\n     *\n     * @param log             logger to use\n     * @param channel         the Netty channel\n     * @param remoteAddress   the remote address when using UDP\n     * @param body            the body to write (send)\n     * @param exchange        the exchange\n     * @param listener        listener with work to be executed when the operation is complete\n     */\n    public static void writeBodyAsync(Logger log, Channel channel, SocketAddress remoteAddress, Object body,\n                                      Exchange exchange, ChannelFutureListener listener) {\n        ChannelFuture future;\n        if (remoteAddress != null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Channel: {} remote address: {} writing body: {}\", new Object[]{channel, remoteAddress, body});\n            }\n            future = channel.write(body, remoteAddress);\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Channel: {} writing body: {}\", new Object[]{channel, body});\n            }\n            future = channel.write(body);\n        }\n\n        if (listener != null) {\n            future.addListener(listener);\n        }\n    }",
            "  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91 +\n  92  \n  93  \n  94  \n  95  \n  96 +\n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  ",
            "    /**\n     * Writes the given body to Netty channel. Will <b>not</b >wait until the body has been written.\n     *\n     * @param log             logger to use\n     * @param channel         the Netty channel\n     * @param remoteAddress   the remote address when using UDP\n     * @param body            the body to write (send)\n     * @param exchange        the exchange\n     * @param listener        listener with work to be executed when the operation is complete\n     */\n    public static void writeBodyAsync(Logger log, Channel channel, SocketAddress remoteAddress, Object body,\n                                      Exchange exchange, ChannelFutureListener listener) {\n        ChannelFuture future;\n        if (remoteAddress != null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Channel: {} remote address: {} writing body: {}\", channel, remoteAddress, body);\n            }\n            future = channel.write(body, remoteAddress);\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Channel: {} writing body: {}\", channel, body);\n            }\n            future = channel.write(body);\n        }\n\n        if (listener != null) {\n            future.addListener(listener);\n        }\n    }"
        ],
        [
            "RestSwaggerProcessor::process(Exchange)",
            "  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112 -\n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  ",
            "    @Override\n    public void process(Exchange exchange) throws Exception {\n\n        String contextId = exchange.getContext().getName();\n        String route = exchange.getIn().getHeader(Exchange.HTTP_PATH, String.class);\n        String accept = exchange.getIn().getHeader(\"Accept\", String.class);\n\n        RestApiResponseAdapter adapter = new ExchangeRestApiResponseAdapter(exchange);\n\n        // whether to use json or yaml\n        boolean json = false;\n        boolean yaml = false;\n        if (route != null && route.endsWith(\"/swagger.json\")) {\n            json = true;\n            route = route.substring(0, route.length() - 13);\n        } else if (route != null && route.endsWith(\"/swagger.yaml\")) {\n            yaml = true;\n            route = route.substring(0, route.length() - 13);\n        }\n        if (accept != null && !json && !yaml) {\n            json = accept.toLowerCase(Locale.US).contains(\"json\");\n            yaml = accept.toLowerCase(Locale.US).contains(\"yaml\");\n        }\n        if (!json && !yaml) {\n            // json is default\n            json = true;\n        }\n\n        try {\n            // render list of camel contexts as root\n            if (contextIdListing && (ObjectHelper.isEmpty(route) || route.equals(\"/\"))) {\n                support.renderCamelContexts(adapter, contextId, contextIdPattern, json, yaml, configuration);\n            } else {\n                String name;\n                if (ObjectHelper.isNotEmpty(route)) {\n                    // first part is the camel context\n                    if (route.startsWith(\"/\")) {\n                        route = route.substring(1);\n                    }\n                    // the remainder is the route part\n                    name = route.split(\"/\")[0];\n                    if (route.startsWith(contextId)) {\n                        route = route.substring(name.length());\n                    }\n                } else {\n                    // listing not enabled then get current camel context as the name\n                    name = exchange.getContext().getName();\n                }\n\n                boolean match = true;\n                if (contextIdPattern != null) {\n                    if (\"#name#\".equals(contextIdPattern)) {\n                        match = name.equals(contextId);\n                    } else {\n                        match = EndpointHelper.matchPattern(name, contextIdPattern);\n                    }\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Match contextId: {} with pattern: {} -> {}\", new Object[]{name, contextIdPattern, match});\n                    }\n                }\n\n                if (!match) {\n                    adapter.noContent();\n                } else {\n                    support.renderResourceListing(adapter, swaggerConfig, name, route, json, yaml, exchange.getContext().getClassResolver(), configuration);\n                }\n            }\n        } catch (Exception e) {\n            LOG.warn(\"Error rendering Swagger API due \" + e.getMessage(), e);\n        }\n    }",
            "  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112 +\n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  ",
            "    @Override\n    public void process(Exchange exchange) throws Exception {\n\n        String contextId = exchange.getContext().getName();\n        String route = exchange.getIn().getHeader(Exchange.HTTP_PATH, String.class);\n        String accept = exchange.getIn().getHeader(\"Accept\", String.class);\n\n        RestApiResponseAdapter adapter = new ExchangeRestApiResponseAdapter(exchange);\n\n        // whether to use json or yaml\n        boolean json = false;\n        boolean yaml = false;\n        if (route != null && route.endsWith(\"/swagger.json\")) {\n            json = true;\n            route = route.substring(0, route.length() - 13);\n        } else if (route != null && route.endsWith(\"/swagger.yaml\")) {\n            yaml = true;\n            route = route.substring(0, route.length() - 13);\n        }\n        if (accept != null && !json && !yaml) {\n            json = accept.toLowerCase(Locale.US).contains(\"json\");\n            yaml = accept.toLowerCase(Locale.US).contains(\"yaml\");\n        }\n        if (!json && !yaml) {\n            // json is default\n            json = true;\n        }\n\n        try {\n            // render list of camel contexts as root\n            if (contextIdListing && (ObjectHelper.isEmpty(route) || route.equals(\"/\"))) {\n                support.renderCamelContexts(adapter, contextId, contextIdPattern, json, yaml, configuration);\n            } else {\n                String name;\n                if (ObjectHelper.isNotEmpty(route)) {\n                    // first part is the camel context\n                    if (route.startsWith(\"/\")) {\n                        route = route.substring(1);\n                    }\n                    // the remainder is the route part\n                    name = route.split(\"/\")[0];\n                    if (route.startsWith(contextId)) {\n                        route = route.substring(name.length());\n                    }\n                } else {\n                    // listing not enabled then get current camel context as the name\n                    name = exchange.getContext().getName();\n                }\n\n                boolean match = true;\n                if (contextIdPattern != null) {\n                    if (\"#name#\".equals(contextIdPattern)) {\n                        match = name.equals(contextId);\n                    } else {\n                        match = EndpointHelper.matchPattern(name, contextIdPattern);\n                    }\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Match contextId: {} with pattern: {} -> {}\", name, contextIdPattern, match);\n                    }\n                }\n\n                if (!match) {\n                    adapter.noContent();\n                } else {\n                    support.renderResourceListing(adapter, swaggerConfig, name, route, json, yaml, exchange.getContext().getClassResolver(), configuration);\n                }\n            }\n        } catch (Exception e) {\n            LOG.warn(\"Error rendering Swagger API due \" + e.getMessage(), e);\n        }\n    }"
        ],
        [
            "SparkConsumer::doStart()",
            "  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56 -\n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  ",
            "    @Override\n    protected void doStart() throws Exception {\n        super.doStart();\n\n        String verb = getEndpoint().getVerb();\n        String path = getEndpoint().getPath();\n        String accept = getEndpoint().getAccept();\n        boolean matchOnUriPrefix = getEndpoint().getSparkConfiguration().isMatchOnUriPrefix();\n\n        if (accept != null) {\n            log.debug(\"Spark-rest: {}({}) accepting: {}\", new Object[]{verb, path, accept});\n        } else {\n            log.debug(\"Spark-rest: {}({})\", verb, path);\n        }\n        CamelSpark.spark(verb, path, accept, route);\n\n        // special if cors is enabled in rest-dsl then we need a spark-route to trigger cors support\n        if (enableCors && !\"options\".equals(verb)) {\n            CamelSpark.spark(\"options\", path, accept, route);\n        }\n\n        if (matchOnUriPrefix) {\n            CamelSpark.spark(verb, path + \"/*\", accept, route);\n        }\n    }",
            "  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56 +\n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  ",
            "    @Override\n    protected void doStart() throws Exception {\n        super.doStart();\n\n        String verb = getEndpoint().getVerb();\n        String path = getEndpoint().getPath();\n        String accept = getEndpoint().getAccept();\n        boolean matchOnUriPrefix = getEndpoint().getSparkConfiguration().isMatchOnUriPrefix();\n\n        if (accept != null) {\n            log.debug(\"Spark-rest: {}({}) accepting: {}\", verb, path, accept);\n        } else {\n            log.debug(\"Spark-rest: {}({})\", verb, path);\n        }\n        CamelSpark.spark(verb, path, accept, route);\n\n        // special if cors is enabled in rest-dsl then we need a spark-route to trigger cors support\n        if (enableCors && !\"options\".equals(verb)) {\n            CamelSpark.spark(\"options\", path, accept, route);\n        }\n\n        if (matchOnUriPrefix) {\n            CamelSpark.spark(verb, path + \"/*\", accept, route);\n        }\n    }"
        ],
        [
            "RestSwaggerServlet::doGet(HttpServletRequest,HttpServletResponse)",
            " 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204 -\n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  ",
            "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\n        if (!initDone) {\n            initBaseAndApiPaths(request);\n        }\n\n        String contextId = null;\n        String route = request.getPathInfo();\n        String accept = request.getHeader(\"Accept\");\n\n        // whether to use json or yaml\n        boolean json = false;\n        boolean yaml = false;\n        if (route != null && route.endsWith(\"/swagger.json\")) {\n            json = true;\n            route = route.substring(0, route.length() - 13);\n        } else if (route != null && route.endsWith(\"/swagger.yaml\")) {\n            yaml = true;\n            route = route.substring(0, route.length() - 13);\n        }\n        if (accept != null && !json && !yaml) {\n            json = accept.toLowerCase(Locale.US).contains(\"json\");\n            yaml = accept.toLowerCase(Locale.US).contains(\"yaml\");\n        }\n        if (!json && !yaml) {\n            // json is default\n            json = true;\n        }\n\n        RestApiResponseAdapter adapter = new ServletRestApiResponseAdapter(response);\n\n        try {\n            // render list of camel contexts as root\n            if (apiContextIdListing && (ObjectHelper.isEmpty(route) || route.equals(\"/\"))) {\n                support.renderCamelContexts(adapter, contextId, apiContextIdPattern, json, yaml, null);\n            } else {\n                String name = null;\n                if (ObjectHelper.isNotEmpty(route)) {\n                    // first part is the camel context\n                    if (route.startsWith(\"/\")) {\n                        route = route.substring(1);\n                    }\n                    // the remainder is the route part\n                    name = route.split(\"/\")[0];\n                    if (ObjectHelper.isNotEmpty(name)) {\n                        route = route.substring(name.length());\n                    }\n                } else {\n                    // listing not enabled then see if there is only one CamelContext and use that as the name\n                    List<String> contexts = support.findCamelContexts();\n                    if (contexts.size() == 1) {\n                        name = contexts.get(0);\n                    }\n                }\n\n                boolean match = false;\n                if (name != null) {\n                    match = true;\n                    if (apiContextIdPattern != null) {\n                        if (\"#name#\".equals(apiContextIdPattern)) {\n                            // always match as we do not know what is the current CamelContext in a plain servlet\n                            match = true;\n                        } else {\n                            match = EndpointHelper.matchPattern(name, apiContextIdPattern);\n                        }\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Match contextId: {} with pattern: {} -> {}\", new Object[]{name, apiContextIdPattern, match});\n                        }\n                    }\n                }\n\n                if (!match) {\n                    adapter.noContent();\n                } else {\n                    support.renderResourceListing(adapter, swaggerConfig, name, route, json, yaml, classResolver, new RestConfiguration());\n                }\n            }\n        } catch (Exception e) {\n            LOG.warn(\"Error rendering Swagger API due \" + e.getMessage(), e);\n        }\n    }",
            " 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204 +\n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  ",
            "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\n        if (!initDone) {\n            initBaseAndApiPaths(request);\n        }\n\n        String contextId = null;\n        String route = request.getPathInfo();\n        String accept = request.getHeader(\"Accept\");\n\n        // whether to use json or yaml\n        boolean json = false;\n        boolean yaml = false;\n        if (route != null && route.endsWith(\"/swagger.json\")) {\n            json = true;\n            route = route.substring(0, route.length() - 13);\n        } else if (route != null && route.endsWith(\"/swagger.yaml\")) {\n            yaml = true;\n            route = route.substring(0, route.length() - 13);\n        }\n        if (accept != null && !json && !yaml) {\n            json = accept.toLowerCase(Locale.US).contains(\"json\");\n            yaml = accept.toLowerCase(Locale.US).contains(\"yaml\");\n        }\n        if (!json && !yaml) {\n            // json is default\n            json = true;\n        }\n\n        RestApiResponseAdapter adapter = new ServletRestApiResponseAdapter(response);\n\n        try {\n            // render list of camel contexts as root\n            if (apiContextIdListing && (ObjectHelper.isEmpty(route) || route.equals(\"/\"))) {\n                support.renderCamelContexts(adapter, contextId, apiContextIdPattern, json, yaml, null);\n            } else {\n                String name = null;\n                if (ObjectHelper.isNotEmpty(route)) {\n                    // first part is the camel context\n                    if (route.startsWith(\"/\")) {\n                        route = route.substring(1);\n                    }\n                    // the remainder is the route part\n                    name = route.split(\"/\")[0];\n                    if (ObjectHelper.isNotEmpty(name)) {\n                        route = route.substring(name.length());\n                    }\n                } else {\n                    // listing not enabled then see if there is only one CamelContext and use that as the name\n                    List<String> contexts = support.findCamelContexts();\n                    if (contexts.size() == 1) {\n                        name = contexts.get(0);\n                    }\n                }\n\n                boolean match = false;\n                if (name != null) {\n                    match = true;\n                    if (apiContextIdPattern != null) {\n                        if (\"#name#\".equals(apiContextIdPattern)) {\n                            // always match as we do not know what is the current CamelContext in a plain servlet\n                            match = true;\n                        } else {\n                            match = EndpointHelper.matchPattern(name, apiContextIdPattern);\n                        }\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Match contextId: {} with pattern: {} -> {}\", name, apiContextIdPattern, match);\n                        }\n                    }\n                }\n\n                if (!match) {\n                    adapter.noContent();\n                } else {\n                    support.renderResourceListing(adapter, swaggerConfig, name, route, json, yaml, classResolver, new RestConfiguration());\n                }\n            }\n        } catch (Exception e) {\n            LOG.warn(\"Error rendering Swagger API due \" + e.getMessage(), e);\n        }\n    }"
        ],
        [
            "SingleUDPNettyServerBootstrapFactory::startServerBootstrap()",
            " 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172 -\n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  ",
            "    protected void startServerBootstrap() throws Exception {\n        // create non-shared worker pool\n        int count = configuration.getWorkerCount() > 0 ? configuration.getWorkerCount() : NettyHelper.DEFAULT_IO_THREADS;\n        workerPool = new NioDatagramWorkerPool(Executors.newCachedThreadPool(), count);\n\n        datagramChannelFactory = new NioDatagramChannelFactory(workerPool);\n\n        connectionlessBootstrap = new ConnectionlessBootstrap(datagramChannelFactory);\n        connectionlessBootstrap.setOption(\"child.keepAlive\", configuration.isKeepAlive());\n        connectionlessBootstrap.setOption(\"child.tcpNoDelay\", configuration.isTcpNoDelay());\n        connectionlessBootstrap.setOption(\"reuseAddress\", configuration.isReuseAddress());\n        connectionlessBootstrap.setOption(\"child.reuseAddress\", configuration.isReuseAddress());\n        connectionlessBootstrap.setOption(\"child.connectTimeoutMillis\", configuration.getConnectTimeout());\n        connectionlessBootstrap.setOption(\"child.broadcast\", configuration.isBroadcast());\n        connectionlessBootstrap.setOption(\"sendBufferSize\", configuration.getSendBufferSize());\n        connectionlessBootstrap.setOption(\"receiveBufferSize\", configuration.getReceiveBufferSize());\n        // only set this if user has specified\n        if (configuration.getReceiveBufferSizePredictor() > 0) {\n            connectionlessBootstrap.setOption(\"receiveBufferSizePredictorFactory\",\n                    new FixedReceiveBufferSizePredictorFactory(configuration.getReceiveBufferSizePredictor()));\n        }\n        if (configuration.getBacklog() > 0) {\n            connectionlessBootstrap.setOption(\"backlog\", configuration.getBacklog());\n        }\n\n        // set any additional netty options\n        if (configuration.getOptions() != null) {\n            for (Map.Entry<String, Object> entry : configuration.getOptions().entrySet()) {\n                connectionlessBootstrap.setOption(entry.getKey(), entry.getValue());\n            }\n        }\n\n        LOG.debug(\"Created ConnectionlessBootstrap {} with options: {}\", connectionlessBootstrap, connectionlessBootstrap.getOptions());\n\n        // set the pipeline factory, which creates the pipeline for each newly created channels\n        connectionlessBootstrap.setPipelineFactory(pipelineFactory);\n\n        InetSocketAddress hostAddress = new InetSocketAddress(configuration.getHost(), configuration.getPort());\n        IpV4Subnet multicastSubnet = new IpV4Subnet(MULTICAST_SUBNET);\n\n        if (multicastSubnet.contains(configuration.getHost())) {\n            datagramChannel = (DatagramChannel)connectionlessBootstrap.bind(hostAddress);\n            String networkInterface = configuration.getNetworkInterface() == null ? LOOPBACK_INTERFACE : configuration.getNetworkInterface();\n            multicastNetworkInterface = NetworkInterface.getByName(networkInterface);\n            ObjectHelper.notNull(multicastNetworkInterface, \"No network interface found for '\" + networkInterface + \"'.\");\n            LOG.info(\"ConnectionlessBootstrap joining {}:{} using network interface: {}\", new Object[]{configuration.getHost(), configuration.getPort(), multicastNetworkInterface.getName()});\n            datagramChannel.joinGroup(hostAddress, multicastNetworkInterface).syncUninterruptibly();\n            allChannels.add(datagramChannel);\n        } else {\n            LOG.info(\"ConnectionlessBootstrap binding to {}:{}\", configuration.getHost(), configuration.getPort());\n            channel = connectionlessBootstrap.bind(hostAddress);\n            allChannels.add(channel);\n        }\n    }",
            " 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172 +\n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  ",
            "    protected void startServerBootstrap() throws Exception {\n        // create non-shared worker pool\n        int count = configuration.getWorkerCount() > 0 ? configuration.getWorkerCount() : NettyHelper.DEFAULT_IO_THREADS;\n        workerPool = new NioDatagramWorkerPool(Executors.newCachedThreadPool(), count);\n\n        datagramChannelFactory = new NioDatagramChannelFactory(workerPool);\n\n        connectionlessBootstrap = new ConnectionlessBootstrap(datagramChannelFactory);\n        connectionlessBootstrap.setOption(\"child.keepAlive\", configuration.isKeepAlive());\n        connectionlessBootstrap.setOption(\"child.tcpNoDelay\", configuration.isTcpNoDelay());\n        connectionlessBootstrap.setOption(\"reuseAddress\", configuration.isReuseAddress());\n        connectionlessBootstrap.setOption(\"child.reuseAddress\", configuration.isReuseAddress());\n        connectionlessBootstrap.setOption(\"child.connectTimeoutMillis\", configuration.getConnectTimeout());\n        connectionlessBootstrap.setOption(\"child.broadcast\", configuration.isBroadcast());\n        connectionlessBootstrap.setOption(\"sendBufferSize\", configuration.getSendBufferSize());\n        connectionlessBootstrap.setOption(\"receiveBufferSize\", configuration.getReceiveBufferSize());\n        // only set this if user has specified\n        if (configuration.getReceiveBufferSizePredictor() > 0) {\n            connectionlessBootstrap.setOption(\"receiveBufferSizePredictorFactory\",\n                    new FixedReceiveBufferSizePredictorFactory(configuration.getReceiveBufferSizePredictor()));\n        }\n        if (configuration.getBacklog() > 0) {\n            connectionlessBootstrap.setOption(\"backlog\", configuration.getBacklog());\n        }\n\n        // set any additional netty options\n        if (configuration.getOptions() != null) {\n            for (Map.Entry<String, Object> entry : configuration.getOptions().entrySet()) {\n                connectionlessBootstrap.setOption(entry.getKey(), entry.getValue());\n            }\n        }\n\n        LOG.debug(\"Created ConnectionlessBootstrap {} with options: {}\", connectionlessBootstrap, connectionlessBootstrap.getOptions());\n\n        // set the pipeline factory, which creates the pipeline for each newly created channels\n        connectionlessBootstrap.setPipelineFactory(pipelineFactory);\n\n        InetSocketAddress hostAddress = new InetSocketAddress(configuration.getHost(), configuration.getPort());\n        IpV4Subnet multicastSubnet = new IpV4Subnet(MULTICAST_SUBNET);\n\n        if (multicastSubnet.contains(configuration.getHost())) {\n            datagramChannel = (DatagramChannel)connectionlessBootstrap.bind(hostAddress);\n            String networkInterface = configuration.getNetworkInterface() == null ? LOOPBACK_INTERFACE : configuration.getNetworkInterface();\n            multicastNetworkInterface = NetworkInterface.getByName(networkInterface);\n            ObjectHelper.notNull(multicastNetworkInterface, \"No network interface found for '\" + networkInterface + \"'.\");\n            LOG.info(\"ConnectionlessBootstrap joining {}:{} using network interface: {}\", configuration.getHost(), configuration.getPort(), multicastNetworkInterface.getName());\n            datagramChannel.joinGroup(hostAddress, multicastNetworkInterface).syncUninterruptibly();\n            allChannels.add(datagramChannel);\n        } else {\n            LOG.info(\"ConnectionlessBootstrap binding to {}:{}\", configuration.getHost(), configuration.getPort());\n            channel = connectionlessBootstrap.bind(hostAddress);\n            allChannels.add(channel);\n        }\n    }"
        ],
        [
            "PGPDataFormatUtil::findSecretKeysWithPrivateKeyAndUserId(Map,String,PGPSecretKeyRingCollection)",
            " 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421 -\n 422 -\n 423  \n 424  \n 425  \n 426  \n 427  \n 428  \n 429  \n 430  \n 431  \n 432  \n 433  \n 434  \n 435  \n 436  \n 437  \n 438  \n 439  \n 440  ",
            "    public static List<PGPSecretKeyAndPrivateKeyAndUserId> findSecretKeysWithPrivateKeyAndUserId(Map<String, String> sigKeyUserId2Password,\n            String provider, PGPSecretKeyRingCollection pgpSec) throws PGPException {\n        List<PGPSecretKeyAndPrivateKeyAndUserId> result = new ArrayList<>(sigKeyUserId2Password.size());\n        for (Iterator<?> i = pgpSec.getKeyRings(); i.hasNext();) {\n            Object data = i.next();\n            if (data instanceof PGPSecretKeyRing) {\n                PGPSecretKeyRing keyring = (PGPSecretKeyRing) data;\n                PGPSecretKey primaryKey = keyring.getSecretKey();\n                List<String> useridParts = new ArrayList<>(sigKeyUserId2Password.keySet());\n                String[] foundKeyUserIdForUserIdPart = findFirstKeyUserIdContainingOneOfTheParts(useridParts, primaryKey.getPublicKey());\n                if (foundKeyUserIdForUserIdPart == null) {\n                    LOG.debug(\"No User ID found in primary key with key ID {} containing one of the parts {}\", primaryKey.getKeyID(),\n                            useridParts);\n                    continue;\n                }\n                LOG.debug(\"User ID {} found in primary key with key ID {} containing one of the parts {}\", new Object[] {\n                    foundKeyUserIdForUserIdPart[0], primaryKey.getKeyID(), useridParts });\n                // add all signing keys\n                for (Iterator<PGPSecretKey> iterKey = keyring.getSecretKeys(); iterKey.hasNext();) {\n                    PGPSecretKey secKey = iterKey.next();\n                    if (isSigningKey(secKey)) {\n                        PGPPrivateKey privateKey = secKey.extractPrivateKey(new JcePBESecretKeyDecryptorBuilder().setProvider(provider)\n                                .build(sigKeyUserId2Password.get(foundKeyUserIdForUserIdPart[1]).toCharArray()));\n                        if (privateKey != null) {\n                            result.add(new PGPSecretKeyAndPrivateKeyAndUserId(secKey, privateKey, foundKeyUserIdForUserIdPart[0]));\n                            LOG.debug(\"Private key with user ID {} and key ID {} added to the signing keys\",\n                                    foundKeyUserIdForUserIdPart[0], Long.toString(privateKey.getKeyID()));\n\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }",
            " 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421 +\n 422 +\n 423  \n 424  \n 425  \n 426  \n 427  \n 428  \n 429  \n 430  \n 431  \n 432  \n 433  \n 434  \n 435  \n 436  \n 437  \n 438  \n 439  \n 440  ",
            "    public static List<PGPSecretKeyAndPrivateKeyAndUserId> findSecretKeysWithPrivateKeyAndUserId(Map<String, String> sigKeyUserId2Password,\n            String provider, PGPSecretKeyRingCollection pgpSec) throws PGPException {\n        List<PGPSecretKeyAndPrivateKeyAndUserId> result = new ArrayList<>(sigKeyUserId2Password.size());\n        for (Iterator<?> i = pgpSec.getKeyRings(); i.hasNext();) {\n            Object data = i.next();\n            if (data instanceof PGPSecretKeyRing) {\n                PGPSecretKeyRing keyring = (PGPSecretKeyRing) data;\n                PGPSecretKey primaryKey = keyring.getSecretKey();\n                List<String> useridParts = new ArrayList<>(sigKeyUserId2Password.keySet());\n                String[] foundKeyUserIdForUserIdPart = findFirstKeyUserIdContainingOneOfTheParts(useridParts, primaryKey.getPublicKey());\n                if (foundKeyUserIdForUserIdPart == null) {\n                    LOG.debug(\"No User ID found in primary key with key ID {} containing one of the parts {}\", primaryKey.getKeyID(),\n                            useridParts);\n                    continue;\n                }\n                LOG.debug(\"User ID {} found in primary key with key ID {} containing one of the parts {}\",\n                    foundKeyUserIdForUserIdPart[0], primaryKey.getKeyID(), useridParts);\n                // add all signing keys\n                for (Iterator<PGPSecretKey> iterKey = keyring.getSecretKeys(); iterKey.hasNext();) {\n                    PGPSecretKey secKey = iterKey.next();\n                    if (isSigningKey(secKey)) {\n                        PGPPrivateKey privateKey = secKey.extractPrivateKey(new JcePBESecretKeyDecryptorBuilder().setProvider(provider)\n                                .build(sigKeyUserId2Password.get(foundKeyUserIdForUserIdPart[1]).toCharArray()));\n                        if (privateKey != null) {\n                            result.add(new PGPSecretKeyAndPrivateKeyAndUserId(secKey, privateKey, foundKeyUserIdForUserIdPart[0]));\n                            LOG.debug(\"Private key with user ID {} and key ID {} added to the signing keys\",\n                                    foundKeyUserIdForUserIdPart[0], Long.toString(privateKey.getKeyID()));\n\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }"
        ],
        [
            "Mina2Consumer::configureDataGramCodecFactory(String,IoService,Mina2Configuration)",
            " 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303 -\n 304  \n 305  \n 306  \n 307  \n 308  ",
            "    /**\n     * For datagrams the entire message is available as a single IoBuffer so lets just pass those around by default\n     * and try converting whatever they payload is into IoBuffer unless some custom converter is specified\n     */\n    protected void configureDataGramCodecFactory(final String type, final IoService service, final Mina2Configuration configuration) {\n        ProtocolCodecFactory codecFactory = configuration.getCodec();\n        if (codecFactory == null) {\n            codecFactory = new Mina2UdpProtocolCodecFactory(this.getEndpoint().getCamelContext());\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"{}: Using CodecFactory: {}\", new Object[]{type, codecFactory});\n            }\n        }\n\n        addCodecFactory(service, codecFactory);\n    }",
            " 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303 +\n 304  \n 305  \n 306  \n 307  \n 308  ",
            "    /**\n     * For datagrams the entire message is available as a single IoBuffer so lets just pass those around by default\n     * and try converting whatever they payload is into IoBuffer unless some custom converter is specified\n     */\n    protected void configureDataGramCodecFactory(final String type, final IoService service, final Mina2Configuration configuration) {\n        ProtocolCodecFactory codecFactory = configuration.getCodec();\n        if (codecFactory == null) {\n            codecFactory = new Mina2UdpProtocolCodecFactory(this.getEndpoint().getCamelContext());\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"{}: Using CodecFactory: {}\", type, codecFactory);\n            }\n        }\n\n        addCodecFactory(service, codecFactory);\n    }"
        ],
        [
            "BindyCsvFactory::product(Map)",
            " 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421 -\n 422  \n 423  \n 424  \n 425  \n 426  \n 427  \n 428 -\n 429  \n 430  \n 431  \n 432  \n 433  \n 434  \n 435  \n 436  \n 437  \n 438  \n 439  \n 440  \n 441  ",
            "    private List<List<String>> product(Map<Integer, List<String>> values) {\n        TreeMap<Integer, List<String>> sortValues = new TreeMap<>(values);\n\n        List<List<String>> product = new ArrayList<>();\n        Map<Integer, Integer> index = new HashMap<>();\n\n        int idx = 0;\n        int idxSize = 0;\n        do {\n            idxSize = 0;\n            List<String> v = new ArrayList<>();\n\n            for (int ii = 1; ii <= sortValues.lastKey(); ii++) {\n                List<String> l = values.get(ii);\n                if (l == null) {\n                    v.add(\"\");\n                    ++idxSize;\n                    continue;\n                }\n\n                if (l.size() >= idx + 1) {\n                    v.add(l.get(idx));\n                    index.put(ii, idx);\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Value: {}, pos: {}, at: {}\", new Object[]{l.get(idx), ii, idx});\n                    }\n                } else {\n                    v.add(l.get(0));\n                    index.put(ii, 0);\n                    ++idxSize;\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Value: {}, pos: {}, at index: {}\", new Object[]{l.get(0), ii, 0});\n                    }\n                }\n            }\n\n            if (idxSize != sortValues.lastKey()) {\n                product.add(v);\n            }\n            ++idx;\n\n        } while (idxSize != sortValues.lastKey());\n\n        return product;\n    }",
            " 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421 +\n 422  \n 423  \n 424  \n 425  \n 426  \n 427  \n 428 +\n 429  \n 430  \n 431  \n 432  \n 433  \n 434  \n 435  \n 436  \n 437  \n 438  \n 439  \n 440  \n 441  ",
            "    private List<List<String>> product(Map<Integer, List<String>> values) {\n        TreeMap<Integer, List<String>> sortValues = new TreeMap<>(values);\n\n        List<List<String>> product = new ArrayList<>();\n        Map<Integer, Integer> index = new HashMap<>();\n\n        int idx = 0;\n        int idxSize = 0;\n        do {\n            idxSize = 0;\n            List<String> v = new ArrayList<>();\n\n            for (int ii = 1; ii <= sortValues.lastKey(); ii++) {\n                List<String> l = values.get(ii);\n                if (l == null) {\n                    v.add(\"\");\n                    ++idxSize;\n                    continue;\n                }\n\n                if (l.size() >= idx + 1) {\n                    v.add(l.get(idx));\n                    index.put(ii, idx);\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Value: {}, pos: {}, at: {}\", l.get(idx), ii, idx);\n                    }\n                } else {\n                    v.add(l.get(0));\n                    index.put(ii, 0);\n                    ++idxSize;\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Value: {}, pos: {}, at index: {}\", l.get(0), ii, 0);\n                    }\n                }\n            }\n\n            if (idxSize != sortValues.lastKey()) {\n                product.add(v);\n            }\n            ++idx;\n\n        } while (idxSize != sortValues.lastKey());\n\n        return product;\n    }"
        ],
        [
            "CouchDbChangesetTracker::run()",
            "  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71 -\n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  ",
            "    @Override\n    public void run() {\n        while (changes.hasNext()) { // blocks until a feed is received\n            ChangesResult.Row feed = changes.next();\n            if (feed.isDeleted() && !endpoint.isDeletes()) {\n                continue;\n            }\n            if (!feed.isDeleted() && !endpoint.isUpdates()) {\n                continue;\n            }\n\n            String seq = feed.getSeq();\n            JsonObject doc = feed.getDoc();\n\n            Exchange exchange = endpoint.createExchange(seq, feed.getId(), doc, feed.isDeleted());\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Created exchange [exchange={}, _id={}, seq={}\", new Object[]{exchange, feed.getId(), seq});\n            }\n\n            try {\n                consumer.getProcessor().process(exchange);\n            } catch (Exception e) {\n                consumer.getExceptionHandler().handleException(\"Error processing exchange.\", exchange, e);\n            }\n        }\n        stopped = true;\n    }",
            "  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71 +\n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  ",
            "    @Override\n    public void run() {\n        while (changes.hasNext()) { // blocks until a feed is received\n            ChangesResult.Row feed = changes.next();\n            if (feed.isDeleted() && !endpoint.isDeletes()) {\n                continue;\n            }\n            if (!feed.isDeleted() && !endpoint.isUpdates()) {\n                continue;\n            }\n\n            String seq = feed.getSeq();\n            JsonObject doc = feed.getDoc();\n\n            Exchange exchange = endpoint.createExchange(seq, feed.getId(), doc, feed.isDeleted());\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Created exchange [exchange={}, _id={}, seq={}\", exchange, feed.getId(), seq);\n            }\n\n            try {\n                consumer.getProcessor().process(exchange);\n            } catch (Exception e) {\n                consumer.getExceptionHandler().handleException(\"Error processing exchange.\", exchange, e);\n            }\n        }\n        stopped = true;\n    }"
        ],
        [
            "SftpConsumer::doPollDirectory(String,String,List,int)",
            " 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163 -\n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  ",
            "    protected boolean doPollDirectory(String absolutePath, String dirName, List<GenericFile<SftpRemoteFile>> fileList, int depth) {\n        log.trace(\"doPollDirectory from absolutePath: {}, dirName: {}\", absolutePath, dirName);\n\n        depth++;\n\n        // remove trailing /\n        dirName = FileUtil.stripTrailingSeparator(dirName);\n\n        // compute dir depending on stepwise is enabled or not\n        String dir = null;\n        List<SftpRemoteFile> files = null;\n        try {\n            if (isStepwise()) {\n                dir = ObjectHelper.isNotEmpty(dirName) ? dirName : absolutePath;\n                operations.changeCurrentDirectory(dir);\n            } else {\n                dir = absolutePath;\n            }\n\n            log.trace(\"Polling directory: {}\", dir);\n            if (isUseList()) {\n                if (isStepwise()) {\n                    files = operations.listFiles();\n                } else {\n                    files = operations.listFiles(dir);\n                }\n            } else {\n                // we cannot use the LIST command(s) so we can only poll a named file\n                // so created a pseudo file with that name\n                fileExpressionResult = evaluateFileExpression();\n                if (fileExpressionResult != null) {\n                    SftpRemoteFile file = new SftpRemoteFileSingle(fileExpressionResult);\n                    files = new ArrayList<>(1);\n                    files.add(file);\n                }\n            }\n        } catch (GenericFileOperationFailedException e) {\n            if (ignoreCannotRetrieveFile(null, null, e)) {\n                log.debug(\"Cannot list files in directory {} due directory does not exists or file permission error.\", dir);\n            } else {\n                throw e;\n            }\n        }\n\n        if (files == null || files.isEmpty()) {\n            // no files in this directory to poll\n            log.trace(\"No files found in directory: {}\", dir);\n            return true;\n        } else {\n            // we found some files\n            log.trace(\"Found {} in directory: {}\", files.size(), dir);\n        }\n        \n        if (getEndpoint().isPreSort()) {\n            Collections.sort(files, (a, b) -> a.getFilename().compareTo(b.getFilename()));\n        }\n\n        for (SftpRemoteFile file : files) {\n\n            if (log.isTraceEnabled()) {\n                log.trace(\"SftpFile[fileName={}, longName={}, dir={}]\", new Object[]{file.getFilename(), file.getLongname(), file.isDirectory()});\n            }\n\n            // check if we can continue polling in files\n            if (!canPollMoreFiles(fileList)) {\n                return false;\n            }\n\n            if (file.isDirectory()) {\n                RemoteFile<SftpRemoteFile> remote = asRemoteFile(absolutePath, file, getEndpoint().getCharset());\n                if (endpoint.isRecursive() && depth < endpoint.getMaxDepth() && isValidFile(remote, true, files)) {\n                    // recursive scan and add the sub files and folders\n                    String subDirectory = file.getFilename();\n                    String path = absolutePath + \"/\" + subDirectory;\n                    boolean canPollMore = pollSubDirectory(path, subDirectory, fileList, depth);\n                    if (!canPollMore) {\n                        return false;\n                    }\n                }\n                // we cannot use file.getAttrs().isLink on Windows, so we dont invoke the method\n                // just assuming its a file we should poll\n            } else {\n                RemoteFile<SftpRemoteFile> remote = asRemoteFile(absolutePath, file, getEndpoint().getCharset());\n                if (depth >= endpoint.getMinDepth() && isValidFile(remote, false, files)) {\n                    // matched file so add\n                    fileList.add(remote);\n                }\n            }\n        }\n\n        return true;\n    }",
            " 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163 +\n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  ",
            "    protected boolean doPollDirectory(String absolutePath, String dirName, List<GenericFile<SftpRemoteFile>> fileList, int depth) {\n        log.trace(\"doPollDirectory from absolutePath: {}, dirName: {}\", absolutePath, dirName);\n\n        depth++;\n\n        // remove trailing /\n        dirName = FileUtil.stripTrailingSeparator(dirName);\n\n        // compute dir depending on stepwise is enabled or not\n        String dir = null;\n        List<SftpRemoteFile> files = null;\n        try {\n            if (isStepwise()) {\n                dir = ObjectHelper.isNotEmpty(dirName) ? dirName : absolutePath;\n                operations.changeCurrentDirectory(dir);\n            } else {\n                dir = absolutePath;\n            }\n\n            log.trace(\"Polling directory: {}\", dir);\n            if (isUseList()) {\n                if (isStepwise()) {\n                    files = operations.listFiles();\n                } else {\n                    files = operations.listFiles(dir);\n                }\n            } else {\n                // we cannot use the LIST command(s) so we can only poll a named file\n                // so created a pseudo file with that name\n                fileExpressionResult = evaluateFileExpression();\n                if (fileExpressionResult != null) {\n                    SftpRemoteFile file = new SftpRemoteFileSingle(fileExpressionResult);\n                    files = new ArrayList<>(1);\n                    files.add(file);\n                }\n            }\n        } catch (GenericFileOperationFailedException e) {\n            if (ignoreCannotRetrieveFile(null, null, e)) {\n                log.debug(\"Cannot list files in directory {} due directory does not exists or file permission error.\", dir);\n            } else {\n                throw e;\n            }\n        }\n\n        if (files == null || files.isEmpty()) {\n            // no files in this directory to poll\n            log.trace(\"No files found in directory: {}\", dir);\n            return true;\n        } else {\n            // we found some files\n            log.trace(\"Found {} in directory: {}\", files.size(), dir);\n        }\n        \n        if (getEndpoint().isPreSort()) {\n            Collections.sort(files, (a, b) -> a.getFilename().compareTo(b.getFilename()));\n        }\n\n        for (SftpRemoteFile file : files) {\n\n            if (log.isTraceEnabled()) {\n                log.trace(\"SftpFile[fileName={}, longName={}, dir={}]\", file.getFilename(), file.getLongname(), file.isDirectory());\n            }\n\n            // check if we can continue polling in files\n            if (!canPollMoreFiles(fileList)) {\n                return false;\n            }\n\n            if (file.isDirectory()) {\n                RemoteFile<SftpRemoteFile> remote = asRemoteFile(absolutePath, file, getEndpoint().getCharset());\n                if (endpoint.isRecursive() && depth < endpoint.getMaxDepth() && isValidFile(remote, true, files)) {\n                    // recursive scan and add the sub files and folders\n                    String subDirectory = file.getFilename();\n                    String path = absolutePath + \"/\" + subDirectory;\n                    boolean canPollMore = pollSubDirectory(path, subDirectory, fileList, depth);\n                    if (!canPollMore) {\n                        return false;\n                    }\n                }\n                // we cannot use file.getAttrs().isLink on Windows, so we dont invoke the method\n                // just assuming its a file we should poll\n            } else {\n                RemoteFile<SftpRemoteFile> remote = asRemoteFile(absolutePath, file, getEndpoint().getCharset());\n                if (depth >= endpoint.getMinDepth() && isValidFile(remote, false, files)) {\n                    // matched file so add\n                    fileList.add(remote);\n                }\n            }\n        }\n\n        return true;\n    }"
        ],
        [
            "JmsRequestReplyExclusiveReplyToConcurrentTest::testJmsRequestReplyExclusiveFixedReplyTo()",
            "  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51 -\n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  ",
            "    @Test\n    public void testJmsRequestReplyExclusiveFixedReplyTo() throws Exception {\n        StopWatch watch = new StopWatch();\n        ExecutorService executor = Executors.newFixedThreadPool(10);\n        for (int i = 0; i < size; i++) {\n            final Integer num = i;\n            executor.submit(new Runnable() {\n                @Override\n                public void run() {\n                    String reply = template.requestBody(\"direct:start\", \"\" + num, String.class);\n                    log.info(\"Sent {} expecting reply 'Hello {}' got --> {}\", new Object[]{num, num, reply});\n                    assertNotNull(reply);\n                    assertEquals(\"Hello \" + num, reply);\n                    latch.countDown();\n                }\n            });\n        }\n\n        log.info(\"Waiting to process {} messages...\", size);\n\n        // if any of the assertions above fails then the latch will not get decremented \n        assertTrue(\"All assertions outside the main thread above should have passed\", latch.await(3, TimeUnit.SECONDS));\n\n        long delta = watch.stop();\n        log.info(\"Took {} millis\", delta);\n\n        // just sleep a bit before shutting down\n        Thread.sleep(1000);\n\n        executor.shutdownNow();\n    }",
            "  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51 +\n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  ",
            "    @Test\n    public void testJmsRequestReplyExclusiveFixedReplyTo() throws Exception {\n        StopWatch watch = new StopWatch();\n        ExecutorService executor = Executors.newFixedThreadPool(10);\n        for (int i = 0; i < size; i++) {\n            final Integer num = i;\n            executor.submit(new Runnable() {\n                @Override\n                public void run() {\n                    String reply = template.requestBody(\"direct:start\", \"\" + num, String.class);\n                    log.info(\"Sent {} expecting reply 'Hello {}' got --> {}\", num, num, reply);\n                    assertNotNull(reply);\n                    assertEquals(\"Hello \" + num, reply);\n                    latch.countDown();\n                }\n            });\n        }\n\n        log.info(\"Waiting to process {} messages...\", size);\n\n        // if any of the assertions above fails then the latch will not get decremented \n        assertTrue(\"All assertions outside the main thread above should have passed\", latch.await(3, TimeUnit.SECONDS));\n\n        long delta = watch.stop();\n        log.info(\"Took {} millis\", delta);\n\n        // just sleep a bit before shutting down\n        Thread.sleep(1000);\n\n        executor.shutdownNow();\n    }"
        ],
        [
            "HttpEndpoint::createHttpClient()",
            " 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192 -\n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  ",
            "    /**\n     * Factory method to create a new {@link HttpClient} instance\n     * <p/>\n     * Producers and consumers should use the {@link #getHttpClient()} method instead.\n     */\n    protected HttpClient createHttpClient() {\n        ObjectHelper.notNull(clientBuilder, \"httpClientBuilder\");\n        ObjectHelper.notNull(clientConnectionManager, \"httpConnectionManager\");\n\n        // setup the cookieStore\n        clientBuilder.setDefaultCookieStore(cookieStore);\n        // setup the httpConnectionManager\n        clientBuilder.setConnectionManager(clientConnectionManager);\n        if (getComponent() != null && getComponent().getClientConnectionManager() == getClientConnectionManager()) {\n            clientBuilder.setConnectionManagerShared(true);\n        }\n\n        if (!useSystemProperties) {\n            // configure http proxy from camelContext\n            if (ObjectHelper.isNotEmpty(getCamelContext().getProperty(\"http.proxyHost\")) && ObjectHelper.isNotEmpty(getCamelContext().getProperty(\"http.proxyPort\"))) {\n                String host = getCamelContext().getProperty(\"http.proxyHost\");\n                int port = Integer.parseInt(getCamelContext().getProperty(\"http.proxyPort\"));\n                String scheme = getCamelContext().getProperty(\"http.proxyScheme\");\n                // fallback and use either http or https depending on secure\n                if (scheme == null) {\n                    scheme = HttpHelper.isSecureConnection(getEndpointUri()) ? \"https\" : \"http\";\n                }\n                LOG.debug(\"CamelContext properties http.proxyHost, http.proxyPort, and http.proxyScheme detected. Using http proxy host: {} port: {} scheme: {}\", new Object[]{host, port, scheme});\n                HttpHost proxy = new HttpHost(host, port, scheme);\n                clientBuilder.setProxy(proxy);\n            }\n        } else {\n            clientBuilder.useSystemProperties();\n        }\n\n        if (isAuthenticationPreemptive()) {\n            // setup the PreemptiveAuthInterceptor here\n            clientBuilder.addInterceptorFirst(new PreemptiveAuthInterceptor());\n        }\n\n        HttpClientConfigurer configurer = getHttpClientConfigurer();\n        if (configurer != null) {\n            configurer.configureHttpClient(clientBuilder);\n        }\n\n        if (isBridgeEndpoint()) {\n            // need to use noop cookiestore as we do not want to keep cookies in memory\n            clientBuilder.setDefaultCookieStore(new NoopCookieStore());\n        }\n\n        LOG.debug(\"Setup the HttpClientBuilder {}\", clientBuilder);\n        return clientBuilder.build();\n    }",
            " 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192 +\n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  ",
            "    /**\n     * Factory method to create a new {@link HttpClient} instance\n     * <p/>\n     * Producers and consumers should use the {@link #getHttpClient()} method instead.\n     */\n    protected HttpClient createHttpClient() {\n        ObjectHelper.notNull(clientBuilder, \"httpClientBuilder\");\n        ObjectHelper.notNull(clientConnectionManager, \"httpConnectionManager\");\n\n        // setup the cookieStore\n        clientBuilder.setDefaultCookieStore(cookieStore);\n        // setup the httpConnectionManager\n        clientBuilder.setConnectionManager(clientConnectionManager);\n        if (getComponent() != null && getComponent().getClientConnectionManager() == getClientConnectionManager()) {\n            clientBuilder.setConnectionManagerShared(true);\n        }\n\n        if (!useSystemProperties) {\n            // configure http proxy from camelContext\n            if (ObjectHelper.isNotEmpty(getCamelContext().getProperty(\"http.proxyHost\")) && ObjectHelper.isNotEmpty(getCamelContext().getProperty(\"http.proxyPort\"))) {\n                String host = getCamelContext().getProperty(\"http.proxyHost\");\n                int port = Integer.parseInt(getCamelContext().getProperty(\"http.proxyPort\"));\n                String scheme = getCamelContext().getProperty(\"http.proxyScheme\");\n                // fallback and use either http or https depending on secure\n                if (scheme == null) {\n                    scheme = HttpHelper.isSecureConnection(getEndpointUri()) ? \"https\" : \"http\";\n                }\n                LOG.debug(\"CamelContext properties http.proxyHost, http.proxyPort, and http.proxyScheme detected. Using http proxy host: {} port: {} scheme: {}\", host, port, scheme);\n                HttpHost proxy = new HttpHost(host, port, scheme);\n                clientBuilder.setProxy(proxy);\n            }\n        } else {\n            clientBuilder.useSystemProperties();\n        }\n\n        if (isAuthenticationPreemptive()) {\n            // setup the PreemptiveAuthInterceptor here\n            clientBuilder.addInterceptorFirst(new PreemptiveAuthInterceptor());\n        }\n\n        HttpClientConfigurer configurer = getHttpClientConfigurer();\n        if (configurer != null) {\n            configurer.configureHttpClient(clientBuilder);\n        }\n\n        if (isBridgeEndpoint()) {\n            // need to use noop cookiestore as we do not want to keep cookies in memory\n            clientBuilder.setDefaultCookieStore(new NoopCookieStore());\n        }\n\n        LOG.debug(\"Setup the HttpClientBuilder {}\", clientBuilder);\n        return clientBuilder.build();\n    }"
        ],
        [
            "MinaComponent::configureDataGramCodecFactory(String,IoServiceConfig,MinaConfiguration)",
            " 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339 -\n 340  \n 341  \n 342  \n 343  \n 344  ",
            "    /**\n     * For datagrams the entire message is available as a single ByteBuffer so lets just pass those around by default\n     * and try converting whatever they payload is into ByteBuffers unless some custom converter is specified\n     */\n    protected void configureDataGramCodecFactory(final String type, final IoServiceConfig config, final MinaConfiguration configuration) {\n        ProtocolCodecFactory codecFactory = configuration.getCodec();\n        if (codecFactory == null) {\n            codecFactory = new MinaUdpProtocolCodecFactory(getCamelContext());\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"{}: Using CodecFactory: {}\", new Object[]{type, codecFactory});\n            }\n        }\n\n        addCodecFactory(config, codecFactory);\n    }",
            " 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339 +\n 340  \n 341  \n 342  \n 343  \n 344  ",
            "    /**\n     * For datagrams the entire message is available as a single ByteBuffer so lets just pass those around by default\n     * and try converting whatever they payload is into ByteBuffers unless some custom converter is specified\n     */\n    protected void configureDataGramCodecFactory(final String type, final IoServiceConfig config, final MinaConfiguration configuration) {\n        ProtocolCodecFactory codecFactory = configuration.getCodec();\n        if (codecFactory == null) {\n            codecFactory = new MinaUdpProtocolCodecFactory(getCamelContext());\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"{}: Using CodecFactory: {}\", type, codecFactory);\n            }\n        }\n\n        addCodecFactory(config, codecFactory);\n    }"
        ],
        [
            "JettyHttpComponent::createHttpClient(JettyHttpEndpoint,Integer,Integer,SSLContextParameters)",
            " 709  \n 710  \n 711  \n 712  \n 713  \n 714  \n 715  \n 716  \n 717  \n 718  \n 719  \n 720  \n 721  \n 722  \n 723  \n 724  \n 725  \n 726  \n 727  \n 728  \n 729  \n 730  \n 731  \n 732  \n 733  \n 734  \n 735  \n 736  \n 737  \n 738  \n 739  \n 740  \n 741  \n 742  \n 743  \n 744  \n 745  \n 746  \n 747  \n 748  \n 749  \n 750  \n 751  \n 752  \n 753  \n 754  \n 755  \n 756  \n 757  \n 758  \n 759  \n 760  \n 761  \n 762 -\n 763  \n 764  \n 765  \n 766  \n 767  \n 768  \n 769  ",
            "    /**\n     * Creates a new {@link HttpClient} and configures its proxy/thread pool and SSL based on this\n     * component settings.\n     *\n     * @param endpoint   the instance of JettyHttpEndpoint\n     * @param minThreads optional minimum number of threads in client thread pool\n     * @param maxThreads optional maximum number of threads in client thread pool\n     * @param ssl        option SSL parameters\n     */\n    public CamelHttpClient createHttpClient(JettyHttpEndpoint endpoint, Integer minThreads, Integer maxThreads, SSLContextParameters ssl) throws Exception {\n        SslContextFactory sslContextFactory = createSslContextFactory(ssl);\n        HttpClientTransport transport = createHttpClientTransport(maxThreads);\n        CamelHttpClient httpClient = createCamelHttpClient(transport, sslContextFactory);\n\n        CamelContext context = endpoint.getCamelContext();\n\n        if (context != null\n            && ObjectHelper.isNotEmpty(context.getProperty(\"http.proxyHost\"))\n            && ObjectHelper.isNotEmpty(context.getProperty(\"http.proxyPort\"))) {\n            String host = context.getProperty(\"http.proxyHost\");\n            int port = Integer.parseInt(context.getProperty(\"http.proxyPort\"));\n            LOG.debug(\"CamelContext properties http.proxyHost and http.proxyPort detected. Using http proxy host: {} port: {}\", host, port);\n            httpClient.setProxy(host, port);\n        }\n\n        if (ObjectHelper.isNotEmpty(endpoint.getProxyHost()) && endpoint.getProxyPort() > 0) {\n            String host = endpoint.getProxyHost();\n            int port = endpoint.getProxyPort();\n            LOG.debug(\"proxyHost and proxyPort options detected. Using http proxy host: {} port: {}\", host, port);\n            httpClient.setProxy(host, port);\n        }\n\n        // must have both min and max\n        if (minThreads != null || maxThreads != null) {\n\n            // must have both options\n            if (minThreads == null || maxThreads == null) {\n                throw new IllegalArgumentException(\"Both min and max thread pool sizes must be provided.\");\n            }\n\n            // use QueueThreadPool as the default bounded is deprecated (see SMXCOMP-157)\n            QueuedThreadPool qtp = new QueuedThreadPool();\n            qtp.setMinThreads(minThreads.intValue());\n            qtp.setMaxThreads(maxThreads.intValue());\n            // and we want to use daemon threads\n            qtp.setDaemon(true);\n            // let the thread names indicate they are from the client\n            qtp.setName(\"CamelJettyClient(\" + ObjectHelper.getIdentityHashCode(httpClient) + \")\");\n            httpClient.setThreadPoolOrExecutor(qtp);\n        }\n\n        if (LOG.isDebugEnabled()) {\n            if (minThreads != null) {\n                LOG.debug(\"Created HttpClient with thread pool {}-{} -> {}\", new Object[]{minThreads, maxThreads, httpClient});\n            } else {\n                LOG.debug(\"Created HttpClient with default thread pool size -> {}\", httpClient);\n            }\n        }\n\n        return httpClient;\n    }",
            " 709  \n 710  \n 711  \n 712  \n 713  \n 714  \n 715  \n 716  \n 717  \n 718  \n 719  \n 720  \n 721  \n 722  \n 723  \n 724  \n 725  \n 726  \n 727  \n 728  \n 729  \n 730  \n 731  \n 732  \n 733  \n 734  \n 735  \n 736  \n 737  \n 738  \n 739  \n 740  \n 741  \n 742  \n 743  \n 744  \n 745  \n 746  \n 747  \n 748  \n 749  \n 750  \n 751  \n 752  \n 753  \n 754  \n 755  \n 756  \n 757  \n 758  \n 759  \n 760  \n 761  \n 762 +\n 763  \n 764  \n 765  \n 766  \n 767  \n 768  \n 769  ",
            "    /**\n     * Creates a new {@link HttpClient} and configures its proxy/thread pool and SSL based on this\n     * component settings.\n     *\n     * @param endpoint   the instance of JettyHttpEndpoint\n     * @param minThreads optional minimum number of threads in client thread pool\n     * @param maxThreads optional maximum number of threads in client thread pool\n     * @param ssl        option SSL parameters\n     */\n    public CamelHttpClient createHttpClient(JettyHttpEndpoint endpoint, Integer minThreads, Integer maxThreads, SSLContextParameters ssl) throws Exception {\n        SslContextFactory sslContextFactory = createSslContextFactory(ssl);\n        HttpClientTransport transport = createHttpClientTransport(maxThreads);\n        CamelHttpClient httpClient = createCamelHttpClient(transport, sslContextFactory);\n\n        CamelContext context = endpoint.getCamelContext();\n\n        if (context != null\n            && ObjectHelper.isNotEmpty(context.getProperty(\"http.proxyHost\"))\n            && ObjectHelper.isNotEmpty(context.getProperty(\"http.proxyPort\"))) {\n            String host = context.getProperty(\"http.proxyHost\");\n            int port = Integer.parseInt(context.getProperty(\"http.proxyPort\"));\n            LOG.debug(\"CamelContext properties http.proxyHost and http.proxyPort detected. Using http proxy host: {} port: {}\", host, port);\n            httpClient.setProxy(host, port);\n        }\n\n        if (ObjectHelper.isNotEmpty(endpoint.getProxyHost()) && endpoint.getProxyPort() > 0) {\n            String host = endpoint.getProxyHost();\n            int port = endpoint.getProxyPort();\n            LOG.debug(\"proxyHost and proxyPort options detected. Using http proxy host: {} port: {}\", host, port);\n            httpClient.setProxy(host, port);\n        }\n\n        // must have both min and max\n        if (minThreads != null || maxThreads != null) {\n\n            // must have both options\n            if (minThreads == null || maxThreads == null) {\n                throw new IllegalArgumentException(\"Both min and max thread pool sizes must be provided.\");\n            }\n\n            // use QueueThreadPool as the default bounded is deprecated (see SMXCOMP-157)\n            QueuedThreadPool qtp = new QueuedThreadPool();\n            qtp.setMinThreads(minThreads.intValue());\n            qtp.setMaxThreads(maxThreads.intValue());\n            // and we want to use daemon threads\n            qtp.setDaemon(true);\n            // let the thread names indicate they are from the client\n            qtp.setName(\"CamelJettyClient(\" + ObjectHelper.getIdentityHashCode(httpClient) + \")\");\n            httpClient.setThreadPoolOrExecutor(qtp);\n        }\n\n        if (LOG.isDebugEnabled()) {\n            if (minThreads != null) {\n                LOG.debug(\"Created HttpClient with thread pool {}-{} -> {}\", minThreads, maxThreads, httpClient);\n            } else {\n                LOG.debug(\"Created HttpClient with default thread pool size -> {}\", httpClient);\n            }\n        }\n\n        return httpClient;\n    }"
        ]
    ]
}