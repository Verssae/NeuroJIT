{
    "7b3117ab99033c23513cf4e5dce2be44591f0e41": [
        [
            "HttpServerMultiplexChannelHandler::channelRead0(ChannelHandlerContext,Object)",
            "  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105 -\n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  ",
            "    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {\n        // store request, as this channel handler is created per pipeline\n        HttpRequest request = (HttpRequest) msg;\n      \n        LOG.debug(\"Message received: {}\", request);\n\n        HttpServerChannelHandler handler = getHandler(request);\n        if (handler != null) {\n            Attribute<HttpServerChannelHandler> attr = ctx.attr(SERVER_HANDLER_KEY);\n            // store handler as attachment\n            attr.set(handler);\n            if (msg instanceof HttpContent) {\n                // need to hold the reference of content\n                HttpContent httpContent = (HttpContent) msg;\n                httpContent.content().retain();\n            }   \n            handler.channelRead(ctx, request);\n        } else {\n            // this resource is not found, so send empty response back\n            HttpResponse response = new DefaultHttpResponse(HTTP_1_1, NOT_FOUND);\n            response.headers().set(Exchange.CONTENT_TYPE, \"text/plain\");\n            response.headers().set(Exchange.CONTENT_LENGTH, 0);\n            ctx.writeAndFlush(response);\n            ctx.close();\n        }\n    }",
            "  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105 +\n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  ",
            "    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {\n        // store request, as this channel handler is created per pipeline\n        HttpRequest request = (HttpRequest) msg;\n      \n        LOG.debug(\"Message received: {}\", request);\n\n        HttpServerChannelHandler handler = getHandler(request);\n        if (handler != null) {\n            Attribute<HttpServerChannelHandler> attr = ctx.channel().attr(SERVER_HANDLER_KEY);\n            // store handler as attachment\n            attr.set(handler);\n            if (msg instanceof HttpContent) {\n                // need to hold the reference of content\n                HttpContent httpContent = (HttpContent) msg;\n                httpContent.content().retain();\n            }   \n            handler.channelRead(ctx, request);\n        } else {\n            // this resource is not found, so send empty response back\n            HttpResponse response = new DefaultHttpResponse(HTTP_1_1, NOT_FOUND);\n            response.headers().set(Exchange.CONTENT_TYPE, \"text/plain\");\n            response.headers().set(Exchange.CONTENT_LENGTH, 0);\n            ctx.writeAndFlush(response);\n            ctx.close();\n        }\n    }"
        ],
        [
            "NettyHttpProducer::getRequestBody(Exchange)",
            "  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65 -\n  66  \n  67  \n  68 -\n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  ",
            "    @Override\n    protected Object getRequestBody(Exchange exchange) throws Exception {\n        // creating the url to use takes 2-steps\n        String uri = NettyHttpHelper.createURL(exchange, getEndpoint());\n        URI u = NettyHttpHelper.createURI(exchange, uri, getEndpoint());\n\n        final HttpRequest request = getEndpoint().getNettyHttpBinding().toNettyRequest(exchange.getIn(), u.toString(), getConfiguration());\n        String actualUri = request.getUri();\n        exchange.getIn().setHeader(Exchange.HTTP_URL, actualUri);\n        // Need to check if we need to close the connection or not\n        if (!HttpHeaders.isKeepAlive(request)) {\n            // just want to make sure we close the channel if the keepAlive is not true\n            exchange.setProperty(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, true);\n        }\n        if (getConfiguration().isBridgeEndpoint()) {\n            // Need to remove the Host key as it should be not used when bridging/proxying\n            exchange.getIn().removeHeader(\"host\");\n        }\n\n        // need to release the request when we are done\n        exchange.addOnCompletion(new SynchronizationAdapter() {\n            @Override\n            public void onDone(Exchange exchange) {\n                if (request instanceof ReferenceCounted) {\n                    if (((ReferenceCounted) request).refCnt() > 0) {\n                        log.debug(\"Releasing Netty HttpRequest ByteBuf\");\n                        ReferenceCountUtil.release(request);\n                    }\n                }\n            }\n        });\n\n        return request;\n    }",
            "  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66 +\n  67  \n  68  \n  69 +\n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  ",
            "    @Override\n    protected Object getRequestBody(Exchange exchange) throws Exception {\n        // creating the url to use takes 2-steps\n        String uri = NettyHttpHelper.createURL(exchange, getEndpoint());\n        URI u = NettyHttpHelper.createURI(exchange, uri, getEndpoint());\n\n        final HttpRequest request = getEndpoint().getNettyHttpBinding().toNettyRequest(exchange.getIn(), u.toString(), getConfiguration());\n        String actualUri = request.uri();\n        exchange.getIn().setHeader(Exchange.HTTP_URL, actualUri);\n        // Need to check if we need to close the connection or not\n        if (!HttpUtil.isKeepAlive(request)) {\n            // just want to make sure we close the channel if the keepAlive is not true\n            exchange.setProperty(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, true);\n        }\n        if (getConfiguration().isBridgeEndpoint()) {\n            // Need to remove the Host key as it should be not used when bridging/proxying\n            exchange.getIn().removeHeader(\"host\");\n        }\n\n        // need to release the request when we are done\n        exchange.addOnCompletion(new SynchronizationAdapter() {\n            @Override\n            public void onDone(Exchange exchange) {\n                if (request instanceof ReferenceCounted) {\n                    if (((ReferenceCounted) request).refCnt() > 0) {\n                        log.debug(\"Releasing Netty HttpRequest ByteBuf\");\n                        ReferenceCountUtil.release(request);\n                    }\n                }\n            }\n        });\n\n        return request;\n    }"
        ],
        [
            "RestNettyHttpBinding::populateCamelHeaders(FullHttpRequest,Map,Exchange,NettyHttpConfiguration)",
            "  47  \n  48  \n  49  \n  50  \n  51 -\n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  ",
            "    @Override\n    public void populateCamelHeaders(FullHttpRequest request, Map<String, Object> headers, Exchange exchange, NettyHttpConfiguration configuration) throws Exception {\n        super.populateCamelHeaders(request, headers, exchange, configuration);\n\n        String path = request.getUri();\n        if (path == null) {\n            return;\n        }\n\n        // skip the scheme/host/port etc, as we only want the context-path\n        URI uri = new URI(path);\n        path = uri.getPath();\n\n        // in the endpoint the user may have defined rest {} placeholders\n        // so we need to map those placeholders with data from the incoming request context path\n\n        String consumerPath = configuration.getPath();\n\n        if (useRestMatching(consumerPath)) {\n\n            // split using single char / is optimized in the jdk\n            String[] paths = path.split(\"/\");\n            String[] consumerPaths = consumerPath.split(\"/\");\n\n            for (int i = 0; i < consumerPaths.length; i++) {\n                if (paths.length < i) {\n                    break;\n                }\n                String p1 = consumerPaths[i];\n                if (p1.startsWith(\"{\") && p1.endsWith(\"}\")) {\n                    String key = p1.substring(1, p1.length() - 1);\n                    String value = paths[i];\n                    if (value != null) {\n                        NettyHttpHelper.appendHeader(headers, key, value);\n                    }\n                }\n            }\n        }\n    }",
            "  47  \n  48  \n  49  \n  50  \n  51 +\n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  ",
            "    @Override\n    public void populateCamelHeaders(FullHttpRequest request, Map<String, Object> headers, Exchange exchange, NettyHttpConfiguration configuration) throws Exception {\n        super.populateCamelHeaders(request, headers, exchange, configuration);\n\n        String path = request.uri();\n        if (path == null) {\n            return;\n        }\n\n        // skip the scheme/host/port etc, as we only want the context-path\n        URI uri = new URI(path);\n        path = uri.getPath();\n\n        // in the endpoint the user may have defined rest {} placeholders\n        // so we need to map those placeholders with data from the incoming request context path\n\n        String consumerPath = configuration.getPath();\n\n        if (useRestMatching(consumerPath)) {\n\n            // split using single char / is optimized in the jdk\n            String[] paths = path.split(\"/\");\n            String[] consumerPaths = consumerPath.split(\"/\");\n\n            for (int i = 0; i < consumerPaths.length; i++) {\n                if (paths.length < i) {\n                    break;\n                }\n                String p1 = consumerPaths[i];\n                if (p1.startsWith(\"{\") && p1.endsWith(\"}\")) {\n                    String key = p1.substring(1, p1.length() - 1);\n                    String value = paths[i];\n                    if (value != null) {\n                        NettyHttpHelper.appendHeader(headers, key, value);\n                    }\n                }\n            }\n        }\n    }"
        ],
        [
            "HttpServerMultiplexChannelHandler::getHandler(HttpRequest)",
            " 148  \n 149  \n 150  \n 151  \n 152  \n 153 -\n 154  \n 155  \n 156  \n 157  \n 158 -\n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  ",
            "    @SuppressWarnings(\"unchecked\")\n    private HttpServerChannelHandler getHandler(HttpRequest request) {\n        HttpServerChannelHandler answer = null;\n\n        // need to strip out host and port etc, as we only need the context-path for matching\n        String method = request.getMethod().name();\n        if (method == null) {\n            return null;\n        }\n\n        String path = request.getUri();\n        int idx = path.indexOf(token);\n        if (idx > -1) {\n            path = path.substring(idx + len);\n        }\n        // use the path as key to find the consumer handler to use\n        path = pathAsKey(path);\n\n        List<RestConsumerContextPathMatcher.ConsumerPath> paths = new ArrayList<RestConsumerContextPathMatcher.ConsumerPath>();\n        for (final HttpServerChannelHandler handler : consumers) {\n            paths.add(new RestConsumerContextPathMatcher.ConsumerPath<HttpServerChannelHandler>() {\n                @Override\n                public String getRestrictMethod() {\n                    return handler.getConsumer().getEndpoint().getHttpMethodRestrict();\n                }\n\n                @Override\n                public String getConsumerPath() {\n                    return handler.getConsumer().getConfiguration().getPath();\n                }\n\n                @Override\n                public HttpServerChannelHandler getConsumer() {\n                    return handler;\n                }\n            });\n        }\n\n        RestConsumerContextPathMatcher.ConsumerPath<HttpServerChannelHandler> best = RestConsumerContextPathMatcher.matchBestPath(method, path, paths);\n        if (best != null) {\n            answer = best.getConsumer();\n        }\n\n        // fallback to regular matching\n        if (answer == null) {\n            for (final HttpServerChannelHandler handler : consumers) {\n                NettyHttpConsumer consumer = handler.getConsumer();\n                String consumerPath = consumer.getConfiguration().getPath();\n                boolean matchOnUriPrefix = consumer.getEndpoint().getConfiguration().isMatchOnUriPrefix();\n                // Just make sure the we get the right consumer path first\n                if (RestConsumerContextPathMatcher.matchPath(path, consumerPath, matchOnUriPrefix)) {\n                    answer = handler;\n                    break;\n                }\n            }\n        }\n\n        return answer;\n    }",
            " 148  \n 149  \n 150  \n 151  \n 152  \n 153 +\n 154  \n 155  \n 156  \n 157  \n 158 +\n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  ",
            "    @SuppressWarnings(\"unchecked\")\n    private HttpServerChannelHandler getHandler(HttpRequest request) {\n        HttpServerChannelHandler answer = null;\n\n        // need to strip out host and port etc, as we only need the context-path for matching\n        String method = request.method().name();\n        if (method == null) {\n            return null;\n        }\n\n        String path = request.uri();\n        int idx = path.indexOf(token);\n        if (idx > -1) {\n            path = path.substring(idx + len);\n        }\n        // use the path as key to find the consumer handler to use\n        path = pathAsKey(path);\n\n        List<RestConsumerContextPathMatcher.ConsumerPath> paths = new ArrayList<RestConsumerContextPathMatcher.ConsumerPath>();\n        for (final HttpServerChannelHandler handler : consumers) {\n            paths.add(new RestConsumerContextPathMatcher.ConsumerPath<HttpServerChannelHandler>() {\n                @Override\n                public String getRestrictMethod() {\n                    return handler.getConsumer().getEndpoint().getHttpMethodRestrict();\n                }\n\n                @Override\n                public String getConsumerPath() {\n                    return handler.getConsumer().getConfiguration().getPath();\n                }\n\n                @Override\n                public HttpServerChannelHandler getConsumer() {\n                    return handler;\n                }\n            });\n        }\n\n        RestConsumerContextPathMatcher.ConsumerPath<HttpServerChannelHandler> best = RestConsumerContextPathMatcher.matchBestPath(method, path, paths);\n        if (best != null) {\n            answer = best.getConsumer();\n        }\n\n        // fallback to regular matching\n        if (answer == null) {\n            for (final HttpServerChannelHandler handler : consumers) {\n                NettyHttpConsumer consumer = handler.getConsumer();\n                String consumerPath = consumer.getConfiguration().getPath();\n                boolean matchOnUriPrefix = consumer.getEndpoint().getConfiguration().isMatchOnUriPrefix();\n                // Just make sure the we get the right consumer path first\n                if (RestConsumerContextPathMatcher.matchPath(path, consumerPath, matchOnUriPrefix)) {\n                    answer = handler;\n                    break;\n                }\n            }\n        }\n\n        return answer;\n    }"
        ],
        [
            "NettyUseRawHttpResponseTest::createRouteBuilder()",
            "  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54 -\n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  ",
            "    @Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                from(\"netty4-http:http://0.0.0.0:{{port}}/foo\")\n                    .to(\"mock:input\")\n                    .process(new Processor() {\n                        @Override\n                        public void process(Exchange exchange) throws Exception {\n                            HttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK,\n                                                                                NettyConverter.toByteBuffer(\"Bye World\".getBytes()));\n                            response.headers().set(HttpHeaders.Names.CONTENT_LENGTH, 9);\n\n                            exchange.getOut().setBody(response);\n                        }\n                    });\n            }\n        };\n    }",
            "  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55 +\n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  ",
            "    @Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                from(\"netty4-http:http://0.0.0.0:{{port}}/foo\")\n                    .to(\"mock:input\")\n                    .process(new Processor() {\n                        @Override\n                        public void process(Exchange exchange) throws Exception {\n                            HttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK,\n                                                                                NettyConverter.toByteBuffer(\"Bye World\".getBytes()));\n                            response.headers().set(HttpHeaderNames.CONTENT_LENGTH.toString(), 9);\n\n                            exchange.getOut().setBody(response);\n                        }\n                    });\n            }\n        };\n    }"
        ],
        [
            "HttpServerChannelHandler::beforeProcess(Exchange,ChannelHandlerContext,Object)",
            " 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291 -\n 292  \n 293  \n 294 -\n 295  \n 296  ",
            "    @Override\n    protected void beforeProcess(Exchange exchange, final ChannelHandlerContext ctx, final Object message) {\n        if (consumer.getConfiguration().isBridgeEndpoint()) {\n            exchange.setProperty(Exchange.SKIP_GZIP_ENCODING, Boolean.TRUE);\n            exchange.setProperty(Exchange.SKIP_WWW_FORM_URLENCODED, Boolean.TRUE);\n        }\n        HttpRequest request = (HttpRequest) message;\n        // setup the connection property in case of the message header is removed\n        boolean keepAlive = HttpHeaders.isKeepAlive(request);\n        if (!keepAlive) {\n            // Just make sure we close the connection this time.\n            exchange.setProperty(HttpHeaders.Names.CONNECTION, HttpHeaders.Values.CLOSE);\n        }\n    }",
            " 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295 +\n 296  \n 297  \n 298 +\n 299  \n 300  ",
            "    @Override\n    protected void beforeProcess(Exchange exchange, final ChannelHandlerContext ctx, final Object message) {\n        if (consumer.getConfiguration().isBridgeEndpoint()) {\n            exchange.setProperty(Exchange.SKIP_GZIP_ENCODING, Boolean.TRUE);\n            exchange.setProperty(Exchange.SKIP_WWW_FORM_URLENCODED, Boolean.TRUE);\n        }\n        HttpRequest request = (HttpRequest) message;\n        // setup the connection property in case of the message header is removed\n        boolean keepAlive = HttpUtil.isKeepAlive(request);\n        if (!keepAlive) {\n            // Just make sure we close the connection this time.\n            exchange.setProperty(HttpHeaderNames.CONNECTION.toString(), HttpHeaderValues.CLOSE.toString());\n        }\n    }"
        ],
        [
            "HttpServerChannelHandler::channelRead0(ChannelHandlerContext,Object)",
            "  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94 -\n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110 -\n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118 -\n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127 -\n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140 -\n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148 -\n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  ",
            "    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {\n        HttpRequest request = (HttpRequest) msg;\n\n        LOG.debug(\"Message received: {}\", request);\n\n        if (consumer.isSuspended()) {\n            // are we suspended?\n            LOG.debug(\"Consumer suspended, cannot service request {}\", request);\n            HttpResponse response = new DefaultHttpResponse(HTTP_1_1, SERVICE_UNAVAILABLE);\n            response.headers().set(Exchange.CONTENT_TYPE, \"text/plain\");\n            response.headers().set(Exchange.CONTENT_LENGTH, 0);\n            ctx.writeAndFlush(response);\n            ctx.channel().close();\n            return;\n        }\n\n        // if its an OPTIONS request then return which methods is allowed\n        boolean isRestrictedToOptions = consumer.getEndpoint().getHttpMethodRestrict() != null\n                && consumer.getEndpoint().getHttpMethodRestrict().contains(\"OPTIONS\");\n        if (\"OPTIONS\".equals(request.getMethod().name()) && !isRestrictedToOptions) {\n            String s;\n            if (consumer.getEndpoint().getHttpMethodRestrict() != null) {\n                s = \"OPTIONS,\" + consumer.getEndpoint().getHttpMethodRestrict();\n            } else {\n                // allow them all\n                s = \"GET,HEAD,POST,PUT,DELETE,TRACE,OPTIONS,CONNECT,PATCH\";\n            }\n            HttpResponse response = new DefaultHttpResponse(HTTP_1_1, OK);\n            response.headers().set(\"Allow\", s);\n            response.headers().set(Exchange.CONTENT_TYPE, \"text/plain\");\n            response.headers().set(Exchange.CONTENT_LENGTH, 0);\n            ctx.writeAndFlush(response);\n            return;\n        }\n        if (consumer.getEndpoint().getHttpMethodRestrict() != null\n                && !consumer.getEndpoint().getHttpMethodRestrict().contains(request.getMethod().name())) {\n            HttpResponse response = new DefaultHttpResponse(HTTP_1_1, METHOD_NOT_ALLOWED);\n            response.headers().set(Exchange.CONTENT_TYPE, \"text/plain\");\n            response.headers().set(Exchange.CONTENT_LENGTH, 0);\n            ctx.writeAndFlush(response);\n            ctx.channel().close();\n            return;\n        }\n        if (\"TRACE\".equals(request.getMethod().name()) && !consumer.getEndpoint().isTraceEnabled()) {\n            HttpResponse response = new DefaultHttpResponse(HTTP_1_1, METHOD_NOT_ALLOWED);\n            response.headers().set(Exchange.CONTENT_TYPE, \"text/plain\");\n            response.headers().set(Exchange.CONTENT_LENGTH, 0);\n            ctx.writeAndFlush(response);\n            ctx.channel().close();\n            return;\n        }\n        // must include HOST header as required by HTTP 1.1\n        if (!request.headers().contains(HttpHeaders.Names.HOST)) {\n            HttpResponse response = new DefaultHttpResponse(HTTP_1_1, BAD_REQUEST);\n            //response.setChunked(false);\n            response.headers().set(Exchange.CONTENT_TYPE, \"text/plain\");\n            response.headers().set(Exchange.CONTENT_LENGTH, 0);\n            ctx.writeAndFlush(response);\n            ctx.channel().close();\n            return;\n        }\n\n        // is basic auth configured\n        NettyHttpSecurityConfiguration security = consumer.getEndpoint().getSecurityConfiguration();\n        if (security != null && security.isAuthenticate() && \"Basic\".equalsIgnoreCase(security.getConstraint())) {\n            String url = request.getUri();\n\n            // drop parameters from url\n            if (url.contains(\"?\")) {\n                url = ObjectHelper.before(url, \"?\");\n            }\n\n            // we need the relative path without the hostname and port\n            URI uri = new URI(request.getUri());\n            String target = uri.getPath();\n\n            // strip the starting endpoint path so the target is relative to the endpoint uri\n            String path = consumer.getConfiguration().getPath();\n            if (path != null && target.startsWith(path)) {\n                // need to match by lower case as we want to ignore case on context-path\n                path = path.toLowerCase(Locale.US);\n                String match = target.toLowerCase(Locale.US);\n                if (match.startsWith(path)) {\n                    target = target.substring(path.length());\n                }\n            }\n\n            // is it a restricted resource?\n            String roles;\n            if (security.getSecurityConstraint() != null) {\n                // if restricted returns null, then the resource is not restricted and we should not authenticate the user\n                roles = security.getSecurityConstraint().restricted(target);\n            } else {\n                // assume any roles is valid if no security constraint has been configured\n                roles = \"*\";\n            }\n            if (roles != null) {\n                // basic auth subject\n                HttpPrincipal principal = extractBasicAuthSubject(request);\n\n                // authenticate principal and check if the user is in role\n                Subject subject = null;\n                boolean inRole = true;\n                if (principal != null) {\n                    subject = authenticate(security.getSecurityAuthenticator(), security.getLoginDeniedLoggingLevel(), principal);\n                    if (subject != null) {\n                        String userRoles = security.getSecurityAuthenticator().getUserRoles(subject);\n                        inRole = matchesRoles(roles, userRoles);\n                    }\n                }\n\n                if (principal == null || subject == null || !inRole) {\n                    if (principal == null) {\n                        LOG.debug(\"Http Basic Auth required for resource: {}\", url);\n                    } else if (subject == null) {\n                        LOG.debug(\"Http Basic Auth not authorized for username: {}\", principal.getUsername());\n                    } else {\n                        LOG.debug(\"Http Basic Auth not in role for username: {}\", principal.getUsername());\n                    }\n                    // restricted resource, so send back 401 to require valid username/password\n                    HttpResponse response = new DefaultHttpResponse(HTTP_1_1, UNAUTHORIZED);\n                    response.headers().set(\"WWW-Authenticate\", \"Basic realm=\\\"\" + security.getRealm() + \"\\\"\");\n                    response.headers().set(Exchange.CONTENT_TYPE, \"text/plain\");\n                    response.headers().set(Exchange.CONTENT_LENGTH, 0);\n                    ctx.writeAndFlush(response);\n                    // close the channel\n                    ctx.channel().close();\n                    return;\n                } else {\n                    LOG.debug(\"Http Basic Auth authorized for username: {}\", principal.getUsername());\n                }\n            }\n        }\n\n        // let Camel process this message\n        super.channelRead0(ctx, msg);\n    }",
            "  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98 +\n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114 +\n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122 +\n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131 +\n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144 +\n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152 +\n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  ",
            "    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {\n        HttpRequest request = (HttpRequest) msg;\n\n        LOG.debug(\"Message received: {}\", request);\n\n        if (consumer.isSuspended()) {\n            // are we suspended?\n            LOG.debug(\"Consumer suspended, cannot service request {}\", request);\n            HttpResponse response = new DefaultHttpResponse(HTTP_1_1, SERVICE_UNAVAILABLE);\n            response.headers().set(Exchange.CONTENT_TYPE, \"text/plain\");\n            response.headers().set(Exchange.CONTENT_LENGTH, 0);\n            ctx.writeAndFlush(response);\n            ctx.channel().close();\n            return;\n        }\n\n        // if its an OPTIONS request then return which methods is allowed\n        boolean isRestrictedToOptions = consumer.getEndpoint().getHttpMethodRestrict() != null\n                && consumer.getEndpoint().getHttpMethodRestrict().contains(\"OPTIONS\");\n        if (\"OPTIONS\".equals(request.method().name()) && !isRestrictedToOptions) {\n            String s;\n            if (consumer.getEndpoint().getHttpMethodRestrict() != null) {\n                s = \"OPTIONS,\" + consumer.getEndpoint().getHttpMethodRestrict();\n            } else {\n                // allow them all\n                s = \"GET,HEAD,POST,PUT,DELETE,TRACE,OPTIONS,CONNECT,PATCH\";\n            }\n            HttpResponse response = new DefaultHttpResponse(HTTP_1_1, OK);\n            response.headers().set(\"Allow\", s);\n            response.headers().set(Exchange.CONTENT_TYPE, \"text/plain\");\n            response.headers().set(Exchange.CONTENT_LENGTH, 0);\n            ctx.writeAndFlush(response);\n            return;\n        }\n        if (consumer.getEndpoint().getHttpMethodRestrict() != null\n                && !consumer.getEndpoint().getHttpMethodRestrict().contains(request.method().name())) {\n            HttpResponse response = new DefaultHttpResponse(HTTP_1_1, METHOD_NOT_ALLOWED);\n            response.headers().set(Exchange.CONTENT_TYPE, \"text/plain\");\n            response.headers().set(Exchange.CONTENT_LENGTH, 0);\n            ctx.writeAndFlush(response);\n            ctx.channel().close();\n            return;\n        }\n        if (\"TRACE\".equals(request.method().name()) && !consumer.getEndpoint().isTraceEnabled()) {\n            HttpResponse response = new DefaultHttpResponse(HTTP_1_1, METHOD_NOT_ALLOWED);\n            response.headers().set(Exchange.CONTENT_TYPE, \"text/plain\");\n            response.headers().set(Exchange.CONTENT_LENGTH, 0);\n            ctx.writeAndFlush(response);\n            ctx.channel().close();\n            return;\n        }\n        // must include HOST header as required by HTTP 1.1\n        if (!request.headers().contains(HttpHeaderNames.HOST.toString())) {\n            HttpResponse response = new DefaultHttpResponse(HTTP_1_1, BAD_REQUEST);\n            //response.setChunked(false);\n            response.headers().set(Exchange.CONTENT_TYPE, \"text/plain\");\n            response.headers().set(Exchange.CONTENT_LENGTH, 0);\n            ctx.writeAndFlush(response);\n            ctx.channel().close();\n            return;\n        }\n\n        // is basic auth configured\n        NettyHttpSecurityConfiguration security = consumer.getEndpoint().getSecurityConfiguration();\n        if (security != null && security.isAuthenticate() && \"Basic\".equalsIgnoreCase(security.getConstraint())) {\n            String url = request.uri();\n\n            // drop parameters from url\n            if (url.contains(\"?\")) {\n                url = ObjectHelper.before(url, \"?\");\n            }\n\n            // we need the relative path without the hostname and port\n            URI uri = new URI(request.uri());\n            String target = uri.getPath();\n\n            // strip the starting endpoint path so the target is relative to the endpoint uri\n            String path = consumer.getConfiguration().getPath();\n            if (path != null && target.startsWith(path)) {\n                // need to match by lower case as we want to ignore case on context-path\n                path = path.toLowerCase(Locale.US);\n                String match = target.toLowerCase(Locale.US);\n                if (match.startsWith(path)) {\n                    target = target.substring(path.length());\n                }\n            }\n\n            // is it a restricted resource?\n            String roles;\n            if (security.getSecurityConstraint() != null) {\n                // if restricted returns null, then the resource is not restricted and we should not authenticate the user\n                roles = security.getSecurityConstraint().restricted(target);\n            } else {\n                // assume any roles is valid if no security constraint has been configured\n                roles = \"*\";\n            }\n            if (roles != null) {\n                // basic auth subject\n                HttpPrincipal principal = extractBasicAuthSubject(request);\n\n                // authenticate principal and check if the user is in role\n                Subject subject = null;\n                boolean inRole = true;\n                if (principal != null) {\n                    subject = authenticate(security.getSecurityAuthenticator(), security.getLoginDeniedLoggingLevel(), principal);\n                    if (subject != null) {\n                        String userRoles = security.getSecurityAuthenticator().getUserRoles(subject);\n                        inRole = matchesRoles(roles, userRoles);\n                    }\n                }\n\n                if (principal == null || subject == null || !inRole) {\n                    if (principal == null) {\n                        LOG.debug(\"Http Basic Auth required for resource: {}\", url);\n                    } else if (subject == null) {\n                        LOG.debug(\"Http Basic Auth not authorized for username: {}\", principal.getUsername());\n                    } else {\n                        LOG.debug(\"Http Basic Auth not in role for username: {}\", principal.getUsername());\n                    }\n                    // restricted resource, so send back 401 to require valid username/password\n                    HttpResponse response = new DefaultHttpResponse(HTTP_1_1, UNAUTHORIZED);\n                    response.headers().set(\"WWW-Authenticate\", \"Basic realm=\\\"\" + security.getRealm() + \"\\\"\");\n                    response.headers().set(Exchange.CONTENT_TYPE, \"text/plain\");\n                    response.headers().set(Exchange.CONTENT_LENGTH, 0);\n                    ctx.writeAndFlush(response);\n                    // close the channel\n                    ctx.channel().close();\n                    return;\n                } else {\n                    LOG.debug(\"Http Basic Auth authorized for username: {}\", principal.getUsername());\n                }\n            }\n        }\n\n        // let Camel process this message\n        super.channelRead0(ctx, msg);\n    }"
        ],
        [
            "NettyHttpHelper::populateNettyHttpOperationFailedException(Exchange,String,FullHttpResponse,int,boolean)",
            " 125  \n 126  \n 127 -\n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  ",
            "    public static Exception populateNettyHttpOperationFailedException(Exchange exchange, String url, FullHttpResponse response, int responseCode, boolean transferException) {\n        String uri = url;\n        String statusText = response.getStatus().reasonPhrase();\n\n        if (responseCode >= 300 && responseCode < 400) {\n            String redirectLocation = response.headers().get(\"location\");\n            if (redirectLocation != null) {\n                return new NettyHttpOperationFailedException(uri, responseCode, statusText, redirectLocation, response);\n            } else {\n                // no redirect location\n                return new NettyHttpOperationFailedException(uri, responseCode, statusText, null, response);\n            }\n        }\n\n        if (transferException) {\n            String contentType = response.headers().get(Exchange.CONTENT_TYPE);\n            if (NettyHttpConstants.CONTENT_TYPE_JAVA_SERIALIZED_OBJECT.equals(contentType)) {\n                // if the response was a serialized exception then use that\n                InputStream is = exchange.getContext().getTypeConverter().convertTo(InputStream.class, response);\n                if (is != null) {\n                    try {\n                        Object body = deserializeJavaObjectFromStream(is);\n                        if (body instanceof Exception) {\n                            return (Exception) body;\n                        }\n                    } catch (Exception e) {\n                        return e;\n                    } finally {\n                        IOHelper.close(is);\n                    }\n                }\n            }\n        }\n\n        // internal server error (error code 500)\n        return new NettyHttpOperationFailedException(uri, responseCode, statusText, null, response);\n    }",
            " 125  \n 126  \n 127 +\n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  ",
            "    public static Exception populateNettyHttpOperationFailedException(Exchange exchange, String url, FullHttpResponse response, int responseCode, boolean transferException) {\n        String uri = url;\n        String statusText = response.status().reasonPhrase();\n\n        if (responseCode >= 300 && responseCode < 400) {\n            String redirectLocation = response.headers().get(\"location\");\n            if (redirectLocation != null) {\n                return new NettyHttpOperationFailedException(uri, responseCode, statusText, redirectLocation, response);\n            } else {\n                // no redirect location\n                return new NettyHttpOperationFailedException(uri, responseCode, statusText, null, response);\n            }\n        }\n\n        if (transferException) {\n            String contentType = response.headers().get(Exchange.CONTENT_TYPE);\n            if (NettyHttpConstants.CONTENT_TYPE_JAVA_SERIALIZED_OBJECT.equals(contentType)) {\n                // if the response was a serialized exception then use that\n                InputStream is = exchange.getContext().getTypeConverter().convertTo(InputStream.class, response);\n                if (is != null) {\n                    try {\n                        Object body = deserializeJavaObjectFromStream(is);\n                        if (body instanceof Exception) {\n                            return (Exception) body;\n                        }\n                    } catch (Exception e) {\n                        return e;\n                    } finally {\n                        IOHelper.close(is);\n                    }\n                }\n            }\n        }\n\n        // internal server error (error code 500)\n        return new NettyHttpOperationFailedException(uri, responseCode, statusText, null, response);\n    }"
        ],
        [
            "DefaultNettyHttpBinding::populateCamelHeaders(FullHttpResponse,Map,Exchange,NettyHttpConfiguration)",
            " 287  \n 288  \n 289  \n 290  \n 291 -\n 292 -\n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309  \n 310  \n 311  ",
            "    @Override\n    public void populateCamelHeaders(FullHttpResponse response, Map<String, Object> headers, Exchange exchange, NettyHttpConfiguration configuration) throws Exception {\n        LOG.trace(\"populateCamelHeaders: {}\", response);\n\n        headers.put(Exchange.HTTP_RESPONSE_CODE, response.getStatus().code());\n        headers.put(Exchange.HTTP_RESPONSE_TEXT, response.getStatus().reasonPhrase());\n\n        for (String name : response.headers().names()) {\n            // mapping the content-type\n            if (name.toLowerCase().equals(\"content-type\")) {\n                name = Exchange.CONTENT_TYPE;\n            }\n            // add the headers one by one, and use the header filter strategy\n            List<String> values = response.headers().getAll(name);\n            Iterator<?> it = ObjectHelper.createIterator(values);\n            while (it.hasNext()) {\n                Object extracted = it.next();\n                LOG.trace(\"HTTP-header: {}\", extracted);\n                if (headerFilterStrategy != null\n                        && !headerFilterStrategy.applyFilterToExternalHeaders(name, extracted, exchange)) {\n                    NettyHttpHelper.appendHeader(headers, name, extracted);\n                }\n            }\n        }\n    }",
            " 289  \n 290  \n 291  \n 292  \n 293 +\n 294 +\n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  ",
            "    @Override\n    public void populateCamelHeaders(FullHttpResponse response, Map<String, Object> headers, Exchange exchange, NettyHttpConfiguration configuration) throws Exception {\n        LOG.trace(\"populateCamelHeaders: {}\", response);\n\n        headers.put(Exchange.HTTP_RESPONSE_CODE, response.status().code());\n        headers.put(Exchange.HTTP_RESPONSE_TEXT, response.status().reasonPhrase());\n\n        for (String name : response.headers().names()) {\n            // mapping the content-type\n            if (name.toLowerCase().equals(\"content-type\")) {\n                name = Exchange.CONTENT_TYPE;\n            }\n            // add the headers one by one, and use the header filter strategy\n            List<String> values = response.headers().getAll(name);\n            Iterator<?> it = ObjectHelper.createIterator(values);\n            while (it.hasNext()) {\n                Object extracted = it.next();\n                LOG.trace(\"HTTP-header: {}\", extracted);\n                if (headerFilterStrategy != null\n                        && !headerFilterStrategy.applyFilterToExternalHeaders(name, extracted, exchange)) {\n                    NettyHttpHelper.appendHeader(headers, name, extracted);\n                }\n            }\n        }\n    }"
        ],
        [
            "DefaultNettyHttpBinding::populateCamelHeaders(FullHttpRequest,Map,Exchange,NettyHttpConfiguration)",
            " 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111 -\n 112  \n 113 -\n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132 -\n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152 -\n 153 -\n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185 -\n 186 -\n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207 -\n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  ",
            "    @Override\n    public void populateCamelHeaders(FullHttpRequest request, Map<String, Object> headers, Exchange exchange, NettyHttpConfiguration configuration) throws Exception {\n        LOG.trace(\"populateCamelHeaders: {}\", request);\n\n        // NOTE: these headers is applied using the same logic as camel-http/camel-jetty to be consistent\n\n        headers.put(Exchange.HTTP_METHOD, request.getMethod().name());\n        // strip query parameters from the uri\n        String s = request.getUri();\n        if (s.contains(\"?\")) {\n            s = ObjectHelper.before(s, \"?\");\n        }\n\n        // we want the full path for the url, as the client may provide the url in the HTTP headers as absolute or relative, eg\n        //   /foo\n        //   http://servername/foo\n        String http = configuration.isSsl() ? \"https://\" : \"http://\";\n        if (!s.startsWith(http)) {\n            if (configuration.getPort() != 80) {\n                s = http + configuration.getHost() + \":\" + configuration.getPort() + s;\n            } else {\n                s = http + configuration.getHost() + s;\n            }\n        }\n\n        headers.put(Exchange.HTTP_URL, s);\n        // uri is without the host and port\n        URI uri = new URI(request.getUri());\n        // uri is path and query parameters\n        headers.put(Exchange.HTTP_URI, uri.getPath());\n        headers.put(Exchange.HTTP_QUERY, uri.getQuery());\n        headers.put(Exchange.HTTP_RAW_QUERY, uri.getRawQuery());\n\n        // strip the starting endpoint path so the path is relative to the endpoint uri\n        String path = uri.getRawPath();\n        if (configuration.getPath() != null) {\n            // need to match by lower case as we want to ignore case on context-path\n            String matchPath = path.toLowerCase(Locale.US);\n            String match = configuration.getPath() != null ? configuration.getPath().toLowerCase(Locale.US) : null;\n            if (match != null && matchPath.startsWith(match)) {\n                path = path.substring(configuration.getPath().length());\n            }\n        }\n        // keep the path uri using the case the request provided (do not convert to lower case)\n        headers.put(Exchange.HTTP_PATH, path);\n\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"HTTP-Method {}\", request.getMethod().name());\n            LOG.trace(\"HTTP-Uri {}\", request.getUri());\n        }\n\n        for (String name : request.headers().names()) {\n            // mapping the content-type\n            if (name.toLowerCase(Locale.US).equals(\"content-type\")) {\n                name = Exchange.CONTENT_TYPE;\n            }\n\n            if (name.toLowerCase(Locale.US).equals(\"authorization\")) {\n                String value = request.headers().get(name);\n                // store a special header that this request was authenticated using HTTP Basic\n                if (value != null && value.trim().startsWith(\"Basic\")) {\n                    NettyHttpHelper.appendHeader(headers, NettyHttpConstants.HTTP_AUTHENTICATION, \"Basic\");\n                }\n            }\n\n            // add the headers one by one, and use the header filter strategy\n            List<String> values = request.headers().getAll(name);\n            Iterator<?> it = ObjectHelper.createIterator(values);\n            while (it.hasNext()) {\n                Object extracted = it.next();\n                Object decoded = shouldUrlDecodeHeader(configuration, name, extracted, \"UTF-8\");\n                LOG.trace(\"HTTP-header: {}\", extracted);\n                if (headerFilterStrategy != null\n                        && !headerFilterStrategy.applyFilterToExternalHeaders(name, decoded, exchange)) {\n                    NettyHttpHelper.appendHeader(headers, name, decoded);\n                }\n            }\n        }\n\n        // add uri parameters as headers to the Camel message\n        if (request.getUri().contains(\"?\")) {\n            String query = ObjectHelper.after(request.getUri(), \"?\");\n            Map<String, Object> uriParameters = URISupport.parseQuery(query, false, true);\n\n            for (Map.Entry<String, Object> entry : uriParameters.entrySet()) {\n                String name = entry.getKey();\n                Object values = entry.getValue();\n                Iterator<?> it = ObjectHelper.createIterator(values);\n                while (it.hasNext()) {\n                    Object extracted = it.next();\n                    Object decoded = shouldUrlDecodeHeader(configuration, name, extracted, \"UTF-8\");\n                    LOG.trace(\"URI-Parameter: {}\", extracted);\n                    if (headerFilterStrategy != null\n                            && !headerFilterStrategy.applyFilterToExternalHeaders(name, decoded, exchange)) {\n                        NettyHttpHelper.appendHeader(headers, name, decoded);\n                    }\n                }\n            }\n        }\n\n        // if body is application/x-www-form-urlencoded then extract the body as query string and append as headers\n        // if it is a bridgeEndpoint we need to skip this part of work\n        if (request.getMethod().name().equals(\"POST\") && request.headers().get(Exchange.CONTENT_TYPE) != null\n                && request.headers().get(Exchange.CONTENT_TYPE).startsWith(NettyHttpConstants.CONTENT_TYPE_WWW_FORM_URLENCODED)\n                && !configuration.isBridgeEndpoint()) {\n\n            String charset = \"UTF-8\";\n\n            // Push POST form params into the headers to retain compatibility with DefaultHttpBinding\n            String body = null;\n            ByteBuf buffer = request.content();\n            try {\n                body = buffer.toString(Charset.forName(charset));\n            } finally {\n                buffer.release();\n            }\n            if (ObjectHelper.isNotEmpty(body)) {\n                for (String param : body.split(\"&\")) {\n                    String[] pair = param.split(\"=\", 2);\n                    if (pair.length == 2) {\n                        String name = shouldUrlDecodeHeader(configuration, \"\", pair[0], charset);\n                        String value = shouldUrlDecodeHeader(configuration, name, pair[1], charset);\n                        if (headerFilterStrategy != null\n                                && !headerFilterStrategy.applyFilterToExternalHeaders(name, value, exchange)) {\n                            NettyHttpHelper.appendHeader(headers, name, value);\n                        }\n                    } else {\n                        throw new IllegalArgumentException(\"Invalid parameter, expected to be a pair but was \" + param);\n                    }\n                }\n            }\n        }\n\n    }",
            " 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113 +\n 114  \n 115 +\n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134 +\n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154 +\n 155 +\n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187 +\n 188 +\n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209 +\n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  ",
            "    @Override\n    public void populateCamelHeaders(FullHttpRequest request, Map<String, Object> headers, Exchange exchange, NettyHttpConfiguration configuration) throws Exception {\n        LOG.trace(\"populateCamelHeaders: {}\", request);\n\n        // NOTE: these headers is applied using the same logic as camel-http/camel-jetty to be consistent\n\n        headers.put(Exchange.HTTP_METHOD, request.method().name());\n        // strip query parameters from the uri\n        String s = request.uri();\n        if (s.contains(\"?\")) {\n            s = ObjectHelper.before(s, \"?\");\n        }\n\n        // we want the full path for the url, as the client may provide the url in the HTTP headers as absolute or relative, eg\n        //   /foo\n        //   http://servername/foo\n        String http = configuration.isSsl() ? \"https://\" : \"http://\";\n        if (!s.startsWith(http)) {\n            if (configuration.getPort() != 80) {\n                s = http + configuration.getHost() + \":\" + configuration.getPort() + s;\n            } else {\n                s = http + configuration.getHost() + s;\n            }\n        }\n\n        headers.put(Exchange.HTTP_URL, s);\n        // uri is without the host and port\n        URI uri = new URI(request.uri());\n        // uri is path and query parameters\n        headers.put(Exchange.HTTP_URI, uri.getPath());\n        headers.put(Exchange.HTTP_QUERY, uri.getQuery());\n        headers.put(Exchange.HTTP_RAW_QUERY, uri.getRawQuery());\n\n        // strip the starting endpoint path so the path is relative to the endpoint uri\n        String path = uri.getRawPath();\n        if (configuration.getPath() != null) {\n            // need to match by lower case as we want to ignore case on context-path\n            String matchPath = path.toLowerCase(Locale.US);\n            String match = configuration.getPath() != null ? configuration.getPath().toLowerCase(Locale.US) : null;\n            if (match != null && matchPath.startsWith(match)) {\n                path = path.substring(configuration.getPath().length());\n            }\n        }\n        // keep the path uri using the case the request provided (do not convert to lower case)\n        headers.put(Exchange.HTTP_PATH, path);\n\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"HTTP-Method {}\", request.method().name());\n            LOG.trace(\"HTTP-Uri {}\", request.uri());\n        }\n\n        for (String name : request.headers().names()) {\n            // mapping the content-type\n            if (name.toLowerCase(Locale.US).equals(\"content-type\")) {\n                name = Exchange.CONTENT_TYPE;\n            }\n\n            if (name.toLowerCase(Locale.US).equals(\"authorization\")) {\n                String value = request.headers().get(name);\n                // store a special header that this request was authenticated using HTTP Basic\n                if (value != null && value.trim().startsWith(\"Basic\")) {\n                    NettyHttpHelper.appendHeader(headers, NettyHttpConstants.HTTP_AUTHENTICATION, \"Basic\");\n                }\n            }\n\n            // add the headers one by one, and use the header filter strategy\n            List<String> values = request.headers().getAll(name);\n            Iterator<?> it = ObjectHelper.createIterator(values);\n            while (it.hasNext()) {\n                Object extracted = it.next();\n                Object decoded = shouldUrlDecodeHeader(configuration, name, extracted, \"UTF-8\");\n                LOG.trace(\"HTTP-header: {}\", extracted);\n                if (headerFilterStrategy != null\n                        && !headerFilterStrategy.applyFilterToExternalHeaders(name, decoded, exchange)) {\n                    NettyHttpHelper.appendHeader(headers, name, decoded);\n                }\n            }\n        }\n\n        // add uri parameters as headers to the Camel message\n        if (request.uri().contains(\"?\")) {\n            String query = ObjectHelper.after(request.uri(), \"?\");\n            Map<String, Object> uriParameters = URISupport.parseQuery(query, false, true);\n\n            for (Map.Entry<String, Object> entry : uriParameters.entrySet()) {\n                String name = entry.getKey();\n                Object values = entry.getValue();\n                Iterator<?> it = ObjectHelper.createIterator(values);\n                while (it.hasNext()) {\n                    Object extracted = it.next();\n                    Object decoded = shouldUrlDecodeHeader(configuration, name, extracted, \"UTF-8\");\n                    LOG.trace(\"URI-Parameter: {}\", extracted);\n                    if (headerFilterStrategy != null\n                            && !headerFilterStrategy.applyFilterToExternalHeaders(name, decoded, exchange)) {\n                        NettyHttpHelper.appendHeader(headers, name, decoded);\n                    }\n                }\n            }\n        }\n\n        // if body is application/x-www-form-urlencoded then extract the body as query string and append as headers\n        // if it is a bridgeEndpoint we need to skip this part of work\n        if (request.method().name().equals(\"POST\") && request.headers().get(Exchange.CONTENT_TYPE) != null\n                && request.headers().get(Exchange.CONTENT_TYPE).startsWith(NettyHttpConstants.CONTENT_TYPE_WWW_FORM_URLENCODED)\n                && !configuration.isBridgeEndpoint()) {\n\n            String charset = \"UTF-8\";\n\n            // Push POST form params into the headers to retain compatibility with DefaultHttpBinding\n            String body = null;\n            ByteBuf buffer = request.content();\n            try {\n                body = buffer.toString(Charset.forName(charset));\n            } finally {\n                buffer.release();\n            }\n            if (ObjectHelper.isNotEmpty(body)) {\n                for (String param : body.split(\"&\")) {\n                    String[] pair = param.split(\"=\", 2);\n                    if (pair.length == 2) {\n                        String name = shouldUrlDecodeHeader(configuration, \"\", pair[0], charset);\n                        String value = shouldUrlDecodeHeader(configuration, name, pair[1], charset);\n                        if (headerFilterStrategy != null\n                                && !headerFilterStrategy.applyFilterToExternalHeaders(name, value, exchange)) {\n                            NettyHttpHelper.appendHeader(headers, name, value);\n                        }\n                    } else {\n                        throw new IllegalArgumentException(\"Invalid parameter, expected to be a pair but was \" + param);\n                    }\n                }\n            }\n        }\n\n    }"
        ],
        [
            "NettyHttpAccessHttpRequestAndResponseBeanTest::myTransformer(FullHttpRequest)",
            "  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71 -\n  72  \n  73  \n  74  ",
            "    /**\n     * We can use both a netty http request and response type for transformation\n     */\n    public static HttpResponse myTransformer(FullHttpRequest request) {\n        String in = request.content().toString(Charset.forName(\"UTF-8\"));\n        String reply = \"Bye \" + in;\n\n        request.content().release();\n\n        HttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK,\n                                                            NettyConverter.toByteBuffer(reply.getBytes()));\n        \n        response.headers().set(HttpHeaders.Names.CONTENT_LENGTH, reply.length());\n\n        return response;\n    }",
            "  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72 +\n  73  \n  74  \n  75  ",
            "    /**\n     * We can use both a netty http request and response type for transformation\n     */\n    public static HttpResponse myTransformer(FullHttpRequest request) {\n        String in = request.content().toString(Charset.forName(\"UTF-8\"));\n        String reply = \"Bye \" + in;\n\n        request.content().release();\n\n        HttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK,\n                                                            NettyConverter.toByteBuffer(reply.getBytes()));\n        \n        response.headers().set(HttpHeaderNames.CONTENT_LENGTH.toString(), reply.length());\n\n        return response;\n    }"
        ],
        [
            "NettyHttpProducerKeepAliveTest::testConnectionClosed()",
            "  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64 -\n  65  ",
            "    @Test\n    public void testConnectionClosed() throws Exception {\n        getMockEndpoint(\"mock:input\").expectedBodiesReceived(\"Hello World\");\n        Exchange ex = template.request(\"netty4-http:http://localhost:{{port}}/bar?keepAlive=false\", new Processor() {\n            @Override\n            public void process(Exchange exchange) throws Exception {\n                exchange.getIn().setBody(\"Hello World\");\n            }\n        });\n        \n        assertMockEndpointsSatisfied();\n        assertEquals(HttpHeaders.Values.CLOSE, ex.getOut().getHeader(HttpHeaders.Names.CONNECTION));\n    }",
            "  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66 +\n  67  ",
            "    @Test\n    public void testConnectionClosed() throws Exception {\n        getMockEndpoint(\"mock:input\").expectedBodiesReceived(\"Hello World\");\n        Exchange ex = template.request(\"netty4-http:http://localhost:{{port}}/bar?keepAlive=false\", new Processor() {\n            @Override\n            public void process(Exchange exchange) throws Exception {\n                exchange.getIn().setBody(\"Hello World\");\n            }\n        });\n        \n        assertMockEndpointsSatisfied();\n        assertEquals(HttpHeaderValues.CLOSE.toString(), ex.getOut().getHeader(HttpHeaderNames.CONNECTION.toString()));\n    }"
        ],
        [
            "NettyHttpProducer::NettyHttpProducerCallback::done(boolean)",
            " 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133 -\n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  ",
            "        @Override\n        public void done(boolean doneSync) {\n            try {\n                // only handle when we are done asynchronous as then the netty producer is done sending, and we have a response\n                if (!doneSync) {\n                    NettyHttpMessage nettyMessage = exchange.hasOut() ? exchange.getOut(NettyHttpMessage.class) : exchange.getIn(NettyHttpMessage.class);\n                    if (nettyMessage != null) {\n                        final FullHttpResponse response = nettyMessage.getHttpResponse();\n                        // Need to retain the ByteBuffer for producer to consumer\n                        if (response != null) {\n                            response.content().retain();\n\n                            // need to release the response when we are done\n                            exchange.addOnCompletion(new SynchronizationAdapter() {\n                                @Override\n                                public void onDone(Exchange exchange) {\n                                    if (response.refCnt() > 0) {\n                                        log.debug(\"Releasing Netty HttpResonse ByteBuf\");\n                                        ReferenceCountUtil.release(response);\n                                    }\n                                }\n                            });\n\n                            // the actual url is stored on the IN message in the getRequestBody method as its accessed on-demand\n                            String actualUrl = exchange.getIn().getHeader(Exchange.HTTP_URL, String.class);\n                            int code = response.getStatus() != null ? response.getStatus().code() : -1;\n                            log.debug(\"Http responseCode: {}\", code);\n\n                            // if there was a http error code then check if we should throw an exception\n                            boolean ok = NettyHttpHelper.isStatusCodeOk(code, configuration.getOkStatusCodeRange());\n                            if (!ok && getConfiguration().isThrowExceptionOnFailure()) {\n                                // operation failed so populate exception to throw\n                                Exception cause = NettyHttpHelper.populateNettyHttpOperationFailedException(exchange, actualUrl, response, code, getConfiguration().isTransferException());\n                                exchange.setException(cause);\n                            }\n                        }\n                    }\n                }\n            } finally {\n                // ensure we call the delegated callback\n                callback.done(doneSync);\n            }\n        }",
            " 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134 +\n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  ",
            "        @Override\n        public void done(boolean doneSync) {\n            try {\n                // only handle when we are done asynchronous as then the netty producer is done sending, and we have a response\n                if (!doneSync) {\n                    NettyHttpMessage nettyMessage = exchange.hasOut() ? exchange.getOut(NettyHttpMessage.class) : exchange.getIn(NettyHttpMessage.class);\n                    if (nettyMessage != null) {\n                        final FullHttpResponse response = nettyMessage.getHttpResponse();\n                        // Need to retain the ByteBuffer for producer to consumer\n                        if (response != null) {\n                            response.content().retain();\n\n                            // need to release the response when we are done\n                            exchange.addOnCompletion(new SynchronizationAdapter() {\n                                @Override\n                                public void onDone(Exchange exchange) {\n                                    if (response.refCnt() > 0) {\n                                        log.debug(\"Releasing Netty HttpResonse ByteBuf\");\n                                        ReferenceCountUtil.release(response);\n                                    }\n                                }\n                            });\n\n                            // the actual url is stored on the IN message in the getRequestBody method as its accessed on-demand\n                            String actualUrl = exchange.getIn().getHeader(Exchange.HTTP_URL, String.class);\n                            int code = response.status() != null ? response.status().code() : -1;\n                            log.debug(\"Http responseCode: {}\", code);\n\n                            // if there was a http error code then check if we should throw an exception\n                            boolean ok = NettyHttpHelper.isStatusCodeOk(code, configuration.getOkStatusCodeRange());\n                            if (!ok && getConfiguration().isThrowExceptionOnFailure()) {\n                                // operation failed so populate exception to throw\n                                Exception cause = NettyHttpHelper.populateNettyHttpOperationFailedException(exchange, actualUrl, response, code, getConfiguration().isTransferException());\n                                exchange.setException(cause);\n                            }\n                        }\n                    }\n                }\n            } finally {\n                // ensure we call the delegated callback\n                callback.done(doneSync);\n            }\n        }"
        ],
        [
            "NettyHttpProducerSimpleTest::testHttpSimpleExchange()",
            "  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54 -\n  55  \n  56  \n  57  \n  58  \n  59 -\n  60  \n  61  \n  62  ",
            "    @Test\n    public void testHttpSimpleExchange() throws Exception {\n        getMockEndpoint(\"mock:input\").expectedBodiesReceived(\"Hello World\");\n\n        Exchange out = template.request(\"netty4-http:http://localhost:{{port}}/foo\", new Processor() {\n            @Override\n            public void process(Exchange exchange) throws Exception {\n                exchange.getIn().setBody(\"Hello World\");\n            }\n        });\n        assertNotNull(out);\n        assertTrue(out.hasOut());\n\n        NettyHttpMessage response = out.getOut(NettyHttpMessage.class);\n        assertNotNull(response);\n        assertEquals(200, response.getHttpResponse().getStatus().code());\n\n        // we can also get the response as body\n        HttpResponse body = out.getOut().getBody(HttpResponse.class);\n        assertNotNull(body);\n        assertEquals(200, body.getStatus().code());\n\n        assertMockEndpointsSatisfied();\n    }",
            "  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54 +\n  55  \n  56  \n  57  \n  58  \n  59 +\n  60  \n  61  \n  62  ",
            "    @Test\n    public void testHttpSimpleExchange() throws Exception {\n        getMockEndpoint(\"mock:input\").expectedBodiesReceived(\"Hello World\");\n\n        Exchange out = template.request(\"netty4-http:http://localhost:{{port}}/foo\", new Processor() {\n            @Override\n            public void process(Exchange exchange) throws Exception {\n                exchange.getIn().setBody(\"Hello World\");\n            }\n        });\n        assertNotNull(out);\n        assertTrue(out.hasOut());\n\n        NettyHttpMessage response = out.getOut(NettyHttpMessage.class);\n        assertNotNull(response);\n        assertEquals(200, response.getHttpResponse().status().code());\n\n        // we can also get the response as body\n        HttpResponse body = out.getOut().getBody(HttpResponse.class);\n        assertNotNull(body);\n        assertEquals(200, body.status().code());\n\n        assertMockEndpointsSatisfied();\n    }"
        ],
        [
            "NettyHttpBindingUseRelativePathInPostTest::createRouteBuilder()",
            "  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64 -\n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  ",
            "    @Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            public void configure() throws Exception {\n                from(\"netty4-http:http://localhost:{{port}}/myapp/myservice\").process(new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        String body = exchange.getIn().getBody(String.class);\n\n                        // for unit testing make sure we got right message\n                        assertEquals(\"The body message is wrong\", \"b1=x&b2=y\", body);\n                        assertEquals(\"Get a wrong query parameter from the message header\", \"a\", exchange.getIn().getHeader(\"query1\"));\n                        assertEquals(\"Get a wrong query parameter from the message header\", \"b\", exchange.getIn().getHeader(\"query2\"));\n                        assertEquals(\"Get a wrong form parameter from the message header\", \"x\", exchange.getIn().getHeader(\"b1\"));\n                        assertEquals(\"Get a wrong form parameter from the message header\", \"y\", exchange.getIn().getHeader(\"b2\"));\n                        assertEquals(\"Get a wrong form parameter from the message header\", \"localhost:\" + getPort(), exchange.getIn().getHeader(\"host\"));\n\n                        NettyHttpMessage in = (NettyHttpMessage) exchange.getIn();\n                        FullHttpRequest request = in.getHttpRequest();\n                        assertEquals(\"Relative path not used in POST\", \"/myapp/myservice?query1=a&query2=b\", request.getUri());\n\n                        // send a response\n                        exchange.getOut().getHeaders().clear();\n                        exchange.getOut().setHeader(Exchange.CONTENT_TYPE, \"text/plain\");\n                        exchange.getOut().setBody(\"Request message is OK\");\n                    }\n                });\n            }\n        };\n    }",
            "  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64 +\n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  ",
            "    @Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            public void configure() throws Exception {\n                from(\"netty4-http:http://localhost:{{port}}/myapp/myservice\").process(new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        String body = exchange.getIn().getBody(String.class);\n\n                        // for unit testing make sure we got right message\n                        assertEquals(\"The body message is wrong\", \"b1=x&b2=y\", body);\n                        assertEquals(\"Get a wrong query parameter from the message header\", \"a\", exchange.getIn().getHeader(\"query1\"));\n                        assertEquals(\"Get a wrong query parameter from the message header\", \"b\", exchange.getIn().getHeader(\"query2\"));\n                        assertEquals(\"Get a wrong form parameter from the message header\", \"x\", exchange.getIn().getHeader(\"b1\"));\n                        assertEquals(\"Get a wrong form parameter from the message header\", \"y\", exchange.getIn().getHeader(\"b2\"));\n                        assertEquals(\"Get a wrong form parameter from the message header\", \"localhost:\" + getPort(), exchange.getIn().getHeader(\"host\"));\n\n                        NettyHttpMessage in = (NettyHttpMessage) exchange.getIn();\n                        FullHttpRequest request = in.getHttpRequest();\n                        assertEquals(\"Relative path not used in POST\", \"/myapp/myservice?query1=a&query2=b\", request.uri());\n\n                        // send a response\n                        exchange.getOut().getHeaders().clear();\n                        exchange.getOut().setHeader(Exchange.CONTENT_TYPE, \"text/plain\");\n                        exchange.getOut().setBody(\"Request message is OK\");\n                    }\n                });\n            }\n        };\n    }"
        ],
        [
            "HttpServerMultiplexChannelHandler::exceptionCaught(ChannelHandlerContext,Throwable)",
            " 124  \n 125  \n 126 -\n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  ",
            "    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n        Attribute<HttpServerChannelHandler> attr = ctx.attr(SERVER_HANDLER_KEY);\n        HttpServerChannelHandler handler = attr.get();\n        if (handler != null) {\n            handler.exceptionCaught(ctx, cause);\n        } else {\n            if (cause instanceof ClosedChannelException) {\n                // The channel is closed so we do nothing here\n                LOG.debug(\"Channel already closed. Ignoring this exception.\");\n                return;\n            } else {\n                // we cannot throw the exception here\n                LOG.warn(\"HttpServerChannelHandler is not found as attachment to handle exception, send 404 back to the client.\", cause);\n                // Now we just send 404 back to the client\n                HttpResponse response = new DefaultHttpResponse(HTTP_1_1, NOT_FOUND);\n                response.headers().set(Exchange.CONTENT_TYPE, \"text/plain\");\n                response.headers().set(Exchange.CONTENT_LENGTH, 0);\n                ctx.writeAndFlush(response);\n                ctx.close();\n            }\n        }\n    }",
            " 124  \n 125  \n 126 +\n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  ",
            "    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n        Attribute<HttpServerChannelHandler> attr = ctx.channel().attr(SERVER_HANDLER_KEY);\n        HttpServerChannelHandler handler = attr.get();\n        if (handler != null) {\n            handler.exceptionCaught(ctx, cause);\n        } else {\n            if (cause instanceof ClosedChannelException) {\n                // The channel is closed so we do nothing here\n                LOG.debug(\"Channel already closed. Ignoring this exception.\");\n                return;\n            } else {\n                // we cannot throw the exception here\n                LOG.warn(\"HttpServerChannelHandler is not found as attachment to handle exception, send 404 back to the client.\", cause);\n                // Now we just send 404 back to the client\n                HttpResponse response = new DefaultHttpResponse(HTTP_1_1, NOT_FOUND);\n                response.headers().set(Exchange.CONTENT_TYPE, \"text/plain\");\n                response.headers().set(Exchange.CONTENT_LENGTH, 0);\n                ctx.writeAndFlush(response);\n                ctx.close();\n            }\n        }\n    }"
        ],
        [
            "DefaultNettyHttpBinding::toNettyRequest(Message,String,NettyHttpConfiguration)",
            " 456  \n 457  \n 458  \n 459  \n 460  \n 461  \n 462  \n 463  \n 464  \n 465  \n 466  \n 467  \n 468  \n 469  \n 470  \n 471  \n 472  \n 473  \n 474  \n 475  \n 476  \n 477  \n 478  \n 479  \n 480  \n 481  \n 482  \n 483  \n 484  \n 485  \n 486  \n 487  \n 488  \n 489  \n 490  \n 491  \n 492  \n 493  \n 494  \n 495 -\n 496  \n 497  \n 498  \n 499  \n 500  \n 501  \n 502  \n 503  \n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512  \n 513  \n 514  \n 515  \n 516  \n 517  \n 518  \n 519  \n 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528  \n 529  \n 530  \n 531  \n 532  \n 533  \n 534  \n 535  \n 536  \n 537  \n 538  \n 539  \n 540  \n 541  \n 542  \n 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550 -\n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558 -\n 559  \n 560  \n 561  \n 562  \n 563 -\n 564  \n 565  \n 566  \n 567 -\n 568  \n 569 -\n 570  \n 571  \n 572 -\n 573  \n 574  \n 575  \n 576  ",
            "    @Override\n    public HttpRequest toNettyRequest(Message message, String uri, NettyHttpConfiguration configuration) throws Exception {\n        LOG.trace(\"toNettyRequest: {}\", message);\n\n        // the message body may already be a Netty HTTP response\n        if (message.getBody() instanceof HttpRequest) {\n            return (HttpRequest) message.getBody();\n        }\n\n        String uriForRequest = uri;\n        if (configuration.isUseRelativePath()) {\n            int indexOfPath = uri.indexOf((new URI(uri)).getPath());\n            if (indexOfPath > 0) {\n                uriForRequest = uri.substring(indexOfPath);               \n            } \n        }\n        \n        // just assume GET for now, we will later change that to the actual method to use\n        HttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, uriForRequest);\n        \n        Object body = message.getBody();\n        if (body != null) {\n            // support bodies as native Netty\n            ByteBuf buffer;\n            if (body instanceof ByteBuf) {\n                buffer = (ByteBuf) body;\n            } else {\n                // try to convert to buffer first\n                buffer = message.getBody(ByteBuf.class);\n                if (buffer == null) {\n                    // fallback to byte array as last resort\n                    byte[] data = message.getMandatoryBody(byte[].class);\n                    buffer = NettyConverter.toByteBuffer(data);\n                }\n            }\n            if (buffer != null) {\n                request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, uriForRequest, buffer);\n                int len = buffer.readableBytes();\n                // set content-length\n                request.headers().set(HttpHeaders.Names.CONTENT_LENGTH, len);\n                LOG.trace(\"Content-Length: {}\", len);\n            } else {\n                // we do not support this kind of body\n                throw new NoTypeConversionAvailableException(body, ByteBuf.class);\n            }\n        }\n\n        // update HTTP method accordingly as we know if we have a body or not\n        HttpMethod method = NettyHttpHelper.createMethod(message, body != null);\n        request.setMethod(method);\n        \n        TypeConverter tc = message.getExchange().getContext().getTypeConverter();\n\n        // if we bridge endpoint then we need to skip matching headers with the HTTP_QUERY to avoid sending\n        // duplicated headers to the receiver, so use this skipRequestHeaders as the list of headers to skip\n        Map<String, Object> skipRequestHeaders = null;\n        if (configuration.isBridgeEndpoint()) {\n            String queryString = message.getHeader(Exchange.HTTP_QUERY, String.class);\n            if (queryString != null) {\n                skipRequestHeaders = URISupport.parseQuery(queryString, false, true);\n            }\n            // Need to remove the Host key as it should be not used\n            message.getHeaders().remove(\"host\");\n        }\n\n        // append headers\n        // must use entrySet to ensure case of keys is preserved\n        for (Map.Entry<String, Object> entry : message.getHeaders().entrySet()) {\n            String key = entry.getKey();\n            Object value = entry.getValue();\n\n            // we should not add headers for the parameters in the uri if we bridge the endpoint\n            // as then we would duplicate headers on both the endpoint uri, and in HTTP headers as well\n            if (skipRequestHeaders != null && skipRequestHeaders.containsKey(key)) {\n                continue;\n            }\n\n            // use an iterator as there can be multiple values. (must not use a delimiter)\n            final Iterator<?> it = ObjectHelper.createIterator(value, null, true);\n            while (it.hasNext()) {\n                String headerValue = tc.convertTo(String.class, it.next());\n\n                if (headerValue != null && headerFilterStrategy != null\n                        && !headerFilterStrategy.applyFilterToCamelHeaders(key, headerValue, message.getExchange())) {\n                    LOG.trace(\"HTTP-Header: {}={}\", key, headerValue);\n                    request.headers().add(key, headerValue);\n                }\n            }\n        }\n\n        // set the content type in the response.\n        String contentType = MessageHelper.getContentType(message);\n        if (contentType != null) {\n            // set content-type\n            request.headers().set(HttpHeaders.Names.CONTENT_TYPE, contentType);\n            LOG.trace(\"Content-Type: {}\", contentType);\n        }\n\n        // must include HOST header as required by HTTP 1.1\n        // use URI as its faster than URL (no DNS lookup)\n        URI u = new URI(uri);\n        String hostHeader = u.getHost() + (u.getPort() == 80 ? \"\" : \":\" + u.getPort());\n        request.headers().set(HttpHeaders.Names.HOST, hostHeader);\n        LOG.trace(\"Host: {}\", hostHeader);\n\n        // configure connection to accordingly to keep alive configuration\n        // favor using the header from the message\n        String connection = message.getHeader(HttpHeaders.Names.CONNECTION, String.class);\n        if (connection == null) {\n            // fallback and use the keep alive from the configuration\n            if (configuration.isKeepAlive()) {\n                connection = HttpHeaders.Values.KEEP_ALIVE;\n            } else {\n                connection = HttpHeaders.Values.CLOSE;\n            }\n        }\n        request.headers().set(HttpHeaders.Names.CONNECTION, connection);\n        LOG.trace(\"Connection: {}\", connection);\n\n        return request;\n    }",
            " 458  \n 459  \n 460  \n 461  \n 462  \n 463  \n 464  \n 465  \n 466  \n 467  \n 468  \n 469  \n 470  \n 471  \n 472  \n 473  \n 474  \n 475  \n 476  \n 477  \n 478  \n 479  \n 480  \n 481  \n 482  \n 483  \n 484  \n 485  \n 486  \n 487  \n 488  \n 489  \n 490  \n 491  \n 492  \n 493  \n 494  \n 495  \n 496  \n 497 +\n 498  \n 499  \n 500  \n 501  \n 502  \n 503  \n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512  \n 513  \n 514  \n 515  \n 516  \n 517  \n 518  \n 519  \n 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528  \n 529  \n 530  \n 531  \n 532  \n 533  \n 534  \n 535  \n 536  \n 537  \n 538  \n 539  \n 540  \n 541  \n 542  \n 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552 +\n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560 +\n 561  \n 562  \n 563  \n 564  \n 565 +\n 566  \n 567  \n 568  \n 569 +\n 570  \n 571 +\n 572  \n 573  \n 574 +\n 575  \n 576  \n 577  \n 578  ",
            "    @Override\n    public HttpRequest toNettyRequest(Message message, String uri, NettyHttpConfiguration configuration) throws Exception {\n        LOG.trace(\"toNettyRequest: {}\", message);\n\n        // the message body may already be a Netty HTTP response\n        if (message.getBody() instanceof HttpRequest) {\n            return (HttpRequest) message.getBody();\n        }\n\n        String uriForRequest = uri;\n        if (configuration.isUseRelativePath()) {\n            int indexOfPath = uri.indexOf((new URI(uri)).getPath());\n            if (indexOfPath > 0) {\n                uriForRequest = uri.substring(indexOfPath);               \n            } \n        }\n        \n        // just assume GET for now, we will later change that to the actual method to use\n        HttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, uriForRequest);\n        \n        Object body = message.getBody();\n        if (body != null) {\n            // support bodies as native Netty\n            ByteBuf buffer;\n            if (body instanceof ByteBuf) {\n                buffer = (ByteBuf) body;\n            } else {\n                // try to convert to buffer first\n                buffer = message.getBody(ByteBuf.class);\n                if (buffer == null) {\n                    // fallback to byte array as last resort\n                    byte[] data = message.getMandatoryBody(byte[].class);\n                    buffer = NettyConverter.toByteBuffer(data);\n                }\n            }\n            if (buffer != null) {\n                request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, uriForRequest, buffer);\n                int len = buffer.readableBytes();\n                // set content-length\n                request.headers().set(HttpHeaderNames.CONTENT_LENGTH.toString(), len);\n                LOG.trace(\"Content-Length: {}\", len);\n            } else {\n                // we do not support this kind of body\n                throw new NoTypeConversionAvailableException(body, ByteBuf.class);\n            }\n        }\n\n        // update HTTP method accordingly as we know if we have a body or not\n        HttpMethod method = NettyHttpHelper.createMethod(message, body != null);\n        request.setMethod(method);\n        \n        TypeConverter tc = message.getExchange().getContext().getTypeConverter();\n\n        // if we bridge endpoint then we need to skip matching headers with the HTTP_QUERY to avoid sending\n        // duplicated headers to the receiver, so use this skipRequestHeaders as the list of headers to skip\n        Map<String, Object> skipRequestHeaders = null;\n        if (configuration.isBridgeEndpoint()) {\n            String queryString = message.getHeader(Exchange.HTTP_QUERY, String.class);\n            if (queryString != null) {\n                skipRequestHeaders = URISupport.parseQuery(queryString, false, true);\n            }\n            // Need to remove the Host key as it should be not used\n            message.getHeaders().remove(\"host\");\n        }\n\n        // append headers\n        // must use entrySet to ensure case of keys is preserved\n        for (Map.Entry<String, Object> entry : message.getHeaders().entrySet()) {\n            String key = entry.getKey();\n            Object value = entry.getValue();\n\n            // we should not add headers for the parameters in the uri if we bridge the endpoint\n            // as then we would duplicate headers on both the endpoint uri, and in HTTP headers as well\n            if (skipRequestHeaders != null && skipRequestHeaders.containsKey(key)) {\n                continue;\n            }\n\n            // use an iterator as there can be multiple values. (must not use a delimiter)\n            final Iterator<?> it = ObjectHelper.createIterator(value, null, true);\n            while (it.hasNext()) {\n                String headerValue = tc.convertTo(String.class, it.next());\n\n                if (headerValue != null && headerFilterStrategy != null\n                        && !headerFilterStrategy.applyFilterToCamelHeaders(key, headerValue, message.getExchange())) {\n                    LOG.trace(\"HTTP-Header: {}={}\", key, headerValue);\n                    request.headers().add(key, headerValue);\n                }\n            }\n        }\n\n        // set the content type in the response.\n        String contentType = MessageHelper.getContentType(message);\n        if (contentType != null) {\n            // set content-type\n            request.headers().set(HttpHeaderNames.CONTENT_TYPE.toString(), contentType);\n            LOG.trace(\"Content-Type: {}\", contentType);\n        }\n\n        // must include HOST header as required by HTTP 1.1\n        // use URI as its faster than URL (no DNS lookup)\n        URI u = new URI(uri);\n        String hostHeader = u.getHost() + (u.getPort() == 80 ? \"\" : \":\" + u.getPort());\n        request.headers().set(HttpHeaderNames.HOST.toString(), hostHeader);\n        LOG.trace(\"Host: {}\", hostHeader);\n\n        // configure connection to accordingly to keep alive configuration\n        // favor using the header from the message\n        String connection = message.getHeader(HttpHeaderNames.CONNECTION.toString(), String.class);\n        if (connection == null) {\n            // fallback and use the keep alive from the configuration\n            if (configuration.isKeepAlive()) {\n                connection = HttpHeaderValues.KEEP_ALIVE.toString();\n            } else {\n                connection = HttpHeaderValues.CLOSE.toString();\n            }\n        }\n        request.headers().set(HttpHeaderNames.CONNECTION.toString(), connection);\n        LOG.trace(\"Connection: {}\", connection);\n\n        return request;\n    }"
        ],
        [
            "NettyHttpGetWithParamTest::MyParamsProcessor::process(Exchange)",
            "  65  \n  66  \n  67  \n  68  \n  69 -\n  70  \n  71  \n  72  \n  73  \n  74  \n  75  ",
            "        public void process(Exchange exchange) throws Exception {\n            NettyHttpMessage message = exchange.getIn(NettyHttpMessage.class);\n            assertNotNull(message.getHttpRequest());\n\n            String uri = message.getHttpRequest().getUri();\n            assertTrue(uri.endsWith(\"one=uno&two=dos\"));\n\n            exchange.getOut().setBody(\"Bye World\");\n            exchange.getOut().setHeader(\"one\", \"eins\");\n            exchange.getOut().setHeader(\"two\", \"zwei\");\n        }",
            "  65  \n  66  \n  67  \n  68  \n  69 +\n  70  \n  71  \n  72  \n  73  \n  74  \n  75  ",
            "        public void process(Exchange exchange) throws Exception {\n            NettyHttpMessage message = exchange.getIn(NettyHttpMessage.class);\n            assertNotNull(message.getHttpRequest());\n\n            String uri = message.getHttpRequest().uri();\n            assertTrue(uri.endsWith(\"one=uno&two=dos\"));\n\n            exchange.getOut().setBody(\"Bye World\");\n            exchange.getOut().setHeader(\"one\", \"eins\");\n            exchange.getOut().setHeader(\"two\", \"zwei\");\n        }"
        ],
        [
            "DefaultNettyHttpBinding::toNettyResponse(Message,NettyHttpConfiguration)",
            " 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344  \n 345  \n 346  \n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398 -\n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  \n 423  \n 424  \n 425  \n 426  \n 427 -\n 428  \n 429  \n 430  \n 431  \n 432  \n 433 -\n 434  \n 435  \n 436 -\n 437  \n 438  \n 439  \n 440  \n 441 -\n 442  \n 443 -\n 444  \n 445  \n 446 -\n 447  \n 448 -\n 449  \n 450  \n 451  \n 452  \n 453  \n 454  ",
            "    @Override\n    public HttpResponse toNettyResponse(Message message, NettyHttpConfiguration configuration) throws Exception {\n        LOG.trace(\"toNettyResponse: {}\", message);\n\n        // the message body may already be a Netty HTTP response\n        if (message.getBody() instanceof HttpResponse) {\n            return (HttpResponse) message.getBody();\n        }\n\n        Object body = message.getBody();\n        Exception cause = message.getExchange().getException();\n        // support bodies as native Netty\n        ByteBuf buffer;\n        // the response code is 200 for OK and 500 for failed\n        boolean failed = message.getExchange().isFailed();\n        int defaultCode = failed ? 500 : 200;\n\n        int code = message.getHeader(Exchange.HTTP_RESPONSE_CODE, defaultCode, int.class);\n        \n        LOG.trace(\"HTTP Status Code: {}\", code);\n\n        // if there was an exception then use that as body\n        if (cause != null) {\n            if (configuration.isTransferException()) {\n                // we failed due an exception, and transfer it as java serialized object\n                ByteArrayOutputStream bos = new ByteArrayOutputStream();\n                ObjectOutputStream oos = new ObjectOutputStream(bos);\n                oos.writeObject(cause);\n                oos.flush();\n                IOHelper.close(oos, bos);\n\n                // the body should be the serialized java object of the exception\n                body = NettyConverter.toByteBuffer(bos.toByteArray());\n                // force content type to be serialized java object\n                message.setHeader(Exchange.CONTENT_TYPE, NettyHttpConstants.CONTENT_TYPE_JAVA_SERIALIZED_OBJECT);\n            } else {\n                // we failed due an exception so print it as plain text\n                StringWriter sw = new StringWriter();\n                PrintWriter pw = new PrintWriter(sw);\n                cause.printStackTrace(pw);\n\n                // the body should then be the stacktrace\n                body = NettyConverter.toByteBuffer(sw.toString().getBytes());\n                // force content type to be text/plain as that is what the stacktrace is\n                message.setHeader(Exchange.CONTENT_TYPE, \"text/plain\");\n            }\n\n            // and mark the exception as failure handled, as we handled it by returning it as the response\n            ExchangeHelper.setFailureHandled(message.getExchange());\n        }\n\n        if (body instanceof ByteBuf) {\n            buffer = (ByteBuf) body;\n        } else {\n            // try to convert to buffer first\n            buffer = message.getBody(ByteBuf.class);\n            if (buffer == null) {\n                // fallback to byte array as last resort\n                byte[] data = message.getBody(byte[].class);\n                if (data != null) {\n                    buffer = NettyConverter.toByteBuffer(data);\n                } else {\n                    // and if byte array fails then try String\n                    String str;\n                    if (body != null) {\n                        str = message.getMandatoryBody(String.class);\n                    } else {\n                        str = \"\";\n                    }\n                    buffer = NettyConverter.toByteBuffer(str.getBytes());\n                }\n            }\n        }\n        \n        HttpResponse response = null;\n        \n        if (buffer != null) {\n            response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.valueOf(code), buffer);\n            // We just need to reset the readerIndex this time\n            if (buffer.readerIndex() == buffer.writerIndex()) {\n                buffer.setIndex(0, buffer.writerIndex());\n            }\n            // TODO How to enable the chunk transport \n            int len = buffer.readableBytes();\n            // set content-length\n            response.headers().set(HttpHeaders.Names.CONTENT_LENGTH, len);\n            LOG.trace(\"Content-Length: {}\", len);\n        } else {\n            response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.valueOf(code));\n        }\n        \n        TypeConverter tc = message.getExchange().getContext().getTypeConverter();\n\n        // append headers\n        // must use entrySet to ensure case of keys is preserved\n        for (Map.Entry<String, Object> entry : message.getHeaders().entrySet()) {\n            String key = entry.getKey();\n            Object value = entry.getValue();\n            // use an iterator as there can be multiple values. (must not use a delimiter)\n            final Iterator<?> it = ObjectHelper.createIterator(value, null);\n            while (it.hasNext()) {\n                String headerValue = tc.convertTo(String.class, it.next());\n                if (headerValue != null && headerFilterStrategy != null\n                        && !headerFilterStrategy.applyFilterToCamelHeaders(key, headerValue, message.getExchange())) {\n                    LOG.trace(\"HTTP-Header: {}={}\", key, headerValue);\n                    response.headers().add(key, headerValue);\n                }\n            }\n        }\n\n        // set the content type in the response.\n        String contentType = MessageHelper.getContentType(message);\n        if (contentType != null) {\n            // set content-type\n            response.headers().set(HttpHeaders.Names.CONTENT_TYPE, contentType);\n            LOG.trace(\"Content-Type: {}\", contentType);\n        }\n\n        // configure connection to accordingly to keep alive configuration\n        // favor using the header from the message\n        String connection = message.getHeader(HttpHeaders.Names.CONNECTION, String.class);\n        // Read the connection header from the exchange property\n        if (connection == null) {\n            connection = message.getExchange().getProperty(HttpHeaders.Names.CONNECTION, String.class);\n        }\n        if (connection == null) {\n            // fallback and use the keep alive from the configuration\n            if (configuration.isKeepAlive()) {\n                connection = HttpHeaders.Values.KEEP_ALIVE;\n            } else {\n                connection = HttpHeaders.Values.CLOSE;\n            }\n        }\n        response.headers().set(HttpHeaders.Names.CONNECTION, connection);\n        // Just make sure we close the channel when the connection value is close\n        if (connection.equalsIgnoreCase(HttpHeaders.Values.CLOSE)) {\n            message.setHeader(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, true);\n        }\n        LOG.trace(\"Connection: {}\", connection);\n\n        return response;\n    }",
            " 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344  \n 345  \n 346  \n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400 +\n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  \n 423  \n 424  \n 425  \n 426  \n 427  \n 428  \n 429 +\n 430  \n 431  \n 432  \n 433  \n 434  \n 435 +\n 436  \n 437  \n 438 +\n 439  \n 440  \n 441  \n 442  \n 443 +\n 444  \n 445 +\n 446  \n 447  \n 448 +\n 449  \n 450 +\n 451  \n 452  \n 453  \n 454  \n 455  \n 456  ",
            "    @Override\n    public HttpResponse toNettyResponse(Message message, NettyHttpConfiguration configuration) throws Exception {\n        LOG.trace(\"toNettyResponse: {}\", message);\n\n        // the message body may already be a Netty HTTP response\n        if (message.getBody() instanceof HttpResponse) {\n            return (HttpResponse) message.getBody();\n        }\n\n        Object body = message.getBody();\n        Exception cause = message.getExchange().getException();\n        // support bodies as native Netty\n        ByteBuf buffer;\n        // the response code is 200 for OK and 500 for failed\n        boolean failed = message.getExchange().isFailed();\n        int defaultCode = failed ? 500 : 200;\n\n        int code = message.getHeader(Exchange.HTTP_RESPONSE_CODE, defaultCode, int.class);\n        \n        LOG.trace(\"HTTP Status Code: {}\", code);\n\n        // if there was an exception then use that as body\n        if (cause != null) {\n            if (configuration.isTransferException()) {\n                // we failed due an exception, and transfer it as java serialized object\n                ByteArrayOutputStream bos = new ByteArrayOutputStream();\n                ObjectOutputStream oos = new ObjectOutputStream(bos);\n                oos.writeObject(cause);\n                oos.flush();\n                IOHelper.close(oos, bos);\n\n                // the body should be the serialized java object of the exception\n                body = NettyConverter.toByteBuffer(bos.toByteArray());\n                // force content type to be serialized java object\n                message.setHeader(Exchange.CONTENT_TYPE, NettyHttpConstants.CONTENT_TYPE_JAVA_SERIALIZED_OBJECT);\n            } else {\n                // we failed due an exception so print it as plain text\n                StringWriter sw = new StringWriter();\n                PrintWriter pw = new PrintWriter(sw);\n                cause.printStackTrace(pw);\n\n                // the body should then be the stacktrace\n                body = NettyConverter.toByteBuffer(sw.toString().getBytes());\n                // force content type to be text/plain as that is what the stacktrace is\n                message.setHeader(Exchange.CONTENT_TYPE, \"text/plain\");\n            }\n\n            // and mark the exception as failure handled, as we handled it by returning it as the response\n            ExchangeHelper.setFailureHandled(message.getExchange());\n        }\n\n        if (body instanceof ByteBuf) {\n            buffer = (ByteBuf) body;\n        } else {\n            // try to convert to buffer first\n            buffer = message.getBody(ByteBuf.class);\n            if (buffer == null) {\n                // fallback to byte array as last resort\n                byte[] data = message.getBody(byte[].class);\n                if (data != null) {\n                    buffer = NettyConverter.toByteBuffer(data);\n                } else {\n                    // and if byte array fails then try String\n                    String str;\n                    if (body != null) {\n                        str = message.getMandatoryBody(String.class);\n                    } else {\n                        str = \"\";\n                    }\n                    buffer = NettyConverter.toByteBuffer(str.getBytes());\n                }\n            }\n        }\n        \n        HttpResponse response = null;\n        \n        if (buffer != null) {\n            response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.valueOf(code), buffer);\n            // We just need to reset the readerIndex this time\n            if (buffer.readerIndex() == buffer.writerIndex()) {\n                buffer.setIndex(0, buffer.writerIndex());\n            }\n            // TODO How to enable the chunk transport \n            int len = buffer.readableBytes();\n            // set content-length\n            response.headers().set(HttpHeaderNames.CONTENT_LENGTH.toString(), len);\n            LOG.trace(\"Content-Length: {}\", len);\n        } else {\n            response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.valueOf(code));\n        }\n        \n        TypeConverter tc = message.getExchange().getContext().getTypeConverter();\n\n        // append headers\n        // must use entrySet to ensure case of keys is preserved\n        for (Map.Entry<String, Object> entry : message.getHeaders().entrySet()) {\n            String key = entry.getKey();\n            Object value = entry.getValue();\n            // use an iterator as there can be multiple values. (must not use a delimiter)\n            final Iterator<?> it = ObjectHelper.createIterator(value, null);\n            while (it.hasNext()) {\n                String headerValue = tc.convertTo(String.class, it.next());\n                if (headerValue != null && headerFilterStrategy != null\n                        && !headerFilterStrategy.applyFilterToCamelHeaders(key, headerValue, message.getExchange())) {\n                    LOG.trace(\"HTTP-Header: {}={}\", key, headerValue);\n                    response.headers().add(key, headerValue);\n                }\n            }\n        }\n\n        // set the content type in the response.\n        String contentType = MessageHelper.getContentType(message);\n        if (contentType != null) {\n            // set content-type\n            response.headers().set(HttpHeaderNames.CONTENT_TYPE.toString(), contentType);\n            LOG.trace(\"Content-Type: {}\", contentType);\n        }\n\n        // configure connection to accordingly to keep alive configuration\n        // favor using the header from the message\n        String connection = message.getHeader(HttpHeaderNames.CONNECTION.toString(), String.class);\n        // Read the connection header from the exchange property\n        if (connection == null) {\n            connection = message.getExchange().getProperty(HttpHeaderNames.CONNECTION.toString(), String.class);\n        }\n        if (connection == null) {\n            // fallback and use the keep alive from the configuration\n            if (configuration.isKeepAlive()) {\n                connection = HttpHeaderValues.KEEP_ALIVE.toString();\n            } else {\n                connection = HttpHeaderValues.CLOSE.toString();\n            }\n        }\n        response.headers().set(HttpHeaderNames.CONNECTION.toString(), connection);\n        // Just make sure we close the channel when the connection value is close\n        if (connection.equalsIgnoreCase(HttpHeaderValues.CLOSE.toString())) {\n            message.setHeader(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, true);\n        }\n        LOG.trace(\"Connection: {}\", connection);\n\n        return response;\n    }"
        ],
        [
            "HttpClientChannelHandler::getResponseMessage(Exchange,ChannelHandlerContext,Object)",
            "  40  \n  41  \n  42  \n  43 -\n  44  \n  45  \n  46  \n  47  \n  48  \n  49  ",
            "    @Override\n    protected Message getResponseMessage(Exchange exchange, ChannelHandlerContext ctx, Object message) throws Exception {\n        FullHttpResponse response = (FullHttpResponse) message;\n        if (!HttpHeaders.isKeepAlive(response)) {\n            // just want to make sure we close the channel if the keepAlive is not true\n            exchange.setProperty(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, true);\n        }\n        // use the binding\n        return producer.getEndpoint().getNettyHttpBinding().toCamelMessage(response, exchange, producer.getConfiguration());\n    }",
            "  42  \n  43  \n  44  \n  45 +\n  46  \n  47  \n  48  \n  49  \n  50  \n  51  ",
            "    @Override\n    protected Message getResponseMessage(Exchange exchange, ChannelHandlerContext ctx, Object message) throws Exception {\n        FullHttpResponse response = (FullHttpResponse) message;\n        if (!HttpUtil.isKeepAlive(response)) {\n            // just want to make sure we close the channel if the keepAlive is not true\n            exchange.setProperty(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, true);\n        }\n        // use the binding\n        return producer.getEndpoint().getNettyHttpBinding().toCamelMessage(response, exchange, producer.getConfiguration());\n    }"
        ],
        [
            "NettyHttpBindingPreservePostFormUrlEncodedBodyTest::createRouteBuilder()",
            "  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64 -\n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  ",
            "    @Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            public void configure() throws Exception {\n                from(\"netty4-http:http://localhost:{{port}}/myapp/myservice\").process(new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        String body = exchange.getIn().getBody(String.class);\n\n                        // for unit testing make sure we got right message\n                        assertEquals(\"The body message is wrong\", \"b1=x&b2=y\", body);\n                        assertEquals(\"Get a wrong query parameter from the message header\", \"a\", exchange.getIn().getHeader(\"query1\"));\n                        assertEquals(\"Get a wrong query parameter from the message header\", \"b\", exchange.getIn().getHeader(\"query2\"));\n                        assertEquals(\"Get a wrong form parameter from the message header\", \"x\", exchange.getIn().getHeader(\"b1\"));\n                        assertEquals(\"Get a wrong form parameter from the message header\", \"y\", exchange.getIn().getHeader(\"b2\"));\n                        assertEquals(\"Get a wrong form parameter from the message header\", \"localhost:\" + getPort(), exchange.getIn().getHeader(\"host\"));\n\n                        NettyHttpMessage in = (NettyHttpMessage) exchange.getIn();\n                        FullHttpRequest request = in.getHttpRequest();\n                        assertNotEquals(\"Relative path should NOT be used in POST\", \"/myapp/myservice?query1=a&query2=b\", request.getUri());\n\n                        // send a response\n                        exchange.getOut().getHeaders().clear();\n                        exchange.getOut().setHeader(Exchange.CONTENT_TYPE, \"text/plain\");\n                        exchange.getOut().setBody(\"Request message is OK\");\n                    }\n                });\n            }\n        };\n    }",
            "  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64 +\n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  ",
            "    @Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            public void configure() throws Exception {\n                from(\"netty4-http:http://localhost:{{port}}/myapp/myservice\").process(new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        String body = exchange.getIn().getBody(String.class);\n\n                        // for unit testing make sure we got right message\n                        assertEquals(\"The body message is wrong\", \"b1=x&b2=y\", body);\n                        assertEquals(\"Get a wrong query parameter from the message header\", \"a\", exchange.getIn().getHeader(\"query1\"));\n                        assertEquals(\"Get a wrong query parameter from the message header\", \"b\", exchange.getIn().getHeader(\"query2\"));\n                        assertEquals(\"Get a wrong form parameter from the message header\", \"x\", exchange.getIn().getHeader(\"b1\"));\n                        assertEquals(\"Get a wrong form parameter from the message header\", \"y\", exchange.getIn().getHeader(\"b2\"));\n                        assertEquals(\"Get a wrong form parameter from the message header\", \"localhost:\" + getPort(), exchange.getIn().getHeader(\"host\"));\n\n                        NettyHttpMessage in = (NettyHttpMessage) exchange.getIn();\n                        FullHttpRequest request = in.getHttpRequest();\n                        assertNotEquals(\"Relative path should NOT be used in POST\", \"/myapp/myservice?query1=a&query2=b\", request.uri());\n\n                        // send a response\n                        exchange.getOut().getHeaders().clear();\n                        exchange.getOut().setHeader(Exchange.CONTENT_TYPE, \"text/plain\");\n                        exchange.getOut().setBody(\"Request message is OK\");\n                    }\n                });\n            }\n        };\n    }"
        ]
    ],
    "b2bb23a2d76395d5f139c6d21faa8c100fa4e8c7": [
        [
            "RestProducer::prepareExchange(Exchange)",
            " 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201 -\n 202 -\n 203 -\n 204 -\n 205 -\n 206  \n 207  \n 208  \n 209  \n 210  ",
            "    protected void prepareExchange(Exchange exchange) throws Exception {\n        boolean hasPath = false;\n\n        // uri template with path parameters resolved\n        // uri template may be optional and the user have entered the uri template in the path instead\n        String resolvedUriTemplate = getEndpoint().getUriTemplate() != null ? getEndpoint().getUriTemplate() : getEndpoint().getPath();\n\n        if (prepareUriTemplate) {\n            if (resolvedUriTemplate.contains(\"{\")) {\n                // resolve template and replace {key} with the values form the exchange\n                // each {} is a parameter (url templating)\n                String[] arr = resolvedUriTemplate.split(\"\\\\/\");\n                CollectionStringBuffer csb = new CollectionStringBuffer(\"/\");\n                for (String a : arr) {\n                    if (a.startsWith(\"{\") && a.endsWith(\"}\")) {\n                        String key = a.substring(1, a.length() - 1);\n                        String value = exchange.getIn().getHeader(key, String.class);\n                        if (value != null) {\n                            hasPath = true;\n                            csb.append(value);\n                        } else {\n                            csb.append(a);\n                        }\n                    } else {\n                        csb.append(a);\n                    }\n                }\n                resolvedUriTemplate = csb.toString();\n            }\n        }\n\n        // resolve uri parameters\n        String query = getEndpoint().getQueryParameters();\n        if (query != null) {\n            Map<String, Object> params = URISupport.parseQuery(query);\n            for (Map.Entry<String, Object> entry : params.entrySet()) {\n                Object v = entry.getValue();\n                if (v != null) {\n                    String a = v.toString();\n                    // decode the key as { may be decoded to %NN\n                    a = URLDecoder.decode(a, \"UTF-8\");\n                    if (a.startsWith(\"{\") && a.endsWith(\"}\")) {\n                        String key = a.substring(1, a.length() - 1);\n                        String value = exchange.getIn().getHeader(key, String.class);\n                        if (value != null) {\n                            params.put(key, value);\n                        } else {\n                            params.put(entry.getKey(), entry.getValue());\n                        }\n                    } else {\n                        params.put(entry.getKey(), entry.getValue());\n                    }\n                }\n            }\n            query = URISupport.createQueryString(params);\n        }\n\n        if (query != null) {\n            // the query parameters for the rest call to be used\n            exchange.getIn().setHeader(Exchange.REST_HTTP_QUERY, query);\n        }\n\n        if (hasPath) {\n            String host = getEndpoint().getHost();\n            String basePath = getEndpoint().getUriTemplate() != null ? getEndpoint().getPath() :  null;\n            basePath = FileUtil.stripLeadingSeparator(basePath);\n            resolvedUriTemplate = FileUtil.stripLeadingSeparator(resolvedUriTemplate);\n            // if so us a header for the dynamic uri template so we reuse same endpoint but the header overrides the actual url to use\n            String overrideUri;\n            if (basePath != null) {\n                overrideUri = String.format(\"%s/%s/%s\", host, basePath, resolvedUriTemplate);\n            } else {\n                overrideUri = String.format(\"%s/%s\", host, resolvedUriTemplate);\n            }\n            // the http uri for the rest call to be used\n            exchange.getIn().setHeader(Exchange.REST_HTTP_URI, overrideUri);\n        }\n    }",
            " 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202 +\n 203 +\n 204 +\n 205 +\n 206 +\n 207 +\n 208  \n 209  \n 210  \n 211  \n 212  ",
            "    protected void prepareExchange(Exchange exchange) throws Exception {\n        boolean hasPath = false;\n\n        // uri template with path parameters resolved\n        // uri template may be optional and the user have entered the uri template in the path instead\n        String resolvedUriTemplate = getEndpoint().getUriTemplate() != null ? getEndpoint().getUriTemplate() : getEndpoint().getPath();\n\n        if (prepareUriTemplate) {\n            if (resolvedUriTemplate.contains(\"{\")) {\n                // resolve template and replace {key} with the values form the exchange\n                // each {} is a parameter (url templating)\n                String[] arr = resolvedUriTemplate.split(\"\\\\/\");\n                CollectionStringBuffer csb = new CollectionStringBuffer(\"/\");\n                for (String a : arr) {\n                    if (a.startsWith(\"{\") && a.endsWith(\"}\")) {\n                        String key = a.substring(1, a.length() - 1);\n                        String value = exchange.getIn().getHeader(key, String.class);\n                        if (value != null) {\n                            hasPath = true;\n                            csb.append(value);\n                        } else {\n                            csb.append(a);\n                        }\n                    } else {\n                        csb.append(a);\n                    }\n                }\n                resolvedUriTemplate = csb.toString();\n            }\n        }\n\n        // resolve uri parameters\n        String query = getEndpoint().getQueryParameters();\n        if (query != null) {\n            Map<String, Object> params = URISupport.parseQuery(query);\n            for (Map.Entry<String, Object> entry : params.entrySet()) {\n                Object v = entry.getValue();\n                if (v != null) {\n                    String a = v.toString();\n                    // decode the key as { may be decoded to %NN\n                    a = URLDecoder.decode(a, \"UTF-8\");\n                    if (a.startsWith(\"{\") && a.endsWith(\"}\")) {\n                        String key = a.substring(1, a.length() - 1);\n                        String value = exchange.getIn().getHeader(key, String.class);\n                        if (value != null) {\n                            params.put(key, value);\n                        } else {\n                            params.put(entry.getKey(), entry.getValue());\n                        }\n                    } else {\n                        params.put(entry.getKey(), entry.getValue());\n                    }\n                }\n            }\n            query = URISupport.createQueryString(params);\n        }\n\n        if (query != null) {\n            // the query parameters for the rest call to be used\n            exchange.getIn().setHeader(Exchange.REST_HTTP_QUERY, query);\n        }\n\n        if (hasPath) {\n            String host = getEndpoint().getHost();\n            String basePath = getEndpoint().getUriTemplate() != null ? getEndpoint().getPath() :  null;\n            basePath = FileUtil.stripLeadingSeparator(basePath);\n            resolvedUriTemplate = FileUtil.stripLeadingSeparator(resolvedUriTemplate);\n            // if so us a header for the dynamic uri template so we reuse same endpoint but the header overrides the actual url to use\n            String overrideUri = host;\n            if (!ObjectHelper.isEmpty(basePath)) {\n                overrideUri += \"/\" + basePath;\n            }\n            if (!ObjectHelper.isEmpty(resolvedUriTemplate)) {\n                overrideUri += \"/\" + resolvedUriTemplate;\n            }\n            // the http uri for the rest call to be used\n            exchange.getIn().setHeader(Exchange.REST_HTTP_URI, overrideUri);\n        }\n    }"
        ],
        [
            "HttpComponent::createProducer(CamelContext,String,String,String,String,String,String,String,Map)",
            " 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299 -\n 300 -\n 301 -\n 302 -\n 303 -\n 304 -\n 305 -\n 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  ",
            "    @Override\n    public Producer createProducer(CamelContext camelContext, String host,\n                                   String verb, String basePath, String uriTemplate, String queryParameters,\n                                   String consumes, String produces, Map<String, Object> parameters) throws Exception {\n\n        // avoid leading slash\n        basePath = FileUtil.stripLeadingSeparator(basePath);\n        uriTemplate = FileUtil.stripLeadingSeparator(uriTemplate);\n\n        // get the endpoint\n        String url;\n        if (uriTemplate != null) {\n            // http is already prefixed in base path\n            url = String.format(\"%s/%s/%s\", host, basePath, uriTemplate);\n        } else {\n            // http is already prefixed in base path\n            url = String.format(\"%s/%s\", host, basePath);\n        }\n\n        HttpEndpoint endpoint = camelContext.getEndpoint(url, HttpEndpoint.class);\n        if (parameters != null && !parameters.isEmpty()) {\n            setProperties(camelContext, endpoint, parameters);\n        }\n        String path = uriTemplate != null ? uriTemplate : basePath;\n        endpoint.setHeaderFilterStrategy(new HttpRestHeaderFilterStrategy(path, queryParameters));\n\n        // the endpoint must be started before creating the producer\n        ServiceHelper.startService(endpoint);\n\n        return endpoint.createProducer();\n    }",
            " 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299 +\n 300 +\n 301 +\n 302 +\n 303 +\n 304 +\n 305  \n 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  ",
            "    @Override\n    public Producer createProducer(CamelContext camelContext, String host,\n                                   String verb, String basePath, String uriTemplate, String queryParameters,\n                                   String consumes, String produces, Map<String, Object> parameters) throws Exception {\n\n        // avoid leading slash\n        basePath = FileUtil.stripLeadingSeparator(basePath);\n        uriTemplate = FileUtil.stripLeadingSeparator(uriTemplate);\n\n        // get the endpoint\n        String url = host;\n        if (!ObjectHelper.isEmpty(basePath)) {\n            url += \"/\" + basePath;\n        }\n        if (!ObjectHelper.isEmpty(uriTemplate)) {\n            url += \"/\" + uriTemplate;\n        }\n\n        HttpEndpoint endpoint = camelContext.getEndpoint(url, HttpEndpoint.class);\n        if (parameters != null && !parameters.isEmpty()) {\n            setProperties(camelContext, endpoint, parameters);\n        }\n        String path = uriTemplate != null ? uriTemplate : basePath;\n        endpoint.setHeaderFilterStrategy(new HttpRestHeaderFilterStrategy(path, queryParameters));\n\n        // the endpoint must be started before creating the producer\n        ServiceHelper.startService(endpoint);\n\n        return endpoint.createProducer();\n    }"
        ],
        [
            "NettyHttpComponent::createProducer(CamelContext,String,String,String,String,String,String,String,Map)",
            " 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405 -\n 406 -\n 407 -\n 408 -\n 409 -\n 410  \n 411 -\n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  \n 423  \n 424  ",
            "    @Override\n    public Producer createProducer(CamelContext camelContext, String host,\n                                   String verb, String basePath, String uriTemplate, String queryParameters,\n                                   String consumes, String produces, Map<String, Object> parameters) throws Exception {\n\n        // avoid leading slash\n        basePath = FileUtil.stripLeadingSeparator(basePath);\n        uriTemplate = FileUtil.stripLeadingSeparator(uriTemplate);\n\n        // get the endpoint\n        String url;\n        if (uriTemplate != null) {\n            url = String.format(\"netty4-http:%s/%s/%s\", host, basePath, uriTemplate);\n        } else {\n            url = String.format(\"netty4-http:%s/%s\", host, basePath);\n        }\n\n\n        NettyHttpEndpoint endpoint = camelContext.getEndpoint(url, NettyHttpEndpoint.class);\n        if (parameters != null && !parameters.isEmpty()) {\n            setProperties(camelContext, endpoint, parameters);\n        }\n        String path = uriTemplate != null ? uriTemplate : basePath;\n        endpoint.setHeaderFilterStrategy(new NettyHttpRestHeaderFilterStrategy(path, queryParameters));\n\n        // the endpoint must be started before creating the producer\n        ServiceHelper.startService(endpoint);\n\n        return endpoint.createProducer();\n    }",
            " 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405 +\n 406 +\n 407 +\n 408 +\n 409 +\n 410 +\n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  \n 423  \n 424  ",
            "    @Override\n    public Producer createProducer(CamelContext camelContext, String host,\n                                   String verb, String basePath, String uriTemplate, String queryParameters,\n                                   String consumes, String produces, Map<String, Object> parameters) throws Exception {\n\n        // avoid leading slash\n        basePath = FileUtil.stripLeadingSeparator(basePath);\n        uriTemplate = FileUtil.stripLeadingSeparator(uriTemplate);\n\n        // get the endpoint\n        String url = \"netty4-http:\" + host;\n        if (!ObjectHelper.isEmpty(basePath)) {\n            url += \"/\" + basePath;\n        }\n        if (!ObjectHelper.isEmpty(uriTemplate)) {\n            url += \"/\" + uriTemplate;\n        }\n\n        NettyHttpEndpoint endpoint = camelContext.getEndpoint(url, NettyHttpEndpoint.class);\n        if (parameters != null && !parameters.isEmpty()) {\n            setProperties(camelContext, endpoint, parameters);\n        }\n        String path = uriTemplate != null ? uriTemplate : basePath;\n        endpoint.setHeaderFilterStrategy(new NettyHttpRestHeaderFilterStrategy(path, queryParameters));\n\n        // the endpoint must be started before creating the producer\n        ServiceHelper.startService(endpoint);\n\n        return endpoint.createProducer();\n    }"
        ],
        [
            "RestletComponent::createProducer(CamelContext,String,String,String,String,String,String,String,Map)",
            " 835  \n 836  \n 837  \n 838  \n 839  \n 840  \n 841  \n 842  \n 843  \n 844  \n 845  \n 846  \n 847  \n 848 -\n 849 -\n 850 -\n 851 -\n 852 -\n 853  \n 854  \n 855  \n 856  \n 857  \n 858  \n 859  \n 860  \n 861  \n 862  \n 863  \n 864  ",
            "    @Override\n    public Producer createProducer(CamelContext camelContext, String host,\n                                   String verb, String basePath, String uriTemplate, String queryParameters,\n                                   String consumes, String produces, Map<String, Object> parameters) throws Exception {\n\n        // avoid leading slash\n        basePath = FileUtil.stripLeadingSeparator(basePath);\n        uriTemplate = FileUtil.stripLeadingSeparator(uriTemplate);\n\n        // restlet method must be in upper-case\n        String restletMethod = verb.toUpperCase(Locale.US);\n\n        // get the endpoint\n        String url;\n        if (uriTemplate != null) {\n            url = String.format(\"restlet:%s/%s/%s?restletMethods=%s\", host, basePath, uriTemplate, restletMethod);\n        } else {\n            url = String.format(\"restlet:%s/%s?restletMethods=%s\", host, basePath, restletMethod);\n        }\n\n        RestletEndpoint endpoint = camelContext.getEndpoint(url, RestletEndpoint.class);\n        if (parameters != null && !parameters.isEmpty()) {\n            setProperties(camelContext, endpoint, parameters);\n        }\n\n        // the endpoint must be started before creating the producer\n        ServiceHelper.startService(endpoint);\n\n        return endpoint.createProducer();\n    }",
            " 835  \n 836  \n 837  \n 838  \n 839  \n 840  \n 841  \n 842  \n 843  \n 844  \n 845  \n 846  \n 847  \n 848 +\n 849 +\n 850 +\n 851 +\n 852 +\n 853 +\n 854  \n 855 +\n 856  \n 857  \n 858  \n 859  \n 860  \n 861  \n 862  \n 863  \n 864  \n 865  \n 866  ",
            "    @Override\n    public Producer createProducer(CamelContext camelContext, String host,\n                                   String verb, String basePath, String uriTemplate, String queryParameters,\n                                   String consumes, String produces, Map<String, Object> parameters) throws Exception {\n\n        // avoid leading slash\n        basePath = FileUtil.stripLeadingSeparator(basePath);\n        uriTemplate = FileUtil.stripLeadingSeparator(uriTemplate);\n\n        // restlet method must be in upper-case\n        String restletMethod = verb.toUpperCase(Locale.US);\n\n        // get the endpoint\n        String url = \"restlet:\" + host;\n        if (!ObjectHelper.isEmpty(basePath)) {\n            url += \"/\" + basePath;\n        }\n        if (!ObjectHelper.isEmpty(uriTemplate)) {\n            url += \"/\" + uriTemplate;\n        }\n        url += \"?restletMethods=\" + restletMethod;\n\n        RestletEndpoint endpoint = camelContext.getEndpoint(url, RestletEndpoint.class);\n        if (parameters != null && !parameters.isEmpty()) {\n            setProperties(camelContext, endpoint, parameters);\n        }\n\n        // the endpoint must be started before creating the producer\n        ServiceHelper.startService(endpoint);\n\n        return endpoint.createProducer();\n    }"
        ],
        [
            "UndertowComponent::createProducer(CamelContext,String,String,String,String,String,String,String,Map)",
            " 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238 -\n 239 -\n 240 -\n 241 -\n 242 -\n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  ",
            "    @Override\n    public Producer createProducer(CamelContext camelContext, String host,\n                                   String verb, String basePath, String uriTemplate, String queryParameters,\n                                   String consumes, String produces, Map<String, Object> parameters) throws Exception {\n\n        // avoid leading slash\n        basePath = FileUtil.stripLeadingSeparator(basePath);\n        uriTemplate = FileUtil.stripLeadingSeparator(uriTemplate);\n\n        // get the endpoint\n        String url;\n        if (uriTemplate != null) {\n            url = String.format(\"undertow:%s/%s/%s\", host, basePath, uriTemplate);\n        } else {\n            url = String.format(\"undertow:%s/%s\", host, basePath);\n        }\n\n        UndertowEndpoint endpoint = camelContext.getEndpoint(url, UndertowEndpoint.class);\n        if (parameters != null && !parameters.isEmpty()) {\n            setProperties(camelContext, endpoint, parameters);\n        }\n        String path = uriTemplate != null ? uriTemplate : basePath;\n        endpoint.setHeaderFilterStrategy(new UndertowRestHeaderFilterStrategy(path, queryParameters));\n\n        // the endpoint must be started before creating the producer\n        ServiceHelper.startService(endpoint);\n\n        return endpoint.createProducer();\n    }",
            " 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238 +\n 239 +\n 240 +\n 241 +\n 242 +\n 243 +\n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  ",
            "    @Override\n    public Producer createProducer(CamelContext camelContext, String host,\n                                   String verb, String basePath, String uriTemplate, String queryParameters,\n                                   String consumes, String produces, Map<String, Object> parameters) throws Exception {\n\n        // avoid leading slash\n        basePath = FileUtil.stripLeadingSeparator(basePath);\n        uriTemplate = FileUtil.stripLeadingSeparator(uriTemplate);\n\n        // get the endpoint\n        String url = \"undertow:\" + host;\n        if (!ObjectHelper.isEmpty(basePath)) {\n            url += \"/\" + basePath;\n        }\n        if (!ObjectHelper.isEmpty(uriTemplate)) {\n            url += \"/\" + uriTemplate;\n        }\n\n        UndertowEndpoint endpoint = camelContext.getEndpoint(url, UndertowEndpoint.class);\n        if (parameters != null && !parameters.isEmpty()) {\n            setProperties(camelContext, endpoint, parameters);\n        }\n        String path = uriTemplate != null ? uriTemplate : basePath;\n        endpoint.setHeaderFilterStrategy(new UndertowRestHeaderFilterStrategy(path, queryParameters));\n\n        // the endpoint must be started before creating the producer\n        ServiceHelper.startService(endpoint);\n\n        return endpoint.createProducer();\n    }"
        ],
        [
            "JettyHttpComponent::createProducer(CamelContext,String,String,String,String,String,String,String,Map)",
            "1178  \n1179  \n1180  \n1181  \n1182  \n1183  \n1184  \n1185  \n1186  \n1187  \n1188 -\n1189 -\n1190 -\n1191 -\n1192 -\n1193  \n1194  \n1195  \n1196  \n1197  \n1198  \n1199  \n1200  \n1201  \n1202  \n1203  ",
            "    @Override\n    public Producer createProducer(CamelContext camelContext, String host,\n                                   String verb, String basePath, String uriTemplate, String queryParameters,\n                                   String consumes, String produces, Map<String, Object> parameters) throws Exception {\n\n        // avoid leading slash\n        basePath = FileUtil.stripLeadingSeparator(basePath);\n        uriTemplate = FileUtil.stripLeadingSeparator(uriTemplate);\n\n        // get the endpoint\n        String url;\n        if (uriTemplate != null) {\n            url = String.format(\"jetty:%s/%s/%s\", host, basePath, uriTemplate);\n        } else {\n            url = String.format(\"jetty:%s/%s\", host, basePath);\n        }\n\n        JettyHttpEndpoint endpoint = camelContext.getEndpoint(url, JettyHttpEndpoint.class);\n        if (parameters != null && !parameters.isEmpty()) {\n            setProperties(camelContext, endpoint, parameters);\n        }\n        String path = uriTemplate != null ? uriTemplate : basePath;\n        endpoint.setHeaderFilterStrategy(new HttpRestHeaderFilterStrategy(path, queryParameters));\n\n        return endpoint.createProducer();\n    }",
            "1178  \n1179  \n1180  \n1181  \n1182  \n1183  \n1184  \n1185  \n1186  \n1187  \n1188 +\n1189 +\n1190 +\n1191 +\n1192 +\n1193 +\n1194  \n1195  \n1196  \n1197  \n1198  \n1199  \n1200  \n1201  \n1202  \n1203  \n1204  ",
            "    @Override\n    public Producer createProducer(CamelContext camelContext, String host,\n                                   String verb, String basePath, String uriTemplate, String queryParameters,\n                                   String consumes, String produces, Map<String, Object> parameters) throws Exception {\n\n        // avoid leading slash\n        basePath = FileUtil.stripLeadingSeparator(basePath);\n        uriTemplate = FileUtil.stripLeadingSeparator(uriTemplate);\n\n        // get the endpoint\n        String url = \"jetty:\" + host;\n        if (!ObjectHelper.isEmpty(basePath)) {\n            url += \"/\" + basePath;\n        }\n        if (!ObjectHelper.isEmpty(uriTemplate)) {\n            url += \"/\" + uriTemplate;\n        }\n\n        JettyHttpEndpoint endpoint = camelContext.getEndpoint(url, JettyHttpEndpoint.class);\n        if (parameters != null && !parameters.isEmpty()) {\n            setProperties(camelContext, endpoint, parameters);\n        }\n        String path = uriTemplate != null ? uriTemplate : basePath;\n        endpoint.setHeaderFilterStrategy(new HttpRestHeaderFilterStrategy(path, queryParameters));\n\n        return endpoint.createProducer();\n    }"
        ]
    ],
    "726bd103a6749409a33a61a724305fe85a344bc8": [
        [
            "XmppPrivateChatProducer::process(Exchange)",
            "  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89 -\n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  ",
            "    public void process(Exchange exchange) {\n\n        // make sure we are connected\n        try {\n            if (connection == null) {\n                connection = endpoint.createConnection();\n            }\n\n            if (!connection.isConnected()) {\n                this.reconnect();\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not connect to XMPP server.\", e);\n        }\n\n        String participant = endpoint.getParticipant();\n        String thread = endpoint.getChatId();\n        if (participant == null) {\n            participant = getParticipant();\n        } else {\n            thread = \"Chat:\" + participant + \":\" + endpoint.getUser();\n        }\n\n        Message message = new Message();\n        try {\n            message.setTo(JidCreate.from(participant));\n            message.setThread(thread);\n            message.setType(Message.Type.normal);\n\n            ChatManager chatManager = ChatManager.getInstanceFor(connection);\n            Chat chat = getOrCreateChat(chatManager, participant, thread);\n\n            endpoint.getBinding().populateXmppMessage(message, exchange);\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Sending XMPP message to {} from {} : {}\", new Object[]{participant, endpoint.getUser(), message.getBody()});\n            }\n            chat.send(message);\n        } catch (Exception e) {\n            throw new RuntimeExchangeException(\"Could not send XMPP message to \" + participant + \" from \" + endpoint.getUser() + \" : \" + message\n                    + \" to: \" + XmppEndpoint.getConnectionMessage(connection), exchange, e);\n        }\n    }",
            "  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89 +\n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  ",
            "    public void process(Exchange exchange) {\n\n        // make sure we are connected\n        try {\n            if (connection == null) {\n                connection = endpoint.createConnection();\n            }\n\n            if (!connection.isConnected()) {\n                this.reconnect();\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not connect to XMPP server.\", e);\n        }\n\n        String participant = endpoint.getParticipant();\n        String thread = endpoint.getChatId();\n        if (participant == null) {\n            participant = getParticipant();\n        } else {\n            thread = \"Chat:\" + participant + \":\" + endpoint.getUser();\n        }\n\n        Message message = new Message();\n        try {\n            message.setTo(JidCreate.from(participant));\n            message.setThread(thread);\n            message.setType(Message.Type.normal);\n\n            ChatManager chatManager = ChatManager.getInstanceFor(connection);\n            Chat chat = getOrCreateChat(chatManager, participant, thread);\n\n            endpoint.getBinding().populateXmppMessage(message, exchange);\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Sending XMPP message to {} from {} : {}\", participant, endpoint.getUser(), message.getBody());\n            }\n            chat.send(message);\n        } catch (Exception e) {\n            throw new RuntimeExchangeException(\"Could not send XMPP message to \" + participant + \" from \" + endpoint.getUser() + \" : \" + message\n                    + \" to: \" + XmppEndpoint.getConnectionMessage(connection), exchange, e);\n        }\n    }"
        ],
        [
            "BindyFixedLengthFactory::generateFixedLengthPositionMap(Class,Object,Map)",
            " 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  \n 423  \n 424  \n 425  \n 426  \n 427  \n 428  \n 429  \n 430  \n 431  \n 432  \n 433  \n 434  \n 435  \n 436  \n 437  \n 438  \n 439  \n 440  \n 441  \n 442  \n 443  \n 444  \n 445  \n 446  \n 447  \n 448  \n 449  \n 450  \n 451  \n 452  \n 453  \n 454  \n 455  \n 456  \n 457  \n 458  \n 459  \n 460  \n 461  \n 462  \n 463  \n 464  \n 465  \n 466  \n 467  \n 468  \n 469  \n 470  \n 471  \n 472  \n 473  \n 474  \n 475  \n 476  \n 477  \n 478  \n 479  \n 480  \n 481  \n 482  \n 483  \n 484  \n 485  \n 486  \n 487  \n 488  \n 489  \n 490  \n 491  \n 492  \n 493  \n 494  \n 495  \n 496  \n 497  \n 498  \n 499  \n 500  \n 501  \n 502  \n 503  \n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510 -\n 511  \n 512  \n 513  \n 514  \n 515  \n 516  \n 517  \n 518  \n 519  \n 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528  \n 529  \n 530  \n 531  \n 532  \n 533  ",
            "    /**\n     *\n     * Generate a table containing the data formatted and sorted with their position/offset\n     * The result is placed in the Map<Integer, List> results\n     */\n    private void generateFixedLengthPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {\n\n        String result = \"\";\n\n        for (Field field : clazz.getDeclaredFields()) {\n\n            field.setAccessible(true);\n\n            DataField datafield = field.getAnnotation(DataField.class);\n\n            if (datafield != null) {\n\n                if (obj != null) {\n\n                    // Create format\n                    FormattingOptions formattingOptions = ConverterUtils.convert(datafield,\n                            field.getType(),\n                            field.getAnnotation(BindyConverter.class),\n                            getLocale());\n                    Format<?> format = formatFactory.getFormat(formattingOptions);\n\n                    // Get field value\n                    Object value = field.get(obj);\n\n                    // If the field value is empty, populate it with the default value\n                    if (ObjectHelper.isNotEmpty(datafield.defaultValue()) && ObjectHelper.isEmpty(value)) {\n                        value = datafield.defaultValue();\n                    }\n\n                    result = formatString(format, value);\n\n                    // trim if enabled\n                    if (datafield.trim()) {\n                        result = result.trim();\n                    }\n\n                    int fieldLength = datafield.length();\n\n                    if (fieldLength == 0 && (datafield.lengthPos() > 0)) {\n                        List<String> resultVals = results.get(datafield.lengthPos());\n                        fieldLength = Integer.valueOf(resultVals.get(0));\n                    }\n\n                    if (fieldLength <= 0 && datafield.delimiter().equals(\"\") && datafield.lengthPos() == 0) {\n                        throw new IllegalArgumentException(\"Either a delimiter value or length for the field: \"\n                                + field.getName() + \" is mandatory.\");\n                    }\n\n                    if (!datafield.delimiter().equals(\"\")) {\n                        result = result + datafield.delimiter();\n                    } else {\n                        // Get length of the field, alignment (LEFT or RIGHT), pad\n                        String align = datafield.align();\n                        char padCharField = datafield.paddingChar();\n                        char padChar;\n\n                        StringBuilder temp = new StringBuilder();\n\n                        // Check if we must pad\n                        if (result.length() < fieldLength) {\n\n                            // No padding defined for the field\n                            if (padCharField == 0) {\n                                // We use the padding defined for the Record\n                                padChar = paddingChar;\n                            } else {\n                                padChar = padCharField;\n                            }\n\n                            if (align.contains(\"R\")) {\n                                temp.append(generatePaddingChars(padChar, fieldLength, result.length()));\n                                temp.append(result);\n                            } else if (align.contains(\"L\")) {\n                                temp.append(result);\n                                temp.append(generatePaddingChars(padChar, fieldLength, result.length()));\n                            } else if (align.contains(\"B\")) {\n                                temp.append(generatePaddingChars(padChar, fieldLength, result.length()));\n                                temp.append(result);\n                            } else {\n                                throw new IllegalArgumentException(\"Alignment for the field: \" + field.getName()\n                                        + \" must be equal to R for RIGHT or L for LEFT or B for trimming both ends\");\n                            }\n\n                            result = temp.toString();\n                        } else if (result.length() > fieldLength) {\n                            // we are bigger than allowed\n\n                            // is clipped enabled? if so clip the field\n                            if (datafield.clip()) {\n                                result = result.substring(0, fieldLength);\n                            } else {\n                                throw new IllegalArgumentException(\"Length for the \" + field.getName()\n                                        + \" must not be larger than allowed, was: \" + result.length() + \", allowed: \" + fieldLength);\n                            }\n                        }\n                    }\n\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Value to be formatted: {}, position: {}, and its formatted value: {}\", new Object[]{value, datafield.pos(), result});\n                    }\n\n                } else {\n                    result = \"\";\n                }\n\n                Integer key;\n                key = datafield.pos();\n\n                if (!results.containsKey(key)) {\n                    List<String> list = new LinkedList<>();\n                    list.add(result);\n                    results.put(key, list);\n                } else {\n                    List<String> list = results.get(key);\n                    list.add(result);\n                }\n\n            }\n\n        }\n\n    }",
            " 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  \n 423  \n 424  \n 425  \n 426  \n 427  \n 428  \n 429  \n 430  \n 431  \n 432  \n 433  \n 434  \n 435  \n 436  \n 437  \n 438  \n 439  \n 440  \n 441  \n 442  \n 443  \n 444  \n 445  \n 446  \n 447  \n 448  \n 449  \n 450  \n 451  \n 452  \n 453  \n 454  \n 455  \n 456  \n 457  \n 458  \n 459  \n 460  \n 461  \n 462  \n 463  \n 464  \n 465  \n 466  \n 467  \n 468  \n 469  \n 470  \n 471  \n 472  \n 473  \n 474  \n 475  \n 476  \n 477  \n 478  \n 479  \n 480  \n 481  \n 482  \n 483  \n 484  \n 485  \n 486  \n 487  \n 488  \n 489  \n 490  \n 491  \n 492  \n 493  \n 494  \n 495  \n 496  \n 497  \n 498  \n 499  \n 500  \n 501  \n 502  \n 503  \n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510 +\n 511  \n 512  \n 513  \n 514  \n 515  \n 516  \n 517  \n 518  \n 519  \n 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528  \n 529  \n 530  \n 531  \n 532  \n 533  ",
            "    /**\n     *\n     * Generate a table containing the data formatted and sorted with their position/offset\n     * The result is placed in the Map<Integer, List> results\n     */\n    private void generateFixedLengthPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {\n\n        String result = \"\";\n\n        for (Field field : clazz.getDeclaredFields()) {\n\n            field.setAccessible(true);\n\n            DataField datafield = field.getAnnotation(DataField.class);\n\n            if (datafield != null) {\n\n                if (obj != null) {\n\n                    // Create format\n                    FormattingOptions formattingOptions = ConverterUtils.convert(datafield,\n                            field.getType(),\n                            field.getAnnotation(BindyConverter.class),\n                            getLocale());\n                    Format<?> format = formatFactory.getFormat(formattingOptions);\n\n                    // Get field value\n                    Object value = field.get(obj);\n\n                    // If the field value is empty, populate it with the default value\n                    if (ObjectHelper.isNotEmpty(datafield.defaultValue()) && ObjectHelper.isEmpty(value)) {\n                        value = datafield.defaultValue();\n                    }\n\n                    result = formatString(format, value);\n\n                    // trim if enabled\n                    if (datafield.trim()) {\n                        result = result.trim();\n                    }\n\n                    int fieldLength = datafield.length();\n\n                    if (fieldLength == 0 && (datafield.lengthPos() > 0)) {\n                        List<String> resultVals = results.get(datafield.lengthPos());\n                        fieldLength = Integer.valueOf(resultVals.get(0));\n                    }\n\n                    if (fieldLength <= 0 && datafield.delimiter().equals(\"\") && datafield.lengthPos() == 0) {\n                        throw new IllegalArgumentException(\"Either a delimiter value or length for the field: \"\n                                + field.getName() + \" is mandatory.\");\n                    }\n\n                    if (!datafield.delimiter().equals(\"\")) {\n                        result = result + datafield.delimiter();\n                    } else {\n                        // Get length of the field, alignment (LEFT or RIGHT), pad\n                        String align = datafield.align();\n                        char padCharField = datafield.paddingChar();\n                        char padChar;\n\n                        StringBuilder temp = new StringBuilder();\n\n                        // Check if we must pad\n                        if (result.length() < fieldLength) {\n\n                            // No padding defined for the field\n                            if (padCharField == 0) {\n                                // We use the padding defined for the Record\n                                padChar = paddingChar;\n                            } else {\n                                padChar = padCharField;\n                            }\n\n                            if (align.contains(\"R\")) {\n                                temp.append(generatePaddingChars(padChar, fieldLength, result.length()));\n                                temp.append(result);\n                            } else if (align.contains(\"L\")) {\n                                temp.append(result);\n                                temp.append(generatePaddingChars(padChar, fieldLength, result.length()));\n                            } else if (align.contains(\"B\")) {\n                                temp.append(generatePaddingChars(padChar, fieldLength, result.length()));\n                                temp.append(result);\n                            } else {\n                                throw new IllegalArgumentException(\"Alignment for the field: \" + field.getName()\n                                        + \" must be equal to R for RIGHT or L for LEFT or B for trimming both ends\");\n                            }\n\n                            result = temp.toString();\n                        } else if (result.length() > fieldLength) {\n                            // we are bigger than allowed\n\n                            // is clipped enabled? if so clip the field\n                            if (datafield.clip()) {\n                                result = result.substring(0, fieldLength);\n                            } else {\n                                throw new IllegalArgumentException(\"Length for the \" + field.getName()\n                                        + \" must not be larger than allowed, was: \" + result.length() + \", allowed: \" + fieldLength);\n                            }\n                        }\n                    }\n\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Value to be formatted: {}, position: {}, and its formatted value: {}\", value, datafield.pos(), result);\n                    }\n\n                } else {\n                    result = \"\";\n                }\n\n                Integer key;\n                key = datafield.pos();\n\n                if (!results.containsKey(key)) {\n                    List<String> list = new LinkedList<>();\n                    list.add(result);\n                    results.put(key, list);\n                } else {\n                    List<String> list = results.get(key);\n                    list.add(result);\n                }\n\n            }\n\n        }\n\n    }"
        ],
        [
            "CamelServlet::init(ServletConfig)",
            "  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70 -\n  71  ",
            "    @Override\n    public void init(ServletConfig config) throws ServletException {\n        super.init(config);\n        this.servletName = config.getServletName();\n\n        final String asyncParam = config.getInitParameter(ASYNC_PARAM);\n        this.async = asyncParam == null ? false : ObjectHelper.toBoolean(asyncParam);\n        log.trace(\"servlet '{}' initialized with: async={}\", new Object[]{servletName, async});\n    }",
            "  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70 +\n  71  ",
            "    @Override\n    public void init(ServletConfig config) throws ServletException {\n        super.init(config);\n        this.servletName = config.getServletName();\n\n        final String asyncParam = config.getInitParameter(ASYNC_PARAM);\n        this.async = asyncParam == null ? false : ObjectHelper.toBoolean(asyncParam);\n        log.trace(\"servlet '{}' initialized with: async={}\", servletName, async);\n    }"
        ],
        [
            "CamelAnnotationsHandler::handleShutdownTimeout(ConfigurableApplicationContext,Class)",
            " 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200 -\n 201  \n 202  \n 203  \n 204  \n 205  ",
            "    /**\n     * Handles updating shutdown timeouts on Camel contexts based on {@link ShutdownTimeout}.\n     *\n     * @param context the initialized Spring context\n     * @param testClass the test class being executed\n     */\n    public static void handleShutdownTimeout(ConfigurableApplicationContext context, Class<?> testClass) throws Exception {\n        final int shutdownTimeout;\n        final TimeUnit shutdownTimeUnit;\n        if (testClass.isAnnotationPresent(ShutdownTimeout.class)) {\n            shutdownTimeout = testClass.getAnnotation(ShutdownTimeout.class).value();\n            shutdownTimeUnit = testClass.getAnnotation(ShutdownTimeout.class).timeUnit();\n        } else {\n            shutdownTimeout = 10;\n            shutdownTimeUnit = TimeUnit.SECONDS;\n        }\n\n        CamelSpringTestHelper.doToSpringCamelContexts(context, new CamelSpringTestHelper.DoToSpringCamelContextsStrategy() {\n\n            public void execute(String contextName, SpringCamelContext camelContext)\n                    throws Exception {\n                LOGGER.info(\"Setting shutdown timeout to [{} {}] on CamelContext with name [{}].\", new Object[]{shutdownTimeout, shutdownTimeUnit, contextName});\n                camelContext.getShutdownStrategy().setTimeout(shutdownTimeout);\n                camelContext.getShutdownStrategy().setTimeUnit(shutdownTimeUnit);\n            }\n        });\n    }",
            " 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200 +\n 201  \n 202  \n 203  \n 204  \n 205  ",
            "    /**\n     * Handles updating shutdown timeouts on Camel contexts based on {@link ShutdownTimeout}.\n     *\n     * @param context the initialized Spring context\n     * @param testClass the test class being executed\n     */\n    public static void handleShutdownTimeout(ConfigurableApplicationContext context, Class<?> testClass) throws Exception {\n        final int shutdownTimeout;\n        final TimeUnit shutdownTimeUnit;\n        if (testClass.isAnnotationPresent(ShutdownTimeout.class)) {\n            shutdownTimeout = testClass.getAnnotation(ShutdownTimeout.class).value();\n            shutdownTimeUnit = testClass.getAnnotation(ShutdownTimeout.class).timeUnit();\n        } else {\n            shutdownTimeout = 10;\n            shutdownTimeUnit = TimeUnit.SECONDS;\n        }\n\n        CamelSpringTestHelper.doToSpringCamelContexts(context, new CamelSpringTestHelper.DoToSpringCamelContextsStrategy() {\n\n            public void execute(String contextName, SpringCamelContext camelContext)\n                    throws Exception {\n                LOGGER.info(\"Setting shutdown timeout to [{} {}] on CamelContext with name [{}].\", shutdownTimeout, shutdownTimeUnit, contextName);\n                camelContext.getShutdownStrategy().setTimeout(shutdownTimeout);\n                camelContext.getShutdownStrategy().setTimeUnit(shutdownTimeUnit);\n            }\n        });\n    }"
        ],
        [
            "MinaProducer::openConnection()",
            " 212  \n 213  \n 214  \n 215  \n 216 -\n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  ",
            "    private void openConnection() {\n        SocketAddress address = getEndpoint().getAddress();\n        connector = getEndpoint().getConnector();\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Creating connector to address: {} using connector: {} timeout: {} millis.\", new Object[]{address, connector, timeout});\n        }\n        IoHandler ioHandler = new ResponseHandler(getEndpoint());\n        // connect and wait until the connection is established\n        ConnectFuture future = connector.connect(address, ioHandler, getEndpoint().getConnectorConfig());\n        future.join();\n        session = future.getSession();\n    }",
            " 212  \n 213  \n 214  \n 215  \n 216 +\n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  ",
            "    private void openConnection() {\n        SocketAddress address = getEndpoint().getAddress();\n        connector = getEndpoint().getConnector();\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Creating connector to address: {} using connector: {} timeout: {} millis.\", address, connector, timeout);\n        }\n        IoHandler ioHandler = new ResponseHandler(getEndpoint());\n        // connect and wait until the connection is established\n        ConnectFuture future = connector.connect(address, ioHandler, getEndpoint().getConnectorConfig());\n        future.join();\n        session = future.getSession();\n    }"
        ],
        [
            "JettyHttpComponent::createHttpClient(JettyHttpEndpoint,Integer,Integer,SSLContextParameters)",
            " 709  \n 710  \n 711  \n 712  \n 713  \n 714  \n 715  \n 716  \n 717  \n 718  \n 719  \n 720  \n 721  \n 722  \n 723  \n 724  \n 725  \n 726  \n 727  \n 728  \n 729  \n 730  \n 731  \n 732  \n 733  \n 734  \n 735  \n 736  \n 737  \n 738  \n 739  \n 740  \n 741  \n 742  \n 743  \n 744  \n 745  \n 746  \n 747  \n 748  \n 749  \n 750  \n 751  \n 752  \n 753  \n 754  \n 755  \n 756  \n 757  \n 758  \n 759  \n 760  \n 761  \n 762 -\n 763  \n 764  \n 765  \n 766  \n 767  \n 768  \n 769  ",
            "    /**\n     * Creates a new {@link HttpClient} and configures its proxy/thread pool and SSL based on this\n     * component settings.\n     *\n     * @param endpoint   the instance of JettyHttpEndpoint\n     * @param minThreads optional minimum number of threads in client thread pool\n     * @param maxThreads optional maximum number of threads in client thread pool\n     * @param ssl        option SSL parameters\n     */\n    public CamelHttpClient createHttpClient(JettyHttpEndpoint endpoint, Integer minThreads, Integer maxThreads, SSLContextParameters ssl) throws Exception {\n        SslContextFactory sslContextFactory = createSslContextFactory(ssl);\n        HttpClientTransport transport = createHttpClientTransport(maxThreads);\n        CamelHttpClient httpClient = createCamelHttpClient(transport, sslContextFactory);\n\n        CamelContext context = endpoint.getCamelContext();\n\n        if (context != null\n            && ObjectHelper.isNotEmpty(context.getProperty(\"http.proxyHost\"))\n            && ObjectHelper.isNotEmpty(context.getProperty(\"http.proxyPort\"))) {\n            String host = context.getProperty(\"http.proxyHost\");\n            int port = Integer.parseInt(context.getProperty(\"http.proxyPort\"));\n            LOG.debug(\"CamelContext properties http.proxyHost and http.proxyPort detected. Using http proxy host: {} port: {}\", host, port);\n            httpClient.setProxy(host, port);\n        }\n\n        if (ObjectHelper.isNotEmpty(endpoint.getProxyHost()) && endpoint.getProxyPort() > 0) {\n            String host = endpoint.getProxyHost();\n            int port = endpoint.getProxyPort();\n            LOG.debug(\"proxyHost and proxyPort options detected. Using http proxy host: {} port: {}\", host, port);\n            httpClient.setProxy(host, port);\n        }\n\n        // must have both min and max\n        if (minThreads != null || maxThreads != null) {\n\n            // must have both options\n            if (minThreads == null || maxThreads == null) {\n                throw new IllegalArgumentException(\"Both min and max thread pool sizes must be provided.\");\n            }\n\n            // use QueueThreadPool as the default bounded is deprecated (see SMXCOMP-157)\n            QueuedThreadPool qtp = new QueuedThreadPool();\n            qtp.setMinThreads(minThreads.intValue());\n            qtp.setMaxThreads(maxThreads.intValue());\n            // and we want to use daemon threads\n            qtp.setDaemon(true);\n            // let the thread names indicate they are from the client\n            qtp.setName(\"CamelJettyClient(\" + ObjectHelper.getIdentityHashCode(httpClient) + \")\");\n            httpClient.setThreadPoolOrExecutor(qtp);\n        }\n\n        if (LOG.isDebugEnabled()) {\n            if (minThreads != null) {\n                LOG.debug(\"Created HttpClient with thread pool {}-{} -> {}\", new Object[]{minThreads, maxThreads, httpClient});\n            } else {\n                LOG.debug(\"Created HttpClient with default thread pool size -> {}\", httpClient);\n            }\n        }\n\n        return httpClient;\n    }",
            " 709  \n 710  \n 711  \n 712  \n 713  \n 714  \n 715  \n 716  \n 717  \n 718  \n 719  \n 720  \n 721  \n 722  \n 723  \n 724  \n 725  \n 726  \n 727  \n 728  \n 729  \n 730  \n 731  \n 732  \n 733  \n 734  \n 735  \n 736  \n 737  \n 738  \n 739  \n 740  \n 741  \n 742  \n 743  \n 744  \n 745  \n 746  \n 747  \n 748  \n 749  \n 750  \n 751  \n 752  \n 753  \n 754  \n 755  \n 756  \n 757  \n 758  \n 759  \n 760  \n 761  \n 762 +\n 763  \n 764  \n 765  \n 766  \n 767  \n 768  \n 769  ",
            "    /**\n     * Creates a new {@link HttpClient} and configures its proxy/thread pool and SSL based on this\n     * component settings.\n     *\n     * @param endpoint   the instance of JettyHttpEndpoint\n     * @param minThreads optional minimum number of threads in client thread pool\n     * @param maxThreads optional maximum number of threads in client thread pool\n     * @param ssl        option SSL parameters\n     */\n    public CamelHttpClient createHttpClient(JettyHttpEndpoint endpoint, Integer minThreads, Integer maxThreads, SSLContextParameters ssl) throws Exception {\n        SslContextFactory sslContextFactory = createSslContextFactory(ssl);\n        HttpClientTransport transport = createHttpClientTransport(maxThreads);\n        CamelHttpClient httpClient = createCamelHttpClient(transport, sslContextFactory);\n\n        CamelContext context = endpoint.getCamelContext();\n\n        if (context != null\n            && ObjectHelper.isNotEmpty(context.getProperty(\"http.proxyHost\"))\n            && ObjectHelper.isNotEmpty(context.getProperty(\"http.proxyPort\"))) {\n            String host = context.getProperty(\"http.proxyHost\");\n            int port = Integer.parseInt(context.getProperty(\"http.proxyPort\"));\n            LOG.debug(\"CamelContext properties http.proxyHost and http.proxyPort detected. Using http proxy host: {} port: {}\", host, port);\n            httpClient.setProxy(host, port);\n        }\n\n        if (ObjectHelper.isNotEmpty(endpoint.getProxyHost()) && endpoint.getProxyPort() > 0) {\n            String host = endpoint.getProxyHost();\n            int port = endpoint.getProxyPort();\n            LOG.debug(\"proxyHost and proxyPort options detected. Using http proxy host: {} port: {}\", host, port);\n            httpClient.setProxy(host, port);\n        }\n\n        // must have both min and max\n        if (minThreads != null || maxThreads != null) {\n\n            // must have both options\n            if (minThreads == null || maxThreads == null) {\n                throw new IllegalArgumentException(\"Both min and max thread pool sizes must be provided.\");\n            }\n\n            // use QueueThreadPool as the default bounded is deprecated (see SMXCOMP-157)\n            QueuedThreadPool qtp = new QueuedThreadPool();\n            qtp.setMinThreads(minThreads.intValue());\n            qtp.setMaxThreads(maxThreads.intValue());\n            // and we want to use daemon threads\n            qtp.setDaemon(true);\n            // let the thread names indicate they are from the client\n            qtp.setName(\"CamelJettyClient(\" + ObjectHelper.getIdentityHashCode(httpClient) + \")\");\n            httpClient.setThreadPoolOrExecutor(qtp);\n        }\n\n        if (LOG.isDebugEnabled()) {\n            if (minThreads != null) {\n                LOG.debug(\"Created HttpClient with thread pool {}-{} -> {}\", minThreads, maxThreads, httpClient);\n            } else {\n                LOG.debug(\"Created HttpClient with default thread pool size -> {}\", httpClient);\n            }\n        }\n\n        return httpClient;\n    }"
        ],
        [
            "Mina2Consumer::configureDataGramCodecFactory(String,IoService,Mina2Configuration)",
            " 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303 -\n 304  \n 305  \n 306  \n 307  \n 308  ",
            "    /**\n     * For datagrams the entire message is available as a single IoBuffer so lets just pass those around by default\n     * and try converting whatever they payload is into IoBuffer unless some custom converter is specified\n     */\n    protected void configureDataGramCodecFactory(final String type, final IoService service, final Mina2Configuration configuration) {\n        ProtocolCodecFactory codecFactory = configuration.getCodec();\n        if (codecFactory == null) {\n            codecFactory = new Mina2UdpProtocolCodecFactory(this.getEndpoint().getCamelContext());\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"{}: Using CodecFactory: {}\", new Object[]{type, codecFactory});\n            }\n        }\n\n        addCodecFactory(service, codecFactory);\n    }",
            " 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303 +\n 304  \n 305  \n 306  \n 307  \n 308  ",
            "    /**\n     * For datagrams the entire message is available as a single IoBuffer so lets just pass those around by default\n     * and try converting whatever they payload is into IoBuffer unless some custom converter is specified\n     */\n    protected void configureDataGramCodecFactory(final String type, final IoService service, final Mina2Configuration configuration) {\n        ProtocolCodecFactory codecFactory = configuration.getCodec();\n        if (codecFactory == null) {\n            codecFactory = new Mina2UdpProtocolCodecFactory(this.getEndpoint().getCamelContext());\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"{}: Using CodecFactory: {}\", type, codecFactory);\n            }\n        }\n\n        addCodecFactory(service, codecFactory);\n    }"
        ],
        [
            "FtpOperations::doConnect(RemoteFileConfiguration)",
            "  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187 -\n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  ",
            "    protected boolean doConnect(RemoteFileConfiguration configuration) throws GenericFileOperationFailedException {\n        log.trace(\"Connecting using FTPClient: {}\", client);\n\n        String host = configuration.getHost();\n        int port = configuration.getPort();\n        String username = configuration.getUsername();\n        String account = ((FtpConfiguration) configuration).getAccount();\n\n        if (clientConfig != null) {\n            log.trace(\"Configuring FTPClient with config: {}\", clientConfig);\n            client.configure(clientConfig);\n        }\n\n        if (log.isTraceEnabled()) {\n            log.trace(\"Connecting to {} using connection timeout: {}\",\n                    configuration.remoteServerInformation(), client.getConnectTimeout());\n        }\n\n        boolean connected = false;\n        int attempt = 0;\n\n        while (!connected) {\n            try {\n                if (log.isTraceEnabled() && attempt > 0) {\n                    log.trace(\"Reconnect attempt #{} connecting to {}\", attempt, configuration.remoteServerInformation());\n                }\n                clientActivityListener.onConnecting(host);\n                client.connect(host, port);\n                // must check reply code if we are connected\n                int reply = client.getReplyCode();\n\n                if (FTPReply.isPositiveCompletion(reply)) {\n                    // yes we could connect\n                    connected = true;\n                } else {\n                    // throw an exception to force the retry logic in the catch exception block\n                    throw new GenericFileOperationFailedException(client.getReplyCode(), client.getReplyString(), \"Server refused connection\");\n                }\n            } catch (Exception e) {\n                // check if we are interrupted so we can break out\n                if (Thread.currentThread().isInterrupted()) {\n                    throw new GenericFileOperationFailedException(\"Interrupted during connecting\", new InterruptedException(\"Interrupted during connecting\"));\n                }\n\n                GenericFileOperationFailedException failed;\n                if (e instanceof GenericFileOperationFailedException) {\n                    failed = (GenericFileOperationFailedException) e;\n                } else {\n                    failed = new GenericFileOperationFailedException(client.getReplyCode(), client.getReplyString(), e.getMessage(), e);\n                }\n\n                log.trace(\"Cannot connect due: {}\", failed.getMessage());\n                attempt++;\n                if (attempt > endpoint.getMaximumReconnectAttempts()) {\n                    throw failed;\n                }\n                if (endpoint.getReconnectDelay() > 0) {\n                    try {\n                        Thread.sleep(endpoint.getReconnectDelay());\n                    } catch (InterruptedException ie) {\n                        // we could potentially also be interrupted during sleep\n                        Thread.currentThread().interrupt();\n                        throw new GenericFileOperationFailedException(\"Interrupted during sleeping\", ie);\n                    }\n                }\n            }\n        }\n\n        // we are now connected\n        clientActivityListener.onConnected(host);\n\n        // must enter passive mode directly after connect\n        if (configuration.isPassiveMode()) {\n            log.trace(\"Using passive mode connections\");\n            client.enterLocalPassiveMode();\n        }\n\n        // must set soTimeout after connect\n        if (endpoint instanceof FtpEndpoint) {\n            FtpEndpoint<?> ftpEndpoint = endpoint;\n            if (ftpEndpoint.getSoTimeout() > 0) {\n                log.trace(\"Using SoTimeout={}\", ftpEndpoint.getSoTimeout());\n                try {\n                    client.setSoTimeout(ftpEndpoint.getSoTimeout());\n                } catch (IOException e) {\n                    throw new GenericFileOperationFailedException(client.getReplyCode(), client.getReplyString(), e.getMessage(), e);\n                }\n            }\n        }\n\n        try {\n            clientActivityListener.onLogin(host);\n            boolean login;\n            if (username != null) {\n                if (account != null) {\n                    log.trace(\"Attempting to login user: {} using password: ******** and account: {}\", new Object[]{username, account});\n                    login = client.login(username, configuration.getPassword(), account);\n                } else {\n                    log.trace(\"Attempting to login user: {} using password: ********\", username);\n                    login = client.login(username, configuration.getPassword());\n                }\n            } else {\n                if (account != null) {\n                    // not sure if it makes sense to login anonymous with account?\n                    log.trace(\"Attempting to login anonymous using account: {}\", account);\n                    login = client.login(\"anonymous\", \"\", account);\n                } else {\n                    log.trace(\"Attempting to login anonymous\");\n                    login = client.login(\"anonymous\", \"\");\n                }\n            }\n            log.trace(\"User {} logged in: {}\", username != null ? username : \"anonymous\", login);\n            if (!login) {\n                // store replyString, because disconnect() will reset it\n                String replyString = client.getReplyString();\n                int replyCode = client.getReplyCode();\n                clientActivityListener.onLoginFailed(replyCode, replyString);\n                // disconnect to prevent connection leaks\n                client.disconnect();\n                throw new GenericFileOperationFailedException(replyCode, replyString);\n            }\n            clientActivityListener.onLoginComplete(host);\n            client.setFileType(configuration.isBinary() ? FTP.BINARY_FILE_TYPE : FTP.ASCII_FILE_TYPE);\n        } catch (IOException e) {\n            throw new GenericFileOperationFailedException(client.getReplyCode(), client.getReplyString(), e.getMessage(), e);\n        }\n\n        // site commands\n        if (endpoint.getConfiguration().getSiteCommand() != null) {\n            // commands can be separated using new line\n            Iterator<?> it = ObjectHelper.createIterator(endpoint.getConfiguration().getSiteCommand(), \"\\n\");\n            while (it.hasNext()) {\n                Object next = it.next();\n                String command = endpoint.getCamelContext().getTypeConverter().convertTo(String.class, next);\n                log.trace(\"Site command to send: {}\", command);\n                if (command != null) {\n                    boolean result = sendSiteCommand(command);\n                    if (!result) {\n                        throw new GenericFileOperationFailedException(\"Site command: \" + command + \" returned false\");\n                    }\n                }\n            }\n        }\n\n        return true;\n    }",
            "  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187 +\n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  ",
            "    protected boolean doConnect(RemoteFileConfiguration configuration) throws GenericFileOperationFailedException {\n        log.trace(\"Connecting using FTPClient: {}\", client);\n\n        String host = configuration.getHost();\n        int port = configuration.getPort();\n        String username = configuration.getUsername();\n        String account = ((FtpConfiguration) configuration).getAccount();\n\n        if (clientConfig != null) {\n            log.trace(\"Configuring FTPClient with config: {}\", clientConfig);\n            client.configure(clientConfig);\n        }\n\n        if (log.isTraceEnabled()) {\n            log.trace(\"Connecting to {} using connection timeout: {}\",\n                    configuration.remoteServerInformation(), client.getConnectTimeout());\n        }\n\n        boolean connected = false;\n        int attempt = 0;\n\n        while (!connected) {\n            try {\n                if (log.isTraceEnabled() && attempt > 0) {\n                    log.trace(\"Reconnect attempt #{} connecting to {}\", attempt, configuration.remoteServerInformation());\n                }\n                clientActivityListener.onConnecting(host);\n                client.connect(host, port);\n                // must check reply code if we are connected\n                int reply = client.getReplyCode();\n\n                if (FTPReply.isPositiveCompletion(reply)) {\n                    // yes we could connect\n                    connected = true;\n                } else {\n                    // throw an exception to force the retry logic in the catch exception block\n                    throw new GenericFileOperationFailedException(client.getReplyCode(), client.getReplyString(), \"Server refused connection\");\n                }\n            } catch (Exception e) {\n                // check if we are interrupted so we can break out\n                if (Thread.currentThread().isInterrupted()) {\n                    throw new GenericFileOperationFailedException(\"Interrupted during connecting\", new InterruptedException(\"Interrupted during connecting\"));\n                }\n\n                GenericFileOperationFailedException failed;\n                if (e instanceof GenericFileOperationFailedException) {\n                    failed = (GenericFileOperationFailedException) e;\n                } else {\n                    failed = new GenericFileOperationFailedException(client.getReplyCode(), client.getReplyString(), e.getMessage(), e);\n                }\n\n                log.trace(\"Cannot connect due: {}\", failed.getMessage());\n                attempt++;\n                if (attempt > endpoint.getMaximumReconnectAttempts()) {\n                    throw failed;\n                }\n                if (endpoint.getReconnectDelay() > 0) {\n                    try {\n                        Thread.sleep(endpoint.getReconnectDelay());\n                    } catch (InterruptedException ie) {\n                        // we could potentially also be interrupted during sleep\n                        Thread.currentThread().interrupt();\n                        throw new GenericFileOperationFailedException(\"Interrupted during sleeping\", ie);\n                    }\n                }\n            }\n        }\n\n        // we are now connected\n        clientActivityListener.onConnected(host);\n\n        // must enter passive mode directly after connect\n        if (configuration.isPassiveMode()) {\n            log.trace(\"Using passive mode connections\");\n            client.enterLocalPassiveMode();\n        }\n\n        // must set soTimeout after connect\n        if (endpoint instanceof FtpEndpoint) {\n            FtpEndpoint<?> ftpEndpoint = endpoint;\n            if (ftpEndpoint.getSoTimeout() > 0) {\n                log.trace(\"Using SoTimeout={}\", ftpEndpoint.getSoTimeout());\n                try {\n                    client.setSoTimeout(ftpEndpoint.getSoTimeout());\n                } catch (IOException e) {\n                    throw new GenericFileOperationFailedException(client.getReplyCode(), client.getReplyString(), e.getMessage(), e);\n                }\n            }\n        }\n\n        try {\n            clientActivityListener.onLogin(host);\n            boolean login;\n            if (username != null) {\n                if (account != null) {\n                    log.trace(\"Attempting to login user: {} using password: ******** and account: {}\", username, account);\n                    login = client.login(username, configuration.getPassword(), account);\n                } else {\n                    log.trace(\"Attempting to login user: {} using password: ********\", username);\n                    login = client.login(username, configuration.getPassword());\n                }\n            } else {\n                if (account != null) {\n                    // not sure if it makes sense to login anonymous with account?\n                    log.trace(\"Attempting to login anonymous using account: {}\", account);\n                    login = client.login(\"anonymous\", \"\", account);\n                } else {\n                    log.trace(\"Attempting to login anonymous\");\n                    login = client.login(\"anonymous\", \"\");\n                }\n            }\n            log.trace(\"User {} logged in: {}\", username != null ? username : \"anonymous\", login);\n            if (!login) {\n                // store replyString, because disconnect() will reset it\n                String replyString = client.getReplyString();\n                int replyCode = client.getReplyCode();\n                clientActivityListener.onLoginFailed(replyCode, replyString);\n                // disconnect to prevent connection leaks\n                client.disconnect();\n                throw new GenericFileOperationFailedException(replyCode, replyString);\n            }\n            clientActivityListener.onLoginComplete(host);\n            client.setFileType(configuration.isBinary() ? FTP.BINARY_FILE_TYPE : FTP.ASCII_FILE_TYPE);\n        } catch (IOException e) {\n            throw new GenericFileOperationFailedException(client.getReplyCode(), client.getReplyString(), e.getMessage(), e);\n        }\n\n        // site commands\n        if (endpoint.getConfiguration().getSiteCommand() != null) {\n            // commands can be separated using new line\n            Iterator<?> it = ObjectHelper.createIterator(endpoint.getConfiguration().getSiteCommand(), \"\\n\");\n            while (it.hasNext()) {\n                Object next = it.next();\n                String command = endpoint.getCamelContext().getTypeConverter().convertTo(String.class, next);\n                log.trace(\"Site command to send: {}\", command);\n                if (command != null) {\n                    boolean result = sendSiteCommand(command);\n                    if (!result) {\n                        throw new GenericFileOperationFailedException(\"Site command: \" + command + \" returned false\");\n                    }\n                }\n            }\n        }\n\n        return true;\n    }"
        ],
        [
            "SingleUDPNettyServerBootstrapFactory::startServerBootstrap()",
            " 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172 -\n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  ",
            "    protected void startServerBootstrap() throws Exception {\n        // create non-shared worker pool\n        int count = configuration.getWorkerCount() > 0 ? configuration.getWorkerCount() : NettyHelper.DEFAULT_IO_THREADS;\n        workerPool = new NioDatagramWorkerPool(Executors.newCachedThreadPool(), count);\n\n        datagramChannelFactory = new NioDatagramChannelFactory(workerPool);\n\n        connectionlessBootstrap = new ConnectionlessBootstrap(datagramChannelFactory);\n        connectionlessBootstrap.setOption(\"child.keepAlive\", configuration.isKeepAlive());\n        connectionlessBootstrap.setOption(\"child.tcpNoDelay\", configuration.isTcpNoDelay());\n        connectionlessBootstrap.setOption(\"reuseAddress\", configuration.isReuseAddress());\n        connectionlessBootstrap.setOption(\"child.reuseAddress\", configuration.isReuseAddress());\n        connectionlessBootstrap.setOption(\"child.connectTimeoutMillis\", configuration.getConnectTimeout());\n        connectionlessBootstrap.setOption(\"child.broadcast\", configuration.isBroadcast());\n        connectionlessBootstrap.setOption(\"sendBufferSize\", configuration.getSendBufferSize());\n        connectionlessBootstrap.setOption(\"receiveBufferSize\", configuration.getReceiveBufferSize());\n        // only set this if user has specified\n        if (configuration.getReceiveBufferSizePredictor() > 0) {\n            connectionlessBootstrap.setOption(\"receiveBufferSizePredictorFactory\",\n                    new FixedReceiveBufferSizePredictorFactory(configuration.getReceiveBufferSizePredictor()));\n        }\n        if (configuration.getBacklog() > 0) {\n            connectionlessBootstrap.setOption(\"backlog\", configuration.getBacklog());\n        }\n\n        // set any additional netty options\n        if (configuration.getOptions() != null) {\n            for (Map.Entry<String, Object> entry : configuration.getOptions().entrySet()) {\n                connectionlessBootstrap.setOption(entry.getKey(), entry.getValue());\n            }\n        }\n\n        LOG.debug(\"Created ConnectionlessBootstrap {} with options: {}\", connectionlessBootstrap, connectionlessBootstrap.getOptions());\n\n        // set the pipeline factory, which creates the pipeline for each newly created channels\n        connectionlessBootstrap.setPipelineFactory(pipelineFactory);\n\n        InetSocketAddress hostAddress = new InetSocketAddress(configuration.getHost(), configuration.getPort());\n        IpV4Subnet multicastSubnet = new IpV4Subnet(MULTICAST_SUBNET);\n\n        if (multicastSubnet.contains(configuration.getHost())) {\n            datagramChannel = (DatagramChannel)connectionlessBootstrap.bind(hostAddress);\n            String networkInterface = configuration.getNetworkInterface() == null ? LOOPBACK_INTERFACE : configuration.getNetworkInterface();\n            multicastNetworkInterface = NetworkInterface.getByName(networkInterface);\n            ObjectHelper.notNull(multicastNetworkInterface, \"No network interface found for '\" + networkInterface + \"'.\");\n            LOG.info(\"ConnectionlessBootstrap joining {}:{} using network interface: {}\", new Object[]{configuration.getHost(), configuration.getPort(), multicastNetworkInterface.getName()});\n            datagramChannel.joinGroup(hostAddress, multicastNetworkInterface).syncUninterruptibly();\n            allChannels.add(datagramChannel);\n        } else {\n            LOG.info(\"ConnectionlessBootstrap binding to {}:{}\", configuration.getHost(), configuration.getPort());\n            channel = connectionlessBootstrap.bind(hostAddress);\n            allChannels.add(channel);\n        }\n    }",
            " 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172 +\n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  ",
            "    protected void startServerBootstrap() throws Exception {\n        // create non-shared worker pool\n        int count = configuration.getWorkerCount() > 0 ? configuration.getWorkerCount() : NettyHelper.DEFAULT_IO_THREADS;\n        workerPool = new NioDatagramWorkerPool(Executors.newCachedThreadPool(), count);\n\n        datagramChannelFactory = new NioDatagramChannelFactory(workerPool);\n\n        connectionlessBootstrap = new ConnectionlessBootstrap(datagramChannelFactory);\n        connectionlessBootstrap.setOption(\"child.keepAlive\", configuration.isKeepAlive());\n        connectionlessBootstrap.setOption(\"child.tcpNoDelay\", configuration.isTcpNoDelay());\n        connectionlessBootstrap.setOption(\"reuseAddress\", configuration.isReuseAddress());\n        connectionlessBootstrap.setOption(\"child.reuseAddress\", configuration.isReuseAddress());\n        connectionlessBootstrap.setOption(\"child.connectTimeoutMillis\", configuration.getConnectTimeout());\n        connectionlessBootstrap.setOption(\"child.broadcast\", configuration.isBroadcast());\n        connectionlessBootstrap.setOption(\"sendBufferSize\", configuration.getSendBufferSize());\n        connectionlessBootstrap.setOption(\"receiveBufferSize\", configuration.getReceiveBufferSize());\n        // only set this if user has specified\n        if (configuration.getReceiveBufferSizePredictor() > 0) {\n            connectionlessBootstrap.setOption(\"receiveBufferSizePredictorFactory\",\n                    new FixedReceiveBufferSizePredictorFactory(configuration.getReceiveBufferSizePredictor()));\n        }\n        if (configuration.getBacklog() > 0) {\n            connectionlessBootstrap.setOption(\"backlog\", configuration.getBacklog());\n        }\n\n        // set any additional netty options\n        if (configuration.getOptions() != null) {\n            for (Map.Entry<String, Object> entry : configuration.getOptions().entrySet()) {\n                connectionlessBootstrap.setOption(entry.getKey(), entry.getValue());\n            }\n        }\n\n        LOG.debug(\"Created ConnectionlessBootstrap {} with options: {}\", connectionlessBootstrap, connectionlessBootstrap.getOptions());\n\n        // set the pipeline factory, which creates the pipeline for each newly created channels\n        connectionlessBootstrap.setPipelineFactory(pipelineFactory);\n\n        InetSocketAddress hostAddress = new InetSocketAddress(configuration.getHost(), configuration.getPort());\n        IpV4Subnet multicastSubnet = new IpV4Subnet(MULTICAST_SUBNET);\n\n        if (multicastSubnet.contains(configuration.getHost())) {\n            datagramChannel = (DatagramChannel)connectionlessBootstrap.bind(hostAddress);\n            String networkInterface = configuration.getNetworkInterface() == null ? LOOPBACK_INTERFACE : configuration.getNetworkInterface();\n            multicastNetworkInterface = NetworkInterface.getByName(networkInterface);\n            ObjectHelper.notNull(multicastNetworkInterface, \"No network interface found for '\" + networkInterface + \"'.\");\n            LOG.info(\"ConnectionlessBootstrap joining {}:{} using network interface: {}\", configuration.getHost(), configuration.getPort(), multicastNetworkInterface.getName());\n            datagramChannel.joinGroup(hostAddress, multicastNetworkInterface).syncUninterruptibly();\n            allChannels.add(datagramChannel);\n        } else {\n            LOG.info(\"ConnectionlessBootstrap binding to {}:{}\", configuration.getHost(), configuration.getPort());\n            channel = connectionlessBootstrap.bind(hostAddress);\n            allChannels.add(channel);\n        }\n    }"
        ],
        [
            "ClientChannelHandler::getResponseMessage(Exchange,MessageEvent)",
            " 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220 -\n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  ",
            "    /**\n     * Gets the Camel {@link Message} to use as the message to be set on the current {@link Exchange} when\n     * we have received a reply message.\n     * <p/>\n     *\n     * @param exchange      the current exchange\n     * @param messageEvent  the incoming event which has the response message from Netty.\n     * @return the Camel {@link Message} to set on the current {@link Exchange} as the response message.\n     * @throws Exception is thrown if error getting the response message\n     */\n    protected Message getResponseMessage(Exchange exchange, MessageEvent messageEvent) throws Exception {\n        Object body = messageEvent.getMessage();\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Channel: {} received body: {}\", new Object[]{messageEvent.getChannel(), body});\n        }\n\n        // if textline enabled then covert to a String which must be used for textline\n        if (producer.getConfiguration().isTextline()) {\n            body = producer.getContext().getTypeConverter().mandatoryConvertTo(String.class, exchange, body);\n        }\n\n        // set the result on either IN or OUT on the original exchange depending on its pattern\n        if (ExchangeHelper.isOutCapable(exchange)) {\n            NettyPayloadHelper.setOut(exchange, body);\n            return exchange.getOut();\n        } else {\n            NettyPayloadHelper.setIn(exchange, body);\n            return exchange.getIn();\n        }\n    }",
            " 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220 +\n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  ",
            "    /**\n     * Gets the Camel {@link Message} to use as the message to be set on the current {@link Exchange} when\n     * we have received a reply message.\n     * <p/>\n     *\n     * @param exchange      the current exchange\n     * @param messageEvent  the incoming event which has the response message from Netty.\n     * @return the Camel {@link Message} to set on the current {@link Exchange} as the response message.\n     * @throws Exception is thrown if error getting the response message\n     */\n    protected Message getResponseMessage(Exchange exchange, MessageEvent messageEvent) throws Exception {\n        Object body = messageEvent.getMessage();\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Channel: {} received body: {}\", messageEvent.getChannel(), body);\n        }\n\n        // if textline enabled then covert to a String which must be used for textline\n        if (producer.getConfiguration().isTextline()) {\n            body = producer.getContext().getTypeConverter().mandatoryConvertTo(String.class, exchange, body);\n        }\n\n        // set the result on either IN or OUT on the original exchange depending on its pattern\n        if (ExchangeHelper.isOutCapable(exchange)) {\n            NettyPayloadHelper.setOut(exchange, body);\n            return exchange.getOut();\n        } else {\n            NettyPayloadHelper.setIn(exchange, body);\n            return exchange.getIn();\n        }\n    }"
        ],
        [
            "CamelNamespaceHandler::autoRegisterBeanDefinition(String,BeanDefinition,ParserContext,String)",
            " 667  \n 668  \n 669  \n 670  \n 671  \n 672  \n 673  \n 674  \n 675  \n 676  \n 677  \n 678  \n 679  \n 680 -\n 681  \n 682  \n 683  \n 684  \n 685  \n 686  \n 687  \n 688  \n 689  \n 690  \n 691  \n 692  ",
            "    private void autoRegisterBeanDefinition(String id, BeanDefinition definition, ParserContext parserContext, String contextId) {\n        // it is a bit cumbersome to work with the spring bean definition parser\n        // as we kinda need to eagerly register the bean definition on the parser context\n        // and then later we might find out that we should not have done that in case we have multiple camel contexts\n        // that would have a id clash by auto registering the same bean definition with the same id such as a producer template\n\n        // see if we have already auto registered this id\n        BeanDefinition existing = autoRegisterMap.get(id);\n        if (existing == null) {\n            // no then add it to the map and register it\n            autoRegisterMap.put(id, definition);\n            parserContext.registerComponent(new BeanComponentDefinition(definition, id));\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Registered default: {} with id: {} on camel context: {}\", new Object[]{definition.getBeanClassName(), id, contextId});\n            }\n        } else {\n            // ups we have already registered it before with same id, but on another camel context\n            // this is not good so we need to remove all traces of this auto registering.\n            // end user must manually add the needed XML elements and provide unique ids access all camel context himself.\n            LOG.debug(\"Unregistered default: {} with id: {} as we have multiple camel contexts and they must use unique ids.\"\n                    + \" You must define the definition in the XML file manually to avoid id clashes when using multiple camel contexts\",\n                    definition.getBeanClassName(), id);\n\n            parserContext.getRegistry().removeBeanDefinition(id);\n        }\n    }",
            " 667  \n 668  \n 669  \n 670  \n 671  \n 672  \n 673  \n 674  \n 675  \n 676  \n 677  \n 678  \n 679  \n 680 +\n 681  \n 682  \n 683  \n 684  \n 685  \n 686  \n 687  \n 688  \n 689  \n 690  \n 691  \n 692  ",
            "    private void autoRegisterBeanDefinition(String id, BeanDefinition definition, ParserContext parserContext, String contextId) {\n        // it is a bit cumbersome to work with the spring bean definition parser\n        // as we kinda need to eagerly register the bean definition on the parser context\n        // and then later we might find out that we should not have done that in case we have multiple camel contexts\n        // that would have a id clash by auto registering the same bean definition with the same id such as a producer template\n\n        // see if we have already auto registered this id\n        BeanDefinition existing = autoRegisterMap.get(id);\n        if (existing == null) {\n            // no then add it to the map and register it\n            autoRegisterMap.put(id, definition);\n            parserContext.registerComponent(new BeanComponentDefinition(definition, id));\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Registered default: {} with id: {} on camel context: {}\", definition.getBeanClassName(), id, contextId);\n            }\n        } else {\n            // ups we have already registered it before with same id, but on another camel context\n            // this is not good so we need to remove all traces of this auto registering.\n            // end user must manually add the needed XML elements and provide unique ids access all camel context himself.\n            LOG.debug(\"Unregistered default: {} with id: {} as we have multiple camel contexts and they must use unique ids.\"\n                    + \" You must define the definition in the XML file manually to avoid id clashes when using multiple camel contexts\",\n                    definition.getBeanClassName(), id);\n\n            parserContext.getRegistry().removeBeanDefinition(id);\n        }\n    }"
        ],
        [
            "MinaComponent::configureDataGramCodecFactory(String,IoServiceConfig,MinaConfiguration)",
            " 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339 -\n 340  \n 341  \n 342  \n 343  \n 344  ",
            "    /**\n     * For datagrams the entire message is available as a single ByteBuffer so lets just pass those around by default\n     * and try converting whatever they payload is into ByteBuffers unless some custom converter is specified\n     */\n    protected void configureDataGramCodecFactory(final String type, final IoServiceConfig config, final MinaConfiguration configuration) {\n        ProtocolCodecFactory codecFactory = configuration.getCodec();\n        if (codecFactory == null) {\n            codecFactory = new MinaUdpProtocolCodecFactory(getCamelContext());\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"{}: Using CodecFactory: {}\", new Object[]{type, codecFactory});\n            }\n        }\n\n        addCodecFactory(config, codecFactory);\n    }",
            " 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339 +\n 340  \n 341  \n 342  \n 343  \n 344  ",
            "    /**\n     * For datagrams the entire message is available as a single ByteBuffer so lets just pass those around by default\n     * and try converting whatever they payload is into ByteBuffers unless some custom converter is specified\n     */\n    protected void configureDataGramCodecFactory(final String type, final IoServiceConfig config, final MinaConfiguration configuration) {\n        ProtocolCodecFactory codecFactory = configuration.getCodec();\n        if (codecFactory == null) {\n            codecFactory = new MinaUdpProtocolCodecFactory(getCamelContext());\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"{}: Using CodecFactory: {}\", type, codecFactory);\n            }\n        }\n\n        addCodecFactory(config, codecFactory);\n    }"
        ],
        [
            "Mina2Producer::configureDataGramCodecFactory(String,IoService,Mina2Configuration)",
            " 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411 -\n 412  \n 413  \n 414  \n 415  \n 416  ",
            "    /**\n     * For datagrams the entire message is available as a single IoBuffer so lets just pass those around by default\n     * and try converting whatever they payload is into IoBuffer unless some custom converter is specified\n     */\n    protected void configureDataGramCodecFactory(final String type, final IoService service, final Mina2Configuration configuration) {\n        ProtocolCodecFactory codecFactory = configuration.getCodec();\n        if (codecFactory == null) {\n            codecFactory = new Mina2UdpProtocolCodecFactory(this.getEndpoint().getCamelContext());\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"{}: Using CodecFactory: {}\", new Object[]{type, codecFactory});\n            }\n        }\n\n        addCodecFactory(service, codecFactory);\n    }",
            " 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411 +\n 412  \n 413  \n 414  \n 415  \n 416  ",
            "    /**\n     * For datagrams the entire message is available as a single IoBuffer so lets just pass those around by default\n     * and try converting whatever they payload is into IoBuffer unless some custom converter is specified\n     */\n    protected void configureDataGramCodecFactory(final String type, final IoService service, final Mina2Configuration configuration) {\n        ProtocolCodecFactory codecFactory = configuration.getCodec();\n        if (codecFactory == null) {\n            codecFactory = new Mina2UdpProtocolCodecFactory(this.getEndpoint().getCamelContext());\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"{}: Using CodecFactory: {}\", type, codecFactory);\n            }\n        }\n\n        addCodecFactory(service, codecFactory);\n    }"
        ],
        [
            "PGPDataFormatUtil::findSecretKeysWithPrivateKeyAndUserId(Map,String,PGPSecretKeyRingCollection)",
            " 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421 -\n 422 -\n 423  \n 424  \n 425  \n 426  \n 427  \n 428  \n 429  \n 430  \n 431  \n 432  \n 433  \n 434  \n 435  \n 436  \n 437  \n 438  \n 439  \n 440  ",
            "    public static List<PGPSecretKeyAndPrivateKeyAndUserId> findSecretKeysWithPrivateKeyAndUserId(Map<String, String> sigKeyUserId2Password,\n            String provider, PGPSecretKeyRingCollection pgpSec) throws PGPException {\n        List<PGPSecretKeyAndPrivateKeyAndUserId> result = new ArrayList<>(sigKeyUserId2Password.size());\n        for (Iterator<?> i = pgpSec.getKeyRings(); i.hasNext();) {\n            Object data = i.next();\n            if (data instanceof PGPSecretKeyRing) {\n                PGPSecretKeyRing keyring = (PGPSecretKeyRing) data;\n                PGPSecretKey primaryKey = keyring.getSecretKey();\n                List<String> useridParts = new ArrayList<>(sigKeyUserId2Password.keySet());\n                String[] foundKeyUserIdForUserIdPart = findFirstKeyUserIdContainingOneOfTheParts(useridParts, primaryKey.getPublicKey());\n                if (foundKeyUserIdForUserIdPart == null) {\n                    LOG.debug(\"No User ID found in primary key with key ID {} containing one of the parts {}\", primaryKey.getKeyID(),\n                            useridParts);\n                    continue;\n                }\n                LOG.debug(\"User ID {} found in primary key with key ID {} containing one of the parts {}\", new Object[] {\n                    foundKeyUserIdForUserIdPart[0], primaryKey.getKeyID(), useridParts });\n                // add all signing keys\n                for (Iterator<PGPSecretKey> iterKey = keyring.getSecretKeys(); iterKey.hasNext();) {\n                    PGPSecretKey secKey = iterKey.next();\n                    if (isSigningKey(secKey)) {\n                        PGPPrivateKey privateKey = secKey.extractPrivateKey(new JcePBESecretKeyDecryptorBuilder().setProvider(provider)\n                                .build(sigKeyUserId2Password.get(foundKeyUserIdForUserIdPart[1]).toCharArray()));\n                        if (privateKey != null) {\n                            result.add(new PGPSecretKeyAndPrivateKeyAndUserId(secKey, privateKey, foundKeyUserIdForUserIdPart[0]));\n                            LOG.debug(\"Private key with user ID {} and key ID {} added to the signing keys\",\n                                    foundKeyUserIdForUserIdPart[0], Long.toString(privateKey.getKeyID()));\n\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }",
            " 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421 +\n 422 +\n 423  \n 424  \n 425  \n 426  \n 427  \n 428  \n 429  \n 430  \n 431  \n 432  \n 433  \n 434  \n 435  \n 436  \n 437  \n 438  \n 439  \n 440  ",
            "    public static List<PGPSecretKeyAndPrivateKeyAndUserId> findSecretKeysWithPrivateKeyAndUserId(Map<String, String> sigKeyUserId2Password,\n            String provider, PGPSecretKeyRingCollection pgpSec) throws PGPException {\n        List<PGPSecretKeyAndPrivateKeyAndUserId> result = new ArrayList<>(sigKeyUserId2Password.size());\n        for (Iterator<?> i = pgpSec.getKeyRings(); i.hasNext();) {\n            Object data = i.next();\n            if (data instanceof PGPSecretKeyRing) {\n                PGPSecretKeyRing keyring = (PGPSecretKeyRing) data;\n                PGPSecretKey primaryKey = keyring.getSecretKey();\n                List<String> useridParts = new ArrayList<>(sigKeyUserId2Password.keySet());\n                String[] foundKeyUserIdForUserIdPart = findFirstKeyUserIdContainingOneOfTheParts(useridParts, primaryKey.getPublicKey());\n                if (foundKeyUserIdForUserIdPart == null) {\n                    LOG.debug(\"No User ID found in primary key with key ID {} containing one of the parts {}\", primaryKey.getKeyID(),\n                            useridParts);\n                    continue;\n                }\n                LOG.debug(\"User ID {} found in primary key with key ID {} containing one of the parts {}\",\n                    foundKeyUserIdForUserIdPart[0], primaryKey.getKeyID(), useridParts);\n                // add all signing keys\n                for (Iterator<PGPSecretKey> iterKey = keyring.getSecretKeys(); iterKey.hasNext();) {\n                    PGPSecretKey secKey = iterKey.next();\n                    if (isSigningKey(secKey)) {\n                        PGPPrivateKey privateKey = secKey.extractPrivateKey(new JcePBESecretKeyDecryptorBuilder().setProvider(provider)\n                                .build(sigKeyUserId2Password.get(foundKeyUserIdForUserIdPart[1]).toCharArray()));\n                        if (privateKey != null) {\n                            result.add(new PGPSecretKeyAndPrivateKeyAndUserId(secKey, privateKey, foundKeyUserIdForUserIdPart[0]));\n                            LOG.debug(\"Private key with user ID {} and key ID {} added to the signing keys\",\n                                    foundKeyUserIdForUserIdPart[0], Long.toString(privateKey.getKeyID()));\n\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }"
        ],
        [
            "BindyKeyValuePairFactory::initAnnotatedFields()",
            "  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96 -\n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  ",
            "    @Override\n    public void initAnnotatedFields() {\n\n        for (Class<?> cl : models) {\n\n            List<Field> linkFields = new ArrayList<>();\n\n            for (Field field : cl.getDeclaredFields()) {\n                KeyValuePairField keyValuePairField = field.getAnnotation(KeyValuePairField.class);\n                if (keyValuePairField != null) {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Key declared in the class : {}, key : {}, Field : {}\", new Object[]{cl.getName(), keyValuePairField.tag(), keyValuePairField});\n                    }\n                    keyValuePairFields.put(keyValuePairField.tag(), keyValuePairField);\n                    annotatedFields.put(keyValuePairField.tag(), field);\n                }\n\n                Link linkField = field.getAnnotation(Link.class);\n\n                if (linkField != null) {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Class linked  : {}, Field {}\", cl.getName(), field);\n                    }\n                    linkFields.add(field);\n                }\n            }\n\n            if (!linkFields.isEmpty()) {\n                annotatedLinkFields.put(cl.getName(), linkFields);\n            }\n\n        }\n    }",
            "  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96 +\n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  ",
            "    @Override\n    public void initAnnotatedFields() {\n\n        for (Class<?> cl : models) {\n\n            List<Field> linkFields = new ArrayList<>();\n\n            for (Field field : cl.getDeclaredFields()) {\n                KeyValuePairField keyValuePairField = field.getAnnotation(KeyValuePairField.class);\n                if (keyValuePairField != null) {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Key declared in the class : {}, key : {}, Field : {}\", cl.getName(), keyValuePairField.tag(), keyValuePairField);\n                    }\n                    keyValuePairFields.put(keyValuePairField.tag(), keyValuePairField);\n                    annotatedFields.put(keyValuePairField.tag(), field);\n                }\n\n                Link linkField = field.getAnnotation(Link.class);\n\n                if (linkField != null) {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Class linked  : {}, Field {}\", cl.getName(), field);\n                    }\n                    linkFields.add(field);\n                }\n            }\n\n            if (!linkFields.isEmpty()) {\n                annotatedLinkFields.put(cl.getName(), linkFields);\n            }\n\n        }\n    }"
        ],
        [
            "PgEventConsumer::notification(int,String,String)",
            "  55  \n  56  \n  57 -\n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  ",
            "    public void notification(int processId, String channel, String payload) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Notification processId: {}, channel: {}, payload: {}\", new Object[]{processId, channel, payload});\n        }\n\n        Exchange exchange = endpoint.createExchange();\n        Message msg = exchange.getIn();\n        msg.setHeader(\"channel\", channel);\n        msg.setBody(payload);\n\n        try {\n            getProcessor().process(exchange);\n        } catch (Exception ex) {\n            String cause = \"Unable to process incoming notification from PostgreSQL: processId='\" + processId + \"', channel='\" + channel + \"', payload='\" + payload + \"'\";\n            getExceptionHandler().handleException(cause, ex);\n        }\n    }",
            "  55  \n  56  \n  57 +\n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  ",
            "    public void notification(int processId, String channel, String payload) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Notification processId: {}, channel: {}, payload: {}\", processId, channel, payload);\n        }\n\n        Exchange exchange = endpoint.createExchange();\n        Message msg = exchange.getIn();\n        msg.setHeader(\"channel\", channel);\n        msg.setBody(payload);\n\n        try {\n            getProcessor().process(exchange);\n        } catch (Exception ex) {\n            String cause = \"Unable to process incoming notification from PostgreSQL: processId='\" + processId + \"', channel='\" + channel + \"', payload='\" + payload + \"'\";\n            getExceptionHandler().handleException(cause, ex);\n        }\n    }"
        ],
        [
            "ClientChannelHandler::getResponseMessage(Exchange,ChannelHandlerContext,Object)",
            " 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236 -\n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  ",
            "    /**\n     * Gets the Camel {@link Message} to use as the message to be set on the current {@link Exchange} when\n     * we have received a reply message.\n     * <p/>\n     *\n     * @param exchange      the current exchange\n     * @param ctx       the channel handler context\n     * @param message  the incoming event which has the response message from Netty.\n     * @return the Camel {@link Message} to set on the current {@link Exchange} as the response message.\n     * @throws Exception is thrown if error getting the response message\n     */\n    protected Message getResponseMessage(Exchange exchange, ChannelHandlerContext ctx, Object message) throws Exception {\n        Object body = message;\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Channel: {} received body: {}\", new Object[]{ctx.channel(), body});\n        }\n\n        // if textline enabled then covert to a String which must be used for textline\n        if (producer.getConfiguration().isTextline()) {\n            body = producer.getContext().getTypeConverter().mandatoryConvertTo(String.class, exchange, message);\n        }\n\n        // set the result on either IN or OUT on the original exchange depending on its pattern\n        if (ExchangeHelper.isOutCapable(exchange)) {\n            NettyPayloadHelper.setOut(exchange, body);\n            return exchange.getOut();\n        } else {\n            NettyPayloadHelper.setIn(exchange, body);\n            return exchange.getIn();\n        }\n    }",
            " 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236 +\n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  ",
            "    /**\n     * Gets the Camel {@link Message} to use as the message to be set on the current {@link Exchange} when\n     * we have received a reply message.\n     * <p/>\n     *\n     * @param exchange      the current exchange\n     * @param ctx       the channel handler context\n     * @param message  the incoming event which has the response message from Netty.\n     * @return the Camel {@link Message} to set on the current {@link Exchange} as the response message.\n     * @throws Exception is thrown if error getting the response message\n     */\n    protected Message getResponseMessage(Exchange exchange, ChannelHandlerContext ctx, Object message) throws Exception {\n        Object body = message;\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Channel: {} received body: {}\", ctx.channel(), body);\n        }\n\n        // if textline enabled then covert to a String which must be used for textline\n        if (producer.getConfiguration().isTextline()) {\n            body = producer.getContext().getTypeConverter().mandatoryConvertTo(String.class, exchange, message);\n        }\n\n        // set the result on either IN or OUT on the original exchange depending on its pattern\n        if (ExchangeHelper.isOutCapable(exchange)) {\n            NettyPayloadHelper.setOut(exchange, body);\n            return exchange.getOut();\n        } else {\n            NettyPayloadHelper.setIn(exchange, body);\n            return exchange.getIn();\n        }\n    }"
        ],
        [
            "BindyCsvFactory::setDataFieldValue(CamelContext,Map,int,int,int,String,DataField)",
            " 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226 -\n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  ",
            "    private int setDataFieldValue(CamelContext camelContext, Map<String, Object> model, int line, int pos, int counterMandatoryFields, String data, DataField dataField) throws Exception {\n        ObjectHelper.notNull(dataField, \"No position \" + pos + \" defined for the field: \" + data + \", line: \" + line);\n\n        if (dataField.trim()) {\n            data = data.trim();\n        }\n\n        if (dataField.required()) {\n            // Increment counter of mandatory fields\n            ++counterMandatoryFields;\n\n            // Check if content of the field is empty\n            // This is not possible for mandatory fields\n            if (data.equals(\"\")) {\n                throw new IllegalArgumentException(\"The mandatory field defined at the position \" + pos + \" is empty for the line: \" + line);\n            }\n        }\n\n        // Get Field to be setted\n        Field field = annotatedFields.get(pos);\n        field.setAccessible(true);\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Pos: {}, Data: {}, Field type: {}\", new Object[]{pos, data, field.getType()});\n        }\n\n        // Create format object to format the field\n        FormattingOptions formattingOptions = ConverterUtils.convert(dataField,\n                field.getType(),\n                field.getAnnotation(BindyConverter.class),\n                getLocale());\n        Format<?> format = formatFactory.getFormat(formattingOptions);\n\n        // field object to be set\n        Object modelField = model.get(field.getDeclaringClass().getName());\n\n        // format the data received\n        Object value = null;\n\n        if (!data.equals(\"\")) {\n            try {\n                if (quoting && quote != null && (data.contains(\"\\\\\" + quote) || data.contains(quote)) && quotingEscaped) {\n                    value = format.parse(data.replaceAll(\"\\\\\\\\\" + quote, \"\\\\\" + quote));\n                } else if (quote != null && quote.equals(DOUBLE_QUOTES_SYMBOL) && data.contains(DOUBLE_QUOTES_SYMBOL + DOUBLE_QUOTES_SYMBOL) && !quotingEscaped) {\n                    // If double-quotes are used to enclose fields, the two double \n                    // quotes character must be replaced with one according to RFC 4180 section 2.7\n                    value = format.parse(data.replaceAll(DOUBLE_QUOTES_SYMBOL + DOUBLE_QUOTES_SYMBOL, DOUBLE_QUOTES_SYMBOL));\n                } else {\n                    value = format.parse(data);\n                }\n            } catch (FormatException ie) {\n                throw new IllegalArgumentException(ie.getMessage() + \", position: \" + pos + \", line: \" + line, ie);\n            } catch (Exception e) {\n                throw new IllegalArgumentException(\"Parsing error detected for field defined at the position: \" + pos + \", line: \" + line, e);\n            }\n        } else {\n            if (!dataField.defaultValue().isEmpty()) {\n                value = format.parse(dataField.defaultValue());\n            } else {\n                value = getDefaultValueForPrimitive(field.getType());\n            }\n        }\n\n        if (value != null && !dataField.method().isEmpty()) {\n            Class<?> clazz;\n            if (dataField.method().contains(\".\")) {\n                clazz = camelContext.getClassResolver().resolveMandatoryClass(dataField.method().substring(0, dataField.method().lastIndexOf(\".\")));\n            } else {\n                clazz = field.getType();\n            }\n\n            String methodName = dataField.method().substring(dataField.method().lastIndexOf(\".\") + 1,\n                    dataField.method().length());\n\n            Method m = ReflectionHelper.findMethod(clazz, methodName, field.getType());\n            if (m != null) {\n                // this method must be static and return type\n                // must be the same as the datafield and \n                // must receive only the datafield value \n                // as the method argument\n                value = ObjectHelper.invokeMethod(m, null, value);\n            } else {\n                // fallback to method without parameter, that is on the value itself\n                m = ReflectionHelper.findMethod(clazz, methodName);\n                value = ObjectHelper.invokeMethod(m, value);\n            }\n        }\n\n        field.set(modelField, value);\n        return counterMandatoryFields;\n    }",
            " 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226 +\n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  ",
            "    private int setDataFieldValue(CamelContext camelContext, Map<String, Object> model, int line, int pos, int counterMandatoryFields, String data, DataField dataField) throws Exception {\n        ObjectHelper.notNull(dataField, \"No position \" + pos + \" defined for the field: \" + data + \", line: \" + line);\n\n        if (dataField.trim()) {\n            data = data.trim();\n        }\n\n        if (dataField.required()) {\n            // Increment counter of mandatory fields\n            ++counterMandatoryFields;\n\n            // Check if content of the field is empty\n            // This is not possible for mandatory fields\n            if (data.equals(\"\")) {\n                throw new IllegalArgumentException(\"The mandatory field defined at the position \" + pos + \" is empty for the line: \" + line);\n            }\n        }\n\n        // Get Field to be setted\n        Field field = annotatedFields.get(pos);\n        field.setAccessible(true);\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Pos: {}, Data: {}, Field type: {}\", pos, data, field.getType());\n        }\n\n        // Create format object to format the field\n        FormattingOptions formattingOptions = ConverterUtils.convert(dataField,\n                field.getType(),\n                field.getAnnotation(BindyConverter.class),\n                getLocale());\n        Format<?> format = formatFactory.getFormat(formattingOptions);\n\n        // field object to be set\n        Object modelField = model.get(field.getDeclaringClass().getName());\n\n        // format the data received\n        Object value = null;\n\n        if (!data.equals(\"\")) {\n            try {\n                if (quoting && quote != null && (data.contains(\"\\\\\" + quote) || data.contains(quote)) && quotingEscaped) {\n                    value = format.parse(data.replaceAll(\"\\\\\\\\\" + quote, \"\\\\\" + quote));\n                } else if (quote != null && quote.equals(DOUBLE_QUOTES_SYMBOL) && data.contains(DOUBLE_QUOTES_SYMBOL + DOUBLE_QUOTES_SYMBOL) && !quotingEscaped) {\n                    // If double-quotes are used to enclose fields, the two double \n                    // quotes character must be replaced with one according to RFC 4180 section 2.7\n                    value = format.parse(data.replaceAll(DOUBLE_QUOTES_SYMBOL + DOUBLE_QUOTES_SYMBOL, DOUBLE_QUOTES_SYMBOL));\n                } else {\n                    value = format.parse(data);\n                }\n            } catch (FormatException ie) {\n                throw new IllegalArgumentException(ie.getMessage() + \", position: \" + pos + \", line: \" + line, ie);\n            } catch (Exception e) {\n                throw new IllegalArgumentException(\"Parsing error detected for field defined at the position: \" + pos + \", line: \" + line, e);\n            }\n        } else {\n            if (!dataField.defaultValue().isEmpty()) {\n                value = format.parse(dataField.defaultValue());\n            } else {\n                value = getDefaultValueForPrimitive(field.getType());\n            }\n        }\n\n        if (value != null && !dataField.method().isEmpty()) {\n            Class<?> clazz;\n            if (dataField.method().contains(\".\")) {\n                clazz = camelContext.getClassResolver().resolveMandatoryClass(dataField.method().substring(0, dataField.method().lastIndexOf(\".\")));\n            } else {\n                clazz = field.getType();\n            }\n\n            String methodName = dataField.method().substring(dataField.method().lastIndexOf(\".\") + 1,\n                    dataField.method().length());\n\n            Method m = ReflectionHelper.findMethod(clazz, methodName, field.getType());\n            if (m != null) {\n                // this method must be static and return type\n                // must be the same as the datafield and \n                // must receive only the datafield value \n                // as the method argument\n                value = ObjectHelper.invokeMethod(m, null, value);\n            } else {\n                // fallback to method without parameter, that is on the value itself\n                m = ReflectionHelper.findMethod(clazz, methodName);\n                value = ObjectHelper.invokeMethod(m, value);\n            }\n        }\n\n        field.set(modelField, value);\n        return counterMandatoryFields;\n    }"
        ],
        [
            "RestSwaggerProcessor::process(Exchange)",
            "  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112 -\n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  ",
            "    @Override\n    public void process(Exchange exchange) throws Exception {\n\n        String contextId = exchange.getContext().getName();\n        String route = exchange.getIn().getHeader(Exchange.HTTP_PATH, String.class);\n        String accept = exchange.getIn().getHeader(\"Accept\", String.class);\n\n        RestApiResponseAdapter adapter = new ExchangeRestApiResponseAdapter(exchange);\n\n        // whether to use json or yaml\n        boolean json = false;\n        boolean yaml = false;\n        if (route != null && route.endsWith(\"/swagger.json\")) {\n            json = true;\n            route = route.substring(0, route.length() - 13);\n        } else if (route != null && route.endsWith(\"/swagger.yaml\")) {\n            yaml = true;\n            route = route.substring(0, route.length() - 13);\n        }\n        if (accept != null && !json && !yaml) {\n            json = accept.toLowerCase(Locale.US).contains(\"json\");\n            yaml = accept.toLowerCase(Locale.US).contains(\"yaml\");\n        }\n        if (!json && !yaml) {\n            // json is default\n            json = true;\n        }\n\n        try {\n            // render list of camel contexts as root\n            if (contextIdListing && (ObjectHelper.isEmpty(route) || route.equals(\"/\"))) {\n                support.renderCamelContexts(adapter, contextId, contextIdPattern, json, yaml, configuration);\n            } else {\n                String name;\n                if (ObjectHelper.isNotEmpty(route)) {\n                    // first part is the camel context\n                    if (route.startsWith(\"/\")) {\n                        route = route.substring(1);\n                    }\n                    // the remainder is the route part\n                    name = route.split(\"/\")[0];\n                    if (route.startsWith(contextId)) {\n                        route = route.substring(name.length());\n                    }\n                } else {\n                    // listing not enabled then get current camel context as the name\n                    name = exchange.getContext().getName();\n                }\n\n                boolean match = true;\n                if (contextIdPattern != null) {\n                    if (\"#name#\".equals(contextIdPattern)) {\n                        match = name.equals(contextId);\n                    } else {\n                        match = EndpointHelper.matchPattern(name, contextIdPattern);\n                    }\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Match contextId: {} with pattern: {} -> {}\", new Object[]{name, contextIdPattern, match});\n                    }\n                }\n\n                if (!match) {\n                    adapter.noContent();\n                } else {\n                    support.renderResourceListing(adapter, swaggerConfig, name, route, json, yaml, exchange.getContext().getClassResolver(), configuration);\n                }\n            }\n        } catch (Exception e) {\n            LOG.warn(\"Error rendering Swagger API due \" + e.getMessage(), e);\n        }\n    }",
            "  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112 +\n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  ",
            "    @Override\n    public void process(Exchange exchange) throws Exception {\n\n        String contextId = exchange.getContext().getName();\n        String route = exchange.getIn().getHeader(Exchange.HTTP_PATH, String.class);\n        String accept = exchange.getIn().getHeader(\"Accept\", String.class);\n\n        RestApiResponseAdapter adapter = new ExchangeRestApiResponseAdapter(exchange);\n\n        // whether to use json or yaml\n        boolean json = false;\n        boolean yaml = false;\n        if (route != null && route.endsWith(\"/swagger.json\")) {\n            json = true;\n            route = route.substring(0, route.length() - 13);\n        } else if (route != null && route.endsWith(\"/swagger.yaml\")) {\n            yaml = true;\n            route = route.substring(0, route.length() - 13);\n        }\n        if (accept != null && !json && !yaml) {\n            json = accept.toLowerCase(Locale.US).contains(\"json\");\n            yaml = accept.toLowerCase(Locale.US).contains(\"yaml\");\n        }\n        if (!json && !yaml) {\n            // json is default\n            json = true;\n        }\n\n        try {\n            // render list of camel contexts as root\n            if (contextIdListing && (ObjectHelper.isEmpty(route) || route.equals(\"/\"))) {\n                support.renderCamelContexts(adapter, contextId, contextIdPattern, json, yaml, configuration);\n            } else {\n                String name;\n                if (ObjectHelper.isNotEmpty(route)) {\n                    // first part is the camel context\n                    if (route.startsWith(\"/\")) {\n                        route = route.substring(1);\n                    }\n                    // the remainder is the route part\n                    name = route.split(\"/\")[0];\n                    if (route.startsWith(contextId)) {\n                        route = route.substring(name.length());\n                    }\n                } else {\n                    // listing not enabled then get current camel context as the name\n                    name = exchange.getContext().getName();\n                }\n\n                boolean match = true;\n                if (contextIdPattern != null) {\n                    if (\"#name#\".equals(contextIdPattern)) {\n                        match = name.equals(contextId);\n                    } else {\n                        match = EndpointHelper.matchPattern(name, contextIdPattern);\n                    }\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Match contextId: {} with pattern: {} -> {}\", name, contextIdPattern, match);\n                    }\n                }\n\n                if (!match) {\n                    adapter.noContent();\n                } else {\n                    support.renderResourceListing(adapter, swaggerConfig, name, route, json, yaml, exchange.getContext().getClassResolver(), configuration);\n                }\n            }\n        } catch (Exception e) {\n            LOG.warn(\"Error rendering Swagger API due \" + e.getMessage(), e);\n        }\n    }"
        ],
        [
            "MailConsumer::createExchanges(List)",
            " 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344  \n 345  \n 346 -\n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  ",
            "    protected Queue<Exchange> createExchanges(List<KeyValueHolder<String, Message>> messages) throws MessagingException {\n        Queue<Exchange> answer = new LinkedList<>();\n\n        int fetchSize = getEndpoint().getConfiguration().getFetchSize();\n        int count = fetchSize == -1 ? messages.size() : Math.min(fetchSize, messages.size());\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Fetching {} messages. Total {} messages.\", count, messages.size());\n        }\n\n        for (int i = 0; i < count; i++) {\n            try {\n                KeyValueHolder<String, Message> holder = messages.get(i);\n                String key = holder.getKey();\n                Message message = holder.getValue();\n\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"Mail #{} is of type: {} - {}\", new Object[]{i, ObjectHelper.classCanonicalName(message), message});\n                }\n\n                if (!message.getFlags().contains(Flags.Flag.DELETED)) {\n                    Exchange exchange = getEndpoint().createExchange(message);\n                    if (getEndpoint().getConfiguration().isMapMailMessage()) {\n                        // ensure the mail message is mapped, which can be ensured by touching the body/header/attachment\n                        LOG.trace(\"Mapping #{} from javax.mail.Message to Camel MailMessage\", i);\n                        exchange.getIn().getBody();\n                        exchange.getIn().getHeaders();\n                        exchange.getIn().getAttachments();\n                    }\n\n                    // If the protocol is POP3 we need to remember the uid on the exchange\n                    // so we can find the mail message again later to be able to delete it\n                    // we also need to remember the UUID for idempotent repository\n                    exchange.setProperty(MAIL_MESSAGE_UID, key);\n\n                    answer.add(exchange);\n                } else {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Skipping message as it was flagged as deleted: {}\", MailUtils.dumpMessage(message));\n                    }\n                }\n            } catch (Exception e) {\n                if (skipFailedMessage) {\n                    LOG.debug(\"Skipping failed message at index \" + i + \" due \" + e.getMessage(), e);\n                } else if (handleFailedMessage) {\n                    handleException(e);\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        return answer;\n    }",
            " 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344  \n 345  \n 346 +\n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  ",
            "    protected Queue<Exchange> createExchanges(List<KeyValueHolder<String, Message>> messages) throws MessagingException {\n        Queue<Exchange> answer = new LinkedList<>();\n\n        int fetchSize = getEndpoint().getConfiguration().getFetchSize();\n        int count = fetchSize == -1 ? messages.size() : Math.min(fetchSize, messages.size());\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Fetching {} messages. Total {} messages.\", count, messages.size());\n        }\n\n        for (int i = 0; i < count; i++) {\n            try {\n                KeyValueHolder<String, Message> holder = messages.get(i);\n                String key = holder.getKey();\n                Message message = holder.getValue();\n\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"Mail #{} is of type: {} - {}\", i, ObjectHelper.classCanonicalName(message), message);\n                }\n\n                if (!message.getFlags().contains(Flags.Flag.DELETED)) {\n                    Exchange exchange = getEndpoint().createExchange(message);\n                    if (getEndpoint().getConfiguration().isMapMailMessage()) {\n                        // ensure the mail message is mapped, which can be ensured by touching the body/header/attachment\n                        LOG.trace(\"Mapping #{} from javax.mail.Message to Camel MailMessage\", i);\n                        exchange.getIn().getBody();\n                        exchange.getIn().getHeaders();\n                        exchange.getIn().getAttachments();\n                    }\n\n                    // If the protocol is POP3 we need to remember the uid on the exchange\n                    // so we can find the mail message again later to be able to delete it\n                    // we also need to remember the UUID for idempotent repository\n                    exchange.setProperty(MAIL_MESSAGE_UID, key);\n\n                    answer.add(exchange);\n                } else {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Skipping message as it was flagged as deleted: {}\", MailUtils.dumpMessage(message));\n                    }\n                }\n            } catch (Exception e) {\n                if (skipFailedMessage) {\n                    LOG.debug(\"Skipping failed message at index \" + i + \" due \" + e.getMessage(), e);\n                } else if (handleFailedMessage) {\n                    handleException(e);\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        return answer;\n    }"
        ],
        [
            "TransactionErrorHandler::logTransactionCommit(String,String)",
            " 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263 -\n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270 -\n 271  ",
            "    /**\n     * Logs the transaction commit\n     */\n    private void logTransactionCommit(String redelivered, String ids) {\n        if (\"true\".equals(redelivered)) {\n            // okay its a redelivered message so log at INFO level if rollbackLoggingLevel is INFO or higher\n            // this allows people to know that the redelivered message was committed this time\n            if (rollbackLoggingLevel == LoggingLevel.INFO || rollbackLoggingLevel == LoggingLevel.WARN || rollbackLoggingLevel == LoggingLevel.ERROR) {\n                log.info(\"Transaction commit ({}) redelivered({}) for {})\", new Object[]{transactionKey, redelivered, ids});\n                // return after we have logged\n                return;\n            }\n        }\n\n        // log non redelivered by default at DEBUG level\n        log.debug(\"Transaction commit ({}) redelivered({}) for {})\", new Object[]{transactionKey, redelivered, ids});\n    }",
            " 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263 +\n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270 +\n 271  ",
            "    /**\n     * Logs the transaction commit\n     */\n    private void logTransactionCommit(String redelivered, String ids) {\n        if (\"true\".equals(redelivered)) {\n            // okay its a redelivered message so log at INFO level if rollbackLoggingLevel is INFO or higher\n            // this allows people to know that the redelivered message was committed this time\n            if (rollbackLoggingLevel == LoggingLevel.INFO || rollbackLoggingLevel == LoggingLevel.WARN || rollbackLoggingLevel == LoggingLevel.ERROR) {\n                log.info(\"Transaction commit ({}) redelivered({}) for {})\", transactionKey, redelivered, ids);\n                // return after we have logged\n                return;\n            }\n        }\n\n        // log non redelivered by default at DEBUG level\n        log.debug(\"Transaction commit ({}) redelivered({}) for {})\", transactionKey, redelivered, ids);\n    }"
        ],
        [
            "EndpointMessageListener::sendReply(Destination,Message,Exchange,org,Exception)",
            " 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377 -\n 378  \n 379  \n 380  \n 381  \n 382  ",
            "    protected void sendReply(Destination replyDestination, final Message message, final Exchange exchange,\n                             final org.apache.camel.Message out, final Exception cause) {\n        if (replyDestination == null) {\n            LOG.debug(\"Cannot send reply message as there is no replyDestination for: {}\", out);\n            return;\n        }\n        getTemplate().send(replyDestination, new MessageCreator() {\n            public Message createMessage(Session session) throws JMSException {\n                Message reply = endpoint.getBinding().makeJmsMessage(exchange, out, session, cause);\n                final String correlationID = determineCorrelationId(message);\n                reply.setJMSCorrelationID(correlationID);\n\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"{} sending reply JMS message [correlationId:{}]: {}\", new Object[]{endpoint, correlationID, reply});\n                }\n                return reply;\n            }\n        });\n    }",
            " 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377 +\n 378  \n 379  \n 380  \n 381  \n 382  ",
            "    protected void sendReply(Destination replyDestination, final Message message, final Exchange exchange,\n                             final org.apache.camel.Message out, final Exception cause) {\n        if (replyDestination == null) {\n            LOG.debug(\"Cannot send reply message as there is no replyDestination for: {}\", out);\n            return;\n        }\n        getTemplate().send(replyDestination, new MessageCreator() {\n            public Message createMessage(Session session) throws JMSException {\n                Message reply = endpoint.getBinding().makeJmsMessage(exchange, out, session, cause);\n                final String correlationID = determineCorrelationId(message);\n                reply.setJMSCorrelationID(correlationID);\n\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"{} sending reply JMS message [correlationId:{}]: {}\", endpoint, correlationID, reply);\n                }\n                return reply;\n            }\n        });\n    }"
        ],
        [
            "ServerChannelHandler::messageReceived(ChannelHandlerContext,MessageEvent)",
            "  85  \n  86  \n  87  \n  88  \n  89 -\n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  ",
            "    @Override\n    public void messageReceived(final ChannelHandlerContext ctx, final MessageEvent messageEvent) throws Exception {\n        Object in = messageEvent.getMessage();\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Channel: {} received body: {}\", new Object[]{messageEvent.getChannel(), in});\n        }\n\n        // create Exchange and let the consumer process it\n        final Exchange exchange = consumer.getEndpoint().createExchange(ctx, messageEvent);\n\n        if (consumer.getConfiguration().isSync()) {\n            exchange.setPattern(ExchangePattern.InOut);\n        }\n        // set the exchange charset property for converting\n        if (consumer.getConfiguration().getCharsetName() != null) {\n            exchange.setProperty(Exchange.CHARSET_NAME, IOHelper.normalizeCharset(consumer.getConfiguration().getCharsetName()));\n        }\n\n        // we want to handle the UoW\n        consumer.createUoW(exchange);\n\n        beforeProcess(exchange, messageEvent);\n\n        // process accordingly to endpoint configuration\n        if (consumer.getEndpoint().isSynchronous()) {\n            processSynchronously(exchange, messageEvent);\n        } else {\n            processAsynchronously(exchange, messageEvent);\n        }\n    }",
            "  85  \n  86  \n  87  \n  88  \n  89 +\n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  ",
            "    @Override\n    public void messageReceived(final ChannelHandlerContext ctx, final MessageEvent messageEvent) throws Exception {\n        Object in = messageEvent.getMessage();\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Channel: {} received body: {}\", messageEvent.getChannel(), in);\n        }\n\n        // create Exchange and let the consumer process it\n        final Exchange exchange = consumer.getEndpoint().createExchange(ctx, messageEvent);\n\n        if (consumer.getConfiguration().isSync()) {\n            exchange.setPattern(ExchangePattern.InOut);\n        }\n        // set the exchange charset property for converting\n        if (consumer.getConfiguration().getCharsetName() != null) {\n            exchange.setProperty(Exchange.CHARSET_NAME, IOHelper.normalizeCharset(consumer.getConfiguration().getCharsetName()));\n        }\n\n        // we want to handle the UoW\n        consumer.createUoW(exchange);\n\n        beforeProcess(exchange, messageEvent);\n\n        // process accordingly to endpoint configuration\n        if (consumer.getEndpoint().isSynchronous()) {\n            processSynchronously(exchange, messageEvent);\n        } else {\n            processAsynchronously(exchange, messageEvent);\n        }\n    }"
        ],
        [
            "BindyCsvFactory::generateCsvPositionMap(Class,Object,Map)",
            " 443  \n 444  \n 445  \n 446  \n 447  \n 448  \n 449  \n 450  \n 451  \n 452  \n 453  \n 454  \n 455  \n 456  \n 457  \n 458  \n 459  \n 460  \n 461  \n 462  \n 463  \n 464  \n 465  \n 466  \n 467  \n 468  \n 469  \n 470  \n 471  \n 472  \n 473  \n 474  \n 475  \n 476  \n 477  \n 478  \n 479  \n 480  \n 481  \n 482  \n 483  \n 484  \n 485  \n 486  \n 487  \n 488  \n 489 -\n 490  \n 491  \n 492  \n 493  \n 494  \n 495  \n 496  \n 497  \n 498  \n 499  \n 500  \n 501  \n 502  \n 503  \n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512  \n 513  \n 514  \n 515  \n 516  \n 517  \n 518  \n 519  \n 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528  \n 529  \n 530  \n 531  \n 532  \n 533  \n 534  \n 535  \n 536  \n 537  \n 538  \n 539  \n 540  \n 541  \n 542  \n 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  ",
            "    /**\n     * Generate a table containing the data formatted and sorted with their position/offset\n     * If the model is Ordered than a key is created combining the annotation @Section and Position of the field\n     * If a relation @OneToMany is defined, than we iterate recursively through this function\n     * The result is placed in the Map<Integer, List> results\n     */\n    private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {\n\n        String result = \"\";\n\n        for (Field field : clazz.getDeclaredFields()) {\n\n            field.setAccessible(true);\n\n            DataField datafield = field.getAnnotation(DataField.class);\n\n            if (datafield != null) {\n\n                if (obj != null) {\n\n                    // Create format\n                    FormattingOptions formattingOptions = ConverterUtils.convert(datafield,\n                            field.getType(),\n                            field.getAnnotation(BindyConverter.class),\n                            getLocale());\n                    Format<?> format = formatFactory.getFormat(formattingOptions);\n\n                    // Get field value\n                    Object value = field.get(obj);\n\n                    // If the field value is empty, populate it with the default value\n                    if (ObjectHelper.isNotEmpty(datafield.defaultValue()) && ObjectHelper.isEmpty(value)) {\n                        value = datafield.defaultValue();\n                    }\n\n                    result = formatString(format, value);\n\n                    if (datafield.trim()) {\n                        result = result.trim();\n                    }\n\n                    if (datafield.clip() && result.length() > datafield.length()) {\n                        result = result.substring(0, datafield.length());\n                    }\n\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Value to be formatted: {}, position: {}, and its formatted value: {}\", new Object[]{value, datafield.pos(), result});\n                    }\n\n                } else {\n                    result = \"\";\n                }\n\n                Integer key;\n\n                if (isMessageOrdered() && obj != null) {\n\n                    // Generate a key using the number of the section\n                    // and the position of the field\n                    Integer key1 = sections.get(obj.getClass().getName());\n                    Integer key2 = datafield.position();\n                    Integer keyGenerated = generateKey(key1, key2);\n\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Key generated: {}, for section: {}\", String.valueOf(keyGenerated), key1);\n                    }\n\n                    key = keyGenerated;\n\n                } else {\n                    key = datafield.pos();\n                }\n\n                if (!results.containsKey(key)) {\n                    List<String> list = new LinkedList<>();\n                    list.add(result);\n                    results.put(key, list);\n                } else {\n                    List<String> list = results.get(key);\n                    list.add(result);\n                }\n\n            }\n\n            OneToMany oneToMany = field.getAnnotation(OneToMany.class);\n            if (oneToMany != null) {\n\n                // Set global variable\n                // Will be used during generation of CSV\n                isOneToMany = true;\n\n                List<?> list = (List<?>)field.get(obj);\n                if (list != null) {\n\n                    Iterator<?> it = list.iterator();\n                    while (it.hasNext()) {\n                        Object target = it.next();\n                        generateCsvPositionMap(target.getClass(), target, results);\n                    }\n\n                } else {\n\n                    // Call this function to add empty value\n                    // in the table\n                    generateCsvPositionMap(field.getClass(), null, results);\n                }\n\n            }\n        }\n\n    }",
            " 443  \n 444  \n 445  \n 446  \n 447  \n 448  \n 449  \n 450  \n 451  \n 452  \n 453  \n 454  \n 455  \n 456  \n 457  \n 458  \n 459  \n 460  \n 461  \n 462  \n 463  \n 464  \n 465  \n 466  \n 467  \n 468  \n 469  \n 470  \n 471  \n 472  \n 473  \n 474  \n 475  \n 476  \n 477  \n 478  \n 479  \n 480  \n 481  \n 482  \n 483  \n 484  \n 485  \n 486  \n 487  \n 488  \n 489 +\n 490  \n 491  \n 492  \n 493  \n 494  \n 495  \n 496  \n 497  \n 498  \n 499  \n 500  \n 501  \n 502  \n 503  \n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512  \n 513  \n 514  \n 515  \n 516  \n 517  \n 518  \n 519  \n 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528  \n 529  \n 530  \n 531  \n 532  \n 533  \n 534  \n 535  \n 536  \n 537  \n 538  \n 539  \n 540  \n 541  \n 542  \n 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  ",
            "    /**\n     * Generate a table containing the data formatted and sorted with their position/offset\n     * If the model is Ordered than a key is created combining the annotation @Section and Position of the field\n     * If a relation @OneToMany is defined, than we iterate recursively through this function\n     * The result is placed in the Map<Integer, List> results\n     */\n    private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {\n\n        String result = \"\";\n\n        for (Field field : clazz.getDeclaredFields()) {\n\n            field.setAccessible(true);\n\n            DataField datafield = field.getAnnotation(DataField.class);\n\n            if (datafield != null) {\n\n                if (obj != null) {\n\n                    // Create format\n                    FormattingOptions formattingOptions = ConverterUtils.convert(datafield,\n                            field.getType(),\n                            field.getAnnotation(BindyConverter.class),\n                            getLocale());\n                    Format<?> format = formatFactory.getFormat(formattingOptions);\n\n                    // Get field value\n                    Object value = field.get(obj);\n\n                    // If the field value is empty, populate it with the default value\n                    if (ObjectHelper.isNotEmpty(datafield.defaultValue()) && ObjectHelper.isEmpty(value)) {\n                        value = datafield.defaultValue();\n                    }\n\n                    result = formatString(format, value);\n\n                    if (datafield.trim()) {\n                        result = result.trim();\n                    }\n\n                    if (datafield.clip() && result.length() > datafield.length()) {\n                        result = result.substring(0, datafield.length());\n                    }\n\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Value to be formatted: {}, position: {}, and its formatted value: {}\", value, datafield.pos(), result);\n                    }\n\n                } else {\n                    result = \"\";\n                }\n\n                Integer key;\n\n                if (isMessageOrdered() && obj != null) {\n\n                    // Generate a key using the number of the section\n                    // and the position of the field\n                    Integer key1 = sections.get(obj.getClass().getName());\n                    Integer key2 = datafield.position();\n                    Integer keyGenerated = generateKey(key1, key2);\n\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Key generated: {}, for section: {}\", String.valueOf(keyGenerated), key1);\n                    }\n\n                    key = keyGenerated;\n\n                } else {\n                    key = datafield.pos();\n                }\n\n                if (!results.containsKey(key)) {\n                    List<String> list = new LinkedList<>();\n                    list.add(result);\n                    results.put(key, list);\n                } else {\n                    List<String> list = results.get(key);\n                    list.add(result);\n                }\n\n            }\n\n            OneToMany oneToMany = field.getAnnotation(OneToMany.class);\n            if (oneToMany != null) {\n\n                // Set global variable\n                // Will be used during generation of CSV\n                isOneToMany = true;\n\n                List<?> list = (List<?>)field.get(obj);\n                if (list != null) {\n\n                    Iterator<?> it = list.iterator();\n                    while (it.hasNext()) {\n                        Object target = it.next();\n                        generateCsvPositionMap(target.getClass(), target, results);\n                    }\n\n                } else {\n\n                    // Call this function to add empty value\n                    // in the table\n                    generateCsvPositionMap(field.getClass(), null, results);\n                }\n\n            }\n        }\n\n    }"
        ],
        [
            "BindyKeyValuePairFactory::unbind(CamelContext,Map)",
            " 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  \n 423  \n 424  \n 425  \n 426  \n 427  \n 428  \n 429  \n 430  \n 431  \n 432  \n 433  \n 434  \n 435  \n 436  \n 437  \n 438  \n 439  \n 440  \n 441  \n 442  \n 443  \n 444  \n 445  \n 446  \n 447  \n 448 -\n 449  \n 450  \n 451  \n 452  \n 453  \n 454  \n 455  \n 456  \n 457  \n 458  \n 459  \n 460  \n 461  \n 462  \n 463  \n 464  \n 465  \n 466  \n 467  \n 468  \n 469  \n 470  \n 471  \n 472  \n 473  \n 474  \n 475  \n 476  \n 477  \n 478  \n 479  \n 480  \n 481  \n 482  \n 483  \n 484  \n 485  \n 486  \n 487  \n 488  \n 489  \n 490  \n 491  \n 492  \n 493  \n 494  \n 495  \n 496 -\n 497  \n 498  \n 499  \n 500  \n 501  \n 502  \n 503  \n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512  \n 513  \n 514  \n 515  \n 516  \n 517  \n 518  \n 519  \n 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528 -\n 529  \n 530  \n 531  \n 532  \n 533  \n 534  \n 535  \n 536  \n 537  \n 538  \n 539  \n 540  \n 541  \n 542  \n 543  \n 544  \n 545 -\n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  ",
            "    /**\n     *\n     */\n    @Override\n    public String unbind(CamelContext camelContext, Map<String, Object> model) throws Exception {\n\n        StringBuilder builder = new StringBuilder();\n\n        Map<Integer, KeyValuePairField> keyValuePairFieldsSorted = new TreeMap<>(keyValuePairFields);\n        Iterator<Integer> it = keyValuePairFieldsSorted.keySet().iterator();\n\n        // Map containing the OUT position of the field\n        // The key is double and is created using the position of the field and\n        // location of the class in the message (using section)\n        Map<Integer, String> positions = new TreeMap<>();\n\n        // Check if separator exists\n        ObjectHelper.notNull(this.pairSeparator, \"The pair separator has not been instantiated or property not defined in the @Message annotation\");\n\n        char separator = ConverterUtils.getCharDelimiter(this.getPairSeparator());\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Separator converted: '0x{}', from: {}\", Integer.toHexString(separator), this.getPairSeparator());\n        }\n\n        while (it.hasNext()) {\n\n            KeyValuePairField keyValuePairField = keyValuePairFieldsSorted.get(it.next());\n            ObjectHelper.notNull(keyValuePairField, \"KeyValuePair\");\n\n            // Retrieve the field\n            Field field = annotatedFields.get(keyValuePairField.tag());\n            // Change accessibility to allow to read protected/private fields\n            field.setAccessible(true);\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Tag: {}, Field type: {}, class: {}\", new Object[]{keyValuePairField.tag(), field.getType(), field.getDeclaringClass().getName()});\n            }\n\n            // Create format\n            FormattingOptions formattingOptions = ConverterUtils.convert(keyValuePairField,\n                    field.getType(),\n                    field.getAnnotation(BindyConverter.class),\n                    getLocale());\n            Format<Object> format = (Format<Object>) formatFactory.getFormat(formattingOptions);\n\n            // Get object to be formatted\n            Object obj = model.get(field.getDeclaringClass().getName());\n\n            if (obj != null) {\n\n                // Get field value\n                Object keyValue = field.get(obj);\n\n                if (this.isMessageOrdered()) {\n                    // Generate a key using the number of the section\n                    // and the position of the field\n                    Integer key1 = sections.get(obj.getClass().getName());\n                    Integer key2 = keyValuePairField.position();\n\n                    LOG.debug(\"Key of the section: {}, and the field: {}\", key1, key2);\n\n                    Integer keyGenerated = generateKey(key1, key2);\n\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Key generated: {}, for section: {}\", String.valueOf(keyGenerated), key1);\n                    }\n\n                    // Add value to the list if not null\n                    if (keyValue != null) {\n\n                        // Format field value\n                        String valueFormatted;\n\n                        try {\n                            valueFormatted = format.format(keyValue);\n                        } catch (Exception e) {\n                            throw new IllegalArgumentException(\"Formatting error detected for the tag: \" + keyValuePairField.tag(), e);\n                        }\n\n                        // Create the key value string\n                        String value = keyValuePairField.tag() + this.getKeyValuePairSeparator() + valueFormatted;\n\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Value to be formatted: {}, for the tag: {}, and its formatted value: {}\", new Object[]{keyValue, keyValuePairField.tag(), valueFormatted});\n                        }\n\n                        // Add the content to the TreeMap according to the\n                        // position defined\n                        positions.put(keyGenerated, value);\n\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Positions size: {}\", positions.size());\n                        }\n                    }\n                } else {\n\n                    // Add value to the list if not null\n                    if (keyValue != null) {\n\n                        // Format field value\n                        String valueFormatted;\n\n                        try {\n                            valueFormatted = format.format(keyValue);\n                        } catch (Exception e) {\n                            throw new IllegalArgumentException(\"Formatting error detected for the tag: \" + keyValuePairField.tag(), e);\n                        }\n\n                        // Create the key value string\n                        String value = keyValuePairField.tag() + this.getKeyValuePairSeparator() + valueFormatted + separator;\n\n                        // Add content to the stringBuilder\n                        builder.append(value);\n\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Value added: {}{}{}{}\", new Object[]{keyValuePairField.tag(), this.getKeyValuePairSeparator(), valueFormatted, separator});\n                        }\n                    }\n                }\n            }\n        }\n\n        // Iterate through the list to generate\n        // the message according to the order/position\n        if (this.isMessageOrdered()) {\n\n            Iterator<Integer> posit = positions.keySet().iterator();\n\n            while (posit.hasNext()) {\n                String value = positions.get(posit.next());\n\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Value added at the position ({}) : {}{}\", new Object[]{posit, value, separator});\n                }\n\n                builder.append(value + separator);\n            }\n        }\n\n        return builder.toString();\n    }",
            " 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  \n 423  \n 424  \n 425  \n 426  \n 427  \n 428  \n 429  \n 430  \n 431  \n 432  \n 433  \n 434  \n 435  \n 436  \n 437  \n 438  \n 439  \n 440  \n 441  \n 442  \n 443  \n 444  \n 445  \n 446  \n 447  \n 448 +\n 449  \n 450  \n 451  \n 452  \n 453  \n 454  \n 455  \n 456  \n 457  \n 458  \n 459  \n 460  \n 461  \n 462  \n 463  \n 464  \n 465  \n 466  \n 467  \n 468  \n 469  \n 470  \n 471  \n 472  \n 473  \n 474  \n 475  \n 476  \n 477  \n 478  \n 479  \n 480  \n 481  \n 482  \n 483  \n 484  \n 485  \n 486  \n 487  \n 488  \n 489  \n 490  \n 491  \n 492  \n 493  \n 494  \n 495  \n 496 +\n 497  \n 498  \n 499  \n 500  \n 501  \n 502  \n 503  \n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512  \n 513  \n 514  \n 515  \n 516  \n 517  \n 518  \n 519  \n 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528 +\n 529  \n 530  \n 531  \n 532  \n 533  \n 534  \n 535  \n 536  \n 537  \n 538  \n 539  \n 540  \n 541  \n 542  \n 543  \n 544  \n 545 +\n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  ",
            "    /**\n     *\n     */\n    @Override\n    public String unbind(CamelContext camelContext, Map<String, Object> model) throws Exception {\n\n        StringBuilder builder = new StringBuilder();\n\n        Map<Integer, KeyValuePairField> keyValuePairFieldsSorted = new TreeMap<>(keyValuePairFields);\n        Iterator<Integer> it = keyValuePairFieldsSorted.keySet().iterator();\n\n        // Map containing the OUT position of the field\n        // The key is double and is created using the position of the field and\n        // location of the class in the message (using section)\n        Map<Integer, String> positions = new TreeMap<>();\n\n        // Check if separator exists\n        ObjectHelper.notNull(this.pairSeparator, \"The pair separator has not been instantiated or property not defined in the @Message annotation\");\n\n        char separator = ConverterUtils.getCharDelimiter(this.getPairSeparator());\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Separator converted: '0x{}', from: {}\", Integer.toHexString(separator), this.getPairSeparator());\n        }\n\n        while (it.hasNext()) {\n\n            KeyValuePairField keyValuePairField = keyValuePairFieldsSorted.get(it.next());\n            ObjectHelper.notNull(keyValuePairField, \"KeyValuePair\");\n\n            // Retrieve the field\n            Field field = annotatedFields.get(keyValuePairField.tag());\n            // Change accessibility to allow to read protected/private fields\n            field.setAccessible(true);\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Tag: {}, Field type: {}, class: {}\", keyValuePairField.tag(), field.getType(), field.getDeclaringClass().getName());\n            }\n\n            // Create format\n            FormattingOptions formattingOptions = ConverterUtils.convert(keyValuePairField,\n                    field.getType(),\n                    field.getAnnotation(BindyConverter.class),\n                    getLocale());\n            Format<Object> format = (Format<Object>) formatFactory.getFormat(formattingOptions);\n\n            // Get object to be formatted\n            Object obj = model.get(field.getDeclaringClass().getName());\n\n            if (obj != null) {\n\n                // Get field value\n                Object keyValue = field.get(obj);\n\n                if (this.isMessageOrdered()) {\n                    // Generate a key using the number of the section\n                    // and the position of the field\n                    Integer key1 = sections.get(obj.getClass().getName());\n                    Integer key2 = keyValuePairField.position();\n\n                    LOG.debug(\"Key of the section: {}, and the field: {}\", key1, key2);\n\n                    Integer keyGenerated = generateKey(key1, key2);\n\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Key generated: {}, for section: {}\", String.valueOf(keyGenerated), key1);\n                    }\n\n                    // Add value to the list if not null\n                    if (keyValue != null) {\n\n                        // Format field value\n                        String valueFormatted;\n\n                        try {\n                            valueFormatted = format.format(keyValue);\n                        } catch (Exception e) {\n                            throw new IllegalArgumentException(\"Formatting error detected for the tag: \" + keyValuePairField.tag(), e);\n                        }\n\n                        // Create the key value string\n                        String value = keyValuePairField.tag() + this.getKeyValuePairSeparator() + valueFormatted;\n\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Value to be formatted: {}, for the tag: {}, and its formatted value: {}\", keyValue, keyValuePairField.tag(), valueFormatted);\n                        }\n\n                        // Add the content to the TreeMap according to the\n                        // position defined\n                        positions.put(keyGenerated, value);\n\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Positions size: {}\", positions.size());\n                        }\n                    }\n                } else {\n\n                    // Add value to the list if not null\n                    if (keyValue != null) {\n\n                        // Format field value\n                        String valueFormatted;\n\n                        try {\n                            valueFormatted = format.format(keyValue);\n                        } catch (Exception e) {\n                            throw new IllegalArgumentException(\"Formatting error detected for the tag: \" + keyValuePairField.tag(), e);\n                        }\n\n                        // Create the key value string\n                        String value = keyValuePairField.tag() + this.getKeyValuePairSeparator() + valueFormatted + separator;\n\n                        // Add content to the stringBuilder\n                        builder.append(value);\n\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Value added: {}{}{}{}\", keyValuePairField.tag(), this.getKeyValuePairSeparator(), valueFormatted, separator);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Iterate through the list to generate\n        // the message according to the order/position\n        if (this.isMessageOrdered()) {\n\n            Iterator<Integer> posit = positions.keySet().iterator();\n\n            while (posit.hasNext()) {\n                String value = positions.get(posit.next());\n\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Value added at the position ({}) : {}{}\", posit, value, separator);\n                }\n\n                builder.append(value + separator);\n            }\n        }\n\n        return builder.toString();\n    }"
        ],
        [
            "SparkConsumer::doStart()",
            "  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56 -\n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  ",
            "    @Override\n    protected void doStart() throws Exception {\n        super.doStart();\n\n        String verb = getEndpoint().getVerb();\n        String path = getEndpoint().getPath();\n        String accept = getEndpoint().getAccept();\n        boolean matchOnUriPrefix = getEndpoint().getSparkConfiguration().isMatchOnUriPrefix();\n\n        if (accept != null) {\n            log.debug(\"Spark-rest: {}({}) accepting: {}\", new Object[]{verb, path, accept});\n        } else {\n            log.debug(\"Spark-rest: {}({})\", verb, path);\n        }\n        CamelSpark.spark(verb, path, accept, route);\n\n        // special if cors is enabled in rest-dsl then we need a spark-route to trigger cors support\n        if (enableCors && !\"options\".equals(verb)) {\n            CamelSpark.spark(\"options\", path, accept, route);\n        }\n\n        if (matchOnUriPrefix) {\n            CamelSpark.spark(verb, path + \"/*\", accept, route);\n        }\n    }",
            "  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56 +\n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  ",
            "    @Override\n    protected void doStart() throws Exception {\n        super.doStart();\n\n        String verb = getEndpoint().getVerb();\n        String path = getEndpoint().getPath();\n        String accept = getEndpoint().getAccept();\n        boolean matchOnUriPrefix = getEndpoint().getSparkConfiguration().isMatchOnUriPrefix();\n\n        if (accept != null) {\n            log.debug(\"Spark-rest: {}({}) accepting: {}\", verb, path, accept);\n        } else {\n            log.debug(\"Spark-rest: {}({})\", verb, path);\n        }\n        CamelSpark.spark(verb, path, accept, route);\n\n        // special if cors is enabled in rest-dsl then we need a spark-route to trigger cors support\n        if (enableCors && !\"options\".equals(verb)) {\n            CamelSpark.spark(\"options\", path, accept, route);\n        }\n\n        if (matchOnUriPrefix) {\n            CamelSpark.spark(verb, path + \"/*\", accept, route);\n        }\n    }"
        ],
        [
            "PGPDataFormatUtil::findPublicKeys(List,boolean,PGPPublicKeyRingCollection)",
            " 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221 -\n 222 -\n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  ",
            "    public static List<PGPPublicKey> findPublicKeys(List<String> useridParts, boolean forEncryption, PGPPublicKeyRingCollection pgpPublicKeyringCollection) {\n        List<PGPPublicKey> result = new ArrayList<>(useridParts.size());\n        for (Iterator<PGPPublicKeyRing> keyRingIter = pgpPublicKeyringCollection.getKeyRings(); keyRingIter.hasNext();) {\n            PGPPublicKeyRing keyRing = keyRingIter.next();\n            PGPPublicKey primaryKey = keyRing.getPublicKey();\n            String[] foundKeyUserIdForUserIdPart = findFirstKeyUserIdContainingOneOfTheParts(useridParts, primaryKey);\n            if (foundKeyUserIdForUserIdPart == null) {\n                LOG.debug(\"No User ID found in primary key with key ID {} containing one of the parts {}\", primaryKey.getKeyID(),\n                        useridParts);\n                continue;\n            }\n            LOG.debug(\"User ID {} found in primary key with key ID {} containing one of the parts {}\", new Object[] {\n                foundKeyUserIdForUserIdPart[0], primaryKey.getKeyID(), useridParts });\n            // add adequate keys to the result\n            for (Iterator<PGPPublicKey> keyIter = keyRing.getPublicKeys(); keyIter.hasNext();) {\n                PGPPublicKey key = keyIter.next();\n                if (forEncryption) {\n                    if (isEncryptionKey(key)) {\n                        LOG.debug(\"Public encryption key with key user ID {} and key ID {} added to the encryption keys\",\n                                foundKeyUserIdForUserIdPart[0], Long.toString(key.getKeyID()));\n                        result.add(key);\n                    }\n                } else if (!forEncryption && isSignatureKey(key)) {\n                    // not used!\n                    result.add(key);\n                    LOG.debug(\"Public key with key user ID {} and key ID {} added to the signing keys\", foundKeyUserIdForUserIdPart[0],\n                            Long.toString(key.getKeyID()));\n                }\n            }\n\n        }\n\n        return result;\n    }",
            " 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221 +\n 222 +\n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  ",
            "    public static List<PGPPublicKey> findPublicKeys(List<String> useridParts, boolean forEncryption, PGPPublicKeyRingCollection pgpPublicKeyringCollection) {\n        List<PGPPublicKey> result = new ArrayList<>(useridParts.size());\n        for (Iterator<PGPPublicKeyRing> keyRingIter = pgpPublicKeyringCollection.getKeyRings(); keyRingIter.hasNext();) {\n            PGPPublicKeyRing keyRing = keyRingIter.next();\n            PGPPublicKey primaryKey = keyRing.getPublicKey();\n            String[] foundKeyUserIdForUserIdPart = findFirstKeyUserIdContainingOneOfTheParts(useridParts, primaryKey);\n            if (foundKeyUserIdForUserIdPart == null) {\n                LOG.debug(\"No User ID found in primary key with key ID {} containing one of the parts {}\", primaryKey.getKeyID(),\n                        useridParts);\n                continue;\n            }\n            LOG.debug(\"User ID {} found in primary key with key ID {} containing one of the parts {}\",\n                foundKeyUserIdForUserIdPart[0], primaryKey.getKeyID(), useridParts);\n            // add adequate keys to the result\n            for (Iterator<PGPPublicKey> keyIter = keyRing.getPublicKeys(); keyIter.hasNext();) {\n                PGPPublicKey key = keyIter.next();\n                if (forEncryption) {\n                    if (isEncryptionKey(key)) {\n                        LOG.debug(\"Public encryption key with key user ID {} and key ID {} added to the encryption keys\",\n                                foundKeyUserIdForUserIdPart[0], Long.toString(key.getKeyID()));\n                        result.add(key);\n                    }\n                } else if (!forEncryption && isSignatureKey(key)) {\n                    // not used!\n                    result.add(key);\n                    LOG.debug(\"Public key with key user ID {} and key ID {} added to the signing keys\", foundKeyUserIdForUserIdPart[0],\n                            Long.toString(key.getKeyID()));\n                }\n            }\n\n        }\n\n        return result;\n    }"
        ],
        [
            "BindyFixedLengthFactory::bind(CamelContext,String,Map,int)",
            " 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253 -\n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  ",
            "    public void bind(CamelContext camelContext, String record, Map<String, Object> model, int line) throws Exception {\n\n        int pos = 1;\n        int counterMandatoryFields = 0;\n        DataField dataField;\n        String token;\n        int offset = 1;\n        int length;\n        String delimiter;\n        Field field;\n\n        // Iterate through the list of positions\n        // defined in the @DataField\n        // and grab the data from the line\n        Collection<DataField> c = dataFields.values();\n        Iterator<DataField> itr = c.iterator();\n\n        // this iterator is for a link list that was built using items in order\n        while (itr.hasNext()) {\n            dataField = itr.next();\n            length = dataField.length();\n            delimiter = dataField.delimiter();\n\n            if (length == 0 && dataField.lengthPos() != 0) {\n                Field lengthField = annotatedFields.get(dataField.lengthPos());\n                lengthField.setAccessible(true);\n                Object modelObj = model.get(lengthField.getDeclaringClass().getName());\n                Object lengthObj =  lengthField.get(modelObj);\n                length = ((Integer)lengthObj).intValue();\n            }\n            if (length < 1 && delimiter == null && dataField.lengthPos() == 0) {\n                throw new IllegalArgumentException(\"Either length or delimiter must be specified for the field : \" + dataField.toString());\n            }\n            if (offset - 1 <= -1) {\n                throw new IllegalArgumentException(\"Offset/Position of the field \" + dataField.toString()\n                                                   + \" cannot be negative\");\n            }\n\n            // skip ahead if the expected position is greater than the offset\n            if (dataField.pos() > offset) {\n                LOG.debug(\"skipping ahead [\" + (dataField.pos() - offset) + \"] chars.\");\n                offset = dataField.pos();\n            }\n\n            if (length > 0) {\n                if (record.length() < offset) {\n                    token = \"\";\n                } else {\n                    int endIndex = offset + length - 1;\n                    if (endIndex > record.length()) {\n                        endIndex = record.length();\n                    }\n                    token = record.substring(offset - 1, endIndex);\n                }\n                offset += length;\n            } else if (!delimiter.equals(\"\")) {\n                String tempToken = record.substring(offset - 1, record.length());\n                token = tempToken.substring(0, tempToken.indexOf(delimiter));\n                // include the delimiter in the offset calculation\n                offset += token.length() + 1;\n            } else {\n                // defined as a zero-length field\n                token = \"\";\n            }\n\n            if (dataField.trim()) {\n                token = trim(token, dataField, paddingChar);\n                //token = token.trim();\n            }\n\n            // Check mandatory field\n            if (dataField.required()) {\n\n                // Increment counter of mandatory fields\n                ++counterMandatoryFields;\n\n                // Check if content of the field is empty\n                // This is not possible for mandatory fields\n                if (token.equals(\"\")) {\n                    throw new IllegalArgumentException(\"The mandatory field defined at the position \" + pos\n                                                       + \" is empty for the line: \" + line);\n                }\n            }\n\n            // Get Field to be set\n            field = annotatedFields.get(dataField.pos());\n            field.setAccessible(true);\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Pos/Offset: {}, Data: {}, Field type: {}\", new Object[]{offset, token, field.getType()});\n            }\n\n            // Create format object to format the field\n            FormattingOptions formattingOptions = ConverterUtils.convert(dataField,\n                    field.getType(),\n                    field.getAnnotation(BindyConverter.class),\n                    getLocale());\n            Format<?> format = formatFactory.getFormat(formattingOptions);\n\n            // field object to be set\n            Object modelField = model.get(field.getDeclaringClass().getName());\n\n            // format the data received\n            Object value = null;\n\n            if (\"\".equals(token)) {\n                token = dataField.defaultValue();\n            }\n            if (!\"\".equals(token)) {\n                try {\n                    value = format.parse(token);\n                } catch (FormatException ie) {\n                    throw new IllegalArgumentException(ie.getMessage() + \", position: \" + offset + \", line: \" + line, ie);\n                } catch (Exception e) {\n                    throw new IllegalArgumentException(\"Parsing error detected for field defined at the position/offset: \" + offset + \", line: \" + line, e);\n                }\n            } else {\n                value = getDefaultValueForPrimitive(field.getType());\n            }\n            \n            if (value != null && !dataField.method().isEmpty()) {\n                Class<?> clazz;\n                if (dataField.method().contains(\".\")) {\n                    clazz = camelContext.getClassResolver().resolveMandatoryClass(dataField.method().substring(0, dataField.method().lastIndexOf(\".\")));\n                } else {\n                    clazz = field.getType();\n                }\n                \n                String methodName = dataField.method().substring(dataField.method().lastIndexOf(\".\") + 1,\n                                                                   dataField.method().length());\n                \n                Method m = ReflectionHelper.findMethod(clazz, methodName, field.getType());\n                if (m != null) {\n                    // this method must be static and return type\n                    // must be the same as the datafield and \n                    // must receive only the datafield value \n                    // as the method argument\n                    value = ObjectHelper.invokeMethod(m, null, value);\n                } else {\n                    // fallback to method without parameter, that is on the value itself\n                    m = ReflectionHelper.findMethod(clazz, methodName);\n                    value = ObjectHelper.invokeMethod(m, value);\n                }\n            }\n\n            field.set(modelField, value);\n\n            ++pos;\n\n        }\n\n        // check for unmapped non-whitespace data at the end of the line\n        if (offset <= record.length() && !(record.substring(offset - 1, record.length())).trim().equals(\"\") && !isIgnoreTrailingChars()) {\n            throw new IllegalArgumentException(\"Unexpected / unmapped characters found at the end of the fixed-length record at line : \" + line);\n        }\n\n        LOG.debug(\"Counter mandatory fields: {}\", counterMandatoryFields);\n\n        if (pos < totalFields) {\n            throw new IllegalArgumentException(\"Some fields are missing (optional or mandatory), line: \" + line);\n        }\n\n        if (counterMandatoryFields < numberMandatoryFields) {\n            throw new IllegalArgumentException(\"Some mandatory fields are missing, line: \" + line);\n        }\n\n    }",
            " 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253 +\n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  ",
            "    public void bind(CamelContext camelContext, String record, Map<String, Object> model, int line) throws Exception {\n\n        int pos = 1;\n        int counterMandatoryFields = 0;\n        DataField dataField;\n        String token;\n        int offset = 1;\n        int length;\n        String delimiter;\n        Field field;\n\n        // Iterate through the list of positions\n        // defined in the @DataField\n        // and grab the data from the line\n        Collection<DataField> c = dataFields.values();\n        Iterator<DataField> itr = c.iterator();\n\n        // this iterator is for a link list that was built using items in order\n        while (itr.hasNext()) {\n            dataField = itr.next();\n            length = dataField.length();\n            delimiter = dataField.delimiter();\n\n            if (length == 0 && dataField.lengthPos() != 0) {\n                Field lengthField = annotatedFields.get(dataField.lengthPos());\n                lengthField.setAccessible(true);\n                Object modelObj = model.get(lengthField.getDeclaringClass().getName());\n                Object lengthObj =  lengthField.get(modelObj);\n                length = ((Integer)lengthObj).intValue();\n            }\n            if (length < 1 && delimiter == null && dataField.lengthPos() == 0) {\n                throw new IllegalArgumentException(\"Either length or delimiter must be specified for the field : \" + dataField.toString());\n            }\n            if (offset - 1 <= -1) {\n                throw new IllegalArgumentException(\"Offset/Position of the field \" + dataField.toString()\n                                                   + \" cannot be negative\");\n            }\n\n            // skip ahead if the expected position is greater than the offset\n            if (dataField.pos() > offset) {\n                LOG.debug(\"skipping ahead [\" + (dataField.pos() - offset) + \"] chars.\");\n                offset = dataField.pos();\n            }\n\n            if (length > 0) {\n                if (record.length() < offset) {\n                    token = \"\";\n                } else {\n                    int endIndex = offset + length - 1;\n                    if (endIndex > record.length()) {\n                        endIndex = record.length();\n                    }\n                    token = record.substring(offset - 1, endIndex);\n                }\n                offset += length;\n            } else if (!delimiter.equals(\"\")) {\n                String tempToken = record.substring(offset - 1, record.length());\n                token = tempToken.substring(0, tempToken.indexOf(delimiter));\n                // include the delimiter in the offset calculation\n                offset += token.length() + 1;\n            } else {\n                // defined as a zero-length field\n                token = \"\";\n            }\n\n            if (dataField.trim()) {\n                token = trim(token, dataField, paddingChar);\n                //token = token.trim();\n            }\n\n            // Check mandatory field\n            if (dataField.required()) {\n\n                // Increment counter of mandatory fields\n                ++counterMandatoryFields;\n\n                // Check if content of the field is empty\n                // This is not possible for mandatory fields\n                if (token.equals(\"\")) {\n                    throw new IllegalArgumentException(\"The mandatory field defined at the position \" + pos\n                                                       + \" is empty for the line: \" + line);\n                }\n            }\n\n            // Get Field to be set\n            field = annotatedFields.get(dataField.pos());\n            field.setAccessible(true);\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Pos/Offset: {}, Data: {}, Field type: {}\", offset, token, field.getType());\n            }\n\n            // Create format object to format the field\n            FormattingOptions formattingOptions = ConverterUtils.convert(dataField,\n                    field.getType(),\n                    field.getAnnotation(BindyConverter.class),\n                    getLocale());\n            Format<?> format = formatFactory.getFormat(formattingOptions);\n\n            // field object to be set\n            Object modelField = model.get(field.getDeclaringClass().getName());\n\n            // format the data received\n            Object value = null;\n\n            if (\"\".equals(token)) {\n                token = dataField.defaultValue();\n            }\n            if (!\"\".equals(token)) {\n                try {\n                    value = format.parse(token);\n                } catch (FormatException ie) {\n                    throw new IllegalArgumentException(ie.getMessage() + \", position: \" + offset + \", line: \" + line, ie);\n                } catch (Exception e) {\n                    throw new IllegalArgumentException(\"Parsing error detected for field defined at the position/offset: \" + offset + \", line: \" + line, e);\n                }\n            } else {\n                value = getDefaultValueForPrimitive(field.getType());\n            }\n            \n            if (value != null && !dataField.method().isEmpty()) {\n                Class<?> clazz;\n                if (dataField.method().contains(\".\")) {\n                    clazz = camelContext.getClassResolver().resolveMandatoryClass(dataField.method().substring(0, dataField.method().lastIndexOf(\".\")));\n                } else {\n                    clazz = field.getType();\n                }\n                \n                String methodName = dataField.method().substring(dataField.method().lastIndexOf(\".\") + 1,\n                                                                   dataField.method().length());\n                \n                Method m = ReflectionHelper.findMethod(clazz, methodName, field.getType());\n                if (m != null) {\n                    // this method must be static and return type\n                    // must be the same as the datafield and \n                    // must receive only the datafield value \n                    // as the method argument\n                    value = ObjectHelper.invokeMethod(m, null, value);\n                } else {\n                    // fallback to method without parameter, that is on the value itself\n                    m = ReflectionHelper.findMethod(clazz, methodName);\n                    value = ObjectHelper.invokeMethod(m, value);\n                }\n            }\n\n            field.set(modelField, value);\n\n            ++pos;\n\n        }\n\n        // check for unmapped non-whitespace data at the end of the line\n        if (offset <= record.length() && !(record.substring(offset - 1, record.length())).trim().equals(\"\") && !isIgnoreTrailingChars()) {\n            throw new IllegalArgumentException(\"Unexpected / unmapped characters found at the end of the fixed-length record at line : \" + line);\n        }\n\n        LOG.debug(\"Counter mandatory fields: {}\", counterMandatoryFields);\n\n        if (pos < totalFields) {\n            throw new IllegalArgumentException(\"Some fields are missing (optional or mandatory), line: \" + line);\n        }\n\n        if (counterMandatoryFields < numberMandatoryFields) {\n            throw new IllegalArgumentException(\"Some mandatory fields are missing, line: \" + line);\n        }\n\n    }"
        ],
        [
            "SftpConsumer::doPollDirectory(String,String,List,int)",
            " 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163 -\n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  ",
            "    protected boolean doPollDirectory(String absolutePath, String dirName, List<GenericFile<SftpRemoteFile>> fileList, int depth) {\n        log.trace(\"doPollDirectory from absolutePath: {}, dirName: {}\", absolutePath, dirName);\n\n        depth++;\n\n        // remove trailing /\n        dirName = FileUtil.stripTrailingSeparator(dirName);\n\n        // compute dir depending on stepwise is enabled or not\n        String dir = null;\n        List<SftpRemoteFile> files = null;\n        try {\n            if (isStepwise()) {\n                dir = ObjectHelper.isNotEmpty(dirName) ? dirName : absolutePath;\n                operations.changeCurrentDirectory(dir);\n            } else {\n                dir = absolutePath;\n            }\n\n            log.trace(\"Polling directory: {}\", dir);\n            if (isUseList()) {\n                if (isStepwise()) {\n                    files = operations.listFiles();\n                } else {\n                    files = operations.listFiles(dir);\n                }\n            } else {\n                // we cannot use the LIST command(s) so we can only poll a named file\n                // so created a pseudo file with that name\n                fileExpressionResult = evaluateFileExpression();\n                if (fileExpressionResult != null) {\n                    SftpRemoteFile file = new SftpRemoteFileSingle(fileExpressionResult);\n                    files = new ArrayList<>(1);\n                    files.add(file);\n                }\n            }\n        } catch (GenericFileOperationFailedException e) {\n            if (ignoreCannotRetrieveFile(null, null, e)) {\n                log.debug(\"Cannot list files in directory {} due directory does not exists or file permission error.\", dir);\n            } else {\n                throw e;\n            }\n        }\n\n        if (files == null || files.isEmpty()) {\n            // no files in this directory to poll\n            log.trace(\"No files found in directory: {}\", dir);\n            return true;\n        } else {\n            // we found some files\n            log.trace(\"Found {} in directory: {}\", files.size(), dir);\n        }\n        \n        if (getEndpoint().isPreSort()) {\n            Collections.sort(files, (a, b) -> a.getFilename().compareTo(b.getFilename()));\n        }\n\n        for (SftpRemoteFile file : files) {\n\n            if (log.isTraceEnabled()) {\n                log.trace(\"SftpFile[fileName={}, longName={}, dir={}]\", new Object[]{file.getFilename(), file.getLongname(), file.isDirectory()});\n            }\n\n            // check if we can continue polling in files\n            if (!canPollMoreFiles(fileList)) {\n                return false;\n            }\n\n            if (file.isDirectory()) {\n                RemoteFile<SftpRemoteFile> remote = asRemoteFile(absolutePath, file, getEndpoint().getCharset());\n                if (endpoint.isRecursive() && depth < endpoint.getMaxDepth() && isValidFile(remote, true, files)) {\n                    // recursive scan and add the sub files and folders\n                    String subDirectory = file.getFilename();\n                    String path = absolutePath + \"/\" + subDirectory;\n                    boolean canPollMore = pollSubDirectory(path, subDirectory, fileList, depth);\n                    if (!canPollMore) {\n                        return false;\n                    }\n                }\n                // we cannot use file.getAttrs().isLink on Windows, so we dont invoke the method\n                // just assuming its a file we should poll\n            } else {\n                RemoteFile<SftpRemoteFile> remote = asRemoteFile(absolutePath, file, getEndpoint().getCharset());\n                if (depth >= endpoint.getMinDepth() && isValidFile(remote, false, files)) {\n                    // matched file so add\n                    fileList.add(remote);\n                }\n            }\n        }\n\n        return true;\n    }",
            " 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163 +\n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  ",
            "    protected boolean doPollDirectory(String absolutePath, String dirName, List<GenericFile<SftpRemoteFile>> fileList, int depth) {\n        log.trace(\"doPollDirectory from absolutePath: {}, dirName: {}\", absolutePath, dirName);\n\n        depth++;\n\n        // remove trailing /\n        dirName = FileUtil.stripTrailingSeparator(dirName);\n\n        // compute dir depending on stepwise is enabled or not\n        String dir = null;\n        List<SftpRemoteFile> files = null;\n        try {\n            if (isStepwise()) {\n                dir = ObjectHelper.isNotEmpty(dirName) ? dirName : absolutePath;\n                operations.changeCurrentDirectory(dir);\n            } else {\n                dir = absolutePath;\n            }\n\n            log.trace(\"Polling directory: {}\", dir);\n            if (isUseList()) {\n                if (isStepwise()) {\n                    files = operations.listFiles();\n                } else {\n                    files = operations.listFiles(dir);\n                }\n            } else {\n                // we cannot use the LIST command(s) so we can only poll a named file\n                // so created a pseudo file with that name\n                fileExpressionResult = evaluateFileExpression();\n                if (fileExpressionResult != null) {\n                    SftpRemoteFile file = new SftpRemoteFileSingle(fileExpressionResult);\n                    files = new ArrayList<>(1);\n                    files.add(file);\n                }\n            }\n        } catch (GenericFileOperationFailedException e) {\n            if (ignoreCannotRetrieveFile(null, null, e)) {\n                log.debug(\"Cannot list files in directory {} due directory does not exists or file permission error.\", dir);\n            } else {\n                throw e;\n            }\n        }\n\n        if (files == null || files.isEmpty()) {\n            // no files in this directory to poll\n            log.trace(\"No files found in directory: {}\", dir);\n            return true;\n        } else {\n            // we found some files\n            log.trace(\"Found {} in directory: {}\", files.size(), dir);\n        }\n        \n        if (getEndpoint().isPreSort()) {\n            Collections.sort(files, (a, b) -> a.getFilename().compareTo(b.getFilename()));\n        }\n\n        for (SftpRemoteFile file : files) {\n\n            if (log.isTraceEnabled()) {\n                log.trace(\"SftpFile[fileName={}, longName={}, dir={}]\", file.getFilename(), file.getLongname(), file.isDirectory());\n            }\n\n            // check if we can continue polling in files\n            if (!canPollMoreFiles(fileList)) {\n                return false;\n            }\n\n            if (file.isDirectory()) {\n                RemoteFile<SftpRemoteFile> remote = asRemoteFile(absolutePath, file, getEndpoint().getCharset());\n                if (endpoint.isRecursive() && depth < endpoint.getMaxDepth() && isValidFile(remote, true, files)) {\n                    // recursive scan and add the sub files and folders\n                    String subDirectory = file.getFilename();\n                    String path = absolutePath + \"/\" + subDirectory;\n                    boolean canPollMore = pollSubDirectory(path, subDirectory, fileList, depth);\n                    if (!canPollMore) {\n                        return false;\n                    }\n                }\n                // we cannot use file.getAttrs().isLink on Windows, so we dont invoke the method\n                // just assuming its a file we should poll\n            } else {\n                RemoteFile<SftpRemoteFile> remote = asRemoteFile(absolutePath, file, getEndpoint().getCharset());\n                if (depth >= endpoint.getMinDepth() && isValidFile(remote, false, files)) {\n                    // matched file so add\n                    fileList.add(remote);\n                }\n            }\n        }\n\n        return true;\n    }"
        ],
        [
            "CouchDbChangesetTracker::run()",
            "  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71 -\n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  ",
            "    @Override\n    public void run() {\n        while (changes.hasNext()) { // blocks until a feed is received\n            ChangesResult.Row feed = changes.next();\n            if (feed.isDeleted() && !endpoint.isDeletes()) {\n                continue;\n            }\n            if (!feed.isDeleted() && !endpoint.isUpdates()) {\n                continue;\n            }\n\n            String seq = feed.getSeq();\n            JsonObject doc = feed.getDoc();\n\n            Exchange exchange = endpoint.createExchange(seq, feed.getId(), doc, feed.isDeleted());\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Created exchange [exchange={}, _id={}, seq={}\", new Object[]{exchange, feed.getId(), seq});\n            }\n\n            try {\n                consumer.getProcessor().process(exchange);\n            } catch (Exception e) {\n                consumer.getExceptionHandler().handleException(\"Error processing exchange.\", exchange, e);\n            }\n        }\n        stopped = true;\n    }",
            "  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71 +\n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  ",
            "    @Override\n    public void run() {\n        while (changes.hasNext()) { // blocks until a feed is received\n            ChangesResult.Row feed = changes.next();\n            if (feed.isDeleted() && !endpoint.isDeletes()) {\n                continue;\n            }\n            if (!feed.isDeleted() && !endpoint.isUpdates()) {\n                continue;\n            }\n\n            String seq = feed.getSeq();\n            JsonObject doc = feed.getDoc();\n\n            Exchange exchange = endpoint.createExchange(seq, feed.getId(), doc, feed.isDeleted());\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Created exchange [exchange={}, _id={}, seq={}\", exchange, feed.getId(), seq);\n            }\n\n            try {\n                consumer.getProcessor().process(exchange);\n            } catch (Exception e) {\n                consumer.getExceptionHandler().handleException(\"Error processing exchange.\", exchange, e);\n            }\n        }\n        stopped = true;\n    }"
        ],
        [
            "OsgiClassResolver::resolveClass(String)",
            "  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60 -\n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67 -\n  68  \n  69  \n  70  \n  71  ",
            "    @Override\n    public Class<?> resolveClass(String name) {\n        LOG.trace(\"Resolve class {}\", name);\n        name = ObjectHelper.normalizeClassName(name);\n        if (ObjectHelper.isEmpty(name)) {\n            return null;\n        }\n        // we need to avoid the NPE issue of loading the class\n        Class<?> clazz = ObjectHelper.loadSimpleType(name);\n        if (clazz == null) {\n            clazz = doLoadClass(name, bundleContext.getBundle());\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Loading class {} using BundleContext {} -> {}\", new Object[]{name, bundleContext.getBundle(), clazz});\n            }\n        }\n        if (clazz == null && camelContext != null) {\n            // fallback and load class using the application context classloader\n            clazz = super.loadClass(name, camelContext.getApplicationContextClassLoader());\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Loading class {} using CamelContext {} -> {}\", new Object[]{name, camelContext, clazz});\n            }\n        }\n        return clazz;\n    }",
            "  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60 +\n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67 +\n  68  \n  69  \n  70  \n  71  ",
            "    @Override\n    public Class<?> resolveClass(String name) {\n        LOG.trace(\"Resolve class {}\", name);\n        name = ObjectHelper.normalizeClassName(name);\n        if (ObjectHelper.isEmpty(name)) {\n            return null;\n        }\n        // we need to avoid the NPE issue of loading the class\n        Class<?> clazz = ObjectHelper.loadSimpleType(name);\n        if (clazz == null) {\n            clazz = doLoadClass(name, bundleContext.getBundle());\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Loading class {} using BundleContext {} -> {}\", name, bundleContext.getBundle(), clazz);\n            }\n        }\n        if (clazz == null && camelContext != null) {\n            // fallback and load class using the application context classloader\n            clazz = super.loadClass(name, camelContext.getApplicationContextClassLoader());\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Loading class {} using CamelContext {} -> {}\", name, camelContext, clazz);\n            }\n        }\n        return clazz;\n    }"
        ],
        [
            "OsgiNamingHelper::findFreeCamelContextName(BundleContext,String,String,AtomicInteger,boolean)",
            "  38  \n  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82 -\n  83  \n  84  ",
            "    /**\n     * Checks the OSGi service registry for a free name (uses the counter if there is a clash to find next free name)\n     *\n     * @param context the bundle context\n     * @param prefix  the prefix for the name\n     * @param key     the key to use in the OSGi filter; either {@link OsgiCamelContextPublisher#CONTEXT_NAME_PROPERTY}\n     *                or {@link OsgiCamelContextPublisher#CONTEXT_MANAGEMENT_NAME_PROPERTY}.\n     * @param counter the counter\n     * @param checkFirst <tt>true</tt> to check the prefix name as-is before using the counter, <tt>false</tt> the counter is used immediately\n     * @return the free name, is never <tt>null</tt>\n     */\n    public static String findFreeCamelContextName(BundleContext context, String prefix, String key, AtomicInteger counter, boolean checkFirst) {\n        String candidate = null;\n        boolean clash = false;\n\n        do {\n            try {\n                clash = false;\n\n                if (candidate == null && checkFirst) {\n                    // try candidate as-is\n                    candidate = prefix;\n                } else {\n                    // generate new candidate\n                    candidate = prefix + \"-\" + getNextCounter(counter);\n                }\n                LOG.trace(\"Checking OSGi Service Registry for existence of existing CamelContext with name: {}\", candidate);\n\n                ServiceReference<?>[] refs = context.getServiceReferences(CamelContext.class.getName(), \"(\" + key + \"=\" + candidate + \")\");\n                if (refs != null && refs.length > 0) {\n                    for (ServiceReference<?> ref : refs) {\n                        Object id = ref.getProperty(key);\n                        if (id != null && candidate.equals(id)) {\n                            clash = true;\n                            break;\n                        }\n                    }\n                }\n            } catch (InvalidSyntaxException e) {\n                LOG.debug(\"Error finding free Camel name in OSGi Service Registry due \" + e.getMessage() + \". This exception is ignored.\", e);\n                break;\n            }\n        } while (clash);\n\n        LOG.debug(\"Generated free name for bundle id: {}, clash: {} -> {}\", new Object[]{context.getBundle().getBundleId(), clash, candidate});\n        return candidate;\n    }",
            "  38  \n  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82 +\n  83  \n  84  ",
            "    /**\n     * Checks the OSGi service registry for a free name (uses the counter if there is a clash to find next free name)\n     *\n     * @param context the bundle context\n     * @param prefix  the prefix for the name\n     * @param key     the key to use in the OSGi filter; either {@link OsgiCamelContextPublisher#CONTEXT_NAME_PROPERTY}\n     *                or {@link OsgiCamelContextPublisher#CONTEXT_MANAGEMENT_NAME_PROPERTY}.\n     * @param counter the counter\n     * @param checkFirst <tt>true</tt> to check the prefix name as-is before using the counter, <tt>false</tt> the counter is used immediately\n     * @return the free name, is never <tt>null</tt>\n     */\n    public static String findFreeCamelContextName(BundleContext context, String prefix, String key, AtomicInteger counter, boolean checkFirst) {\n        String candidate = null;\n        boolean clash = false;\n\n        do {\n            try {\n                clash = false;\n\n                if (candidate == null && checkFirst) {\n                    // try candidate as-is\n                    candidate = prefix;\n                } else {\n                    // generate new candidate\n                    candidate = prefix + \"-\" + getNextCounter(counter);\n                }\n                LOG.trace(\"Checking OSGi Service Registry for existence of existing CamelContext with name: {}\", candidate);\n\n                ServiceReference<?>[] refs = context.getServiceReferences(CamelContext.class.getName(), \"(\" + key + \"=\" + candidate + \")\");\n                if (refs != null && refs.length > 0) {\n                    for (ServiceReference<?> ref : refs) {\n                        Object id = ref.getProperty(key);\n                        if (id != null && candidate.equals(id)) {\n                            clash = true;\n                            break;\n                        }\n                    }\n                }\n            } catch (InvalidSyntaxException e) {\n                LOG.debug(\"Error finding free Camel name in OSGi Service Registry due \" + e.getMessage() + \". This exception is ignored.\", e);\n                break;\n            }\n        } while (clash);\n\n        LOG.debug(\"Generated free name for bundle id: {}, clash: {} -> {}\", context.getBundle().getBundleId(), clash, candidate);\n        return candidate;\n    }"
        ],
        [
            "Mina2Consumer::doStart()",
            "  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105 -\n 106  \n 107  \n 108  \n 109  \n 110  \n 111  ",
            "    @Override\n    protected void doStart() throws Exception {\n        super.doStart();\n        if (configuration.isClientMode() && configuration.getProtocol().equals(\"tcp\")) {\n            connector.setHandler(new ReceiveHandler());\n            ConnectFuture future = connector.connect(address);\n            future.awaitUninterruptibly();\n            session = future.getSession();\n            LOG.info(\"Connected to server address: {} using connector: {} timeout: {} millis.\", new Object[]{address, connector, configuration.getTimeout()});\n        } else {\n            acceptor.setHandler(new ReceiveHandler());\n            acceptor.bind(address);\n            LOG.info(\"Bound to server address: {} using acceptor: {}\", address, acceptor);\n        }\n    }",
            "  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105 +\n 106  \n 107  \n 108  \n 109  \n 110  \n 111  ",
            "    @Override\n    protected void doStart() throws Exception {\n        super.doStart();\n        if (configuration.isClientMode() && configuration.getProtocol().equals(\"tcp\")) {\n            connector.setHandler(new ReceiveHandler());\n            ConnectFuture future = connector.connect(address);\n            future.awaitUninterruptibly();\n            session = future.getSession();\n            LOG.info(\"Connected to server address: {} using connector: {} timeout: {} millis.\", address, connector, configuration.getTimeout());\n        } else {\n            acceptor.setHandler(new ReceiveHandler());\n            acceptor.bind(address);\n            LOG.info(\"Bound to server address: {} using acceptor: {}\", address, acceptor);\n        }\n    }"
        ],
        [
            "WebsocketComponent::doStop()",
            " 796  \n 797  \n 798  \n 799  \n 800  \n 801  \n 802  \n 803  \n 804  \n 805  \n 806  \n 807  \n 808  \n 809  \n 810  \n 811  \n 812  \n 813  \n 814  \n 815 -\n 816  \n 817  \n 818  \n 819  \n 820  \n 821  \n 822  ",
            "    @Override\n    public void doStop() throws Exception {\n        super.doStop();\n        if (CONNECTORS.size() > 0) {\n            for (String connectorKey : CONNECTORS.keySet()) {\n                ConnectorRef connectorRef = CONNECTORS.get(connectorKey);\n                if (connectorRef != null && connectorRef.getRefCount() == 0) {\n                    connectorRef.server.removeConnector(connectorRef.connector);\n                    connectorRef.connector.stop();\n                    connectorRef.server.stop();\n                    connectorRef.memoryStore.stop();\n                    connectorRef.servlet = null;\n                }\n                CONNECTORS.remove(connectorKey);\n            }\n        }\n        CONNECTORS.clear();\n\n        if (staticResourcesServer != null) {\n            LOG.info(\"Stopping static resources server {}:{} with static resource: {}\", new Object[]{host, port, staticResources});\n            staticResourcesServer.stop();\n            staticResourcesServer.destroy();\n            staticResourcesServer = null;\n        }\n\n        servlets.clear();\n    }",
            " 796  \n 797  \n 798  \n 799  \n 800  \n 801  \n 802  \n 803  \n 804  \n 805  \n 806  \n 807  \n 808  \n 809  \n 810  \n 811  \n 812  \n 813  \n 814  \n 815 +\n 816  \n 817  \n 818  \n 819  \n 820  \n 821  \n 822  ",
            "    @Override\n    public void doStop() throws Exception {\n        super.doStop();\n        if (CONNECTORS.size() > 0) {\n            for (String connectorKey : CONNECTORS.keySet()) {\n                ConnectorRef connectorRef = CONNECTORS.get(connectorKey);\n                if (connectorRef != null && connectorRef.getRefCount() == 0) {\n                    connectorRef.server.removeConnector(connectorRef.connector);\n                    connectorRef.connector.stop();\n                    connectorRef.server.stop();\n                    connectorRef.memoryStore.stop();\n                    connectorRef.servlet = null;\n                }\n                CONNECTORS.remove(connectorKey);\n            }\n        }\n        CONNECTORS.clear();\n\n        if (staticResourcesServer != null) {\n            LOG.info(\"Stopping static resources server {}:{} with static resource: {}\", host, port, staticResources);\n            staticResourcesServer.stop();\n            staticResourcesServer.destroy();\n            staticResourcesServer = null;\n        }\n\n        servlets.clear();\n    }"
        ],
        [
            "NettyHelper::writeBodyAsync(Logger,Channel,SocketAddress,Object,Exchange,ChannelFutureListener)",
            "  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91 -\n  92  \n  93  \n  94  \n  95  \n  96 -\n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  ",
            "    /**\n     * Writes the given body to Netty channel. Will <b>not</b >wait until the body has been written.\n     *\n     * @param log             logger to use\n     * @param channel         the Netty channel\n     * @param remoteAddress   the remote address when using UDP\n     * @param body            the body to write (send)\n     * @param exchange        the exchange\n     * @param listener        listener with work to be executed when the operation is complete\n     */\n    public static void writeBodyAsync(Logger log, Channel channel, SocketAddress remoteAddress, Object body,\n                                      Exchange exchange, ChannelFutureListener listener) {\n        ChannelFuture future;\n        if (remoteAddress != null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Channel: {} remote address: {} writing body: {}\", new Object[]{channel, remoteAddress, body});\n            }\n            future = channel.write(body, remoteAddress);\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Channel: {} writing body: {}\", new Object[]{channel, body});\n            }\n            future = channel.write(body);\n        }\n\n        if (listener != null) {\n            future.addListener(listener);\n        }\n    }",
            "  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91 +\n  92  \n  93  \n  94  \n  95  \n  96 +\n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  ",
            "    /**\n     * Writes the given body to Netty channel. Will <b>not</b >wait until the body has been written.\n     *\n     * @param log             logger to use\n     * @param channel         the Netty channel\n     * @param remoteAddress   the remote address when using UDP\n     * @param body            the body to write (send)\n     * @param exchange        the exchange\n     * @param listener        listener with work to be executed when the operation is complete\n     */\n    public static void writeBodyAsync(Logger log, Channel channel, SocketAddress remoteAddress, Object body,\n                                      Exchange exchange, ChannelFutureListener listener) {\n        ChannelFuture future;\n        if (remoteAddress != null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Channel: {} remote address: {} writing body: {}\", channel, remoteAddress, body);\n            }\n            future = channel.write(body, remoteAddress);\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Channel: {} writing body: {}\", channel, body);\n            }\n            future = channel.write(body);\n        }\n\n        if (listener != null) {\n            future.addListener(listener);\n        }\n    }"
        ],
        [
            "HdfsProducer::setupHdfs(boolean)",
            " 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136 -\n 137  \n 138  \n 139 -\n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146 -\n 147  \n 148  \n 149 -\n 150  \n 151  \n 152  \n 153  \n 154  ",
            "    private synchronized HdfsOutputStream setupHdfs(boolean onStartup) throws Exception {\n        if (ostream != null) {\n            return ostream;\n        }\n\n        StringBuilder actualPath = new StringBuilder(hdfsPath);\n        if (config.getSplitStrategies().size() > 0) {\n            actualPath = newFileName();\n        }\n\n        // if we are starting up then log at info level, and if runtime then log at debug level to not flood the log\n        if (onStartup) {\n            log.info(\"Connecting to hdfs file-system {}:{}/{} (may take a while if connection is not available)\", new Object[]{config.getHostName(), config.getPort(), actualPath.toString()});\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Connecting to hdfs file-system {}:{}/{} (may take a while if connection is not available)\", new Object[]{config.getHostName(), config.getPort(), actualPath.toString()});\n            }\n        }\n\n        HdfsOutputStream answer = HdfsOutputStream.createOutputStream(actualPath.toString(), config);\n\n        if (onStartup) {\n            log.info(\"Connected to hdfs file-system {}:{}/{}\", new Object[]{config.getHostName(), config.getPort(), actualPath.toString()});\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Connected to hdfs file-system {}:{}/{}\", new Object[]{config.getHostName(), config.getPort(), actualPath.toString()});\n            }\n        }\n\n        return answer;\n    }",
            " 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136 +\n 137  \n 138  \n 139 +\n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146 +\n 147  \n 148  \n 149 +\n 150  \n 151  \n 152  \n 153  \n 154  ",
            "    private synchronized HdfsOutputStream setupHdfs(boolean onStartup) throws Exception {\n        if (ostream != null) {\n            return ostream;\n        }\n\n        StringBuilder actualPath = new StringBuilder(hdfsPath);\n        if (config.getSplitStrategies().size() > 0) {\n            actualPath = newFileName();\n        }\n\n        // if we are starting up then log at info level, and if runtime then log at debug level to not flood the log\n        if (onStartup) {\n            log.info(\"Connecting to hdfs file-system {}:{}/{} (may take a while if connection is not available)\", config.getHostName(), config.getPort(), actualPath.toString());\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Connecting to hdfs file-system {}:{}/{} (may take a while if connection is not available)\", config.getHostName(), config.getPort(), actualPath.toString());\n            }\n        }\n\n        HdfsOutputStream answer = HdfsOutputStream.createOutputStream(actualPath.toString(), config);\n\n        if (onStartup) {\n            log.info(\"Connected to hdfs file-system {}:{}/{}\", config.getHostName(), config.getPort(), actualPath.toString());\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Connected to hdfs file-system {}:{}/{}\", config.getHostName(), config.getPort(), actualPath.toString());\n            }\n        }\n\n        return answer;\n    }"
        ],
        [
            "HttpEndpoint::createHttpClient()",
            " 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192 -\n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  ",
            "    /**\n     * Factory method to create a new {@link HttpClient} instance\n     * <p/>\n     * Producers and consumers should use the {@link #getHttpClient()} method instead.\n     */\n    protected HttpClient createHttpClient() {\n        ObjectHelper.notNull(clientBuilder, \"httpClientBuilder\");\n        ObjectHelper.notNull(clientConnectionManager, \"httpConnectionManager\");\n\n        // setup the cookieStore\n        clientBuilder.setDefaultCookieStore(cookieStore);\n        // setup the httpConnectionManager\n        clientBuilder.setConnectionManager(clientConnectionManager);\n        if (getComponent() != null && getComponent().getClientConnectionManager() == getClientConnectionManager()) {\n            clientBuilder.setConnectionManagerShared(true);\n        }\n\n        if (!useSystemProperties) {\n            // configure http proxy from camelContext\n            if (ObjectHelper.isNotEmpty(getCamelContext().getProperty(\"http.proxyHost\")) && ObjectHelper.isNotEmpty(getCamelContext().getProperty(\"http.proxyPort\"))) {\n                String host = getCamelContext().getProperty(\"http.proxyHost\");\n                int port = Integer.parseInt(getCamelContext().getProperty(\"http.proxyPort\"));\n                String scheme = getCamelContext().getProperty(\"http.proxyScheme\");\n                // fallback and use either http or https depending on secure\n                if (scheme == null) {\n                    scheme = HttpHelper.isSecureConnection(getEndpointUri()) ? \"https\" : \"http\";\n                }\n                LOG.debug(\"CamelContext properties http.proxyHost, http.proxyPort, and http.proxyScheme detected. Using http proxy host: {} port: {} scheme: {}\", new Object[]{host, port, scheme});\n                HttpHost proxy = new HttpHost(host, port, scheme);\n                clientBuilder.setProxy(proxy);\n            }\n        } else {\n            clientBuilder.useSystemProperties();\n        }\n\n        if (isAuthenticationPreemptive()) {\n            // setup the PreemptiveAuthInterceptor here\n            clientBuilder.addInterceptorFirst(new PreemptiveAuthInterceptor());\n        }\n\n        HttpClientConfigurer configurer = getHttpClientConfigurer();\n        if (configurer != null) {\n            configurer.configureHttpClient(clientBuilder);\n        }\n\n        if (isBridgeEndpoint()) {\n            // need to use noop cookiestore as we do not want to keep cookies in memory\n            clientBuilder.setDefaultCookieStore(new NoopCookieStore());\n        }\n\n        LOG.debug(\"Setup the HttpClientBuilder {}\", clientBuilder);\n        return clientBuilder.build();\n    }",
            " 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192 +\n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  ",
            "    /**\n     * Factory method to create a new {@link HttpClient} instance\n     * <p/>\n     * Producers and consumers should use the {@link #getHttpClient()} method instead.\n     */\n    protected HttpClient createHttpClient() {\n        ObjectHelper.notNull(clientBuilder, \"httpClientBuilder\");\n        ObjectHelper.notNull(clientConnectionManager, \"httpConnectionManager\");\n\n        // setup the cookieStore\n        clientBuilder.setDefaultCookieStore(cookieStore);\n        // setup the httpConnectionManager\n        clientBuilder.setConnectionManager(clientConnectionManager);\n        if (getComponent() != null && getComponent().getClientConnectionManager() == getClientConnectionManager()) {\n            clientBuilder.setConnectionManagerShared(true);\n        }\n\n        if (!useSystemProperties) {\n            // configure http proxy from camelContext\n            if (ObjectHelper.isNotEmpty(getCamelContext().getProperty(\"http.proxyHost\")) && ObjectHelper.isNotEmpty(getCamelContext().getProperty(\"http.proxyPort\"))) {\n                String host = getCamelContext().getProperty(\"http.proxyHost\");\n                int port = Integer.parseInt(getCamelContext().getProperty(\"http.proxyPort\"));\n                String scheme = getCamelContext().getProperty(\"http.proxyScheme\");\n                // fallback and use either http or https depending on secure\n                if (scheme == null) {\n                    scheme = HttpHelper.isSecureConnection(getEndpointUri()) ? \"https\" : \"http\";\n                }\n                LOG.debug(\"CamelContext properties http.proxyHost, http.proxyPort, and http.proxyScheme detected. Using http proxy host: {} port: {} scheme: {}\", host, port, scheme);\n                HttpHost proxy = new HttpHost(host, port, scheme);\n                clientBuilder.setProxy(proxy);\n            }\n        } else {\n            clientBuilder.useSystemProperties();\n        }\n\n        if (isAuthenticationPreemptive()) {\n            // setup the PreemptiveAuthInterceptor here\n            clientBuilder.addInterceptorFirst(new PreemptiveAuthInterceptor());\n        }\n\n        HttpClientConfigurer configurer = getHttpClientConfigurer();\n        if (configurer != null) {\n            configurer.configureHttpClient(clientBuilder);\n        }\n\n        if (isBridgeEndpoint()) {\n            // need to use noop cookiestore as we do not want to keep cookies in memory\n            clientBuilder.setDefaultCookieStore(new NoopCookieStore());\n        }\n\n        LOG.debug(\"Setup the HttpClientBuilder {}\", clientBuilder);\n        return clientBuilder.build();\n    }"
        ],
        [
            "BindyCsvFactory::product(Map)",
            " 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421 -\n 422  \n 423  \n 424  \n 425  \n 426  \n 427  \n 428 -\n 429  \n 430  \n 431  \n 432  \n 433  \n 434  \n 435  \n 436  \n 437  \n 438  \n 439  \n 440  \n 441  ",
            "    private List<List<String>> product(Map<Integer, List<String>> values) {\n        TreeMap<Integer, List<String>> sortValues = new TreeMap<>(values);\n\n        List<List<String>> product = new ArrayList<>();\n        Map<Integer, Integer> index = new HashMap<>();\n\n        int idx = 0;\n        int idxSize = 0;\n        do {\n            idxSize = 0;\n            List<String> v = new ArrayList<>();\n\n            for (int ii = 1; ii <= sortValues.lastKey(); ii++) {\n                List<String> l = values.get(ii);\n                if (l == null) {\n                    v.add(\"\");\n                    ++idxSize;\n                    continue;\n                }\n\n                if (l.size() >= idx + 1) {\n                    v.add(l.get(idx));\n                    index.put(ii, idx);\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Value: {}, pos: {}, at: {}\", new Object[]{l.get(idx), ii, idx});\n                    }\n                } else {\n                    v.add(l.get(0));\n                    index.put(ii, 0);\n                    ++idxSize;\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Value: {}, pos: {}, at index: {}\", new Object[]{l.get(0), ii, 0});\n                    }\n                }\n            }\n\n            if (idxSize != sortValues.lastKey()) {\n                product.add(v);\n            }\n            ++idx;\n\n        } while (idxSize != sortValues.lastKey());\n\n        return product;\n    }",
            " 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421 +\n 422  \n 423  \n 424  \n 425  \n 426  \n 427  \n 428 +\n 429  \n 430  \n 431  \n 432  \n 433  \n 434  \n 435  \n 436  \n 437  \n 438  \n 439  \n 440  \n 441  ",
            "    private List<List<String>> product(Map<Integer, List<String>> values) {\n        TreeMap<Integer, List<String>> sortValues = new TreeMap<>(values);\n\n        List<List<String>> product = new ArrayList<>();\n        Map<Integer, Integer> index = new HashMap<>();\n\n        int idx = 0;\n        int idxSize = 0;\n        do {\n            idxSize = 0;\n            List<String> v = new ArrayList<>();\n\n            for (int ii = 1; ii <= sortValues.lastKey(); ii++) {\n                List<String> l = values.get(ii);\n                if (l == null) {\n                    v.add(\"\");\n                    ++idxSize;\n                    continue;\n                }\n\n                if (l.size() >= idx + 1) {\n                    v.add(l.get(idx));\n                    index.put(ii, idx);\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Value: {}, pos: {}, at: {}\", l.get(idx), ii, idx);\n                    }\n                } else {\n                    v.add(l.get(0));\n                    index.put(ii, 0);\n                    ++idxSize;\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Value: {}, pos: {}, at index: {}\", l.get(0), ii, 0);\n                    }\n                }\n            }\n\n            if (idxSize != sortValues.lastKey()) {\n                product.add(v);\n            }\n            ++idx;\n\n        } while (idxSize != sortValues.lastKey());\n\n        return product;\n    }"
        ],
        [
            "JmsRequestReplyExclusiveReplyToConcurrentTest::testJmsRequestReplyExclusiveFixedReplyTo()",
            "  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51 -\n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  ",
            "    @Test\n    public void testJmsRequestReplyExclusiveFixedReplyTo() throws Exception {\n        StopWatch watch = new StopWatch();\n        ExecutorService executor = Executors.newFixedThreadPool(10);\n        for (int i = 0; i < size; i++) {\n            final Integer num = i;\n            executor.submit(new Runnable() {\n                @Override\n                public void run() {\n                    String reply = template.requestBody(\"direct:start\", \"\" + num, String.class);\n                    log.info(\"Sent {} expecting reply 'Hello {}' got --> {}\", new Object[]{num, num, reply});\n                    assertNotNull(reply);\n                    assertEquals(\"Hello \" + num, reply);\n                    latch.countDown();\n                }\n            });\n        }\n\n        log.info(\"Waiting to process {} messages...\", size);\n\n        // if any of the assertions above fails then the latch will not get decremented \n        assertTrue(\"All assertions outside the main thread above should have passed\", latch.await(3, TimeUnit.SECONDS));\n\n        long delta = watch.stop();\n        log.info(\"Took {} millis\", delta);\n\n        // just sleep a bit before shutting down\n        Thread.sleep(1000);\n\n        executor.shutdownNow();\n    }",
            "  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51 +\n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  ",
            "    @Test\n    public void testJmsRequestReplyExclusiveFixedReplyTo() throws Exception {\n        StopWatch watch = new StopWatch();\n        ExecutorService executor = Executors.newFixedThreadPool(10);\n        for (int i = 0; i < size; i++) {\n            final Integer num = i;\n            executor.submit(new Runnable() {\n                @Override\n                public void run() {\n                    String reply = template.requestBody(\"direct:start\", \"\" + num, String.class);\n                    log.info(\"Sent {} expecting reply 'Hello {}' got --> {}\", num, num, reply);\n                    assertNotNull(reply);\n                    assertEquals(\"Hello \" + num, reply);\n                    latch.countDown();\n                }\n            });\n        }\n\n        log.info(\"Waiting to process {} messages...\", size);\n\n        // if any of the assertions above fails then the latch will not get decremented \n        assertTrue(\"All assertions outside the main thread above should have passed\", latch.await(3, TimeUnit.SECONDS));\n\n        long delta = watch.stop();\n        log.info(\"Took {} millis\", delta);\n\n        // just sleep a bit before shutting down\n        Thread.sleep(1000);\n\n        executor.shutdownNow();\n    }"
        ],
        [
            "CamelSpringTestContextLoader::handleShutdownTimeout(GenericApplicationContext,Class)",
            " 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385 -\n 386  \n 387  \n 388  \n 389  \n 390  ",
            "    /**\n     * Handles updating shutdown timeouts on Camel contexts based on {@link ShutdownTimeout}.\n     *\n     * @param context the initialized Spring context\n     * @param testClass the test class being executed\n     */\n    protected void handleShutdownTimeout(GenericApplicationContext context, Class<?> testClass) throws Exception {\n        final int shutdownTimeout;\n        final TimeUnit shutdownTimeUnit;\n        if (testClass.isAnnotationPresent(ShutdownTimeout.class)) {\n            shutdownTimeout = testClass.getAnnotation(ShutdownTimeout.class).value();\n            shutdownTimeUnit = testClass.getAnnotation(ShutdownTimeout.class).timeUnit();\n        } else {\n            shutdownTimeout = 10;\n            shutdownTimeUnit = TimeUnit.SECONDS;\n        }\n        \n        CamelSpringTestHelper.doToSpringCamelContexts(context, new DoToSpringCamelContextsStrategy() {\n            \n            @Override\n            public void execute(String contextName, SpringCamelContext camelContext)\n                throws Exception {\n                LOG.info(\"Setting shutdown timeout to [{} {}] on CamelContext with name [{}].\", new Object[]{shutdownTimeout, shutdownTimeUnit, contextName});\n                camelContext.getShutdownStrategy().setTimeout(shutdownTimeout);\n                camelContext.getShutdownStrategy().setTimeUnit(shutdownTimeUnit);\n            }\n        });\n    }",
            " 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385 +\n 386  \n 387  \n 388  \n 389  \n 390  ",
            "    /**\n     * Handles updating shutdown timeouts on Camel contexts based on {@link ShutdownTimeout}.\n     *\n     * @param context the initialized Spring context\n     * @param testClass the test class being executed\n     */\n    protected void handleShutdownTimeout(GenericApplicationContext context, Class<?> testClass) throws Exception {\n        final int shutdownTimeout;\n        final TimeUnit shutdownTimeUnit;\n        if (testClass.isAnnotationPresent(ShutdownTimeout.class)) {\n            shutdownTimeout = testClass.getAnnotation(ShutdownTimeout.class).value();\n            shutdownTimeUnit = testClass.getAnnotation(ShutdownTimeout.class).timeUnit();\n        } else {\n            shutdownTimeout = 10;\n            shutdownTimeUnit = TimeUnit.SECONDS;\n        }\n        \n        CamelSpringTestHelper.doToSpringCamelContexts(context, new DoToSpringCamelContextsStrategy() {\n            \n            @Override\n            public void execute(String contextName, SpringCamelContext camelContext)\n                throws Exception {\n                LOG.info(\"Setting shutdown timeout to [{} {}] on CamelContext with name [{}].\", shutdownTimeout, shutdownTimeUnit, contextName);\n                camelContext.getShutdownStrategy().setTimeout(shutdownTimeout);\n                camelContext.getShutdownStrategy().setTimeUnit(shutdownTimeUnit);\n            }\n        });\n    }"
        ],
        [
            "SftpOperations::changeCurrentDirectory(String)",
            " 584  \n 585  \n 586  \n 587  \n 588  \n 589  \n 590  \n 591  \n 592  \n 593  \n 594  \n 595  \n 596 -\n 597  \n 598  \n 599  \n 600  \n 601  \n 602  \n 603  \n 604  \n 605  \n 606  \n 607  \n 608  \n 609  \n 610  \n 611  \n 612  \n 613  \n 614  \n 615  \n 616  \n 617  \n 618  \n 619  \n 620  \n 621  \n 622  \n 623  \n 624  \n 625  \n 626  \n 627  \n 628  \n 629  \n 630  \n 631  \n 632  \n 633  \n 634  ",
            "    public synchronized void changeCurrentDirectory(String path) throws GenericFileOperationFailedException {\n        LOG.trace(\"changeCurrentDirectory({})\", path);\n        if (ObjectHelper.isEmpty(path)) {\n            return;\n        }\n\n        // must compact path so SFTP server can traverse correctly, make use of the '/'\n        // separator because JSch expects this as the file separator even on Windows\n        String before = path;\n        char separatorChar = '/';\n        path = FileUtil.compactPath(path, separatorChar);\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Compacted path: {} -> {} using separator: {}\", new Object[]{before, path, separatorChar});\n        }\n\n        // not stepwise should change directory in one operation\n        if (!endpoint.getConfiguration().isStepwise()) {\n            doChangeDirectory(path);\n            return;\n        }\n        if (getCurrentDirectory().startsWith(path)) {\n            // extract the path segment relative to the target path and make sure it keeps the preceding '/' for the regex op\n            String p = getCurrentDirectory().substring(path.length() - (path.endsWith(\"/\") ?  1 : 0));\n            if (p.length() == 0) {\n                return;\n            }\n            // the first character must be '/' and hence removed\n            path = UP_DIR_PATTERN.matcher(p).replaceAll(\"/..\").substring(1);\n        }\n\n        // if it starts with the root path then a little special handling for that\n        if (FileUtil.hasLeadingSeparator(path)) {\n            // change to root path\n            doChangeDirectory(path.substring(0, 1));\n            path = path.substring(1);\n        }\n\n        // split into multiple dirs\n        final String[] dirs = path.split(\"/|\\\\\\\\\");\n\n        if (dirs == null || dirs.length == 0) {\n            // path was just a relative single path\n            doChangeDirectory(path);\n            return;\n        }\n\n        // there are multiple dirs so do this in chunks\n        for (String dir : dirs) {\n            doChangeDirectory(dir);\n        }\n    }",
            " 584  \n 585  \n 586  \n 587  \n 588  \n 589  \n 590  \n 591  \n 592  \n 593  \n 594  \n 595  \n 596 +\n 597  \n 598  \n 599  \n 600  \n 601  \n 602  \n 603  \n 604  \n 605  \n 606  \n 607  \n 608  \n 609  \n 610  \n 611  \n 612  \n 613  \n 614  \n 615  \n 616  \n 617  \n 618  \n 619  \n 620  \n 621  \n 622  \n 623  \n 624  \n 625  \n 626  \n 627  \n 628  \n 629  \n 630  \n 631  \n 632  \n 633  \n 634  ",
            "    public synchronized void changeCurrentDirectory(String path) throws GenericFileOperationFailedException {\n        LOG.trace(\"changeCurrentDirectory({})\", path);\n        if (ObjectHelper.isEmpty(path)) {\n            return;\n        }\n\n        // must compact path so SFTP server can traverse correctly, make use of the '/'\n        // separator because JSch expects this as the file separator even on Windows\n        String before = path;\n        char separatorChar = '/';\n        path = FileUtil.compactPath(path, separatorChar);\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Compacted path: {} -> {} using separator: {}\", before, path, separatorChar);\n        }\n\n        // not stepwise should change directory in one operation\n        if (!endpoint.getConfiguration().isStepwise()) {\n            doChangeDirectory(path);\n            return;\n        }\n        if (getCurrentDirectory().startsWith(path)) {\n            // extract the path segment relative to the target path and make sure it keeps the preceding '/' for the regex op\n            String p = getCurrentDirectory().substring(path.length() - (path.endsWith(\"/\") ?  1 : 0));\n            if (p.length() == 0) {\n                return;\n            }\n            // the first character must be '/' and hence removed\n            path = UP_DIR_PATTERN.matcher(p).replaceAll(\"/..\").substring(1);\n        }\n\n        // if it starts with the root path then a little special handling for that\n        if (FileUtil.hasLeadingSeparator(path)) {\n            // change to root path\n            doChangeDirectory(path.substring(0, 1));\n            path = path.substring(1);\n        }\n\n        // split into multiple dirs\n        final String[] dirs = path.split(\"/|\\\\\\\\\");\n\n        if (dirs == null || dirs.length == 0) {\n            // path was just a relative single path\n            doChangeDirectory(path);\n            return;\n        }\n\n        // there are multiple dirs so do this in chunks\n        for (String dir : dirs) {\n            doChangeDirectory(dir);\n        }\n    }"
        ],
        [
            "VelocityEndpoint::onExchange(Exchange)",
            " 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195 -\n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  ",
            "    @Override\n    protected void onExchange(Exchange exchange) throws Exception {\n        String path = getResourceUri();\n        ObjectHelper.notNull(path, \"resourceUri\");\n\n        String newResourceUri = exchange.getIn().getHeader(VelocityConstants.VELOCITY_RESOURCE_URI, String.class);\n        if (newResourceUri != null) {\n            exchange.getIn().removeHeader(VelocityConstants.VELOCITY_RESOURCE_URI);\n\n            log.debug(\"{} set to {} creating new endpoint to handle exchange\", VelocityConstants.VELOCITY_RESOURCE_URI, newResourceUri);\n            VelocityEndpoint newEndpoint = findOrCreateEndpoint(getEndpointUri(), newResourceUri);\n            newEndpoint.onExchange(exchange);\n            return;\n        }\n\n        Reader reader;\n        String content = exchange.getIn().getHeader(VelocityConstants.VELOCITY_TEMPLATE, String.class);\n        if (content != null) {\n            // use content from header\n            reader = new StringReader(content);\n            if (log.isDebugEnabled()) {\n                log.debug(\"Velocity content read from header {} for endpoint {}\", VelocityConstants.VELOCITY_TEMPLATE, getEndpointUri());\n            }\n            // remove the header to avoid it being propagated in the routing\n            exchange.getIn().removeHeader(VelocityConstants.VELOCITY_TEMPLATE);\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Velocity content read from resource {} with resourceUri: {} for endpoint {}\", new Object[]{getResourceUri(), path, getEndpointUri()});\n            }\n            reader = getEncoding() != null ? new InputStreamReader(getResourceAsInputStream(), getEncoding()) : new InputStreamReader(getResourceAsInputStream());\n        }\n\n        // getResourceAsInputStream also considers the content cache\n        StringWriter buffer = new StringWriter();\n        String logTag = getClass().getName();\n        Context velocityContext = exchange.getIn().getHeader(VelocityConstants.VELOCITY_CONTEXT, Context.class);\n        if (velocityContext == null) {\n            Map<String, Object> variableMap = ExchangeHelper.createVariableMap(exchange);\n\n            @SuppressWarnings(\"unchecked\")\n            Map<String, Object> supplementalMap = exchange.getIn().getHeader(VelocityConstants.VELOCITY_SUPPLEMENTAL_CONTEXT, Map.class);\n            if (supplementalMap != null) {\n                variableMap.putAll(supplementalMap);\n            }\n\n            velocityContext = new VelocityContext(variableMap);\n        }\n\n        // let velocity parse and generate the result in buffer\n        VelocityEngine engine = getVelocityEngine();\n        log.debug(\"Velocity is evaluating using velocity context: {}\", velocityContext);\n        engine.evaluate(velocityContext, buffer, logTag, reader);\n\n        // now lets output the results to the exchange\n        Message out = exchange.getOut();\n        out.setBody(buffer.toString());\n        out.setHeaders(exchange.getIn().getHeaders());\n        out.setAttachments(exchange.getIn().getAttachments());\n    }",
            " 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195 +\n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  ",
            "    @Override\n    protected void onExchange(Exchange exchange) throws Exception {\n        String path = getResourceUri();\n        ObjectHelper.notNull(path, \"resourceUri\");\n\n        String newResourceUri = exchange.getIn().getHeader(VelocityConstants.VELOCITY_RESOURCE_URI, String.class);\n        if (newResourceUri != null) {\n            exchange.getIn().removeHeader(VelocityConstants.VELOCITY_RESOURCE_URI);\n\n            log.debug(\"{} set to {} creating new endpoint to handle exchange\", VelocityConstants.VELOCITY_RESOURCE_URI, newResourceUri);\n            VelocityEndpoint newEndpoint = findOrCreateEndpoint(getEndpointUri(), newResourceUri);\n            newEndpoint.onExchange(exchange);\n            return;\n        }\n\n        Reader reader;\n        String content = exchange.getIn().getHeader(VelocityConstants.VELOCITY_TEMPLATE, String.class);\n        if (content != null) {\n            // use content from header\n            reader = new StringReader(content);\n            if (log.isDebugEnabled()) {\n                log.debug(\"Velocity content read from header {} for endpoint {}\", VelocityConstants.VELOCITY_TEMPLATE, getEndpointUri());\n            }\n            // remove the header to avoid it being propagated in the routing\n            exchange.getIn().removeHeader(VelocityConstants.VELOCITY_TEMPLATE);\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Velocity content read from resource {} with resourceUri: {} for endpoint {}\", getResourceUri(), path, getEndpointUri());\n            }\n            reader = getEncoding() != null ? new InputStreamReader(getResourceAsInputStream(), getEncoding()) : new InputStreamReader(getResourceAsInputStream());\n        }\n\n        // getResourceAsInputStream also considers the content cache\n        StringWriter buffer = new StringWriter();\n        String logTag = getClass().getName();\n        Context velocityContext = exchange.getIn().getHeader(VelocityConstants.VELOCITY_CONTEXT, Context.class);\n        if (velocityContext == null) {\n            Map<String, Object> variableMap = ExchangeHelper.createVariableMap(exchange);\n\n            @SuppressWarnings(\"unchecked\")\n            Map<String, Object> supplementalMap = exchange.getIn().getHeader(VelocityConstants.VELOCITY_SUPPLEMENTAL_CONTEXT, Map.class);\n            if (supplementalMap != null) {\n                variableMap.putAll(supplementalMap);\n            }\n\n            velocityContext = new VelocityContext(variableMap);\n        }\n\n        // let velocity parse and generate the result in buffer\n        VelocityEngine engine = getVelocityEngine();\n        log.debug(\"Velocity is evaluating using velocity context: {}\", velocityContext);\n        engine.evaluate(velocityContext, buffer, logTag, reader);\n\n        // now lets output the results to the exchange\n        Message out = exchange.getOut();\n        out.setBody(buffer.toString());\n        out.setHeaders(exchange.getIn().getHeaders());\n        out.setAttachments(exchange.getIn().getAttachments());\n    }"
        ],
        [
            "MvelEndpoint::onExchange(Exchange)",
            "  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108 -\n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  ",
            "    @Override\n    protected void onExchange(Exchange exchange) throws Exception {\n        String path = getResourceUri();\n        ObjectHelper.notNull(path, \"resourceUri\");\n\n        String newResourceUri = exchange.getIn().getHeader(MvelConstants.MVEL_RESOURCE_URI, String.class);\n        if (newResourceUri != null) {\n            exchange.getIn().removeHeader(MvelConstants.MVEL_RESOURCE_URI);\n\n            log.debug(\"{} set to {} creating new endpoint to handle exchange\", MvelConstants.MVEL_RESOURCE_URI, newResourceUri);\n            MvelEndpoint newEndpoint = findOrCreateEndpoint(getEndpointUri(), newResourceUri);\n            newEndpoint.onExchange(exchange);\n            return;\n        }\n\n        CompiledTemplate compiled;\n        ParserContext mvelContext = ParserContext.create();\n        Map<String, Object> variableMap = ExchangeHelper.createVariableMap(exchange);\n\n        String content = exchange.getIn().getHeader(MvelConstants.MVEL_TEMPLATE, String.class);\n        if (content != null) {\n            // use content from header\n            if (log.isDebugEnabled()) {\n                log.debug(\"Mvel content read from header {} for endpoint {}\", MvelConstants.MVEL_TEMPLATE, getEndpointUri());\n            }\n            // remove the header to avoid it being propagated in the routing\n            exchange.getIn().removeHeader(MvelConstants.MVEL_TEMPLATE);\n            compiled = TemplateCompiler.compileTemplate(content, mvelContext);\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Mvel content read from resource {} with resourceUri: {} for endpoint {}\", new Object[]{getResourceUri(), path, getEndpointUri()});\n            }\n            // getResourceAsInputStream also considers the content cache\n            Reader reader = getEncoding() != null ? new InputStreamReader(getResourceAsInputStream(), getEncoding()) : new InputStreamReader(getResourceAsInputStream());\n            String template = IOConverter.toString(reader);\n            if (!template.equals(this.template)) {\n                this.template = template;\n                this.compiled = TemplateCompiler.compileTemplate(template, mvelContext);\n            }\n            compiled = this.compiled;\n        }\n\n        // let mvel parse and execute the template\n        log.debug(\"Mvel is evaluating using mvel context: {}\", variableMap);\n        Object result = TemplateRuntime.execute(compiled, mvelContext, variableMap);\n\n        // now lets output the results to the exchange\n        Message out = exchange.getOut();\n        out.setBody(result.toString());\n        out.setHeaders(exchange.getIn().getHeaders());\n        out.setAttachments(exchange.getIn().getAttachments());\n    }",
            "  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108 +\n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  ",
            "    @Override\n    protected void onExchange(Exchange exchange) throws Exception {\n        String path = getResourceUri();\n        ObjectHelper.notNull(path, \"resourceUri\");\n\n        String newResourceUri = exchange.getIn().getHeader(MvelConstants.MVEL_RESOURCE_URI, String.class);\n        if (newResourceUri != null) {\n            exchange.getIn().removeHeader(MvelConstants.MVEL_RESOURCE_URI);\n\n            log.debug(\"{} set to {} creating new endpoint to handle exchange\", MvelConstants.MVEL_RESOURCE_URI, newResourceUri);\n            MvelEndpoint newEndpoint = findOrCreateEndpoint(getEndpointUri(), newResourceUri);\n            newEndpoint.onExchange(exchange);\n            return;\n        }\n\n        CompiledTemplate compiled;\n        ParserContext mvelContext = ParserContext.create();\n        Map<String, Object> variableMap = ExchangeHelper.createVariableMap(exchange);\n\n        String content = exchange.getIn().getHeader(MvelConstants.MVEL_TEMPLATE, String.class);\n        if (content != null) {\n            // use content from header\n            if (log.isDebugEnabled()) {\n                log.debug(\"Mvel content read from header {} for endpoint {}\", MvelConstants.MVEL_TEMPLATE, getEndpointUri());\n            }\n            // remove the header to avoid it being propagated in the routing\n            exchange.getIn().removeHeader(MvelConstants.MVEL_TEMPLATE);\n            compiled = TemplateCompiler.compileTemplate(content, mvelContext);\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Mvel content read from resource {} with resourceUri: {} for endpoint {}\", getResourceUri(), path, getEndpointUri());\n            }\n            // getResourceAsInputStream also considers the content cache\n            Reader reader = getEncoding() != null ? new InputStreamReader(getResourceAsInputStream(), getEncoding()) : new InputStreamReader(getResourceAsInputStream());\n            String template = IOConverter.toString(reader);\n            if (!template.equals(this.template)) {\n                this.template = template;\n                this.compiled = TemplateCompiler.compileTemplate(template, mvelContext);\n            }\n            compiled = this.compiled;\n        }\n\n        // let mvel parse and execute the template\n        log.debug(\"Mvel is evaluating using mvel context: {}\", variableMap);\n        Object result = TemplateRuntime.execute(compiled, mvelContext, variableMap);\n\n        // now lets output the results to the exchange\n        Message out = exchange.getOut();\n        out.setBody(result.toString());\n        out.setHeaders(exchange.getIn().getHeaders());\n        out.setAttachments(exchange.getIn().getAttachments());\n    }"
        ],
        [
            "WebsocketComponent::doStart()",
            " 772  \n 773  \n 774  \n 775  \n 776  \n 777  \n 778  \n 779  \n 780  \n 781 -\n 782  \n 783  \n 784  \n 785  \n 786  \n 787  \n 788  \n 789  \n 790  \n 791  \n 792  \n 793  \n 794  ",
            "    @Override\n    protected void doStart() throws Exception {\n        super.doStart();\n\n        if (staticResources != null) {\n            // host and port must be configured\n            StringHelper.notEmpty(host, \"host\", this);\n            ObjectHelper.notNull(port, \"port\", this);\n\n            LOG.info(\"Starting static resources server {}:{} with static resource: {}\", new Object[]{host, port, staticResources});\n            ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);\n            staticResourcesServer = createStaticResourcesServer(context, host, port, staticResources);\n            staticResourcesServer.start();\n            ServerConnector connector = (ServerConnector) staticResourcesServer.getConnectors()[0];\n\n            // must add static resource server to CONNECTORS in case the websocket producers/consumers\n            // uses the same port number, and therefore we must be part of this\n            MemoryWebsocketStore memoryStore = new MemoryWebsocketStore();\n            ConnectorRef ref = new ConnectorRef(staticResourcesServer, connector, null, memoryStore);\n            String key = \"websocket:\" + host + \":\" + port;\n            CONNECTORS.put(key, ref);\n        }\n    }",
            " 772  \n 773  \n 774  \n 775  \n 776  \n 777  \n 778  \n 779  \n 780  \n 781 +\n 782  \n 783  \n 784  \n 785  \n 786  \n 787  \n 788  \n 789  \n 790  \n 791  \n 792  \n 793  \n 794  ",
            "    @Override\n    protected void doStart() throws Exception {\n        super.doStart();\n\n        if (staticResources != null) {\n            // host and port must be configured\n            StringHelper.notEmpty(host, \"host\", this);\n            ObjectHelper.notNull(port, \"port\", this);\n\n            LOG.info(\"Starting static resources server {}:{} with static resource: {}\", host, port, staticResources);\n            ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);\n            staticResourcesServer = createStaticResourcesServer(context, host, port, staticResources);\n            staticResourcesServer.start();\n            ServerConnector connector = (ServerConnector) staticResourcesServer.getConnectors()[0];\n\n            // must add static resource server to CONNECTORS in case the websocket producers/consumers\n            // uses the same port number, and therefore we must be part of this\n            MemoryWebsocketStore memoryStore = new MemoryWebsocketStore();\n            ConnectorRef ref = new ConnectorRef(staticResourcesServer, connector, null, memoryStore);\n            String key = \"websocket:\" + host + \":\" + port;\n            CONNECTORS.put(key, ref);\n        }\n    }"
        ],
        [
            "TransactionErrorHandler::logTransactionRollback(String,String,Throwable,boolean)",
            " 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281 -\n 282  \n 283 -\n 284  \n 285  \n 286  \n 287 -\n 288  \n 289 -\n 290  \n 291  \n 292  \n 293 -\n 294  \n 295 -\n 296  \n 297  \n 298  \n 299 -\n 300  \n 301 -\n 302  \n 303  \n 304  \n 305 -\n 306  \n 307 -\n 308  \n 309  \n 310  ",
            "    /**\n     * Logs the transaction rollback.\n     */\n    private void logTransactionRollback(String redelivered, String ids, Throwable e, boolean rollbackOnly) {\n        if (rollbackLoggingLevel == LoggingLevel.OFF) {\n            return;\n        } else if (rollbackLoggingLevel == LoggingLevel.ERROR && log.isErrorEnabled()) {\n            if (rollbackOnly) {\n                log.error(\"Transaction rollback ({}) redelivered({}) for {} due exchange was marked for rollbackOnly\", new Object[]{transactionKey, redelivered, ids});\n            } else {\n                log.error(\"Transaction rollback ({}) redelivered({}) for {} caught: {}\", new Object[]{transactionKey, redelivered, ids, e.getMessage()});\n            }\n        } else if (rollbackLoggingLevel == LoggingLevel.WARN && log.isWarnEnabled()) {\n            if (rollbackOnly) {\n                log.warn(\"Transaction rollback ({}) redelivered({}) for {} due exchange was marked for rollbackOnly\", new Object[]{transactionKey, redelivered, ids});\n            } else {\n                log.warn(\"Transaction rollback ({}) redelivered({}) for {} caught: {}\", new Object[]{transactionKey, redelivered, ids, e.getMessage()});\n            }\n        } else if (rollbackLoggingLevel == LoggingLevel.INFO && log.isInfoEnabled()) {\n            if (rollbackOnly) {\n                log.info(\"Transaction rollback ({}) redelivered({}) for {} due exchange was marked for rollbackOnly\", new Object[]{transactionKey, redelivered, ids});\n            } else {\n                log.info(\"Transaction rollback ({}) redelivered({}) for {} caught: {}\", new Object[]{transactionKey, redelivered, ids, e.getMessage()});\n            }\n        } else if (rollbackLoggingLevel == LoggingLevel.DEBUG && log.isDebugEnabled()) {\n            if (rollbackOnly) {\n                log.debug(\"Transaction rollback ({}) redelivered({}) for {} due exchange was marked for rollbackOnly\", new Object[]{transactionKey, redelivered, ids});\n            } else {\n                log.debug(\"Transaction rollback ({}) redelivered({}) for {} caught: {}\", new Object[]{transactionKey, redelivered, ids, e.getMessage()});\n            }\n        } else if (rollbackLoggingLevel == LoggingLevel.TRACE && log.isTraceEnabled()) {\n            if (rollbackOnly) {\n                log.trace(\"Transaction rollback ({}) redelivered({}) for {} due exchange was marked for rollbackOnly\", new Object[]{transactionKey, redelivered, ids});\n            } else {\n                log.trace(\"Transaction rollback ({}) redelivered({}) for {} caught: {}\", new Object[]{transactionKey, redelivered, ids, e.getMessage()});\n            }\n        }\n    }",
            " 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281 +\n 282  \n 283 +\n 284  \n 285  \n 286  \n 287 +\n 288  \n 289 +\n 290  \n 291  \n 292  \n 293 +\n 294  \n 295 +\n 296  \n 297  \n 298  \n 299 +\n 300  \n 301 +\n 302  \n 303  \n 304  \n 305 +\n 306  \n 307 +\n 308  \n 309  \n 310  ",
            "    /**\n     * Logs the transaction rollback.\n     */\n    private void logTransactionRollback(String redelivered, String ids, Throwable e, boolean rollbackOnly) {\n        if (rollbackLoggingLevel == LoggingLevel.OFF) {\n            return;\n        } else if (rollbackLoggingLevel == LoggingLevel.ERROR && log.isErrorEnabled()) {\n            if (rollbackOnly) {\n                log.error(\"Transaction rollback ({}) redelivered({}) for {} due exchange was marked for rollbackOnly\", transactionKey, redelivered, ids);\n            } else {\n                log.error(\"Transaction rollback ({}) redelivered({}) for {} caught: {}\", transactionKey, redelivered, ids, e.getMessage());\n            }\n        } else if (rollbackLoggingLevel == LoggingLevel.WARN && log.isWarnEnabled()) {\n            if (rollbackOnly) {\n                log.warn(\"Transaction rollback ({}) redelivered({}) for {} due exchange was marked for rollbackOnly\", transactionKey, redelivered, ids);\n            } else {\n                log.warn(\"Transaction rollback ({}) redelivered({}) for {} caught: {}\", transactionKey, redelivered, ids, e.getMessage());\n            }\n        } else if (rollbackLoggingLevel == LoggingLevel.INFO && log.isInfoEnabled()) {\n            if (rollbackOnly) {\n                log.info(\"Transaction rollback ({}) redelivered({}) for {} due exchange was marked for rollbackOnly\", transactionKey, redelivered, ids);\n            } else {\n                log.info(\"Transaction rollback ({}) redelivered({}) for {} caught: {}\", transactionKey, redelivered, ids, e.getMessage());\n            }\n        } else if (rollbackLoggingLevel == LoggingLevel.DEBUG && log.isDebugEnabled()) {\n            if (rollbackOnly) {\n                log.debug(\"Transaction rollback ({}) redelivered({}) for {} due exchange was marked for rollbackOnly\", transactionKey, redelivered, ids);\n            } else {\n                log.debug(\"Transaction rollback ({}) redelivered({}) for {} caught: {}\", transactionKey, redelivered, ids, e.getMessage());\n            }\n        } else if (rollbackLoggingLevel == LoggingLevel.TRACE && log.isTraceEnabled()) {\n            if (rollbackOnly) {\n                log.trace(\"Transaction rollback ({}) redelivered({}) for {} due exchange was marked for rollbackOnly\", transactionKey, redelivered, ids);\n            } else {\n                log.trace(\"Transaction rollback ({}) redelivered({}) for {} caught: {}\", transactionKey, redelivered, ids, e.getMessage());\n            }\n        }\n    }"
        ],
        [
            "Jt400PgmProducer::process(Exchange)",
            "  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75 -\n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  ",
            "    public void process(Exchange exchange) throws Exception {\n\n        String commandStr = getISeriesEndpoint().getObjectPath();\n        ProgramParameter[] parameterList = getParameterList(exchange);\n\n        ProgramCall pgmCall;\n        if (getISeriesEndpoint().getType() == Jt400Type.PGM) {\n            pgmCall = new ProgramCall(iSeries);\n        } else {\n            pgmCall = new ServiceProgramCall(iSeries);\n            ((ServiceProgramCall)pgmCall).setProcedureName(getISeriesEndpoint().getProcedureName());\n            ((ServiceProgramCall)pgmCall).setReturnValueFormat(ServiceProgramCall.NO_RETURN_VALUE);\n        }\n        pgmCall.setProgram(commandStr);\n        pgmCall.setParameterList(parameterList);\n\n        if (LOG.isDebugEnabled()) {\n            LOG.trace(\"Starting to call PGM '{}' in host '{}' authentication with the user '{}'\",\n                    new Object[]{commandStr, iSeries.getSystemName(), iSeries.getUserId()});\n        }\n\n        boolean result = pgmCall.run();\n\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Executed PGM '{}' in host '{}'. Success? {}\", new Object[]{commandStr, iSeries.getSystemName(), result});\n        }\n\n        if (result) {\n            handlePGMOutput(exchange, pgmCall, parameterList);\n        } else {\n            throw new Jt400PgmCallException(getOutputMessages(pgmCall));\n        }\n    }",
            "  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75 +\n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  ",
            "    public void process(Exchange exchange) throws Exception {\n\n        String commandStr = getISeriesEndpoint().getObjectPath();\n        ProgramParameter[] parameterList = getParameterList(exchange);\n\n        ProgramCall pgmCall;\n        if (getISeriesEndpoint().getType() == Jt400Type.PGM) {\n            pgmCall = new ProgramCall(iSeries);\n        } else {\n            pgmCall = new ServiceProgramCall(iSeries);\n            ((ServiceProgramCall)pgmCall).setProcedureName(getISeriesEndpoint().getProcedureName());\n            ((ServiceProgramCall)pgmCall).setReturnValueFormat(ServiceProgramCall.NO_RETURN_VALUE);\n        }\n        pgmCall.setProgram(commandStr);\n        pgmCall.setParameterList(parameterList);\n\n        if (LOG.isDebugEnabled()) {\n            LOG.trace(\"Starting to call PGM '{}' in host '{}' authentication with the user '{}'\",\n                    new Object[]{commandStr, iSeries.getSystemName(), iSeries.getUserId()});\n        }\n\n        boolean result = pgmCall.run();\n\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Executed PGM '{}' in host '{}'. Success? {}\", commandStr, iSeries.getSystemName(), result);\n        }\n\n        if (result) {\n            handlePGMOutput(exchange, pgmCall, parameterList);\n        } else {\n            throw new Jt400PgmCallException(getOutputMessages(pgmCall));\n        }\n    }"
        ],
        [
            "ServerChannelHandler::channelRead0(ChannelHandlerContext,Object)",
            "  83  \n  84  \n  85  \n  86  \n  87 -\n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  ",
            "    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {\n        Object in = msg;\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Channel: {} received body: {}\", new Object[]{ctx.channel(), in});\n        }\n\n        // create Exchange and let the consumer process it\n        final Exchange exchange = consumer.getEndpoint().createExchange(ctx, msg);\n        if (consumer.getConfiguration().isSync()) {\n            exchange.setPattern(ExchangePattern.InOut);\n        }\n        // set the exchange charset property for converting\n        if (consumer.getConfiguration().getCharsetName() != null) {\n            exchange.setProperty(Exchange.CHARSET_NAME, IOHelper.normalizeCharset(consumer.getConfiguration().getCharsetName()));\n        }\n        if (consumer.getConfiguration().isReuseChannel()) {\n            exchange.setProperty(NettyConstants.NETTY_CHANNEL, ctx.channel());\n        }\n\n        // we want to handle the UoW\n        consumer.createUoW(exchange);\n\n        beforeProcess(exchange, ctx, msg);\n\n        // process accordingly to endpoint configuration\n        if (consumer.getEndpoint().isSynchronous()) {\n            processSynchronously(exchange, ctx, msg);\n        } else {\n            processAsynchronously(exchange, ctx, msg);\n        }\n    }",
            "  83  \n  84  \n  85  \n  86  \n  87 +\n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  ",
            "    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {\n        Object in = msg;\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Channel: {} received body: {}\", ctx.channel(), in);\n        }\n\n        // create Exchange and let the consumer process it\n        final Exchange exchange = consumer.getEndpoint().createExchange(ctx, msg);\n        if (consumer.getConfiguration().isSync()) {\n            exchange.setPattern(ExchangePattern.InOut);\n        }\n        // set the exchange charset property for converting\n        if (consumer.getConfiguration().getCharsetName() != null) {\n            exchange.setProperty(Exchange.CHARSET_NAME, IOHelper.normalizeCharset(consumer.getConfiguration().getCharsetName()));\n        }\n        if (consumer.getConfiguration().isReuseChannel()) {\n            exchange.setProperty(NettyConstants.NETTY_CHANNEL, ctx.channel());\n        }\n\n        // we want to handle the UoW\n        consumer.createUoW(exchange);\n\n        beforeProcess(exchange, ctx, msg);\n\n        // process accordingly to endpoint configuration\n        if (consumer.getEndpoint().isSynchronous()) {\n            processSynchronously(exchange, ctx, msg);\n        } else {\n            processAsynchronously(exchange, ctx, msg);\n        }\n    }"
        ],
        [
            "JoltEndpoint::getTransform()",
            "  79  \n  80  \n  81  \n  82  \n  83 -\n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  ",
            "    private synchronized JoltTransform getTransform() throws Exception {\n        if (transform == null) {\n            if (log.isDebugEnabled()) {\n                String path = getResourceUri();\n                log.debug(\"Jolt content read from resource {} with resourceUri: {} for endpoint {}\", new Object[]{getResourceUri(), path, getEndpointUri()});\n            }\n\n            // Sortr does not require a spec\n            if (this.transformDsl == JoltTransformType.Sortr) {\n                this.transform = new Sortr();\n            } else {\n                // getResourceAsInputStream also considers the content cache\n                Object spec = JsonUtils.jsonToObject(getResourceAsInputStream());\n                switch(this.transformDsl) {\n                case Shiftr:\n                    this.transform = new Shiftr(spec);\n                    break;\n                case Defaultr:\n                    this.transform = new Defaultr(spec);\n                    break;\n                case Removr:\n                    this.transform = new Removr(spec);\n                    break;\n                case Chainr:\n                default:\n                    this.transform = Chainr.fromSpec(spec);\n                    break;\n                }\n            }\n\n        }\n        return transform;\n    }",
            "  79  \n  80  \n  81  \n  82  \n  83 +\n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  ",
            "    private synchronized JoltTransform getTransform() throws Exception {\n        if (transform == null) {\n            if (log.isDebugEnabled()) {\n                String path = getResourceUri();\n                log.debug(\"Jolt content read from resource {} with resourceUri: {} for endpoint {}\", getResourceUri(), path, getEndpointUri());\n            }\n\n            // Sortr does not require a spec\n            if (this.transformDsl == JoltTransformType.Sortr) {\n                this.transform = new Sortr();\n            } else {\n                // getResourceAsInputStream also considers the content cache\n                Object spec = JsonUtils.jsonToObject(getResourceAsInputStream());\n                switch(this.transformDsl) {\n                case Shiftr:\n                    this.transform = new Shiftr(spec);\n                    break;\n                case Defaultr:\n                    this.transform = new Defaultr(spec);\n                    break;\n                case Removr:\n                    this.transform = new Removr(spec);\n                    break;\n                case Chainr:\n                default:\n                    this.transform = Chainr.fromSpec(spec);\n                    break;\n                }\n            }\n\n        }\n        return transform;\n    }"
        ],
        [
            "HdfsConsumer::setupHdfs(boolean)",
            "  70  \n  71  \n  72  \n  73 -\n  74  \n  75  \n  76 -\n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84 -\n  85  \n  86  \n  87 -\n  88  \n  89  \n  90  \n  91  ",
            "    private HdfsInfo setupHdfs(boolean onStartup) throws Exception {\n        // if we are starting up then log at info level, and if runtime then log at debug level to not flood the log\n        if (onStartup) {\n            log.info(\"Connecting to hdfs file-system {}:{}/{} (may take a while if connection is not available)\", new Object[]{config.getHostName(), config.getPort(), hdfsPath.toString()});\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Connecting to hdfs file-system {}:{}/{} (may take a while if connection is not available)\", new Object[]{config.getHostName(), config.getPort(), hdfsPath.toString()});\n            }\n        }\n\n        // hadoop will cache the connection by default so its faster to get in the poll method\n        HdfsInfo answer = HdfsInfoFactory.newHdfsInfo(this.hdfsPath.toString());\n\n        if (onStartup) {\n            log.info(\"Connected to hdfs file-system {}:{}/{}\", new Object[]{config.getHostName(), config.getPort(), hdfsPath.toString()});\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Connected to hdfs file-system {}:{}/{}\", new Object[]{config.getHostName(), config.getPort(), hdfsPath.toString()});\n            }\n        }\n        return answer;\n    }",
            "  70  \n  71  \n  72  \n  73 +\n  74  \n  75  \n  76 +\n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84 +\n  85  \n  86  \n  87 +\n  88  \n  89  \n  90  \n  91  ",
            "    private HdfsInfo setupHdfs(boolean onStartup) throws Exception {\n        // if we are starting up then log at info level, and if runtime then log at debug level to not flood the log\n        if (onStartup) {\n            log.info(\"Connecting to hdfs file-system {}:{}/{} (may take a while if connection is not available)\", config.getHostName(), config.getPort(), hdfsPath.toString());\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Connecting to hdfs file-system {}:{}/{} (may take a while if connection is not available)\", config.getHostName(), config.getPort(), hdfsPath.toString());\n            }\n        }\n\n        // hadoop will cache the connection by default so its faster to get in the poll method\n        HdfsInfo answer = HdfsInfoFactory.newHdfsInfo(this.hdfsPath.toString());\n\n        if (onStartup) {\n            log.info(\"Connected to hdfs file-system {}:{}/{}\", config.getHostName(), config.getPort(), hdfsPath.toString());\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Connected to hdfs file-system {}:{}/{}\", config.getHostName(), config.getPort(), hdfsPath.toString());\n            }\n        }\n        return answer;\n    }"
        ],
        [
            "EndpointMessageListener::sendReply(String,Message,Exchange,org,Exception)",
            " 384  \n 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397 -\n 398  \n 399  \n 400  \n 401  \n 402  ",
            "    protected void sendReply(String replyDestination, final Message message, final Exchange exchange,\n                             final org.apache.camel.Message out, final Exception cause) {\n        if (replyDestination == null) {\n            LOG.debug(\"Cannot send reply message as there is no replyDestination for: {}\", out);\n            return;\n        }\n        getTemplate().send(replyDestination, new MessageCreator() {\n            public Message createMessage(Session session) throws JMSException {\n                Message reply = endpoint.getBinding().makeJmsMessage(exchange, out, session, cause);\n                final String correlationID = determineCorrelationId(message);\n                reply.setJMSCorrelationID(correlationID);\n\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"{} sending reply JMS message [correlationId:{}]: {}\", new Object[]{endpoint, correlationID, reply});\n                }\n                return reply;\n            }\n        });\n    }",
            " 384  \n 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397 +\n 398  \n 399  \n 400  \n 401  \n 402  ",
            "    protected void sendReply(String replyDestination, final Message message, final Exchange exchange,\n                             final org.apache.camel.Message out, final Exception cause) {\n        if (replyDestination == null) {\n            LOG.debug(\"Cannot send reply message as there is no replyDestination for: {}\", out);\n            return;\n        }\n        getTemplate().send(replyDestination, new MessageCreator() {\n            public Message createMessage(Session session) throws JMSException {\n                Message reply = endpoint.getBinding().makeJmsMessage(exchange, out, session, cause);\n                final String correlationID = determineCorrelationId(message);\n                reply.setJMSCorrelationID(correlationID);\n\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"{} sending reply JMS message [correlationId:{}]: {}\", endpoint, correlationID, reply);\n                }\n                return reply;\n            }\n        });\n    }"
        ],
        [
            "StreamProducer::writeToStream(OutputStream,Exchange)",
            " 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153 -\n 154  \n 155  \n 156  \n 157  \n 158  ",
            "    private void writeToStream(OutputStream outputStream, Exchange exchange) throws IOException, CamelExchangeException {\n        Object body = exchange.getIn().getBody();\n\n        if (body == null) {\n            log.debug(\"Body is null, cannot write it to the stream.\");\n            return;\n        }\n\n        // if not a string then try as byte array first\n        if (!(body instanceof String)) {\n            byte[] bytes = exchange.getIn().getBody(byte[].class);\n            if (bytes != null) {\n                LOG.debug(\"Writing as byte[]: {} to {}\", bytes, outputStream);\n                outputStream.write(bytes);\n                return;\n            }\n        }\n\n        // okay now fallback to mandatory converterable to string\n        String s = exchange.getIn().getMandatoryBody(String.class);\n        Charset charset = endpoint.getCharset();\n        Writer writer = new OutputStreamWriter(outputStream, charset);\n        BufferedWriter bw = IOHelper.buffered(writer);\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Writing as text: {} to {} using encoding: {}\", new Object[]{body, outputStream, charset});\n        }\n        bw.write(s);\n        bw.write(System.lineSeparator());\n        bw.flush();\n    }",
            " 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153 +\n 154  \n 155  \n 156  \n 157  \n 158  ",
            "    private void writeToStream(OutputStream outputStream, Exchange exchange) throws IOException, CamelExchangeException {\n        Object body = exchange.getIn().getBody();\n\n        if (body == null) {\n            log.debug(\"Body is null, cannot write it to the stream.\");\n            return;\n        }\n\n        // if not a string then try as byte array first\n        if (!(body instanceof String)) {\n            byte[] bytes = exchange.getIn().getBody(byte[].class);\n            if (bytes != null) {\n                LOG.debug(\"Writing as byte[]: {} to {}\", bytes, outputStream);\n                outputStream.write(bytes);\n                return;\n            }\n        }\n\n        // okay now fallback to mandatory converterable to string\n        String s = exchange.getIn().getMandatoryBody(String.class);\n        Charset charset = endpoint.getCharset();\n        Writer writer = new OutputStreamWriter(outputStream, charset);\n        BufferedWriter bw = IOHelper.buffered(writer);\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Writing as text: {} to {} using encoding: {}\", body, outputStream, charset);\n        }\n        bw.write(s);\n        bw.write(System.lineSeparator());\n        bw.flush();\n    }"
        ],
        [
            "BindyFixedLengthFactory::initAnnotatedFields()",
            " 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117 -\n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  ",
            "    @Override\n    public void initAnnotatedFields() {\n\n        for (Class<?> cl : models) {\n\n            List<Field> linkFields = new ArrayList<>();\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Class retrieved: {}\", cl.getName());\n            }\n\n            for (Field field : cl.getDeclaredFields()) {\n                DataField dataField = field.getAnnotation(DataField.class);\n                if (dataField != null) {\n\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Position defined in the class: {}, position: {}, Field: {}\", new Object[]{cl.getName(), dataField.pos(), dataField});\n                    }\n\n                    if (dataField.required()) {\n                        ++numberMandatoryFields;\n                    } else {\n                        ++numberOptionalFields;\n                    }\n\n                    dataFields.put(dataField.pos(), dataField);\n                    annotatedFields.put(dataField.pos(), field);\n                }\n\n                Link linkField = field.getAnnotation(Link.class);\n\n                if (linkField != null) {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Class linked: {}, Field: {}\", cl.getName(), field);\n                    }\n                    linkFields.add(field);\n                }\n\n            }\n\n            if (!linkFields.isEmpty()) {\n                annotatedLinkFields.put(cl.getName(), linkFields);\n            }\n\n            totalFields = numberMandatoryFields + numberOptionalFields;\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Number of optional fields: {}\", numberOptionalFields);\n                LOG.debug(\"Number of mandatory fields: {}\", numberMandatoryFields);\n                LOG.debug(\"Total: {}\", totalFields);\n            }\n\n        }\n    }",
            " 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117 +\n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  ",
            "    @Override\n    public void initAnnotatedFields() {\n\n        for (Class<?> cl : models) {\n\n            List<Field> linkFields = new ArrayList<>();\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Class retrieved: {}\", cl.getName());\n            }\n\n            for (Field field : cl.getDeclaredFields()) {\n                DataField dataField = field.getAnnotation(DataField.class);\n                if (dataField != null) {\n\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Position defined in the class: {}, position: {}, Field: {}\", cl.getName(), dataField.pos(), dataField);\n                    }\n\n                    if (dataField.required()) {\n                        ++numberMandatoryFields;\n                    } else {\n                        ++numberOptionalFields;\n                    }\n\n                    dataFields.put(dataField.pos(), dataField);\n                    annotatedFields.put(dataField.pos(), field);\n                }\n\n                Link linkField = field.getAnnotation(Link.class);\n\n                if (linkField != null) {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Class linked: {}, Field: {}\", cl.getName(), field);\n                    }\n                    linkFields.add(field);\n                }\n\n            }\n\n            if (!linkFields.isEmpty()) {\n                annotatedLinkFields.put(cl.getName(), linkFields);\n            }\n\n            totalFields = numberMandatoryFields + numberOptionalFields;\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Number of optional fields: {}\", numberOptionalFields);\n                LOG.debug(\"Number of mandatory fields: {}\", numberMandatoryFields);\n                LOG.debug(\"Total: {}\", totalFields);\n            }\n\n        }\n    }"
        ],
        [
            "ScheduledRoutePolicy::scheduleRoute(Action,Route)",
            "  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117 -\n 118  \n 119  ",
            "    public void scheduleRoute(Action action, Route route) throws Exception {\n        JobDetail jobDetail = createJobDetail(action, route);\n        Trigger trigger = createTrigger(action, route);\n        updateScheduledRouteDetails(action, jobDetail, trigger, route);\n        \n        loadCallbackDataIntoSchedulerContext(jobDetail, action, route);\n\n        boolean isClustered = route.getRouteContext().getCamelContext().getComponent(\"quartz\", QuartzComponent.class).isClustered();\n        if (isClustered) {\n            // check to see if the same job has already been setup through another node of the cluster\n            JobDetail existingJobDetail = getScheduler().getJobDetail(jobDetail.getName(), jobDetail.getGroup());\n            if (jobDetail.equals(existingJobDetail)) {\n                if (LOG.isInfoEnabled()) {\n                    LOG.info(\"Skipping to schedule the job: {} for action: {} on route {} as the job: {} already existing inside the cluster\",\n                             new Object[] {jobDetail.getFullName(), action, route.getId(), existingJobDetail.getFullName()});\n                }\n\n                // skip scheduling the same job again as one is already existing for the same routeId and action\n                return;\n            }\n        }\n\n        getScheduler().scheduleJob(jobDetail, trigger);\n\n        if (LOG.isInfoEnabled()) {\n            LOG.info(\"Scheduled trigger: {} for action: {} on route {}\", new Object[]{trigger.getFullName(), action, route.getId()});\n        }\n    }",
            "  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117 +\n 118  \n 119  ",
            "    public void scheduleRoute(Action action, Route route) throws Exception {\n        JobDetail jobDetail = createJobDetail(action, route);\n        Trigger trigger = createTrigger(action, route);\n        updateScheduledRouteDetails(action, jobDetail, trigger, route);\n        \n        loadCallbackDataIntoSchedulerContext(jobDetail, action, route);\n\n        boolean isClustered = route.getRouteContext().getCamelContext().getComponent(\"quartz\", QuartzComponent.class).isClustered();\n        if (isClustered) {\n            // check to see if the same job has already been setup through another node of the cluster\n            JobDetail existingJobDetail = getScheduler().getJobDetail(jobDetail.getName(), jobDetail.getGroup());\n            if (jobDetail.equals(existingJobDetail)) {\n                if (LOG.isInfoEnabled()) {\n                    LOG.info(\"Skipping to schedule the job: {} for action: {} on route {} as the job: {} already existing inside the cluster\",\n                             new Object[] {jobDetail.getFullName(), action, route.getId(), existingJobDetail.getFullName()});\n                }\n\n                // skip scheduling the same job again as one is already existing for the same routeId and action\n                return;\n            }\n        }\n\n        getScheduler().scheduleJob(jobDetail, trigger);\n\n        if (LOG.isInfoEnabled()) {\n            LOG.info(\"Scheduled trigger: {} for action: {} on route {}\", trigger.getFullName(), action, route.getId());\n        }\n    }"
        ],
        [
            "TransactionErrorHandler::logTransactionBegin(String,String)",
            " 246  \n 247  \n 248  \n 249  \n 250  \n 251 -\n 252  \n 253  ",
            "    /**\n     * Logs the transaction begin\n     */\n    private void logTransactionBegin(String redelivered, String ids) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Transaction begin ({}) redelivered({}) for {})\", new Object[]{transactionKey, redelivered, ids});\n        }\n    }",
            " 246  \n 247  \n 248  \n 249  \n 250  \n 251 +\n 252  \n 253  ",
            "    /**\n     * Logs the transaction begin\n     */\n    private void logTransactionBegin(String redelivered, String ids) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Transaction begin ({}) redelivered({}) for {})\", transactionKey, redelivered, ids);\n        }\n    }"
        ],
        [
            "RestSwaggerServlet::doGet(HttpServletRequest,HttpServletResponse)",
            " 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204 -\n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  ",
            "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\n        if (!initDone) {\n            initBaseAndApiPaths(request);\n        }\n\n        String contextId = null;\n        String route = request.getPathInfo();\n        String accept = request.getHeader(\"Accept\");\n\n        // whether to use json or yaml\n        boolean json = false;\n        boolean yaml = false;\n        if (route != null && route.endsWith(\"/swagger.json\")) {\n            json = true;\n            route = route.substring(0, route.length() - 13);\n        } else if (route != null && route.endsWith(\"/swagger.yaml\")) {\n            yaml = true;\n            route = route.substring(0, route.length() - 13);\n        }\n        if (accept != null && !json && !yaml) {\n            json = accept.toLowerCase(Locale.US).contains(\"json\");\n            yaml = accept.toLowerCase(Locale.US).contains(\"yaml\");\n        }\n        if (!json && !yaml) {\n            // json is default\n            json = true;\n        }\n\n        RestApiResponseAdapter adapter = new ServletRestApiResponseAdapter(response);\n\n        try {\n            // render list of camel contexts as root\n            if (apiContextIdListing && (ObjectHelper.isEmpty(route) || route.equals(\"/\"))) {\n                support.renderCamelContexts(adapter, contextId, apiContextIdPattern, json, yaml, null);\n            } else {\n                String name = null;\n                if (ObjectHelper.isNotEmpty(route)) {\n                    // first part is the camel context\n                    if (route.startsWith(\"/\")) {\n                        route = route.substring(1);\n                    }\n                    // the remainder is the route part\n                    name = route.split(\"/\")[0];\n                    if (ObjectHelper.isNotEmpty(name)) {\n                        route = route.substring(name.length());\n                    }\n                } else {\n                    // listing not enabled then see if there is only one CamelContext and use that as the name\n                    List<String> contexts = support.findCamelContexts();\n                    if (contexts.size() == 1) {\n                        name = contexts.get(0);\n                    }\n                }\n\n                boolean match = false;\n                if (name != null) {\n                    match = true;\n                    if (apiContextIdPattern != null) {\n                        if (\"#name#\".equals(apiContextIdPattern)) {\n                            // always match as we do not know what is the current CamelContext in a plain servlet\n                            match = true;\n                        } else {\n                            match = EndpointHelper.matchPattern(name, apiContextIdPattern);\n                        }\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Match contextId: {} with pattern: {} -> {}\", new Object[]{name, apiContextIdPattern, match});\n                        }\n                    }\n                }\n\n                if (!match) {\n                    adapter.noContent();\n                } else {\n                    support.renderResourceListing(adapter, swaggerConfig, name, route, json, yaml, classResolver, new RestConfiguration());\n                }\n            }\n        } catch (Exception e) {\n            LOG.warn(\"Error rendering Swagger API due \" + e.getMessage(), e);\n        }\n    }",
            " 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204 +\n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  ",
            "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\n        if (!initDone) {\n            initBaseAndApiPaths(request);\n        }\n\n        String contextId = null;\n        String route = request.getPathInfo();\n        String accept = request.getHeader(\"Accept\");\n\n        // whether to use json or yaml\n        boolean json = false;\n        boolean yaml = false;\n        if (route != null && route.endsWith(\"/swagger.json\")) {\n            json = true;\n            route = route.substring(0, route.length() - 13);\n        } else if (route != null && route.endsWith(\"/swagger.yaml\")) {\n            yaml = true;\n            route = route.substring(0, route.length() - 13);\n        }\n        if (accept != null && !json && !yaml) {\n            json = accept.toLowerCase(Locale.US).contains(\"json\");\n            yaml = accept.toLowerCase(Locale.US).contains(\"yaml\");\n        }\n        if (!json && !yaml) {\n            // json is default\n            json = true;\n        }\n\n        RestApiResponseAdapter adapter = new ServletRestApiResponseAdapter(response);\n\n        try {\n            // render list of camel contexts as root\n            if (apiContextIdListing && (ObjectHelper.isEmpty(route) || route.equals(\"/\"))) {\n                support.renderCamelContexts(adapter, contextId, apiContextIdPattern, json, yaml, null);\n            } else {\n                String name = null;\n                if (ObjectHelper.isNotEmpty(route)) {\n                    // first part is the camel context\n                    if (route.startsWith(\"/\")) {\n                        route = route.substring(1);\n                    }\n                    // the remainder is the route part\n                    name = route.split(\"/\")[0];\n                    if (ObjectHelper.isNotEmpty(name)) {\n                        route = route.substring(name.length());\n                    }\n                } else {\n                    // listing not enabled then see if there is only one CamelContext and use that as the name\n                    List<String> contexts = support.findCamelContexts();\n                    if (contexts.size() == 1) {\n                        name = contexts.get(0);\n                    }\n                }\n\n                boolean match = false;\n                if (name != null) {\n                    match = true;\n                    if (apiContextIdPattern != null) {\n                        if (\"#name#\".equals(apiContextIdPattern)) {\n                            // always match as we do not know what is the current CamelContext in a plain servlet\n                            match = true;\n                        } else {\n                            match = EndpointHelper.matchPattern(name, apiContextIdPattern);\n                        }\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Match contextId: {} with pattern: {} -> {}\", name, apiContextIdPattern, match);\n                        }\n                    }\n                }\n\n                if (!match) {\n                    adapter.noContent();\n                } else {\n                    support.renderResourceListing(adapter, swaggerConfig, name, route, json, yaml, classResolver, new RestConfiguration());\n                }\n            }\n        } catch (Exception e) {\n            LOG.warn(\"Error rendering Swagger API due \" + e.getMessage(), e);\n        }\n    }"
        ],
        [
            "FtpConsumer::doPollDirectory(String,String,List,int)",
            " 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176 -\n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  ",
            "    protected boolean doPollDirectory(String absolutePath, String dirName, List<GenericFile<FTPFile>> fileList, int depth) {\n        log.trace(\"doPollDirectory from absolutePath: {}, dirName: {}\", absolutePath, dirName);\n\n        depth++;\n\n        // remove trailing /\n        dirName = FileUtil.stripTrailingSeparator(dirName);\n\n        // compute dir depending on stepwise is enabled or not\n        String dir = null;\n        List<FTPFile> files = null;\n        try {\n            if (isStepwise()) {\n                dir = ObjectHelper.isNotEmpty(dirName) ? dirName : absolutePath;\n                operations.changeCurrentDirectory(dir);\n            } else {\n                dir = absolutePath;\n            }\n\n            log.trace(\"Polling directory: {}\", dir);\n            if (isUseList()) {\n                if (isStepwise()) {\n                    files = operations.listFiles();\n                } else {\n                    files = operations.listFiles(dir);\n                }\n            } else {\n                // we cannot use the LIST command(s) so we can only poll a named file\n                // so created a pseudo file with that name\n                FTPFile file = new FTPFile();\n                file.setType(FTPFile.FILE_TYPE);\n                fileExpressionResult = evaluateFileExpression();\n                if (fileExpressionResult != null) {\n                    file.setName(fileExpressionResult);\n                    files = new ArrayList<>(1);\n                    files.add(file);\n                }\n            }\n        } catch (GenericFileOperationFailedException e) {\n            if (ignoreCannotRetrieveFile(null, null, e)) {\n                log.debug(\"Cannot list files in directory {} due directory does not exists or file permission error.\", dir);\n            } else {\n                throw e;\n            }\n        }\n\n        if (files == null || files.isEmpty()) {\n            // no files in this directory to poll\n            log.trace(\"No files found in directory: {}\", dir);\n            return true;\n        } else {\n            // we found some files\n            log.trace(\"Found {} in directory: {}\", files.size(), dir);\n        }\n\n        if (getEndpoint().isPreSort()) {\n            Collections.sort(files, (a, b) -> a.getName().compareTo(b.getName()));\n        }\n\n        for (FTPFile file : files) {\n\n            if (log.isTraceEnabled()) {\n                log.trace(\"FtpFile[name={}, dir={}, file={}]\", new Object[]{file.getName(), file.isDirectory(), file.isFile()});\n            }\n\n            // check if we can continue polling in files\n            if (!canPollMoreFiles(fileList)) {\n                return false;\n            }\n\n            if (file.isDirectory()) {\n                RemoteFile<FTPFile> remote = asRemoteFile(absolutePath, file, getEndpoint().getCharset());\n                if (endpoint.isRecursive() && depth < endpoint.getMaxDepth() && isValidFile(remote, true, files)) {\n                    // recursive scan and add the sub files and folders\n                    String subDirectory = file.getName();\n                    String path = absolutePath + \"/\" + subDirectory;\n                    boolean canPollMore = pollSubDirectory(path, subDirectory, fileList, depth);\n                    if (!canPollMore) {\n                        return false;\n                    }\n                }\n            } else if (file.isFile()) {\n                RemoteFile<FTPFile> remote = asRemoteFile(absolutePath, file, getEndpoint().getCharset());\n                if (depth >= endpoint.getMinDepth() && isValidFile(remote, false, files)) {\n                    // matched file so add\n                    fileList.add(remote);\n                }\n            } else {\n                log.debug(\"Ignoring unsupported remote file type: \" + file);\n            }\n        }\n\n        return true;\n    }",
            " 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176 +\n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  ",
            "    protected boolean doPollDirectory(String absolutePath, String dirName, List<GenericFile<FTPFile>> fileList, int depth) {\n        log.trace(\"doPollDirectory from absolutePath: {}, dirName: {}\", absolutePath, dirName);\n\n        depth++;\n\n        // remove trailing /\n        dirName = FileUtil.stripTrailingSeparator(dirName);\n\n        // compute dir depending on stepwise is enabled or not\n        String dir = null;\n        List<FTPFile> files = null;\n        try {\n            if (isStepwise()) {\n                dir = ObjectHelper.isNotEmpty(dirName) ? dirName : absolutePath;\n                operations.changeCurrentDirectory(dir);\n            } else {\n                dir = absolutePath;\n            }\n\n            log.trace(\"Polling directory: {}\", dir);\n            if (isUseList()) {\n                if (isStepwise()) {\n                    files = operations.listFiles();\n                } else {\n                    files = operations.listFiles(dir);\n                }\n            } else {\n                // we cannot use the LIST command(s) so we can only poll a named file\n                // so created a pseudo file with that name\n                FTPFile file = new FTPFile();\n                file.setType(FTPFile.FILE_TYPE);\n                fileExpressionResult = evaluateFileExpression();\n                if (fileExpressionResult != null) {\n                    file.setName(fileExpressionResult);\n                    files = new ArrayList<>(1);\n                    files.add(file);\n                }\n            }\n        } catch (GenericFileOperationFailedException e) {\n            if (ignoreCannotRetrieveFile(null, null, e)) {\n                log.debug(\"Cannot list files in directory {} due directory does not exists or file permission error.\", dir);\n            } else {\n                throw e;\n            }\n        }\n\n        if (files == null || files.isEmpty()) {\n            // no files in this directory to poll\n            log.trace(\"No files found in directory: {}\", dir);\n            return true;\n        } else {\n            // we found some files\n            log.trace(\"Found {} in directory: {}\", files.size(), dir);\n        }\n\n        if (getEndpoint().isPreSort()) {\n            Collections.sort(files, (a, b) -> a.getName().compareTo(b.getName()));\n        }\n\n        for (FTPFile file : files) {\n\n            if (log.isTraceEnabled()) {\n                log.trace(\"FtpFile[name={}, dir={}, file={}]\", file.getName(), file.isDirectory(), file.isFile());\n            }\n\n            // check if we can continue polling in files\n            if (!canPollMoreFiles(fileList)) {\n                return false;\n            }\n\n            if (file.isDirectory()) {\n                RemoteFile<FTPFile> remote = asRemoteFile(absolutePath, file, getEndpoint().getCharset());\n                if (endpoint.isRecursive() && depth < endpoint.getMaxDepth() && isValidFile(remote, true, files)) {\n                    // recursive scan and add the sub files and folders\n                    String subDirectory = file.getName();\n                    String path = absolutePath + \"/\" + subDirectory;\n                    boolean canPollMore = pollSubDirectory(path, subDirectory, fileList, depth);\n                    if (!canPollMore) {\n                        return false;\n                    }\n                }\n            } else if (file.isFile()) {\n                RemoteFile<FTPFile> remote = asRemoteFile(absolutePath, file, getEndpoint().getCharset());\n                if (depth >= endpoint.getMinDepth() && isValidFile(remote, false, files)) {\n                    // matched file so add\n                    fileList.add(remote);\n                }\n            } else {\n                log.debug(\"Ignoring unsupported remote file type: \" + file);\n            }\n        }\n\n        return true;\n    }"
        ]
    ]
}