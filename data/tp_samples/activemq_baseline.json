{
    "3b5d89a78b12e63f998f239a155f71a557a87ea9": [
        [
            "BaseDestination::convertToNonRangedAck(MessageAck,MessageReference)",
            " 775  \n 776  \n 777  \n 778  \n 779  \n 780  \n 781  \n 782  \n 783  \n 784  \n 785 -\n 786 -\n 787  \n 788  \n 789  \n 790  ",
            "    protected MessageAck convertToNonRangedAck(MessageAck ack, MessageReference node) {\n        // the original ack may be a ranged ack, but we are trying to delete\n        // a specific\n        // message store here so we need to convert to a non ranged ack.\n        if (ack.getMessageCount() > 0) {\n            // Dup the ack\n            MessageAck a = new MessageAck();\n            ack.copy(a);\n            ack = a;\n            // Convert to non-ranged.\n            ack.setFirstMessageId(node.getMessageId());\n            ack.setLastMessageId(node.getMessageId());\n            ack.setMessageCount(1);\n        }\n        return ack;\n    }",
            " 775  \n 776  \n 777  \n 778  \n 779  \n 780  \n 781  \n 782  \n 783  \n 784  \n 785  \n 786  \n 787 +\n 788 +\n 789 +\n 790  \n 791  ",
            "    protected MessageAck convertToNonRangedAck(MessageAck ack, MessageReference node) {\n        // the original ack may be a ranged ack, but we are trying to delete\n        // a specific\n        // message store here so we need to convert to a non ranged ack.\n        if (ack.getMessageCount() > 0) {\n            // Dup the ack\n            MessageAck a = new MessageAck();\n            ack.copy(a);\n            ack = a;\n            // Convert to non-ranged.\n            ack.setMessageCount(1);\n        }\n        // always use node messageId so we can access entry/data Location\n        ack.setFirstMessageId(node.getMessageId());\n        ack.setLastMessageId(node.getMessageId());\n        return ack;\n    }"
        ],
        [
            "JDBCMessageStore::recoverNextMessages(int,MessageRecoveryListener)",
            " 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344  \n 345  \n 346  \n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  ",
            "    /**\n     * @param maxReturned\n     * @param listener\n     * @throws Exception\n     * @see org.apache.activemq.store.MessageStore#recoverNextMessages(int,\n     *      org.apache.activemq.store.MessageRecoveryListener)\n     */\n    public void recoverNextMessages(int maxReturned, final MessageRecoveryListener listener) throws Exception {\n        TransactionContext c = persistenceAdapter.getTransactionContext();\n        try {\n            if (!recoveredAdditions.isEmpty()) {\n                for (Iterator<Long> iterator = recoveredAdditions.iterator(); iterator.hasNext(); )  {\n                    Long sequenceId = iterator.next();\n                    iterator.remove();\n                    maxReturned--;\n                    if (sequenceId <= lastRecoveredSequenceId.get()) {\n                        Message msg = (Message)wireFormat.unmarshal(new ByteSequence(adapter.doGetMessageById(c, sequenceId)));\n                        LOG.trace(\"recovered add {} {}\", this, msg.getMessageId());\n                        listener.recoverMessage(msg);\n                    }\n                }\n            }\n            adapter.doRecoverNextMessages(c, destination, minPendingSequeunceId(), lastRecoveredSequenceId.get(), lastRecoveredPriority.get(),\n                    maxReturned, isPrioritizedMessages(), new JDBCMessageRecoveryListener() {\n\n                public boolean recoverMessage(long sequenceId, byte[] data) throws Exception {\n                        Message msg = (Message)wireFormat.unmarshal(new ByteSequence(data));\n                        msg.getMessageId().setBrokerSequenceId(sequenceId);\n                        listener.recoverMessage(msg);\n                        lastRecoveredSequenceId.set(sequenceId);\n                        lastRecoveredPriority.set(msg.getPriority());\n                        return true;\n                }\n\n                public boolean recoverMessageReference(String reference) throws Exception {\n                    if (listener.hasSpace()) {\n                        listener.recoverMessageReference(new MessageId(reference));\n                        return true;\n                    }\n                    return false;\n                }\n\n            });\n        } catch (SQLException e) {\n            JDBCPersistenceAdapter.log(\"JDBC Failure: \", e);\n        } finally {\n            c.close();\n        }\n\n    }",
            " 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344 +\n 345  \n 346  \n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  ",
            "    /**\n     * @param maxReturned\n     * @param listener\n     * @throws Exception\n     * @see org.apache.activemq.store.MessageStore#recoverNextMessages(int,\n     *      org.apache.activemq.store.MessageRecoveryListener)\n     */\n    public void recoverNextMessages(int maxReturned, final MessageRecoveryListener listener) throws Exception {\n        TransactionContext c = persistenceAdapter.getTransactionContext();\n        try {\n            if (!recoveredAdditions.isEmpty()) {\n                for (Iterator<Long> iterator = recoveredAdditions.iterator(); iterator.hasNext(); )  {\n                    Long sequenceId = iterator.next();\n                    iterator.remove();\n                    maxReturned--;\n                    if (sequenceId <= lastRecoveredSequenceId.get()) {\n                        Message msg = (Message)wireFormat.unmarshal(new ByteSequence(adapter.doGetMessageById(c, sequenceId)));\n                        LOG.trace(\"recovered add {} {}\", this, msg.getMessageId());\n                        listener.recoverMessage(msg);\n                    }\n                }\n            }\n            adapter.doRecoverNextMessages(c, destination, minPendingSequeunceId(), lastRecoveredSequenceId.get(), lastRecoveredPriority.get(),\n                    maxReturned, isPrioritizedMessages(), new JDBCMessageRecoveryListener() {\n\n                public boolean recoverMessage(long sequenceId, byte[] data) throws Exception {\n                        Message msg = (Message)wireFormat.unmarshal(new ByteSequence(data));\n                        msg.getMessageId().setBrokerSequenceId(sequenceId);\n                        msg.getMessageId().setEntryLocator(sequenceId);\n                        listener.recoverMessage(msg);\n                        lastRecoveredSequenceId.set(sequenceId);\n                        lastRecoveredPriority.set(msg.getPriority());\n                        return true;\n                }\n\n                public boolean recoverMessageReference(String reference) throws Exception {\n                    if (listener.hasSpace()) {\n                        listener.recoverMessageReference(new MessageId(reference));\n                        return true;\n                    }\n                    return false;\n                }\n\n            });\n        } catch (SQLException e) {\n            JDBCPersistenceAdapter.log(\"JDBC Failure: \", e);\n        } finally {\n            c.close();\n        }\n\n    }"
        ],
        [
            "JDBCMessageStore::removeMessage(ConnectionContext,MessageAck)",
            " 238  \n 239  \n 240 -\n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  ",
            "    public void removeMessage(ConnectionContext context, MessageAck ack) throws IOException {\n\n    \tlong seq = persistenceAdapter.getStoreSequenceIdForMessageId(ack.getLastMessageId(), destination)[0];\n\n        // Get a connection and remove the message from the DB\n        TransactionContext c = persistenceAdapter.getTransactionContext(context);\n        try {\n            adapter.doRemoveMessage(c, seq, context != null ? context.getXid() : null);\n        } catch (SQLException e) {\n            JDBCPersistenceAdapter.log(\"JDBC Failure: \", e);\n            throw IOExceptionSupport.create(\"Failed to broker message: \" + ack.getLastMessageId() + \" in container: \" + e, e);\n        } finally {\n            c.close();\n        }\n        if (context != null && context.getXid() != null) {\n            ack.getLastMessageId().setEntryLocator(seq);\n        }\n    }",
            " 238  \n 239  \n 240 +\n 241 +\n 242 +\n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  ",
            "    public void removeMessage(ConnectionContext context, MessageAck ack) throws IOException {\n\n    \tlong seq = ack.getLastMessageId().getEntryLocator() != null ?\n                (Long) ack.getLastMessageId().getEntryLocator() :\n                persistenceAdapter.getStoreSequenceIdForMessageId(ack.getLastMessageId(), destination)[0];\n\n        // Get a connection and remove the message from the DB\n        TransactionContext c = persistenceAdapter.getTransactionContext(context);\n        try {\n            adapter.doRemoveMessage(c, seq, context != null ? context.getXid() : null);\n        } catch (SQLException e) {\n            JDBCPersistenceAdapter.log(\"JDBC Failure: \", e);\n            throw IOExceptionSupport.create(\"Failed to broker message: \" + ack.getLastMessageId() + \" in container: \" + e, e);\n        } finally {\n            c.close();\n        }\n        if (context != null && context.getXid() != null) {\n            ack.getLastMessageId().setEntryLocator(seq);\n        }\n    }"
        ]
    ],
    "5c7985c695407faecaced0cc147f7940dc901a05": [
        [
            "StatisticsBroker::send(ProducerBrokerExchange,Message)",
            "  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122 -\n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161 -\n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  ",
            "    /**\n     * Sets the persistence mode\n     *\n     * @see org.apache.activemq.broker.BrokerFilter#send(org.apache.activemq.broker.ProducerBrokerExchange,\n     *      org.apache.activemq.command.Message)\n     */\n    @Override\n    public void send(ProducerBrokerExchange producerExchange, Message messageSend) throws Exception {\n        ActiveMQDestination msgDest = messageSend.getDestination();\n        ActiveMQDestination replyTo = messageSend.getReplyTo();\n        if (replyTo != null) {\n            String physicalName = msgDest.getPhysicalName();\n            boolean destStats = physicalName.regionMatches(true, 0, STATS_DESTINATION_PREFIX, 0,\n                    STATS_DESTINATION_PREFIX.length());\n            boolean brokerStats = physicalName.regionMatches(true, 0, STATS_BROKER_PREFIX, 0, STATS_BROKER_PREFIX\n                    .length());\n            boolean subStats = physicalName.regionMatches(true, 0, STATS_SUBSCRIPTION_PREFIX, 0, STATS_SUBSCRIPTION_PREFIX\n                    .length());\n            BrokerService brokerService = getBrokerService();\n            RegionBroker regionBroker = (RegionBroker) brokerService.getRegionBroker();\n            if (destStats) {\n                String destinationName = physicalName.substring(STATS_DESTINATION_PREFIX.length(), physicalName.length());\n                if (destinationName.startsWith(\".\")) {\n                    destinationName = destinationName.substring(1);\n                }\n                String destinationQuery = destinationName.replace(STATS_DENOTE_END_LIST,\"\");\n                boolean endListMessage = !destinationName.equals(destinationQuery);\n                ActiveMQDestination queryDestination = ActiveMQDestination.createDestination(destinationQuery,msgDest.getDestinationType());\n                Set<Destination> destinations = getDestinations(queryDestination);\n\n                for (Destination dest : destinations) {\n                    DestinationStatistics stats = dest.getDestinationStatistics();\n                    if (stats != null) {\n                        ActiveMQMapMessage statsMessage = new ActiveMQMapMessage();\n                        statsMessage.setString(\"brokerName\", regionBroker.getBrokerName());\n                        statsMessage.setString(\"brokerId\", regionBroker.getBrokerId().toString());\n                        statsMessage.setString(\"destinationName\", dest.getActiveMQDestination().toString());\n                        statsMessage.setLong(\"size\", stats.getMessages().getCount());\n                        statsMessage.setLong(\"enqueueCount\", stats.getEnqueues().getCount());\n                        statsMessage.setLong(\"dequeueCount\", stats.getDequeues().getCount());\n                        statsMessage.setLong(\"dispatchCount\", stats.getDispatched().getCount());\n                        statsMessage.setLong(\"expiredCount\", stats.getExpired().getCount());\n                        statsMessage.setLong(\"inflightCount\", stats.getInflight().getCount());\n                        statsMessage.setLong(\"messagesCached\", stats.getMessagesCached().getCount());\n                        statsMessage.setDouble(\"averageMessageSize\", stats.getMessageSize().getAveragePerSecond());\n                        statsMessage.setInt(\"memoryPercentUsage\", dest.getMemoryUsage().getPercentUsage());\n                        statsMessage.setLong(\"memoryUsage\", dest.getMemoryUsage().getUsage());\n                        statsMessage.setLong(\"memoryLimit\", dest.getMemoryUsage().getLimit());\n                        statsMessage.setDouble(\"averageEnqueueTime\", stats.getProcessTime().getAverageTime());\n                        statsMessage.setDouble(\"maxEnqueueTime\", stats.getProcessTime().getMaxTime());\n                        statsMessage.setDouble(\"minEnqueueTime\", stats.getProcessTime().getMinTime());\n                        statsMessage.setLong(\"consumerCount\", stats.getConsumers().getCount());\n                        statsMessage.setLong(\"producerCount\", stats.getProducers().getCount());\n                        statsMessage.setJMSCorrelationID(messageSend.getCorrelationId());\n                        sendStats(producerExchange.getConnectionContext(), statsMessage, replyTo);\n                    }\n                }\n                if(endListMessage){\n                    ActiveMQMapMessage statsMessage = new ActiveMQMapMessage();\n                    statsMessage.setJMSCorrelationID(messageSend.getCorrelationId());\n                    sendStats(producerExchange.getConnectionContext(),statsMessage,replyTo);\n                }\n\n            } else if (subStats) {\n                sendSubStats(producerExchange.getConnectionContext(), getBrokerView().getQueueSubscribers(), replyTo);\n                sendSubStats(producerExchange.getConnectionContext(), getBrokerView().getTopicSubscribers(), replyTo);\n            } else if (brokerStats) {\n\n                if (messageSend.getProperties().containsKey(STATS_BROKER_RESET_HEADER)) {\n                    getBrokerView().resetStatistics();\n                }\n\n                ActiveMQMapMessage statsMessage = new ActiveMQMapMessage();\n                SystemUsage systemUsage = brokerService.getSystemUsage();\n                DestinationStatistics stats = regionBroker.getDestinationStatistics();\n                statsMessage.setString(\"brokerName\", regionBroker.getBrokerName());\n                statsMessage.setString(\"brokerId\", regionBroker.getBrokerId().toString());\n                statsMessage.setLong(\"size\", stats.getMessages().getCount());\n                statsMessage.setLong(\"enqueueCount\", stats.getEnqueues().getCount());\n                statsMessage.setLong(\"dequeueCount\", stats.getDequeues().getCount());\n                statsMessage.setLong(\"dispatchCount\", stats.getDispatched().getCount());\n                statsMessage.setLong(\"expiredCount\", stats.getExpired().getCount());\n                statsMessage.setLong(\"inflightCount\", stats.getInflight().getCount());\n                statsMessage.setDouble(\"averageMessageSize\",stats.getMessageSize().getAverageSize());\n                statsMessage.setLong(\"messagesCached\", stats.getMessagesCached().getCount());\n                statsMessage.setInt(\"memoryPercentUsage\", systemUsage.getMemoryUsage().getPercentUsage());\n                statsMessage.setLong(\"memoryUsage\", systemUsage.getMemoryUsage().getUsage());\n                statsMessage.setLong(\"memoryLimit\", systemUsage.getMemoryUsage().getLimit());\n                statsMessage.setInt(\"storePercentUsage\", systemUsage.getStoreUsage().getPercentUsage());\n                statsMessage.setLong(\"storeUsage\", systemUsage.getStoreUsage().getUsage());\n                statsMessage.setLong(\"storeLimit\", systemUsage.getStoreUsage().getLimit());\n                statsMessage.setInt(\"tempPercentUsage\", systemUsage.getTempUsage().getPercentUsage());\n                statsMessage.setLong(\"tempUsage\", systemUsage.getTempUsage().getUsage());\n                statsMessage.setLong(\"tempLimit\", systemUsage.getTempUsage().getLimit());\n                statsMessage.setDouble(\"averageEnqueueTime\", stats.getProcessTime().getAverageTime());\n                statsMessage.setDouble(\"maxEnqueueTime\", stats.getProcessTime().getMaxTime());\n                statsMessage.setDouble(\"minEnqueueTime\", stats.getProcessTime().getMinTime());\n                statsMessage.setLong(\"consumerCount\", stats.getConsumers().getCount());\n                statsMessage.setLong(\"producerCount\", stats.getProducers().getCount());\n                String answer = brokerService.getTransportConnectorURIsAsMap().get(\"tcp\");\n                answer = answer != null ? answer : \"\";\n                statsMessage.setString(\"openwire\", answer);\n                answer = brokerService.getTransportConnectorURIsAsMap().get(\"stomp\");\n                answer = answer != null ? answer : \"\";\n                statsMessage.setString(\"stomp\", answer);\n                answer = brokerService.getTransportConnectorURIsAsMap().get(\"ssl\");\n                answer = answer != null ? answer : \"\";\n                statsMessage.setString(\"ssl\", answer);\n                answer = brokerService.getTransportConnectorURIsAsMap().get(\"stomp+ssl\");\n                answer = answer != null ? answer : \"\";\n                statsMessage.setString(\"stomp+ssl\", answer);\n                URI uri = brokerService.getVmConnectorURI();\n                answer = uri != null ? uri.toString() : \"\";\n                statsMessage.setString(\"vm\", answer);\n                File file = brokerService.getDataDirectoryFile();\n                answer = file != null ? file.getCanonicalPath() : \"\";\n                statsMessage.setString(\"dataDirectory\", answer);\n                statsMessage.setJMSCorrelationID(messageSend.getCorrelationId());\n                sendStats(producerExchange.getConnectionContext(), statsMessage, replyTo);\n            } else {\n                super.send(producerExchange, messageSend);\n            }\n        } else {\n            super.send(producerExchange, messageSend);\n        }\n    }",
            "  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122 +\n 123 +\n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162 +\n 163 +\n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  ",
            "    /**\n     * Sets the persistence mode\n     *\n     * @see org.apache.activemq.broker.BrokerFilter#send(org.apache.activemq.broker.ProducerBrokerExchange,\n     *      org.apache.activemq.command.Message)\n     */\n    @Override\n    public void send(ProducerBrokerExchange producerExchange, Message messageSend) throws Exception {\n        ActiveMQDestination msgDest = messageSend.getDestination();\n        ActiveMQDestination replyTo = messageSend.getReplyTo();\n        if (replyTo != null) {\n            String physicalName = msgDest.getPhysicalName();\n            boolean destStats = physicalName.regionMatches(true, 0, STATS_DESTINATION_PREFIX, 0,\n                    STATS_DESTINATION_PREFIX.length());\n            boolean brokerStats = physicalName.regionMatches(true, 0, STATS_BROKER_PREFIX, 0, STATS_BROKER_PREFIX\n                    .length());\n            boolean subStats = physicalName.regionMatches(true, 0, STATS_SUBSCRIPTION_PREFIX, 0, STATS_SUBSCRIPTION_PREFIX\n                    .length());\n            BrokerService brokerService = getBrokerService();\n            RegionBroker regionBroker = (RegionBroker) brokerService.getRegionBroker();\n            if (destStats) {\n                String destinationName = physicalName.substring(STATS_DESTINATION_PREFIX.length(), physicalName.length());\n                if (destinationName.startsWith(\".\")) {\n                    destinationName = destinationName.substring(1);\n                }\n                String destinationQuery = destinationName.replace(STATS_DENOTE_END_LIST,\"\");\n                boolean endListMessage = !destinationName.equals(destinationQuery);\n                ActiveMQDestination queryDestination = ActiveMQDestination.createDestination(destinationQuery,msgDest.getDestinationType());\n                Set<Destination> destinations = getDestinations(queryDestination);\n\n                for (Destination dest : destinations) {\n                    DestinationStatistics stats = dest.getDestinationStatistics();\n                    if (stats != null) {\n                        ActiveMQMapMessage statsMessage = new ActiveMQMapMessage();\n                        statsMessage.setString(\"brokerName\", regionBroker.getBrokerName());\n                        statsMessage.setString(\"brokerId\", regionBroker.getBrokerId().toString());\n                        statsMessage.setString(\"destinationName\", dest.getActiveMQDestination().toString());\n                        statsMessage.setLong(\"size\", stats.getMessages().getCount());\n                        statsMessage.setLong(\"enqueueCount\", stats.getEnqueues().getCount());\n                        statsMessage.setLong(\"dequeueCount\", stats.getDequeues().getCount());\n                        statsMessage.setLong(\"dispatchCount\", stats.getDispatched().getCount());\n                        statsMessage.setLong(\"expiredCount\", stats.getExpired().getCount());\n                        statsMessage.setLong(\"inflightCount\", stats.getInflight().getCount());\n                        statsMessage.setLong(\"messagesCached\", stats.getMessagesCached().getCount());\n                        // we are okay with the size without decimals so cast to long\n                        statsMessage.setLong(\"averageMessageSize\", (long) stats.getMessageSize().getAveragePerSecond());\n                        statsMessage.setInt(\"memoryPercentUsage\", dest.getMemoryUsage().getPercentUsage());\n                        statsMessage.setLong(\"memoryUsage\", dest.getMemoryUsage().getUsage());\n                        statsMessage.setLong(\"memoryLimit\", dest.getMemoryUsage().getLimit());\n                        statsMessage.setDouble(\"averageEnqueueTime\", stats.getProcessTime().getAverageTime());\n                        statsMessage.setDouble(\"maxEnqueueTime\", stats.getProcessTime().getMaxTime());\n                        statsMessage.setDouble(\"minEnqueueTime\", stats.getProcessTime().getMinTime());\n                        statsMessage.setLong(\"consumerCount\", stats.getConsumers().getCount());\n                        statsMessage.setLong(\"producerCount\", stats.getProducers().getCount());\n                        statsMessage.setJMSCorrelationID(messageSend.getCorrelationId());\n                        sendStats(producerExchange.getConnectionContext(), statsMessage, replyTo);\n                    }\n                }\n                if(endListMessage){\n                    ActiveMQMapMessage statsMessage = new ActiveMQMapMessage();\n                    statsMessage.setJMSCorrelationID(messageSend.getCorrelationId());\n                    sendStats(producerExchange.getConnectionContext(),statsMessage,replyTo);\n                }\n\n            } else if (subStats) {\n                sendSubStats(producerExchange.getConnectionContext(), getBrokerView().getQueueSubscribers(), replyTo);\n                sendSubStats(producerExchange.getConnectionContext(), getBrokerView().getTopicSubscribers(), replyTo);\n            } else if (brokerStats) {\n\n                if (messageSend.getProperties().containsKey(STATS_BROKER_RESET_HEADER)) {\n                    getBrokerView().resetStatistics();\n                }\n\n                ActiveMQMapMessage statsMessage = new ActiveMQMapMessage();\n                SystemUsage systemUsage = brokerService.getSystemUsage();\n                DestinationStatistics stats = regionBroker.getDestinationStatistics();\n                statsMessage.setString(\"brokerName\", regionBroker.getBrokerName());\n                statsMessage.setString(\"brokerId\", regionBroker.getBrokerId().toString());\n                statsMessage.setLong(\"size\", stats.getMessages().getCount());\n                statsMessage.setLong(\"enqueueCount\", stats.getEnqueues().getCount());\n                statsMessage.setLong(\"dequeueCount\", stats.getDequeues().getCount());\n                statsMessage.setLong(\"dispatchCount\", stats.getDispatched().getCount());\n                statsMessage.setLong(\"expiredCount\", stats.getExpired().getCount());\n                statsMessage.setLong(\"inflightCount\", stats.getInflight().getCount());\n                // we are okay with the size without decimals so cast to long\n                statsMessage.setLong(\"averageMessageSize\",(long) stats.getMessageSize().getAverageSize());\n                statsMessage.setLong(\"messagesCached\", stats.getMessagesCached().getCount());\n                statsMessage.setInt(\"memoryPercentUsage\", systemUsage.getMemoryUsage().getPercentUsage());\n                statsMessage.setLong(\"memoryUsage\", systemUsage.getMemoryUsage().getUsage());\n                statsMessage.setLong(\"memoryLimit\", systemUsage.getMemoryUsage().getLimit());\n                statsMessage.setInt(\"storePercentUsage\", systemUsage.getStoreUsage().getPercentUsage());\n                statsMessage.setLong(\"storeUsage\", systemUsage.getStoreUsage().getUsage());\n                statsMessage.setLong(\"storeLimit\", systemUsage.getStoreUsage().getLimit());\n                statsMessage.setInt(\"tempPercentUsage\", systemUsage.getTempUsage().getPercentUsage());\n                statsMessage.setLong(\"tempUsage\", systemUsage.getTempUsage().getUsage());\n                statsMessage.setLong(\"tempLimit\", systemUsage.getTempUsage().getLimit());\n                statsMessage.setDouble(\"averageEnqueueTime\", stats.getProcessTime().getAverageTime());\n                statsMessage.setDouble(\"maxEnqueueTime\", stats.getProcessTime().getMaxTime());\n                statsMessage.setDouble(\"minEnqueueTime\", stats.getProcessTime().getMinTime());\n                statsMessage.setLong(\"consumerCount\", stats.getConsumers().getCount());\n                statsMessage.setLong(\"producerCount\", stats.getProducers().getCount());\n                String answer = brokerService.getTransportConnectorURIsAsMap().get(\"tcp\");\n                answer = answer != null ? answer : \"\";\n                statsMessage.setString(\"openwire\", answer);\n                answer = brokerService.getTransportConnectorURIsAsMap().get(\"stomp\");\n                answer = answer != null ? answer : \"\";\n                statsMessage.setString(\"stomp\", answer);\n                answer = brokerService.getTransportConnectorURIsAsMap().get(\"ssl\");\n                answer = answer != null ? answer : \"\";\n                statsMessage.setString(\"ssl\", answer);\n                answer = brokerService.getTransportConnectorURIsAsMap().get(\"stomp+ssl\");\n                answer = answer != null ? answer : \"\";\n                statsMessage.setString(\"stomp+ssl\", answer);\n                URI uri = brokerService.getVmConnectorURI();\n                answer = uri != null ? uri.toString() : \"\";\n                statsMessage.setString(\"vm\", answer);\n                File file = brokerService.getDataDirectoryFile();\n                answer = file != null ? file.getCanonicalPath() : \"\";\n                statsMessage.setString(\"dataDirectory\", answer);\n                statsMessage.setJMSCorrelationID(messageSend.getCorrelationId());\n                sendStats(producerExchange.getConnectionContext(), statsMessage, replyTo);\n            } else {\n                super.send(producerExchange, messageSend);\n            }\n        } else {\n            super.send(producerExchange, messageSend);\n        }\n    }"
        ]
    ],
    "ce16735bb07e9df5e280c9cd9f82b331ee284f24": [
        [
            "BrokerRedeliveryTest::startBroker(boolean)",
            " 145  \n 146  \n 147  \n 148  \n 149 -\n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  ",
            "    private void startBroker(boolean deleteMessages) throws Exception {\n        broker = new BrokerService();\n        broker.setSchedulerSupport(true);\n\n\n        RedeliveryPlugin redeliveryPlugin = new RedeliveryPlugin();\n\n        RedeliveryPolicy brokerRedeliveryPolicy = new RedeliveryPolicy();\n        brokerRedeliveryPolicy.setRedeliveryDelay(redeliveryDelayMillis);\n        brokerRedeliveryPolicy.setInitialRedeliveryDelay(initialRedeliveryDelayMillis);\n        brokerRedeliveryPolicy.setMaximumRedeliveries(maxBrokerRedeliveries);\n\n        RedeliveryPolicyMap redeliveryPolicyMap = new RedeliveryPolicyMap();\n        redeliveryPolicyMap.setDefaultEntry(brokerRedeliveryPolicy);\n        redeliveryPlugin.setRedeliveryPolicyMap(redeliveryPolicyMap);\n\n        broker.setPlugins(new BrokerPlugin[]{redeliveryPlugin});\n\n        if (deleteMessages) {\n            broker.setDeleteAllMessagesOnStartup(true);\n        }\n        broker.start();\n    }",
            " 146  \n 147  \n 148 +\n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  ",
            "    private void startBroker(boolean deleteMessages) throws Exception {\n        broker = new BrokerService();\n        broker.setPersistent(false);\n        broker.setSchedulerSupport(true);\n\n        RedeliveryPlugin redeliveryPlugin = new RedeliveryPlugin();\n\n        RedeliveryPolicy brokerRedeliveryPolicy = new RedeliveryPolicy();\n        brokerRedeliveryPolicy.setRedeliveryDelay(redeliveryDelayMillis);\n        brokerRedeliveryPolicy.setInitialRedeliveryDelay(initialRedeliveryDelayMillis);\n        brokerRedeliveryPolicy.setMaximumRedeliveries(maxBrokerRedeliveries);\n\n        RedeliveryPolicyMap redeliveryPolicyMap = new RedeliveryPolicyMap();\n        redeliveryPolicyMap.setDefaultEntry(brokerRedeliveryPolicy);\n        redeliveryPlugin.setRedeliveryPolicyMap(redeliveryPolicyMap);\n\n        broker.setPlugins(new BrokerPlugin[]{redeliveryPlugin});\n\n        if (deleteMessages) {\n            broker.setDeleteAllMessagesOnStartup(true);\n        }\n        broker.start();\n    }"
        ],
        [
            "BrokerRedeliveryTest::stopBroker()",
            " 170  \n 171 -\n 172  \n 173 -\n 174  ",
            "    private void stopBroker() throws Exception {\n        if (broker != null)\n            broker.stop();\n        broker = null;\n    }",
            " 170  \n 171 +\n 172  \n 173 +\n 174 +\n 175  ",
            "    private void stopBroker() throws Exception {\n        if (broker != null) {\n            broker.stop();\n            broker = null;\n        }\n    }"
        ],
        [
            "BrokerRedeliveryTest::doTestScheduledRedelivery(int,boolean)",
            "  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74 -\n  75  \n  76  \n  77  \n  78 -\n  79  \n  80 -\n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  ",
            "    public void doTestScheduledRedelivery(int maxBrokerRedeliveriesToValidate, boolean validateDLQ) throws Exception {\n\n        startBroker(true);\n        sendMessage(0);\n\n        ActiveMQConnection consumerConnection = (ActiveMQConnection) createConnection();\n        RedeliveryPolicy redeliveryPolicy = new RedeliveryPolicy();\n        redeliveryPolicy.setInitialRedeliveryDelay(0);\n        redeliveryPolicy.setMaximumRedeliveries(0);\n        consumerConnection.setRedeliveryPolicy(redeliveryPolicy);\n        consumerConnection.start();\n        Session consumerSession = consumerConnection.createSession(true, Session.SESSION_TRANSACTED);\n        MessageConsumer consumer = consumerSession.createConsumer(destination);\n        Message message = consumer.receive(1000);\n        assertNotNull(\"got message\", message);\n        LOG.info(\"got: \" + message);\n        consumerSession.rollback();\n\n        for (int i=0;i<maxBrokerRedeliveriesToValidate;i++) {\n            Message shouldBeNull = consumer.receive(500);\n            assertNull(\"did not get message after redelivery count exceeded: \" + shouldBeNull, shouldBeNull);\n\n            TimeUnit.SECONDS.sleep(3);\n\n            Message brokerRedeliveryMessage = consumer.receive(500);\n            LOG.info(\"got: \" + brokerRedeliveryMessage);\n            assertNotNull(\"got message via broker redelivery after delay\", brokerRedeliveryMessage);\n            assertEquals(\"message matches\", message.getStringProperty(\"data\"), brokerRedeliveryMessage.getStringProperty(\"data\"));\n            assertEquals(\"has expiryDelay specified - iteration:\" + i, i == 0 ? initialRedeliveryDelayMillis : redeliveryDelayMillis, brokerRedeliveryMessage.getLongProperty(RedeliveryPlugin.REDELIVERY_DELAY));\n\n            consumerSession.rollback();\n        }\n\n        if (validateDLQ) {\n            MessageConsumer dlqConsumer = consumerSession.createConsumer(new ActiveMQQueue(SharedDeadLetterStrategy.DEFAULT_DEAD_LETTER_QUEUE_NAME));\n            Message dlqMessage = dlqConsumer.receive(2000);\n            assertNotNull(\"Got message from dql\", dlqMessage);\n            assertEquals(\"message matches\", message.getStringProperty(\"data\"), dlqMessage.getStringProperty(\"data\"));\n            consumerSession.commit();\n        } else {\n            // consume/commit ok\n            message = consumer.receive(3000);\n            assertNotNull(\"got message\", message);\n            assertEquals(\"redeliveries accounted for\", maxBrokerRedeliveriesToValidate + 2, message.getLongProperty(\"JMSXDeliveryCount\"));\n            consumerSession.commit();\n        }\n\n        consumerConnection.close();\n    }",
            "  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75 +\n  76  \n  77  \n  78  \n  79 +\n  80  \n  81 +\n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  ",
            "    public void doTestScheduledRedelivery(int maxBrokerRedeliveriesToValidate, boolean validateDLQ) throws Exception {\n\n        startBroker(true);\n        sendMessage(0);\n\n        ActiveMQConnection consumerConnection = (ActiveMQConnection) createConnection();\n        RedeliveryPolicy redeliveryPolicy = new RedeliveryPolicy();\n        redeliveryPolicy.setInitialRedeliveryDelay(0);\n        redeliveryPolicy.setMaximumRedeliveries(0);\n        consumerConnection.setRedeliveryPolicy(redeliveryPolicy);\n        consumerConnection.start();\n        Session consumerSession = consumerConnection.createSession(true, Session.SESSION_TRANSACTED);\n        MessageConsumer consumer = consumerSession.createConsumer(destination);\n        Message message = consumer.receive(1000);\n        assertNotNull(\"got message\", message);\n        LOG.info(\"got: \" + message);\n        consumerSession.rollback();\n\n        for (int i = 0; i < maxBrokerRedeliveriesToValidate; i++) {\n            Message shouldBeNull = consumer.receive(500);\n            assertNull(\"did not get message after redelivery count exceeded: \" + shouldBeNull, shouldBeNull);\n\n            TimeUnit.SECONDS.sleep(4);\n\n            Message brokerRedeliveryMessage = consumer.receive(1500);\n            LOG.info(\"got: \" + brokerRedeliveryMessage);\n            assertNotNull(\"got message via broker redelivery after delay\", brokerRedeliveryMessage);\n            assertEquals(\"message matches\", message.getStringProperty(\"data\"), brokerRedeliveryMessage.getStringProperty(\"data\"));\n            assertEquals(\"has expiryDelay specified - iteration:\" + i, i == 0 ? initialRedeliveryDelayMillis : redeliveryDelayMillis, brokerRedeliveryMessage.getLongProperty(RedeliveryPlugin.REDELIVERY_DELAY));\n\n            consumerSession.rollback();\n        }\n\n        if (validateDLQ) {\n            MessageConsumer dlqConsumer = consumerSession.createConsumer(new ActiveMQQueue(SharedDeadLetterStrategy.DEFAULT_DEAD_LETTER_QUEUE_NAME));\n            Message dlqMessage = dlqConsumer.receive(2000);\n            assertNotNull(\"Got message from dql\", dlqMessage);\n            assertEquals(\"message matches\", message.getStringProperty(\"data\"), dlqMessage.getStringProperty(\"data\"));\n            consumerSession.commit();\n        } else {\n            // consume/commit ok\n            message = consumer.receive(3000);\n            assertNotNull(\"got message\", message);\n            assertEquals(\"redeliveries accounted for\", maxBrokerRedeliveriesToValidate + 2, message.getLongProperty(\"JMSXDeliveryCount\"));\n            consumerSession.commit();\n        }\n\n        consumerConnection.close();\n    }"
        ]
    ],
    "dce2b61f870245a0c12b634d12cd0fa3a8a60daa": [
        [
            "TransportConnection::getActiveTransactionCount()",
            " 464  \n 465  \n 466  \n 467  \n 468 -\n 469 -\n 470 -\n 471 -\n 472  \n 473  \n 474  ",
            "    @Override\n    public int getActiveTransactionCount() {\n        int rc = 0;\n        for (TransportConnectionState cs : connectionStateRegister.listConnectionStates()) {\n            Collection<TransactionState> transactions = cs.getTransactionStates();\n            for (TransactionState transaction : transactions) {\n                rc++;\n            }\n        }\n        return rc;\n    }",
            " 456  \n 457  \n 458  \n 459  \n 460 +\n 461  \n 462  \n 463  ",
            "    @Override\n    public int getActiveTransactionCount() {\n        int rc = 0;\n        for (TransportConnectionState cs : connectionStateRegister.listConnectionStates()) {\n            rc += cs.getTransactionStates().size();\n        }\n        return rc;\n    }"
        ],
        [
            "TransportConnection::service(Command)",
            " 328  \n 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335 -\n 336  \n 337  \n 338 -\n 339  \n 340  \n 341  \n 342  \n 343  \n 344  \n 345  \n 346  \n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  ",
            "    @Override\n    public Response service(Command command) {\n        MDC.put(\"activemq.connector\", connector.getUri().toString());\n        Response response = null;\n        boolean responseRequired = command.isResponseRequired();\n        int commandId = command.getCommandId();\n        try {\n            if (!pendingStop) {\n                response = command.visit(this);\n            } else {\n                response = new ExceptionResponse(transportException.get());\n            }\n        } catch (Throwable e) {\n            if (SERVICELOG.isDebugEnabled() && e.getClass() != BrokerStoppedException.class) {\n                SERVICELOG.debug(\"Error occured while processing \" + (responseRequired ? \"sync\" : \"async\")\n                        + \" command: \" + command + \", exception: \" + e, e);\n            }\n\n            if (e instanceof SuppressReplyException || (e.getCause() instanceof SuppressReplyException)) {\n                LOG.info(\"Suppressing reply to: \" + command + \" on: \" + e + \", cause: \" + e.getCause());\n                responseRequired = false;\n            }\n\n            if (responseRequired) {\n                if (e instanceof SecurityException || e.getCause() instanceof SecurityException) {\n                    SERVICELOG.warn(\"Security Error occurred on connection to: {}, {}\",\n                            transport.getRemoteAddress(), e.getMessage());\n                }\n                response = new ExceptionResponse(e);\n            } else {\n                forceRollbackOnlyOnFailedAsyncTransactionOp(e, command);\n                serviceException(e);\n            }\n        }\n        if (responseRequired) {\n            if (response == null) {\n                response = new Response();\n            }\n            response.setCorrelationId(commandId);\n        }\n        // The context may have been flagged so that the response is not\n        // sent.\n        if (context != null) {\n            if (context.isDontSendReponse()) {\n                context.setDontSendReponse(false);\n                response = null;\n            }\n            context = null;\n        }\n        MDC.remove(\"activemq.connector\");\n        return response;\n    }",
            " 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324 +\n 325 +\n 326 +\n 327 +\n 328  \n 329  \n 330 +\n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344  \n 345  \n 346  \n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  ",
            "    @Override\n    public Response service(Command command) {\n        MDC.put(\"activemq.connector\", connector.getUri().toString());\n        Response response = null;\n        boolean responseRequired = command.isResponseRequired();\n        int commandId = command.getCommandId();\n        try {\n            if (brokerService.isStopping()) {\n                response = responseRequired ? new ExceptionResponse(\n                    new BrokerStoppedException(\"Broker \" + brokerService + \" is being stopped\")) : null;\n            } else if (!pendingStop) {\n                response = command.visit(this);\n            } else {\n                response = responseRequired ? new ExceptionResponse(transportException.get()) : null;\n            }\n        } catch (Throwable e) {\n            if (SERVICELOG.isDebugEnabled() && e.getClass() != BrokerStoppedException.class) {\n                SERVICELOG.debug(\"Error occured while processing \" + (responseRequired ? \"sync\" : \"async\")\n                        + \" command: \" + command + \", exception: \" + e, e);\n            }\n\n            if (e instanceof SuppressReplyException || (e.getCause() instanceof SuppressReplyException)) {\n                LOG.info(\"Suppressing reply to: \" + command + \" on: \" + e + \", cause: \" + e.getCause());\n                responseRequired = false;\n            }\n\n            if (responseRequired) {\n                if (e instanceof SecurityException || e.getCause() instanceof SecurityException) {\n                    SERVICELOG.warn(\"Security Error occurred on connection to: {}, {}\",\n                            transport.getRemoteAddress(), e.getMessage());\n                }\n                response = new ExceptionResponse(e);\n            } else {\n                forceRollbackOnlyOnFailedAsyncTransactionOp(e, command);\n                serviceException(e);\n            }\n        }\n        if (responseRequired) {\n            if (response == null) {\n                response = new Response();\n            }\n            response.setCorrelationId(commandId);\n        }\n        // The context may have been flagged so that the response is not\n        // sent.\n        if (context != null) {\n            if (context.isDontSendReponse()) {\n                context.setDontSendReponse(false);\n                response = null;\n            }\n            context = null;\n        }\n        MDC.remove(\"activemq.connector\");\n        return response;\n    }"
        ],
        [
            "TransportConnection::TransportConnection(TransportConnector,Transport,Broker,TaskRunnerFactory,TaskRunnerFactory)",
            " 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199 -\n 200 -\n 201 -\n 202 -\n 203 -\n 204 -\n 205 -\n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  ",
            "    /**\n     * @param taskRunnerFactory - can be null if you want direct dispatch to the transport\n     *                          else commands are sent async.\n     * @param stopTaskRunnerFactory - can <b>not</b> be null, used for stopping this connection.\n     */\n    public TransportConnection(TransportConnector connector, final Transport transport, Broker broker,\n                               TaskRunnerFactory taskRunnerFactory, TaskRunnerFactory stopTaskRunnerFactory) {\n        this.connector = connector;\n        this.broker = broker;\n        this.brokerService = broker.getBrokerService();\n\n        RegionBroker rb = (RegionBroker) broker.getAdaptor(RegionBroker.class);\n        brokerConnectionStates = rb.getConnectionStates();\n        if (connector != null) {\n            this.statistics.setParent(connector.getStatistics());\n            this.messageAuthorizationPolicy = connector.getMessageAuthorizationPolicy();\n        }\n        this.taskRunnerFactory = taskRunnerFactory;\n        this.stopTaskRunnerFactory = stopTaskRunnerFactory;\n        this.transport = transport;\n        if( this.transport instanceof BrokerServiceAware ) {\n            ((BrokerServiceAware)this.transport).setBrokerService(brokerService);\n        }\n        this.transport.setTransportListener(new DefaultTransportListener() {\n            @Override\n            public void onCommand(Object o) {\n                serviceLock.readLock().lock();\n                try {\n                    if (!(o instanceof Command)) {\n                        throw new RuntimeException(\"Protocol violation - Command corrupted: \" + o.toString());\n                    }\n                    Command command = (Command) o;\n                    if (!brokerService.isStopping()) {\n                        Response response = service(command);\n                        if (response != null && !brokerService.isStopping()) {\n                            dispatchSync(response);\n                        }\n                    } else {\n                        throw new BrokerStoppedException(\"Broker \" + brokerService + \" is being stopped\");\n                    }\n                } finally {\n                    serviceLock.readLock().unlock();\n                }\n            }\n\n            @Override\n            public void onException(IOException exception) {\n                serviceLock.readLock().lock();\n                try {\n                    serviceTransportException(exception);\n                } finally {\n                    serviceLock.readLock().unlock();\n                }\n            }\n        });\n        connected = true;\n    }",
            " 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192 +\n 193 +\n 194 +\n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  ",
            "    /**\n     * @param taskRunnerFactory - can be null if you want direct dispatch to the transport\n     *                          else commands are sent async.\n     * @param stopTaskRunnerFactory - can <b>not</b> be null, used for stopping this connection.\n     */\n    public TransportConnection(TransportConnector connector, final Transport transport, Broker broker,\n                               TaskRunnerFactory taskRunnerFactory, TaskRunnerFactory stopTaskRunnerFactory) {\n        this.connector = connector;\n        this.broker = broker;\n        this.brokerService = broker.getBrokerService();\n\n        RegionBroker rb = (RegionBroker) broker.getAdaptor(RegionBroker.class);\n        brokerConnectionStates = rb.getConnectionStates();\n        if (connector != null) {\n            this.statistics.setParent(connector.getStatistics());\n            this.messageAuthorizationPolicy = connector.getMessageAuthorizationPolicy();\n        }\n        this.taskRunnerFactory = taskRunnerFactory;\n        this.stopTaskRunnerFactory = stopTaskRunnerFactory;\n        this.transport = transport;\n        if( this.transport instanceof BrokerServiceAware ) {\n            ((BrokerServiceAware)this.transport).setBrokerService(brokerService);\n        }\n        this.transport.setTransportListener(new DefaultTransportListener() {\n            @Override\n            public void onCommand(Object o) {\n                serviceLock.readLock().lock();\n                try {\n                    if (!(o instanceof Command)) {\n                        throw new RuntimeException(\"Protocol violation - Command corrupted: \" + o.toString());\n                    }\n                    Command command = (Command) o;\n                    Response response = service(command);\n                    if (response != null) {\n                        dispatchSync(response);\n                    }\n                } finally {\n                    serviceLock.readLock().unlock();\n                }\n            }\n\n            @Override\n            public void onException(IOException exception) {\n                serviceLock.readLock().lock();\n                try {\n                    serviceTransportException(exception);\n                } finally {\n                    serviceLock.readLock().unlock();\n                }\n            }\n        });\n        connected = true;\n    }"
        ]
    ],
    "af1329291687d4aed4755d67e4e7bcf640c2a3e1": [
        [
            "AmqpSendReceiveTest::testCloseBusyReceiver()",
            "  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74 -\n  75  \n  76  \n  77  \n  78  \n  79  \n  80  ",
            "    @Ignore(\"Test fails when JMS transformer is in play\")\n    @Test(timeout = 60000)\n    public void testCloseBusyReceiver() throws Exception {\n        final int MSG_COUNT = 20;\n\n        AmqpClient client = createAmqpClient();\n        AmqpConnection connection = client.connect();\n        AmqpSession session = connection.createSession();\n\n        AmqpSender sender = session.createSender(\"queue://\" + getTestName());\n\n        for (int i = 0; i < MSG_COUNT; i++) {\n            AmqpMessage message = new AmqpMessage();\n\n            message.setMessageId(\"msg\" + i);\n            message.setMessageAnnotation(\"serialNo\", i);\n            message.setText(\"Test-Message\");\n\n            sender.send(message);\n        }\n\n        sender.close();\n\n        QueueViewMBean queue = getProxyToQueue(getTestName());\n        assertEquals(20, queue.getQueueSize());\n\n        AmqpReceiver receiver1 = session.createReceiver(\"queue://\" + getTestName());\n        receiver1.flow(MSG_COUNT);\n        AmqpMessage received = receiver1.receive(5, TimeUnit.SECONDS);\n        assertEquals(\"msg0\", received.getMessageId());\n        receiver1.close();\n\n        AmqpReceiver receiver2 = session.createReceiver(\"queue://\" + getTestName());\n        receiver2.flow(200);\n        for (int i = 0; i < MSG_COUNT; ++i) {\n            received = receiver1.receive(5, TimeUnit.SECONDS);\n            assertEquals(\"msg\" + i, received.getMessageId());\n        }\n\n        receiver2.close();\n        connection.close();\n    }",
            "  38  \n  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72 +\n  73  \n  74  \n  75  \n  76  \n  77  \n  78  ",
            "    @Test(timeout = 60000)\n    public void testCloseBusyReceiver() throws Exception {\n        final int MSG_COUNT = 20;\n\n        AmqpClient client = createAmqpClient();\n        AmqpConnection connection = client.connect();\n        AmqpSession session = connection.createSession();\n\n        AmqpSender sender = session.createSender(\"queue://\" + getTestName());\n\n        for (int i = 0; i < MSG_COUNT; i++) {\n            AmqpMessage message = new AmqpMessage();\n\n            message.setMessageId(\"msg\" + i);\n            message.setMessageAnnotation(\"serialNo\", i);\n            message.setText(\"Test-Message\");\n\n            sender.send(message);\n        }\n\n        sender.close();\n\n        QueueViewMBean queue = getProxyToQueue(getTestName());\n        assertEquals(20, queue.getQueueSize());\n\n        AmqpReceiver receiver1 = session.createReceiver(\"queue://\" + getTestName());\n        receiver1.flow(MSG_COUNT);\n        AmqpMessage received = receiver1.receive(5, TimeUnit.SECONDS);\n        assertEquals(\"msg0\", received.getMessageId());\n        receiver1.close();\n\n        AmqpReceiver receiver2 = session.createReceiver(\"queue://\" + getTestName());\n        receiver2.flow(200);\n        for (int i = 0; i < MSG_COUNT; ++i) {\n            received = receiver2.receive(5, TimeUnit.SECONDS);\n            assertEquals(\"msg\" + i, received.getMessageId());\n        }\n\n        receiver2.close();\n        connection.close();\n    }"
        ],
        [
            "JMSMappingOutboundTransformer::convert(Message)",
            " 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177 -\n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  ",
            "    /**\n     * Perform the conversion between JMS Message and Proton Message without\n     * re-encoding it to array. This is needed because some frameworks may elect\n     * to do this on their own way (Netty for instance using Nettybuffers)\n     *\n     * @param msg\n     * @return\n     * @throws Exception\n     */\n    public ProtonJMessage convert(Message msg) throws JMSException, UnsupportedEncodingException {\n        Header header = new Header();\n        Properties props = new Properties();\n        HashMap<Symbol, Object> daMap = null;\n        HashMap<Symbol, Object> maMap = null;\n        HashMap apMap = null;\n        Section body = null;\n        HashMap footerMap = null;\n        if (msg instanceof BytesMessage) {\n            BytesMessage m = (BytesMessage) msg;\n            byte data[] = new byte[(int) m.getBodyLength()];\n            m.readBytes(data);\n            m.reset(); // Need to reset after readBytes or future readBytes\n                       // calls (ex: redeliveries) will fail and return -1\n            body = new Data(new Binary(data));\n        }\n        if (msg instanceof TextMessage) {\n            body = new AmqpValue(((TextMessage) msg).getText());\n        }\n        if (msg instanceof MapMessage) {\n            final HashMap<String, Object> map = new HashMap<String, Object>();\n            final MapMessage m = (MapMessage) msg;\n            final Enumeration<String> names = m.getMapNames();\n            while (names.hasMoreElements()) {\n                String key = names.nextElement();\n                map.put(key, m.getObject(key));\n            }\n            body = new AmqpValue(map);\n        }\n        if (msg instanceof StreamMessage) {\n            ArrayList<Object> list = new ArrayList<Object>();\n            final StreamMessage m = (StreamMessage) msg;\n            try {\n                while (true) {\n                    list.add(m.readObject());\n                }\n            } catch (MessageEOFException e) {\n            }\n            body = new AmqpSequence(list);\n        }\n        if (msg instanceof ObjectMessage) {\n            body = new AmqpValue(((ObjectMessage) msg).getObject());\n        }\n\n        header.setDurable(msg.getJMSDeliveryMode() == DeliveryMode.PERSISTENT ? true : false);\n        header.setPriority(new UnsignedByte((byte) msg.getJMSPriority()));\n        if (msg.getJMSType() != null) {\n            props.setSubject(msg.getJMSType());\n        }\n        if (msg.getJMSMessageID() != null) {\n            props.setMessageId(msg.getJMSMessageID());\n        }\n        if (msg.getJMSDestination() != null) {\n            props.setTo(vendor.toAddress(msg.getJMSDestination()));\n            if (maMap == null) {\n                maMap = new HashMap<Symbol, Object>();\n            }\n            maMap.put(JMS_DEST_TYPE_MSG_ANNOTATION, destinationType(msg.getJMSDestination()));\n\n            // Deprecated: used by legacy QPid AMQP 1.0 JMS client\n            maMap.put(LEGACY_JMS_DEST_TYPE_MSG_ANNOTATION, destinationAttributes(msg.getJMSDestination()));\n        }\n        if (msg.getJMSReplyTo() != null) {\n            props.setReplyTo(vendor.toAddress(msg.getJMSReplyTo()));\n            if (maMap == null) {\n                maMap = new HashMap<Symbol, Object>();\n            }\n            maMap.put(JMS_REPLY_TO_TYPE_MSG_ANNOTATION, destinationType(msg.getJMSReplyTo()));\n\n            // Deprecated: used by legacy QPid AMQP 1.0 JMS client\n            maMap.put(LEGACY_JMS_REPLY_TO_TYPE_MSG_ANNOTATION, destinationAttributes(msg.getJMSReplyTo()));\n        }\n        if (msg.getJMSCorrelationID() != null) {\n            props.setCorrelationId(msg.getJMSCorrelationID());\n        }\n        if (msg.getJMSExpiration() != 0) {\n            long ttl = msg.getJMSExpiration() - System.currentTimeMillis();\n            if (ttl < 0) {\n                ttl = 1;\n            }\n            header.setTtl(new UnsignedInteger((int) ttl));\n\n            props.setAbsoluteExpiryTime(new Date(msg.getJMSExpiration()));\n        }\n        if (msg.getJMSTimestamp() != 0) {\n            props.setCreationTime(new Date(msg.getJMSTimestamp()));\n        }\n\n        final Enumeration<String> keys = msg.getPropertyNames();\n        while (keys.hasMoreElements()) {\n            String key = keys.nextElement();\n            if (key.equals(messageFormatKey) || key.equals(nativeKey)) {\n                // skip..\n            } else if (key.equals(firstAcquirerKey)) {\n                header.setFirstAcquirer(msg.getBooleanProperty(key));\n            } else if (key.startsWith(\"JMSXDeliveryCount\")) {\n                // The AMQP delivery-count field only includes prior failed delivery attempts,\n                // whereas JMSXDeliveryCount includes the first/current delivery attempt.\n                int amqpDeliveryCount = msg.getIntProperty(key) - 1;\n                if (amqpDeliveryCount > 0) {\n                    header.setDeliveryCount(new UnsignedInteger(amqpDeliveryCount));\n                }\n            } else if (key.startsWith(\"JMSXUserID\")) {\n                String value = msg.getStringProperty(key);\n                props.setUserId(new Binary(value.getBytes(\"UTF-8\")));\n            } else if (key.startsWith(\"JMSXGroupID\")) {\n                String value = msg.getStringProperty(key);\n                props.setGroupId(value);\n                if (apMap == null) {\n                    apMap = new HashMap();\n                }\n                apMap.put(key, value);\n            } else if (key.startsWith(\"JMSXGroupSeq\")) {\n                UnsignedInteger value = new UnsignedInteger(msg.getIntProperty(key));\n                props.setGroupSequence(value);\n                if (apMap == null) {\n                    apMap = new HashMap();\n                }\n                apMap.put(key, value);\n            } else if (key.startsWith(prefixDeliveryAnnotationsKey)) {\n                if (daMap == null) {\n                    daMap = new HashMap<Symbol, Object>();\n                }\n                String name = key.substring(prefixDeliveryAnnotationsKey.length());\n                daMap.put(Symbol.valueOf(name), msg.getObjectProperty(key));\n            } else if (key.startsWith(prefixMessageAnnotationsKey)) {\n                if (maMap == null) {\n                    maMap = new HashMap<Symbol, Object>();\n                }\n                String name = key.substring(prefixMessageAnnotationsKey.length());\n                maMap.put(Symbol.valueOf(name), msg.getObjectProperty(key));\n            } else if (key.equals(contentTypeKey)) {\n                props.setContentType(Symbol.getSymbol(msg.getStringProperty(key)));\n            } else if (key.equals(contentEncodingKey)) {\n                props.setContentEncoding(Symbol.getSymbol(msg.getStringProperty(key)));\n            } else if (key.equals(replyToGroupIDKey)) {\n                props.setReplyToGroupId(msg.getStringProperty(key));\n            } else if (key.startsWith(prefixFooterKey)) {\n                if (footerMap == null) {\n                    footerMap = new HashMap();\n                }\n                String name = key.substring(prefixFooterKey.length());\n                footerMap.put(name, msg.getObjectProperty(key));\n            } else {\n                if (apMap == null) {\n                    apMap = new HashMap();\n                }\n                apMap.put(key, msg.getObjectProperty(key));\n            }\n        }\n\n        MessageAnnotations ma = null;\n        if (maMap != null) {\n            ma = new MessageAnnotations(maMap);\n        }\n        DeliveryAnnotations da = null;\n        if (daMap != null) {\n            da = new DeliveryAnnotations(daMap);\n        }\n        ApplicationProperties ap = null;\n        if (apMap != null) {\n            ap = new ApplicationProperties(apMap);\n        }\n        Footer footer = null;\n        if (footerMap != null) {\n            footer = new Footer(footerMap);\n        }\n\n        return (ProtonJMessage) org.apache.qpid.proton.message.Message.Factory.create(header, da, ma, props, ap, body, footer);\n    }",
            " 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179 +\n 180 +\n 181 +\n 182 +\n 183 +\n 184 +\n 185 +\n 186 +\n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  ",
            "    /**\n     * Perform the conversion between JMS Message and Proton Message without\n     * re-encoding it to array. This is needed because some frameworks may elect\n     * to do this on their own way (Netty for instance using Nettybuffers)\n     *\n     * @param msg\n     * @return\n     * @throws Exception\n     */\n    public ProtonJMessage convert(Message msg) throws JMSException, UnsupportedEncodingException {\n        Header header = new Header();\n        Properties props = new Properties();\n        HashMap<Symbol, Object> daMap = null;\n        HashMap<Symbol, Object> maMap = null;\n        HashMap apMap = null;\n        Section body = null;\n        HashMap footerMap = null;\n        if (msg instanceof BytesMessage) {\n            BytesMessage m = (BytesMessage) msg;\n            byte data[] = new byte[(int) m.getBodyLength()];\n            m.readBytes(data);\n            m.reset(); // Need to reset after readBytes or future readBytes\n                       // calls (ex: redeliveries) will fail and return -1\n            body = new Data(new Binary(data));\n        }\n        if (msg instanceof TextMessage) {\n            body = new AmqpValue(((TextMessage) msg).getText());\n        }\n        if (msg instanceof MapMessage) {\n            final HashMap<String, Object> map = new HashMap<String, Object>();\n            final MapMessage m = (MapMessage) msg;\n            final Enumeration<String> names = m.getMapNames();\n            while (names.hasMoreElements()) {\n                String key = names.nextElement();\n                map.put(key, m.getObject(key));\n            }\n            body = new AmqpValue(map);\n        }\n        if (msg instanceof StreamMessage) {\n            ArrayList<Object> list = new ArrayList<Object>();\n            final StreamMessage m = (StreamMessage) msg;\n            try {\n                while (true) {\n                    list.add(m.readObject());\n                }\n            } catch (MessageEOFException e) {\n            }\n            body = new AmqpSequence(list);\n        }\n        if (msg instanceof ObjectMessage) {\n            body = new AmqpValue(((ObjectMessage) msg).getObject());\n        }\n\n        header.setDurable(msg.getJMSDeliveryMode() == DeliveryMode.PERSISTENT ? true : false);\n        header.setPriority(new UnsignedByte((byte) msg.getJMSPriority()));\n        if (msg.getJMSType() != null) {\n            props.setSubject(msg.getJMSType());\n        }\n        if (msg.getJMSMessageID() != null) {\n            ActiveMQMessage amqMsg = (ActiveMQMessage) msg;\n\n            MessageId msgId = amqMsg.getMessageId();\n            if (msgId.getTextView() != null) {\n                props.setMessageId(msgId.getTextView());\n            } else {\n                props.setMessageId(msgId.toString());\n            }\n        }\n        if (msg.getJMSDestination() != null) {\n            props.setTo(vendor.toAddress(msg.getJMSDestination()));\n            if (maMap == null) {\n                maMap = new HashMap<Symbol, Object>();\n            }\n            maMap.put(JMS_DEST_TYPE_MSG_ANNOTATION, destinationType(msg.getJMSDestination()));\n\n            // Deprecated: used by legacy QPid AMQP 1.0 JMS client\n            maMap.put(LEGACY_JMS_DEST_TYPE_MSG_ANNOTATION, destinationAttributes(msg.getJMSDestination()));\n        }\n        if (msg.getJMSReplyTo() != null) {\n            props.setReplyTo(vendor.toAddress(msg.getJMSReplyTo()));\n            if (maMap == null) {\n                maMap = new HashMap<Symbol, Object>();\n            }\n            maMap.put(JMS_REPLY_TO_TYPE_MSG_ANNOTATION, destinationType(msg.getJMSReplyTo()));\n\n            // Deprecated: used by legacy QPid AMQP 1.0 JMS client\n            maMap.put(LEGACY_JMS_REPLY_TO_TYPE_MSG_ANNOTATION, destinationAttributes(msg.getJMSReplyTo()));\n        }\n        if (msg.getJMSCorrelationID() != null) {\n            props.setCorrelationId(msg.getJMSCorrelationID());\n        }\n        if (msg.getJMSExpiration() != 0) {\n            long ttl = msg.getJMSExpiration() - System.currentTimeMillis();\n            if (ttl < 0) {\n                ttl = 1;\n            }\n            header.setTtl(new UnsignedInteger((int) ttl));\n\n            props.setAbsoluteExpiryTime(new Date(msg.getJMSExpiration()));\n        }\n        if (msg.getJMSTimestamp() != 0) {\n            props.setCreationTime(new Date(msg.getJMSTimestamp()));\n        }\n\n        final Enumeration<String> keys = msg.getPropertyNames();\n        while (keys.hasMoreElements()) {\n            String key = keys.nextElement();\n            if (key.equals(messageFormatKey) || key.equals(nativeKey)) {\n                // skip..\n            } else if (key.equals(firstAcquirerKey)) {\n                header.setFirstAcquirer(msg.getBooleanProperty(key));\n            } else if (key.startsWith(\"JMSXDeliveryCount\")) {\n                // The AMQP delivery-count field only includes prior failed delivery attempts,\n                // whereas JMSXDeliveryCount includes the first/current delivery attempt.\n                int amqpDeliveryCount = msg.getIntProperty(key) - 1;\n                if (amqpDeliveryCount > 0) {\n                    header.setDeliveryCount(new UnsignedInteger(amqpDeliveryCount));\n                }\n            } else if (key.startsWith(\"JMSXUserID\")) {\n                String value = msg.getStringProperty(key);\n                props.setUserId(new Binary(value.getBytes(\"UTF-8\")));\n            } else if (key.startsWith(\"JMSXGroupID\")) {\n                String value = msg.getStringProperty(key);\n                props.setGroupId(value);\n                if (apMap == null) {\n                    apMap = new HashMap();\n                }\n                apMap.put(key, value);\n            } else if (key.startsWith(\"JMSXGroupSeq\")) {\n                UnsignedInteger value = new UnsignedInteger(msg.getIntProperty(key));\n                props.setGroupSequence(value);\n                if (apMap == null) {\n                    apMap = new HashMap();\n                }\n                apMap.put(key, value);\n            } else if (key.startsWith(prefixDeliveryAnnotationsKey)) {\n                if (daMap == null) {\n                    daMap = new HashMap<Symbol, Object>();\n                }\n                String name = key.substring(prefixDeliveryAnnotationsKey.length());\n                daMap.put(Symbol.valueOf(name), msg.getObjectProperty(key));\n            } else if (key.startsWith(prefixMessageAnnotationsKey)) {\n                if (maMap == null) {\n                    maMap = new HashMap<Symbol, Object>();\n                }\n                String name = key.substring(prefixMessageAnnotationsKey.length());\n                maMap.put(Symbol.valueOf(name), msg.getObjectProperty(key));\n            } else if (key.equals(contentTypeKey)) {\n                props.setContentType(Symbol.getSymbol(msg.getStringProperty(key)));\n            } else if (key.equals(contentEncodingKey)) {\n                props.setContentEncoding(Symbol.getSymbol(msg.getStringProperty(key)));\n            } else if (key.equals(replyToGroupIDKey)) {\n                props.setReplyToGroupId(msg.getStringProperty(key));\n            } else if (key.startsWith(prefixFooterKey)) {\n                if (footerMap == null) {\n                    footerMap = new HashMap();\n                }\n                String name = key.substring(prefixFooterKey.length());\n                footerMap.put(name, msg.getObjectProperty(key));\n            } else {\n                if (apMap == null) {\n                    apMap = new HashMap();\n                }\n                apMap.put(key, msg.getObjectProperty(key));\n            }\n        }\n\n        MessageAnnotations ma = null;\n        if (maMap != null) {\n            ma = new MessageAnnotations(maMap);\n        }\n        DeliveryAnnotations da = null;\n        if (daMap != null) {\n            da = new DeliveryAnnotations(daMap);\n        }\n        ApplicationProperties ap = null;\n        if (apMap != null) {\n            ap = new ApplicationProperties(apMap);\n        }\n        Footer footer = null;\n        if (footerMap != null) {\n            footer = new Footer(footerMap);\n        }\n\n        return (ProtonJMessage) org.apache.qpid.proton.message.Message.Factory.create(header, da, ma, props, ap, body, footer);\n    }"
        ]
    ],
    "8ca6341d401027a9f1517e6ddc78cc29f91be30f": [
        [
            "WSServlet::doGet(HttpServletRequest,HttpServletResponse)",
            "  46 -\n  47 -\n  48 -\n  49  ",
            "    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n        throws ServletException ,IOException  {\n        getServletContext().getNamedDispatcher(\"default\").forward(request,response);\n    }",
            "  48  \n  49 +\n  50 +\n  51  ",
            "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        getServletContext().getNamedDispatcher(\"default\").forward(request, response);\n    }"
        ],
        [
            "WSServlet::init()",
            "  38  \n  39  \n  40 -\n  41  \n  42  \n  43  \n  44  ",
            "    public void init() throws ServletException {\n        super.init();\n        listener = (TransportAcceptListener)getServletContext().getAttribute(\"acceptListener\");\n        if (listener == null) {\n            throw new ServletException(\"No such attribute 'acceptListener' available in the ServletContext\");\n        }\n    }",
            "  39  \n  40  \n  41  \n  42 +\n  43  \n  44  \n  45  \n  46  ",
            "    @Override\n    public void init() throws ServletException {\n        super.init();\n        listener = (TransportAcceptListener) getServletContext().getAttribute(\"acceptListener\");\n        if (listener == null) {\n            throw new ServletException(\"No such attribute 'acceptListener' available in the ServletContext\");\n        }\n    }"
        ],
        [
            "WSServlet::doWebSocketConnect(HttpServletRequest,String)",
            "  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59 -\n  60  \n  61  ",
            "    @Override\n    public WebSocket doWebSocketConnect(HttpServletRequest request, String protocol) {\n        WebSocket socket;\n        if (protocol != null && protocol.startsWith(\"mqtt\")) {\n            socket = new MQTTSocket();\n        } else {\n            socket = new StompSocket();\n        }\n        listener.onAccept((Transport)socket);\n        return socket;\n    }",
            "  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61 +\n  62  \n  63  ",
            "    @Override\n    public WebSocket doWebSocketConnect(HttpServletRequest request, String protocol) {\n        WebSocket socket;\n        if (protocol != null && protocol.startsWith(\"mqtt\")) {\n            socket = new MQTTSocket();\n        } else {\n            socket = new StompSocket();\n        }\n        listener.onAccept((Transport) socket);\n        return socket;\n    }"
        ],
        [
            "WSServlet::configure(WebSocketServletFactory)",
            "  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69 -\n  70  ",
            "    public void configure(WebSocketServletFactory factory) {\n        factory.setCreator(new WebSocketCreator() {\n            @Override\n            public Object createWebSocket(ServletUpgradeRequest req, ServletUpgradeResponse resp) {\n                WebSocketListener socket;\n                if (req.getSubProtocols().contains(\"mqtt\")) {\n                    socket = new MQTTSocket();\n                } else {\n                    socket = new StompSocket();\n                }\n                return socket;\n            }\n        });\n        \n    }",
            "  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66 +\n  67  \n  68  \n  69 +\n  70  \n  71 +\n  72  \n  73  \n  74  \n  75  ",
            "    @Override\n    public void configure(WebSocketServletFactory factory) {\n        factory.setCreator(new WebSocketCreator() {\n            @Override\n            public Object createWebSocket(ServletUpgradeRequest req, ServletUpgradeResponse resp) {\n                WebSocketListener socket;\n                if (req.getSubProtocols().contains(\"mqtt\")) {\n                    socket = new MQTTSocket();\n                    resp.setAcceptedSubProtocol(\"mqtt\");\n                } else {\n                    socket = new StompSocket();\n                    resp.setAcceptedSubProtocol(\"stomp\");\n                }\n                listener.onAccept((Transport) socket);\n                return socket;\n            }\n        });\n    }"
        ]
    ]
}