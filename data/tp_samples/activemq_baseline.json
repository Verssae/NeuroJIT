{
    "3b5d89a78b12e63f998f239a155f71a557a87ea9": [
        [
            "JDBCMessageStore::recoverNextMessages(int,MessageRecoveryListener)",
            " 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344  \n 345  \n 346  \n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  ",
            "    /**\n     * @param maxReturned\n     * @param listener\n     * @throws Exception\n     * @see org.apache.activemq.store.MessageStore#recoverNextMessages(int,\n     *      org.apache.activemq.store.MessageRecoveryListener)\n     */\n    public void recoverNextMessages(int maxReturned, final MessageRecoveryListener listener) throws Exception {\n        TransactionContext c = persistenceAdapter.getTransactionContext();\n        try {\n            if (!recoveredAdditions.isEmpty()) {\n                for (Iterator<Long> iterator = recoveredAdditions.iterator(); iterator.hasNext(); )  {\n                    Long sequenceId = iterator.next();\n                    iterator.remove();\n                    maxReturned--;\n                    if (sequenceId <= lastRecoveredSequenceId.get()) {\n                        Message msg = (Message)wireFormat.unmarshal(new ByteSequence(adapter.doGetMessageById(c, sequenceId)));\n                        LOG.trace(\"recovered add {} {}\", this, msg.getMessageId());\n                        listener.recoverMessage(msg);\n                    }\n                }\n            }\n            adapter.doRecoverNextMessages(c, destination, minPendingSequeunceId(), lastRecoveredSequenceId.get(), lastRecoveredPriority.get(),\n                    maxReturned, isPrioritizedMessages(), new JDBCMessageRecoveryListener() {\n\n                public boolean recoverMessage(long sequenceId, byte[] data) throws Exception {\n                        Message msg = (Message)wireFormat.unmarshal(new ByteSequence(data));\n                        msg.getMessageId().setBrokerSequenceId(sequenceId);\n                        listener.recoverMessage(msg);\n                        lastRecoveredSequenceId.set(sequenceId);\n                        lastRecoveredPriority.set(msg.getPriority());\n                        return true;\n                }\n\n                public boolean recoverMessageReference(String reference) throws Exception {\n                    if (listener.hasSpace()) {\n                        listener.recoverMessageReference(new MessageId(reference));\n                        return true;\n                    }\n                    return false;\n                }\n\n            });\n        } catch (SQLException e) {\n            JDBCPersistenceAdapter.log(\"JDBC Failure: \", e);\n        } finally {\n            c.close();\n        }\n\n    }",
            " 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344 +\n 345  \n 346  \n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  ",
            "    /**\n     * @param maxReturned\n     * @param listener\n     * @throws Exception\n     * @see org.apache.activemq.store.MessageStore#recoverNextMessages(int,\n     *      org.apache.activemq.store.MessageRecoveryListener)\n     */\n    public void recoverNextMessages(int maxReturned, final MessageRecoveryListener listener) throws Exception {\n        TransactionContext c = persistenceAdapter.getTransactionContext();\n        try {\n            if (!recoveredAdditions.isEmpty()) {\n                for (Iterator<Long> iterator = recoveredAdditions.iterator(); iterator.hasNext(); )  {\n                    Long sequenceId = iterator.next();\n                    iterator.remove();\n                    maxReturned--;\n                    if (sequenceId <= lastRecoveredSequenceId.get()) {\n                        Message msg = (Message)wireFormat.unmarshal(new ByteSequence(adapter.doGetMessageById(c, sequenceId)));\n                        LOG.trace(\"recovered add {} {}\", this, msg.getMessageId());\n                        listener.recoverMessage(msg);\n                    }\n                }\n            }\n            adapter.doRecoverNextMessages(c, destination, minPendingSequeunceId(), lastRecoveredSequenceId.get(), lastRecoveredPriority.get(),\n                    maxReturned, isPrioritizedMessages(), new JDBCMessageRecoveryListener() {\n\n                public boolean recoverMessage(long sequenceId, byte[] data) throws Exception {\n                        Message msg = (Message)wireFormat.unmarshal(new ByteSequence(data));\n                        msg.getMessageId().setBrokerSequenceId(sequenceId);\n                        msg.getMessageId().setEntryLocator(sequenceId);\n                        listener.recoverMessage(msg);\n                        lastRecoveredSequenceId.set(sequenceId);\n                        lastRecoveredPriority.set(msg.getPriority());\n                        return true;\n                }\n\n                public boolean recoverMessageReference(String reference) throws Exception {\n                    if (listener.hasSpace()) {\n                        listener.recoverMessageReference(new MessageId(reference));\n                        return true;\n                    }\n                    return false;\n                }\n\n            });\n        } catch (SQLException e) {\n            JDBCPersistenceAdapter.log(\"JDBC Failure: \", e);\n        } finally {\n            c.close();\n        }\n\n    }"
        ],
        [
            "JDBCMessageStore::removeMessage(ConnectionContext,MessageAck)",
            " 238  \n 239  \n 240 -\n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  ",
            "    public void removeMessage(ConnectionContext context, MessageAck ack) throws IOException {\n\n    \tlong seq = persistenceAdapter.getStoreSequenceIdForMessageId(ack.getLastMessageId(), destination)[0];\n\n        // Get a connection and remove the message from the DB\n        TransactionContext c = persistenceAdapter.getTransactionContext(context);\n        try {\n            adapter.doRemoveMessage(c, seq, context != null ? context.getXid() : null);\n        } catch (SQLException e) {\n            JDBCPersistenceAdapter.log(\"JDBC Failure: \", e);\n            throw IOExceptionSupport.create(\"Failed to broker message: \" + ack.getLastMessageId() + \" in container: \" + e, e);\n        } finally {\n            c.close();\n        }\n        if (context != null && context.getXid() != null) {\n            ack.getLastMessageId().setEntryLocator(seq);\n        }\n    }",
            " 238  \n 239  \n 240 +\n 241 +\n 242 +\n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  ",
            "    public void removeMessage(ConnectionContext context, MessageAck ack) throws IOException {\n\n    \tlong seq = ack.getLastMessageId().getEntryLocator() != null ?\n                (Long) ack.getLastMessageId().getEntryLocator() :\n                persistenceAdapter.getStoreSequenceIdForMessageId(ack.getLastMessageId(), destination)[0];\n\n        // Get a connection and remove the message from the DB\n        TransactionContext c = persistenceAdapter.getTransactionContext(context);\n        try {\n            adapter.doRemoveMessage(c, seq, context != null ? context.getXid() : null);\n        } catch (SQLException e) {\n            JDBCPersistenceAdapter.log(\"JDBC Failure: \", e);\n            throw IOExceptionSupport.create(\"Failed to broker message: \" + ack.getLastMessageId() + \" in container: \" + e, e);\n        } finally {\n            c.close();\n        }\n        if (context != null && context.getXid() != null) {\n            ack.getLastMessageId().setEntryLocator(seq);\n        }\n    }"
        ],
        [
            "BaseDestination::convertToNonRangedAck(MessageAck,MessageReference)",
            " 775  \n 776  \n 777  \n 778  \n 779  \n 780  \n 781  \n 782  \n 783  \n 784  \n 785 -\n 786 -\n 787  \n 788  \n 789  \n 790  ",
            "    protected MessageAck convertToNonRangedAck(MessageAck ack, MessageReference node) {\n        // the original ack may be a ranged ack, but we are trying to delete\n        // a specific\n        // message store here so we need to convert to a non ranged ack.\n        if (ack.getMessageCount() > 0) {\n            // Dup the ack\n            MessageAck a = new MessageAck();\n            ack.copy(a);\n            ack = a;\n            // Convert to non-ranged.\n            ack.setFirstMessageId(node.getMessageId());\n            ack.setLastMessageId(node.getMessageId());\n            ack.setMessageCount(1);\n        }\n        return ack;\n    }",
            " 775  \n 776  \n 777  \n 778  \n 779  \n 780  \n 781  \n 782  \n 783  \n 784  \n 785  \n 786  \n 787 +\n 788 +\n 789 +\n 790  \n 791  ",
            "    protected MessageAck convertToNonRangedAck(MessageAck ack, MessageReference node) {\n        // the original ack may be a ranged ack, but we are trying to delete\n        // a specific\n        // message store here so we need to convert to a non ranged ack.\n        if (ack.getMessageCount() > 0) {\n            // Dup the ack\n            MessageAck a = new MessageAck();\n            ack.copy(a);\n            ack = a;\n            // Convert to non-ranged.\n            ack.setMessageCount(1);\n        }\n        // always use node messageId so we can access entry/data Location\n        ack.setFirstMessageId(node.getMessageId());\n        ack.setLastMessageId(node.getMessageId());\n        return ack;\n    }"
        ]
    ],
    "5c7985c695407faecaced0cc147f7940dc901a05": [
        [
            "StatisticsBroker::send(ProducerBrokerExchange,Message)",
            "  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122 -\n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161 -\n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  ",
            "    /**\n     * Sets the persistence mode\n     *\n     * @see org.apache.activemq.broker.BrokerFilter#send(org.apache.activemq.broker.ProducerBrokerExchange,\n     *      org.apache.activemq.command.Message)\n     */\n    @Override\n    public void send(ProducerBrokerExchange producerExchange, Message messageSend) throws Exception {\n        ActiveMQDestination msgDest = messageSend.getDestination();\n        ActiveMQDestination replyTo = messageSend.getReplyTo();\n        if (replyTo != null) {\n            String physicalName = msgDest.getPhysicalName();\n            boolean destStats = physicalName.regionMatches(true, 0, STATS_DESTINATION_PREFIX, 0,\n                    STATS_DESTINATION_PREFIX.length());\n            boolean brokerStats = physicalName.regionMatches(true, 0, STATS_BROKER_PREFIX, 0, STATS_BROKER_PREFIX\n                    .length());\n            boolean subStats = physicalName.regionMatches(true, 0, STATS_SUBSCRIPTION_PREFIX, 0, STATS_SUBSCRIPTION_PREFIX\n                    .length());\n            BrokerService brokerService = getBrokerService();\n            RegionBroker regionBroker = (RegionBroker) brokerService.getRegionBroker();\n            if (destStats) {\n                String destinationName = physicalName.substring(STATS_DESTINATION_PREFIX.length(), physicalName.length());\n                if (destinationName.startsWith(\".\")) {\n                    destinationName = destinationName.substring(1);\n                }\n                String destinationQuery = destinationName.replace(STATS_DENOTE_END_LIST,\"\");\n                boolean endListMessage = !destinationName.equals(destinationQuery);\n                ActiveMQDestination queryDestination = ActiveMQDestination.createDestination(destinationQuery,msgDest.getDestinationType());\n                Set<Destination> destinations = getDestinations(queryDestination);\n\n                for (Destination dest : destinations) {\n                    DestinationStatistics stats = dest.getDestinationStatistics();\n                    if (stats != null) {\n                        ActiveMQMapMessage statsMessage = new ActiveMQMapMessage();\n                        statsMessage.setString(\"brokerName\", regionBroker.getBrokerName());\n                        statsMessage.setString(\"brokerId\", regionBroker.getBrokerId().toString());\n                        statsMessage.setString(\"destinationName\", dest.getActiveMQDestination().toString());\n                        statsMessage.setLong(\"size\", stats.getMessages().getCount());\n                        statsMessage.setLong(\"enqueueCount\", stats.getEnqueues().getCount());\n                        statsMessage.setLong(\"dequeueCount\", stats.getDequeues().getCount());\n                        statsMessage.setLong(\"dispatchCount\", stats.getDispatched().getCount());\n                        statsMessage.setLong(\"expiredCount\", stats.getExpired().getCount());\n                        statsMessage.setLong(\"inflightCount\", stats.getInflight().getCount());\n                        statsMessage.setLong(\"messagesCached\", stats.getMessagesCached().getCount());\n                        statsMessage.setDouble(\"averageMessageSize\", stats.getMessageSize().getAveragePerSecond());\n                        statsMessage.setInt(\"memoryPercentUsage\", dest.getMemoryUsage().getPercentUsage());\n                        statsMessage.setLong(\"memoryUsage\", dest.getMemoryUsage().getUsage());\n                        statsMessage.setLong(\"memoryLimit\", dest.getMemoryUsage().getLimit());\n                        statsMessage.setDouble(\"averageEnqueueTime\", stats.getProcessTime().getAverageTime());\n                        statsMessage.setDouble(\"maxEnqueueTime\", stats.getProcessTime().getMaxTime());\n                        statsMessage.setDouble(\"minEnqueueTime\", stats.getProcessTime().getMinTime());\n                        statsMessage.setLong(\"consumerCount\", stats.getConsumers().getCount());\n                        statsMessage.setLong(\"producerCount\", stats.getProducers().getCount());\n                        statsMessage.setJMSCorrelationID(messageSend.getCorrelationId());\n                        sendStats(producerExchange.getConnectionContext(), statsMessage, replyTo);\n                    }\n                }\n                if(endListMessage){\n                    ActiveMQMapMessage statsMessage = new ActiveMQMapMessage();\n                    statsMessage.setJMSCorrelationID(messageSend.getCorrelationId());\n                    sendStats(producerExchange.getConnectionContext(),statsMessage,replyTo);\n                }\n\n            } else if (subStats) {\n                sendSubStats(producerExchange.getConnectionContext(), getBrokerView().getQueueSubscribers(), replyTo);\n                sendSubStats(producerExchange.getConnectionContext(), getBrokerView().getTopicSubscribers(), replyTo);\n            } else if (brokerStats) {\n\n                if (messageSend.getProperties().containsKey(STATS_BROKER_RESET_HEADER)) {\n                    getBrokerView().resetStatistics();\n                }\n\n                ActiveMQMapMessage statsMessage = new ActiveMQMapMessage();\n                SystemUsage systemUsage = brokerService.getSystemUsage();\n                DestinationStatistics stats = regionBroker.getDestinationStatistics();\n                statsMessage.setString(\"brokerName\", regionBroker.getBrokerName());\n                statsMessage.setString(\"brokerId\", regionBroker.getBrokerId().toString());\n                statsMessage.setLong(\"size\", stats.getMessages().getCount());\n                statsMessage.setLong(\"enqueueCount\", stats.getEnqueues().getCount());\n                statsMessage.setLong(\"dequeueCount\", stats.getDequeues().getCount());\n                statsMessage.setLong(\"dispatchCount\", stats.getDispatched().getCount());\n                statsMessage.setLong(\"expiredCount\", stats.getExpired().getCount());\n                statsMessage.setLong(\"inflightCount\", stats.getInflight().getCount());\n                statsMessage.setDouble(\"averageMessageSize\",stats.getMessageSize().getAverageSize());\n                statsMessage.setLong(\"messagesCached\", stats.getMessagesCached().getCount());\n                statsMessage.setInt(\"memoryPercentUsage\", systemUsage.getMemoryUsage().getPercentUsage());\n                statsMessage.setLong(\"memoryUsage\", systemUsage.getMemoryUsage().getUsage());\n                statsMessage.setLong(\"memoryLimit\", systemUsage.getMemoryUsage().getLimit());\n                statsMessage.setInt(\"storePercentUsage\", systemUsage.getStoreUsage().getPercentUsage());\n                statsMessage.setLong(\"storeUsage\", systemUsage.getStoreUsage().getUsage());\n                statsMessage.setLong(\"storeLimit\", systemUsage.getStoreUsage().getLimit());\n                statsMessage.setInt(\"tempPercentUsage\", systemUsage.getTempUsage().getPercentUsage());\n                statsMessage.setLong(\"tempUsage\", systemUsage.getTempUsage().getUsage());\n                statsMessage.setLong(\"tempLimit\", systemUsage.getTempUsage().getLimit());\n                statsMessage.setDouble(\"averageEnqueueTime\", stats.getProcessTime().getAverageTime());\n                statsMessage.setDouble(\"maxEnqueueTime\", stats.getProcessTime().getMaxTime());\n                statsMessage.setDouble(\"minEnqueueTime\", stats.getProcessTime().getMinTime());\n                statsMessage.setLong(\"consumerCount\", stats.getConsumers().getCount());\n                statsMessage.setLong(\"producerCount\", stats.getProducers().getCount());\n                String answer = brokerService.getTransportConnectorURIsAsMap().get(\"tcp\");\n                answer = answer != null ? answer : \"\";\n                statsMessage.setString(\"openwire\", answer);\n                answer = brokerService.getTransportConnectorURIsAsMap().get(\"stomp\");\n                answer = answer != null ? answer : \"\";\n                statsMessage.setString(\"stomp\", answer);\n                answer = brokerService.getTransportConnectorURIsAsMap().get(\"ssl\");\n                answer = answer != null ? answer : \"\";\n                statsMessage.setString(\"ssl\", answer);\n                answer = brokerService.getTransportConnectorURIsAsMap().get(\"stomp+ssl\");\n                answer = answer != null ? answer : \"\";\n                statsMessage.setString(\"stomp+ssl\", answer);\n                URI uri = brokerService.getVmConnectorURI();\n                answer = uri != null ? uri.toString() : \"\";\n                statsMessage.setString(\"vm\", answer);\n                File file = brokerService.getDataDirectoryFile();\n                answer = file != null ? file.getCanonicalPath() : \"\";\n                statsMessage.setString(\"dataDirectory\", answer);\n                statsMessage.setJMSCorrelationID(messageSend.getCorrelationId());\n                sendStats(producerExchange.getConnectionContext(), statsMessage, replyTo);\n            } else {\n                super.send(producerExchange, messageSend);\n            }\n        } else {\n            super.send(producerExchange, messageSend);\n        }\n    }",
            "  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122 +\n 123 +\n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162 +\n 163 +\n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  ",
            "    /**\n     * Sets the persistence mode\n     *\n     * @see org.apache.activemq.broker.BrokerFilter#send(org.apache.activemq.broker.ProducerBrokerExchange,\n     *      org.apache.activemq.command.Message)\n     */\n    @Override\n    public void send(ProducerBrokerExchange producerExchange, Message messageSend) throws Exception {\n        ActiveMQDestination msgDest = messageSend.getDestination();\n        ActiveMQDestination replyTo = messageSend.getReplyTo();\n        if (replyTo != null) {\n            String physicalName = msgDest.getPhysicalName();\n            boolean destStats = physicalName.regionMatches(true, 0, STATS_DESTINATION_PREFIX, 0,\n                    STATS_DESTINATION_PREFIX.length());\n            boolean brokerStats = physicalName.regionMatches(true, 0, STATS_BROKER_PREFIX, 0, STATS_BROKER_PREFIX\n                    .length());\n            boolean subStats = physicalName.regionMatches(true, 0, STATS_SUBSCRIPTION_PREFIX, 0, STATS_SUBSCRIPTION_PREFIX\n                    .length());\n            BrokerService brokerService = getBrokerService();\n            RegionBroker regionBroker = (RegionBroker) brokerService.getRegionBroker();\n            if (destStats) {\n                String destinationName = physicalName.substring(STATS_DESTINATION_PREFIX.length(), physicalName.length());\n                if (destinationName.startsWith(\".\")) {\n                    destinationName = destinationName.substring(1);\n                }\n                String destinationQuery = destinationName.replace(STATS_DENOTE_END_LIST,\"\");\n                boolean endListMessage = !destinationName.equals(destinationQuery);\n                ActiveMQDestination queryDestination = ActiveMQDestination.createDestination(destinationQuery,msgDest.getDestinationType());\n                Set<Destination> destinations = getDestinations(queryDestination);\n\n                for (Destination dest : destinations) {\n                    DestinationStatistics stats = dest.getDestinationStatistics();\n                    if (stats != null) {\n                        ActiveMQMapMessage statsMessage = new ActiveMQMapMessage();\n                        statsMessage.setString(\"brokerName\", regionBroker.getBrokerName());\n                        statsMessage.setString(\"brokerId\", regionBroker.getBrokerId().toString());\n                        statsMessage.setString(\"destinationName\", dest.getActiveMQDestination().toString());\n                        statsMessage.setLong(\"size\", stats.getMessages().getCount());\n                        statsMessage.setLong(\"enqueueCount\", stats.getEnqueues().getCount());\n                        statsMessage.setLong(\"dequeueCount\", stats.getDequeues().getCount());\n                        statsMessage.setLong(\"dispatchCount\", stats.getDispatched().getCount());\n                        statsMessage.setLong(\"expiredCount\", stats.getExpired().getCount());\n                        statsMessage.setLong(\"inflightCount\", stats.getInflight().getCount());\n                        statsMessage.setLong(\"messagesCached\", stats.getMessagesCached().getCount());\n                        // we are okay with the size without decimals so cast to long\n                        statsMessage.setLong(\"averageMessageSize\", (long) stats.getMessageSize().getAveragePerSecond());\n                        statsMessage.setInt(\"memoryPercentUsage\", dest.getMemoryUsage().getPercentUsage());\n                        statsMessage.setLong(\"memoryUsage\", dest.getMemoryUsage().getUsage());\n                        statsMessage.setLong(\"memoryLimit\", dest.getMemoryUsage().getLimit());\n                        statsMessage.setDouble(\"averageEnqueueTime\", stats.getProcessTime().getAverageTime());\n                        statsMessage.setDouble(\"maxEnqueueTime\", stats.getProcessTime().getMaxTime());\n                        statsMessage.setDouble(\"minEnqueueTime\", stats.getProcessTime().getMinTime());\n                        statsMessage.setLong(\"consumerCount\", stats.getConsumers().getCount());\n                        statsMessage.setLong(\"producerCount\", stats.getProducers().getCount());\n                        statsMessage.setJMSCorrelationID(messageSend.getCorrelationId());\n                        sendStats(producerExchange.getConnectionContext(), statsMessage, replyTo);\n                    }\n                }\n                if(endListMessage){\n                    ActiveMQMapMessage statsMessage = new ActiveMQMapMessage();\n                    statsMessage.setJMSCorrelationID(messageSend.getCorrelationId());\n                    sendStats(producerExchange.getConnectionContext(),statsMessage,replyTo);\n                }\n\n            } else if (subStats) {\n                sendSubStats(producerExchange.getConnectionContext(), getBrokerView().getQueueSubscribers(), replyTo);\n                sendSubStats(producerExchange.getConnectionContext(), getBrokerView().getTopicSubscribers(), replyTo);\n            } else if (brokerStats) {\n\n                if (messageSend.getProperties().containsKey(STATS_BROKER_RESET_HEADER)) {\n                    getBrokerView().resetStatistics();\n                }\n\n                ActiveMQMapMessage statsMessage = new ActiveMQMapMessage();\n                SystemUsage systemUsage = brokerService.getSystemUsage();\n                DestinationStatistics stats = regionBroker.getDestinationStatistics();\n                statsMessage.setString(\"brokerName\", regionBroker.getBrokerName());\n                statsMessage.setString(\"brokerId\", regionBroker.getBrokerId().toString());\n                statsMessage.setLong(\"size\", stats.getMessages().getCount());\n                statsMessage.setLong(\"enqueueCount\", stats.getEnqueues().getCount());\n                statsMessage.setLong(\"dequeueCount\", stats.getDequeues().getCount());\n                statsMessage.setLong(\"dispatchCount\", stats.getDispatched().getCount());\n                statsMessage.setLong(\"expiredCount\", stats.getExpired().getCount());\n                statsMessage.setLong(\"inflightCount\", stats.getInflight().getCount());\n                // we are okay with the size without decimals so cast to long\n                statsMessage.setLong(\"averageMessageSize\",(long) stats.getMessageSize().getAverageSize());\n                statsMessage.setLong(\"messagesCached\", stats.getMessagesCached().getCount());\n                statsMessage.setInt(\"memoryPercentUsage\", systemUsage.getMemoryUsage().getPercentUsage());\n                statsMessage.setLong(\"memoryUsage\", systemUsage.getMemoryUsage().getUsage());\n                statsMessage.setLong(\"memoryLimit\", systemUsage.getMemoryUsage().getLimit());\n                statsMessage.setInt(\"storePercentUsage\", systemUsage.getStoreUsage().getPercentUsage());\n                statsMessage.setLong(\"storeUsage\", systemUsage.getStoreUsage().getUsage());\n                statsMessage.setLong(\"storeLimit\", systemUsage.getStoreUsage().getLimit());\n                statsMessage.setInt(\"tempPercentUsage\", systemUsage.getTempUsage().getPercentUsage());\n                statsMessage.setLong(\"tempUsage\", systemUsage.getTempUsage().getUsage());\n                statsMessage.setLong(\"tempLimit\", systemUsage.getTempUsage().getLimit());\n                statsMessage.setDouble(\"averageEnqueueTime\", stats.getProcessTime().getAverageTime());\n                statsMessage.setDouble(\"maxEnqueueTime\", stats.getProcessTime().getMaxTime());\n                statsMessage.setDouble(\"minEnqueueTime\", stats.getProcessTime().getMinTime());\n                statsMessage.setLong(\"consumerCount\", stats.getConsumers().getCount());\n                statsMessage.setLong(\"producerCount\", stats.getProducers().getCount());\n                String answer = brokerService.getTransportConnectorURIsAsMap().get(\"tcp\");\n                answer = answer != null ? answer : \"\";\n                statsMessage.setString(\"openwire\", answer);\n                answer = brokerService.getTransportConnectorURIsAsMap().get(\"stomp\");\n                answer = answer != null ? answer : \"\";\n                statsMessage.setString(\"stomp\", answer);\n                answer = brokerService.getTransportConnectorURIsAsMap().get(\"ssl\");\n                answer = answer != null ? answer : \"\";\n                statsMessage.setString(\"ssl\", answer);\n                answer = brokerService.getTransportConnectorURIsAsMap().get(\"stomp+ssl\");\n                answer = answer != null ? answer : \"\";\n                statsMessage.setString(\"stomp+ssl\", answer);\n                URI uri = brokerService.getVmConnectorURI();\n                answer = uri != null ? uri.toString() : \"\";\n                statsMessage.setString(\"vm\", answer);\n                File file = brokerService.getDataDirectoryFile();\n                answer = file != null ? file.getCanonicalPath() : \"\";\n                statsMessage.setString(\"dataDirectory\", answer);\n                statsMessage.setJMSCorrelationID(messageSend.getCorrelationId());\n                sendStats(producerExchange.getConnectionContext(), statsMessage, replyTo);\n            } else {\n                super.send(producerExchange, messageSend);\n            }\n        } else {\n            super.send(producerExchange, messageSend);\n        }\n    }"
        ]
    ],
    "ce16735bb07e9df5e280c9cd9f82b331ee284f24": [
        [
            "BrokerRedeliveryTest::startBroker(boolean)",
            " 145  \n 146  \n 147  \n 148  \n 149 -\n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  ",
            "    private void startBroker(boolean deleteMessages) throws Exception {\n        broker = new BrokerService();\n        broker.setSchedulerSupport(true);\n\n\n        RedeliveryPlugin redeliveryPlugin = new RedeliveryPlugin();\n\n        RedeliveryPolicy brokerRedeliveryPolicy = new RedeliveryPolicy();\n        brokerRedeliveryPolicy.setRedeliveryDelay(redeliveryDelayMillis);\n        brokerRedeliveryPolicy.setInitialRedeliveryDelay(initialRedeliveryDelayMillis);\n        brokerRedeliveryPolicy.setMaximumRedeliveries(maxBrokerRedeliveries);\n\n        RedeliveryPolicyMap redeliveryPolicyMap = new RedeliveryPolicyMap();\n        redeliveryPolicyMap.setDefaultEntry(brokerRedeliveryPolicy);\n        redeliveryPlugin.setRedeliveryPolicyMap(redeliveryPolicyMap);\n\n        broker.setPlugins(new BrokerPlugin[]{redeliveryPlugin});\n\n        if (deleteMessages) {\n            broker.setDeleteAllMessagesOnStartup(true);\n        }\n        broker.start();\n    }",
            " 146  \n 147  \n 148 +\n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  ",
            "    private void startBroker(boolean deleteMessages) throws Exception {\n        broker = new BrokerService();\n        broker.setPersistent(false);\n        broker.setSchedulerSupport(true);\n\n        RedeliveryPlugin redeliveryPlugin = new RedeliveryPlugin();\n\n        RedeliveryPolicy brokerRedeliveryPolicy = new RedeliveryPolicy();\n        brokerRedeliveryPolicy.setRedeliveryDelay(redeliveryDelayMillis);\n        brokerRedeliveryPolicy.setInitialRedeliveryDelay(initialRedeliveryDelayMillis);\n        brokerRedeliveryPolicy.setMaximumRedeliveries(maxBrokerRedeliveries);\n\n        RedeliveryPolicyMap redeliveryPolicyMap = new RedeliveryPolicyMap();\n        redeliveryPolicyMap.setDefaultEntry(brokerRedeliveryPolicy);\n        redeliveryPlugin.setRedeliveryPolicyMap(redeliveryPolicyMap);\n\n        broker.setPlugins(new BrokerPlugin[]{redeliveryPlugin});\n\n        if (deleteMessages) {\n            broker.setDeleteAllMessagesOnStartup(true);\n        }\n        broker.start();\n    }"
        ],
        [
            "BrokerRedeliveryTest::doTestScheduledRedelivery(int,boolean)",
            "  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74 -\n  75  \n  76  \n  77  \n  78 -\n  79  \n  80 -\n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  ",
            "    public void doTestScheduledRedelivery(int maxBrokerRedeliveriesToValidate, boolean validateDLQ) throws Exception {\n\n        startBroker(true);\n        sendMessage(0);\n\n        ActiveMQConnection consumerConnection = (ActiveMQConnection) createConnection();\n        RedeliveryPolicy redeliveryPolicy = new RedeliveryPolicy();\n        redeliveryPolicy.setInitialRedeliveryDelay(0);\n        redeliveryPolicy.setMaximumRedeliveries(0);\n        consumerConnection.setRedeliveryPolicy(redeliveryPolicy);\n        consumerConnection.start();\n        Session consumerSession = consumerConnection.createSession(true, Session.SESSION_TRANSACTED);\n        MessageConsumer consumer = consumerSession.createConsumer(destination);\n        Message message = consumer.receive(1000);\n        assertNotNull(\"got message\", message);\n        LOG.info(\"got: \" + message);\n        consumerSession.rollback();\n\n        for (int i=0;i<maxBrokerRedeliveriesToValidate;i++) {\n            Message shouldBeNull = consumer.receive(500);\n            assertNull(\"did not get message after redelivery count exceeded: \" + shouldBeNull, shouldBeNull);\n\n            TimeUnit.SECONDS.sleep(3);\n\n            Message brokerRedeliveryMessage = consumer.receive(500);\n            LOG.info(\"got: \" + brokerRedeliveryMessage);\n            assertNotNull(\"got message via broker redelivery after delay\", brokerRedeliveryMessage);\n            assertEquals(\"message matches\", message.getStringProperty(\"data\"), brokerRedeliveryMessage.getStringProperty(\"data\"));\n            assertEquals(\"has expiryDelay specified - iteration:\" + i, i == 0 ? initialRedeliveryDelayMillis : redeliveryDelayMillis, brokerRedeliveryMessage.getLongProperty(RedeliveryPlugin.REDELIVERY_DELAY));\n\n            consumerSession.rollback();\n        }\n\n        if (validateDLQ) {\n            MessageConsumer dlqConsumer = consumerSession.createConsumer(new ActiveMQQueue(SharedDeadLetterStrategy.DEFAULT_DEAD_LETTER_QUEUE_NAME));\n            Message dlqMessage = dlqConsumer.receive(2000);\n            assertNotNull(\"Got message from dql\", dlqMessage);\n            assertEquals(\"message matches\", message.getStringProperty(\"data\"), dlqMessage.getStringProperty(\"data\"));\n            consumerSession.commit();\n        } else {\n            // consume/commit ok\n            message = consumer.receive(3000);\n            assertNotNull(\"got message\", message);\n            assertEquals(\"redeliveries accounted for\", maxBrokerRedeliveriesToValidate + 2, message.getLongProperty(\"JMSXDeliveryCount\"));\n            consumerSession.commit();\n        }\n\n        consumerConnection.close();\n    }",
            "  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75 +\n  76  \n  77  \n  78  \n  79 +\n  80  \n  81 +\n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  ",
            "    public void doTestScheduledRedelivery(int maxBrokerRedeliveriesToValidate, boolean validateDLQ) throws Exception {\n\n        startBroker(true);\n        sendMessage(0);\n\n        ActiveMQConnection consumerConnection = (ActiveMQConnection) createConnection();\n        RedeliveryPolicy redeliveryPolicy = new RedeliveryPolicy();\n        redeliveryPolicy.setInitialRedeliveryDelay(0);\n        redeliveryPolicy.setMaximumRedeliveries(0);\n        consumerConnection.setRedeliveryPolicy(redeliveryPolicy);\n        consumerConnection.start();\n        Session consumerSession = consumerConnection.createSession(true, Session.SESSION_TRANSACTED);\n        MessageConsumer consumer = consumerSession.createConsumer(destination);\n        Message message = consumer.receive(1000);\n        assertNotNull(\"got message\", message);\n        LOG.info(\"got: \" + message);\n        consumerSession.rollback();\n\n        for (int i = 0; i < maxBrokerRedeliveriesToValidate; i++) {\n            Message shouldBeNull = consumer.receive(500);\n            assertNull(\"did not get message after redelivery count exceeded: \" + shouldBeNull, shouldBeNull);\n\n            TimeUnit.SECONDS.sleep(4);\n\n            Message brokerRedeliveryMessage = consumer.receive(1500);\n            LOG.info(\"got: \" + brokerRedeliveryMessage);\n            assertNotNull(\"got message via broker redelivery after delay\", brokerRedeliveryMessage);\n            assertEquals(\"message matches\", message.getStringProperty(\"data\"), brokerRedeliveryMessage.getStringProperty(\"data\"));\n            assertEquals(\"has expiryDelay specified - iteration:\" + i, i == 0 ? initialRedeliveryDelayMillis : redeliveryDelayMillis, brokerRedeliveryMessage.getLongProperty(RedeliveryPlugin.REDELIVERY_DELAY));\n\n            consumerSession.rollback();\n        }\n\n        if (validateDLQ) {\n            MessageConsumer dlqConsumer = consumerSession.createConsumer(new ActiveMQQueue(SharedDeadLetterStrategy.DEFAULT_DEAD_LETTER_QUEUE_NAME));\n            Message dlqMessage = dlqConsumer.receive(2000);\n            assertNotNull(\"Got message from dql\", dlqMessage);\n            assertEquals(\"message matches\", message.getStringProperty(\"data\"), dlqMessage.getStringProperty(\"data\"));\n            consumerSession.commit();\n        } else {\n            // consume/commit ok\n            message = consumer.receive(3000);\n            assertNotNull(\"got message\", message);\n            assertEquals(\"redeliveries accounted for\", maxBrokerRedeliveriesToValidate + 2, message.getLongProperty(\"JMSXDeliveryCount\"));\n            consumerSession.commit();\n        }\n\n        consumerConnection.close();\n    }"
        ],
        [
            "BrokerRedeliveryTest::stopBroker()",
            " 170  \n 171 -\n 172  \n 173 -\n 174  ",
            "    private void stopBroker() throws Exception {\n        if (broker != null)\n            broker.stop();\n        broker = null;\n    }",
            " 170  \n 171 +\n 172  \n 173 +\n 174 +\n 175  ",
            "    private void stopBroker() throws Exception {\n        if (broker != null) {\n            broker.stop();\n            broker = null;\n        }\n    }"
        ]
    ],
    "35115fece7c0f5c6c8c4af8b45b811d1710b9c9d": [
        [
            "MemoryLimitTest::testCursorBatch()",
            "  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107 -\n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135 -\n 136  \n 137  \n 138  \n 139  \n 140 -\n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  ",
            "    @Test(timeout = 120000)\n    public void testCursorBatch() throws Exception {\n\n        ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(\"vm://localhost?jms.prefetchPolicy.all=10\");\n        factory.setOptimizeAcknowledge(true);\n        Connection conn = factory.createConnection();\n        conn.start();\n        Session sess = conn.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n        Queue queue = sess.createQueue(\"STORE\");\n        final ProducerThread producer = new ProducerThread(sess, queue) {\n            @Override\n            protected Message createMessage(int i) throws Exception {\n                return sess.createTextMessage(payload + \"::\" + i);\n            }\n        };\n        producer.setMessageCount(2000);\n        producer.start();\n        producer.join();\n\n        Thread.sleep(1000);\n\n        // assert we didn't break high watermark (70%) usage\n        final Destination dest = broker.getDestination((ActiveMQQueue) queue);\n        LOG.info(\"Destination usage: \" + dest.getMemoryUsage());\n        int percentUsage = dest.getMemoryUsage().getPercentUsage();\n        assertTrue(\"Should be less than 70% of limit but was: \" + percentUsage, percentUsage <= 71);\n        LOG.info(\"Broker usage: \" + broker.getSystemUsage().getMemoryUsage());\n        assertTrue(broker.getSystemUsage().getMemoryUsage().getPercentUsage() <= 71);\n\n        // consume one message\n        MessageConsumer consumer = sess.createConsumer(queue);\n        Message msg = consumer.receive(5000);\n        msg.acknowledge();\n\n        // this should free some space and allow us to get new batch of messages in the memory\n        // exceeding the limit\n        assertTrue(\"Limit is exceeded\", Wait.waitFor(new Wait.Condition() {\n            @Override\n            public boolean isSatisified() throws Exception {\n                LOG.info(\"Destination usage: \" + dest.getMemoryUsage());\n                return dest.getMemoryUsage().getPercentUsage() >= 470;\n            }\n        }));\n\n        LOG.info(\"Broker usage: \" + broker.getSystemUsage().getMemoryUsage());\n        assertTrue(broker.getSystemUsage().getMemoryUsage().getPercentUsage() >= 470);\n\n        // let's make sure we can consume all messages\n        for (int i = 1; i < 2000; i++) {\n            msg = consumer.receive(5000);\n            if (msg == null) {\n               dumpAllThreads(\"NoMessage\");\n            }\n            assertNotNull(\"Didn't receive message \" + i, msg);\n            msg.acknowledge();\n        }\n    }",
            "  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108 +\n 109 +\n 110 +\n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138 +\n 139  \n 140  \n 141  \n 142  \n 143 +\n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  ",
            "    @Test(timeout = 120000)\n    public void testCursorBatch() throws Exception {\n\n        ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(\"vm://localhost?jms.prefetchPolicy.all=10\");\n        factory.setOptimizeAcknowledge(true);\n        Connection conn = factory.createConnection();\n        conn.start();\n        Session sess = conn.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n        Queue queue = sess.createQueue(\"STORE\");\n        final ProducerThread producer = new ProducerThread(sess, queue) {\n            @Override\n            protected Message createMessage(int i) throws Exception {\n                BytesMessage bytesMessage = sess.createBytesMessage();\n                bytesMessage.writeBytes(payload);\n                return bytesMessage;\n            }\n        };\n        producer.setMessageCount(2000);\n        producer.start();\n        producer.join();\n\n        Thread.sleep(1000);\n\n        // assert we didn't break high watermark (70%) usage\n        final Destination dest = broker.getDestination((ActiveMQQueue) queue);\n        LOG.info(\"Destination usage: \" + dest.getMemoryUsage());\n        int percentUsage = dest.getMemoryUsage().getPercentUsage();\n        assertTrue(\"Should be less than 70% of limit but was: \" + percentUsage, percentUsage <= 71);\n        LOG.info(\"Broker usage: \" + broker.getSystemUsage().getMemoryUsage());\n        assertTrue(broker.getSystemUsage().getMemoryUsage().getPercentUsage() <= 71);\n\n        // consume one message\n        MessageConsumer consumer = sess.createConsumer(queue);\n        Message msg = consumer.receive(5000);\n        msg.acknowledge();\n\n        // this should free some space and allow us to get new batch of messages in the memory\n        // exceeding the limit\n        assertTrue(\"Limit is exceeded\", Wait.waitFor(new Wait.Condition() {\n            @Override\n            public boolean isSatisified() throws Exception {\n                LOG.info(\"Destination usage: \" + dest.getMemoryUsage());\n                return dest.getMemoryUsage().getPercentUsage() >= 200;\n            }\n        }));\n\n        LOG.info(\"Broker usage: \" + broker.getSystemUsage().getMemoryUsage());\n        assertTrue(broker.getSystemUsage().getMemoryUsage().getPercentUsage() >= 200);\n\n        // let's make sure we can consume all messages\n        for (int i = 1; i < 2000; i++) {\n            msg = consumer.receive(5000);\n            if (msg == null) {\n               dumpAllThreads(\"NoMessage\");\n            }\n            assertNotNull(\"Didn't receive message \" + i, msg);\n            msg.acknowledge();\n        }\n    }"
        ]
    ],
    "af1329291687d4aed4755d67e4e7bcf640c2a3e1": [
        [
            "AmqpSendReceiveTest::testCloseBusyReceiver()",
            "  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74 -\n  75  \n  76  \n  77  \n  78  \n  79  \n  80  ",
            "    @Ignore(\"Test fails when JMS transformer is in play\")\n    @Test(timeout = 60000)\n    public void testCloseBusyReceiver() throws Exception {\n        final int MSG_COUNT = 20;\n\n        AmqpClient client = createAmqpClient();\n        AmqpConnection connection = client.connect();\n        AmqpSession session = connection.createSession();\n\n        AmqpSender sender = session.createSender(\"queue://\" + getTestName());\n\n        for (int i = 0; i < MSG_COUNT; i++) {\n            AmqpMessage message = new AmqpMessage();\n\n            message.setMessageId(\"msg\" + i);\n            message.setMessageAnnotation(\"serialNo\", i);\n            message.setText(\"Test-Message\");\n\n            sender.send(message);\n        }\n\n        sender.close();\n\n        QueueViewMBean queue = getProxyToQueue(getTestName());\n        assertEquals(20, queue.getQueueSize());\n\n        AmqpReceiver receiver1 = session.createReceiver(\"queue://\" + getTestName());\n        receiver1.flow(MSG_COUNT);\n        AmqpMessage received = receiver1.receive(5, TimeUnit.SECONDS);\n        assertEquals(\"msg0\", received.getMessageId());\n        receiver1.close();\n\n        AmqpReceiver receiver2 = session.createReceiver(\"queue://\" + getTestName());\n        receiver2.flow(200);\n        for (int i = 0; i < MSG_COUNT; ++i) {\n            received = receiver1.receive(5, TimeUnit.SECONDS);\n            assertEquals(\"msg\" + i, received.getMessageId());\n        }\n\n        receiver2.close();\n        connection.close();\n    }",
            "  38  \n  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72 +\n  73  \n  74  \n  75  \n  76  \n  77  \n  78  ",
            "    @Test(timeout = 60000)\n    public void testCloseBusyReceiver() throws Exception {\n        final int MSG_COUNT = 20;\n\n        AmqpClient client = createAmqpClient();\n        AmqpConnection connection = client.connect();\n        AmqpSession session = connection.createSession();\n\n        AmqpSender sender = session.createSender(\"queue://\" + getTestName());\n\n        for (int i = 0; i < MSG_COUNT; i++) {\n            AmqpMessage message = new AmqpMessage();\n\n            message.setMessageId(\"msg\" + i);\n            message.setMessageAnnotation(\"serialNo\", i);\n            message.setText(\"Test-Message\");\n\n            sender.send(message);\n        }\n\n        sender.close();\n\n        QueueViewMBean queue = getProxyToQueue(getTestName());\n        assertEquals(20, queue.getQueueSize());\n\n        AmqpReceiver receiver1 = session.createReceiver(\"queue://\" + getTestName());\n        receiver1.flow(MSG_COUNT);\n        AmqpMessage received = receiver1.receive(5, TimeUnit.SECONDS);\n        assertEquals(\"msg0\", received.getMessageId());\n        receiver1.close();\n\n        AmqpReceiver receiver2 = session.createReceiver(\"queue://\" + getTestName());\n        receiver2.flow(200);\n        for (int i = 0; i < MSG_COUNT; ++i) {\n            received = receiver2.receive(5, TimeUnit.SECONDS);\n            assertEquals(\"msg\" + i, received.getMessageId());\n        }\n\n        receiver2.close();\n        connection.close();\n    }"
        ],
        [
            "JMSMappingOutboundTransformer::convert(Message)",
            " 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177 -\n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  ",
            "    /**\n     * Perform the conversion between JMS Message and Proton Message without\n     * re-encoding it to array. This is needed because some frameworks may elect\n     * to do this on their own way (Netty for instance using Nettybuffers)\n     *\n     * @param msg\n     * @return\n     * @throws Exception\n     */\n    public ProtonJMessage convert(Message msg) throws JMSException, UnsupportedEncodingException {\n        Header header = new Header();\n        Properties props = new Properties();\n        HashMap<Symbol, Object> daMap = null;\n        HashMap<Symbol, Object> maMap = null;\n        HashMap apMap = null;\n        Section body = null;\n        HashMap footerMap = null;\n        if (msg instanceof BytesMessage) {\n            BytesMessage m = (BytesMessage) msg;\n            byte data[] = new byte[(int) m.getBodyLength()];\n            m.readBytes(data);\n            m.reset(); // Need to reset after readBytes or future readBytes\n                       // calls (ex: redeliveries) will fail and return -1\n            body = new Data(new Binary(data));\n        }\n        if (msg instanceof TextMessage) {\n            body = new AmqpValue(((TextMessage) msg).getText());\n        }\n        if (msg instanceof MapMessage) {\n            final HashMap<String, Object> map = new HashMap<String, Object>();\n            final MapMessage m = (MapMessage) msg;\n            final Enumeration<String> names = m.getMapNames();\n            while (names.hasMoreElements()) {\n                String key = names.nextElement();\n                map.put(key, m.getObject(key));\n            }\n            body = new AmqpValue(map);\n        }\n        if (msg instanceof StreamMessage) {\n            ArrayList<Object> list = new ArrayList<Object>();\n            final StreamMessage m = (StreamMessage) msg;\n            try {\n                while (true) {\n                    list.add(m.readObject());\n                }\n            } catch (MessageEOFException e) {\n            }\n            body = new AmqpSequence(list);\n        }\n        if (msg instanceof ObjectMessage) {\n            body = new AmqpValue(((ObjectMessage) msg).getObject());\n        }\n\n        header.setDurable(msg.getJMSDeliveryMode() == DeliveryMode.PERSISTENT ? true : false);\n        header.setPriority(new UnsignedByte((byte) msg.getJMSPriority()));\n        if (msg.getJMSType() != null) {\n            props.setSubject(msg.getJMSType());\n        }\n        if (msg.getJMSMessageID() != null) {\n            props.setMessageId(msg.getJMSMessageID());\n        }\n        if (msg.getJMSDestination() != null) {\n            props.setTo(vendor.toAddress(msg.getJMSDestination()));\n            if (maMap == null) {\n                maMap = new HashMap<Symbol, Object>();\n            }\n            maMap.put(JMS_DEST_TYPE_MSG_ANNOTATION, destinationType(msg.getJMSDestination()));\n\n            // Deprecated: used by legacy QPid AMQP 1.0 JMS client\n            maMap.put(LEGACY_JMS_DEST_TYPE_MSG_ANNOTATION, destinationAttributes(msg.getJMSDestination()));\n        }\n        if (msg.getJMSReplyTo() != null) {\n            props.setReplyTo(vendor.toAddress(msg.getJMSReplyTo()));\n            if (maMap == null) {\n                maMap = new HashMap<Symbol, Object>();\n            }\n            maMap.put(JMS_REPLY_TO_TYPE_MSG_ANNOTATION, destinationType(msg.getJMSReplyTo()));\n\n            // Deprecated: used by legacy QPid AMQP 1.0 JMS client\n            maMap.put(LEGACY_JMS_REPLY_TO_TYPE_MSG_ANNOTATION, destinationAttributes(msg.getJMSReplyTo()));\n        }\n        if (msg.getJMSCorrelationID() != null) {\n            props.setCorrelationId(msg.getJMSCorrelationID());\n        }\n        if (msg.getJMSExpiration() != 0) {\n            long ttl = msg.getJMSExpiration() - System.currentTimeMillis();\n            if (ttl < 0) {\n                ttl = 1;\n            }\n            header.setTtl(new UnsignedInteger((int) ttl));\n\n            props.setAbsoluteExpiryTime(new Date(msg.getJMSExpiration()));\n        }\n        if (msg.getJMSTimestamp() != 0) {\n            props.setCreationTime(new Date(msg.getJMSTimestamp()));\n        }\n\n        final Enumeration<String> keys = msg.getPropertyNames();\n        while (keys.hasMoreElements()) {\n            String key = keys.nextElement();\n            if (key.equals(messageFormatKey) || key.equals(nativeKey)) {\n                // skip..\n            } else if (key.equals(firstAcquirerKey)) {\n                header.setFirstAcquirer(msg.getBooleanProperty(key));\n            } else if (key.startsWith(\"JMSXDeliveryCount\")) {\n                // The AMQP delivery-count field only includes prior failed delivery attempts,\n                // whereas JMSXDeliveryCount includes the first/current delivery attempt.\n                int amqpDeliveryCount = msg.getIntProperty(key) - 1;\n                if (amqpDeliveryCount > 0) {\n                    header.setDeliveryCount(new UnsignedInteger(amqpDeliveryCount));\n                }\n            } else if (key.startsWith(\"JMSXUserID\")) {\n                String value = msg.getStringProperty(key);\n                props.setUserId(new Binary(value.getBytes(\"UTF-8\")));\n            } else if (key.startsWith(\"JMSXGroupID\")) {\n                String value = msg.getStringProperty(key);\n                props.setGroupId(value);\n                if (apMap == null) {\n                    apMap = new HashMap();\n                }\n                apMap.put(key, value);\n            } else if (key.startsWith(\"JMSXGroupSeq\")) {\n                UnsignedInteger value = new UnsignedInteger(msg.getIntProperty(key));\n                props.setGroupSequence(value);\n                if (apMap == null) {\n                    apMap = new HashMap();\n                }\n                apMap.put(key, value);\n            } else if (key.startsWith(prefixDeliveryAnnotationsKey)) {\n                if (daMap == null) {\n                    daMap = new HashMap<Symbol, Object>();\n                }\n                String name = key.substring(prefixDeliveryAnnotationsKey.length());\n                daMap.put(Symbol.valueOf(name), msg.getObjectProperty(key));\n            } else if (key.startsWith(prefixMessageAnnotationsKey)) {\n                if (maMap == null) {\n                    maMap = new HashMap<Symbol, Object>();\n                }\n                String name = key.substring(prefixMessageAnnotationsKey.length());\n                maMap.put(Symbol.valueOf(name), msg.getObjectProperty(key));\n            } else if (key.equals(contentTypeKey)) {\n                props.setContentType(Symbol.getSymbol(msg.getStringProperty(key)));\n            } else if (key.equals(contentEncodingKey)) {\n                props.setContentEncoding(Symbol.getSymbol(msg.getStringProperty(key)));\n            } else if (key.equals(replyToGroupIDKey)) {\n                props.setReplyToGroupId(msg.getStringProperty(key));\n            } else if (key.startsWith(prefixFooterKey)) {\n                if (footerMap == null) {\n                    footerMap = new HashMap();\n                }\n                String name = key.substring(prefixFooterKey.length());\n                footerMap.put(name, msg.getObjectProperty(key));\n            } else {\n                if (apMap == null) {\n                    apMap = new HashMap();\n                }\n                apMap.put(key, msg.getObjectProperty(key));\n            }\n        }\n\n        MessageAnnotations ma = null;\n        if (maMap != null) {\n            ma = new MessageAnnotations(maMap);\n        }\n        DeliveryAnnotations da = null;\n        if (daMap != null) {\n            da = new DeliveryAnnotations(daMap);\n        }\n        ApplicationProperties ap = null;\n        if (apMap != null) {\n            ap = new ApplicationProperties(apMap);\n        }\n        Footer footer = null;\n        if (footerMap != null) {\n            footer = new Footer(footerMap);\n        }\n\n        return (ProtonJMessage) org.apache.qpid.proton.message.Message.Factory.create(header, da, ma, props, ap, body, footer);\n    }",
            " 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179 +\n 180 +\n 181 +\n 182 +\n 183 +\n 184 +\n 185 +\n 186 +\n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  ",
            "    /**\n     * Perform the conversion between JMS Message and Proton Message without\n     * re-encoding it to array. This is needed because some frameworks may elect\n     * to do this on their own way (Netty for instance using Nettybuffers)\n     *\n     * @param msg\n     * @return\n     * @throws Exception\n     */\n    public ProtonJMessage convert(Message msg) throws JMSException, UnsupportedEncodingException {\n        Header header = new Header();\n        Properties props = new Properties();\n        HashMap<Symbol, Object> daMap = null;\n        HashMap<Symbol, Object> maMap = null;\n        HashMap apMap = null;\n        Section body = null;\n        HashMap footerMap = null;\n        if (msg instanceof BytesMessage) {\n            BytesMessage m = (BytesMessage) msg;\n            byte data[] = new byte[(int) m.getBodyLength()];\n            m.readBytes(data);\n            m.reset(); // Need to reset after readBytes or future readBytes\n                       // calls (ex: redeliveries) will fail and return -1\n            body = new Data(new Binary(data));\n        }\n        if (msg instanceof TextMessage) {\n            body = new AmqpValue(((TextMessage) msg).getText());\n        }\n        if (msg instanceof MapMessage) {\n            final HashMap<String, Object> map = new HashMap<String, Object>();\n            final MapMessage m = (MapMessage) msg;\n            final Enumeration<String> names = m.getMapNames();\n            while (names.hasMoreElements()) {\n                String key = names.nextElement();\n                map.put(key, m.getObject(key));\n            }\n            body = new AmqpValue(map);\n        }\n        if (msg instanceof StreamMessage) {\n            ArrayList<Object> list = new ArrayList<Object>();\n            final StreamMessage m = (StreamMessage) msg;\n            try {\n                while (true) {\n                    list.add(m.readObject());\n                }\n            } catch (MessageEOFException e) {\n            }\n            body = new AmqpSequence(list);\n        }\n        if (msg instanceof ObjectMessage) {\n            body = new AmqpValue(((ObjectMessage) msg).getObject());\n        }\n\n        header.setDurable(msg.getJMSDeliveryMode() == DeliveryMode.PERSISTENT ? true : false);\n        header.setPriority(new UnsignedByte((byte) msg.getJMSPriority()));\n        if (msg.getJMSType() != null) {\n            props.setSubject(msg.getJMSType());\n        }\n        if (msg.getJMSMessageID() != null) {\n            ActiveMQMessage amqMsg = (ActiveMQMessage) msg;\n\n            MessageId msgId = amqMsg.getMessageId();\n            if (msgId.getTextView() != null) {\n                props.setMessageId(msgId.getTextView());\n            } else {\n                props.setMessageId(msgId.toString());\n            }\n        }\n        if (msg.getJMSDestination() != null) {\n            props.setTo(vendor.toAddress(msg.getJMSDestination()));\n            if (maMap == null) {\n                maMap = new HashMap<Symbol, Object>();\n            }\n            maMap.put(JMS_DEST_TYPE_MSG_ANNOTATION, destinationType(msg.getJMSDestination()));\n\n            // Deprecated: used by legacy QPid AMQP 1.0 JMS client\n            maMap.put(LEGACY_JMS_DEST_TYPE_MSG_ANNOTATION, destinationAttributes(msg.getJMSDestination()));\n        }\n        if (msg.getJMSReplyTo() != null) {\n            props.setReplyTo(vendor.toAddress(msg.getJMSReplyTo()));\n            if (maMap == null) {\n                maMap = new HashMap<Symbol, Object>();\n            }\n            maMap.put(JMS_REPLY_TO_TYPE_MSG_ANNOTATION, destinationType(msg.getJMSReplyTo()));\n\n            // Deprecated: used by legacy QPid AMQP 1.0 JMS client\n            maMap.put(LEGACY_JMS_REPLY_TO_TYPE_MSG_ANNOTATION, destinationAttributes(msg.getJMSReplyTo()));\n        }\n        if (msg.getJMSCorrelationID() != null) {\n            props.setCorrelationId(msg.getJMSCorrelationID());\n        }\n        if (msg.getJMSExpiration() != 0) {\n            long ttl = msg.getJMSExpiration() - System.currentTimeMillis();\n            if (ttl < 0) {\n                ttl = 1;\n            }\n            header.setTtl(new UnsignedInteger((int) ttl));\n\n            props.setAbsoluteExpiryTime(new Date(msg.getJMSExpiration()));\n        }\n        if (msg.getJMSTimestamp() != 0) {\n            props.setCreationTime(new Date(msg.getJMSTimestamp()));\n        }\n\n        final Enumeration<String> keys = msg.getPropertyNames();\n        while (keys.hasMoreElements()) {\n            String key = keys.nextElement();\n            if (key.equals(messageFormatKey) || key.equals(nativeKey)) {\n                // skip..\n            } else if (key.equals(firstAcquirerKey)) {\n                header.setFirstAcquirer(msg.getBooleanProperty(key));\n            } else if (key.startsWith(\"JMSXDeliveryCount\")) {\n                // The AMQP delivery-count field only includes prior failed delivery attempts,\n                // whereas JMSXDeliveryCount includes the first/current delivery attempt.\n                int amqpDeliveryCount = msg.getIntProperty(key) - 1;\n                if (amqpDeliveryCount > 0) {\n                    header.setDeliveryCount(new UnsignedInteger(amqpDeliveryCount));\n                }\n            } else if (key.startsWith(\"JMSXUserID\")) {\n                String value = msg.getStringProperty(key);\n                props.setUserId(new Binary(value.getBytes(\"UTF-8\")));\n            } else if (key.startsWith(\"JMSXGroupID\")) {\n                String value = msg.getStringProperty(key);\n                props.setGroupId(value);\n                if (apMap == null) {\n                    apMap = new HashMap();\n                }\n                apMap.put(key, value);\n            } else if (key.startsWith(\"JMSXGroupSeq\")) {\n                UnsignedInteger value = new UnsignedInteger(msg.getIntProperty(key));\n                props.setGroupSequence(value);\n                if (apMap == null) {\n                    apMap = new HashMap();\n                }\n                apMap.put(key, value);\n            } else if (key.startsWith(prefixDeliveryAnnotationsKey)) {\n                if (daMap == null) {\n                    daMap = new HashMap<Symbol, Object>();\n                }\n                String name = key.substring(prefixDeliveryAnnotationsKey.length());\n                daMap.put(Symbol.valueOf(name), msg.getObjectProperty(key));\n            } else if (key.startsWith(prefixMessageAnnotationsKey)) {\n                if (maMap == null) {\n                    maMap = new HashMap<Symbol, Object>();\n                }\n                String name = key.substring(prefixMessageAnnotationsKey.length());\n                maMap.put(Symbol.valueOf(name), msg.getObjectProperty(key));\n            } else if (key.equals(contentTypeKey)) {\n                props.setContentType(Symbol.getSymbol(msg.getStringProperty(key)));\n            } else if (key.equals(contentEncodingKey)) {\n                props.setContentEncoding(Symbol.getSymbol(msg.getStringProperty(key)));\n            } else if (key.equals(replyToGroupIDKey)) {\n                props.setReplyToGroupId(msg.getStringProperty(key));\n            } else if (key.startsWith(prefixFooterKey)) {\n                if (footerMap == null) {\n                    footerMap = new HashMap();\n                }\n                String name = key.substring(prefixFooterKey.length());\n                footerMap.put(name, msg.getObjectProperty(key));\n            } else {\n                if (apMap == null) {\n                    apMap = new HashMap();\n                }\n                apMap.put(key, msg.getObjectProperty(key));\n            }\n        }\n\n        MessageAnnotations ma = null;\n        if (maMap != null) {\n            ma = new MessageAnnotations(maMap);\n        }\n        DeliveryAnnotations da = null;\n        if (daMap != null) {\n            da = new DeliveryAnnotations(daMap);\n        }\n        ApplicationProperties ap = null;\n        if (apMap != null) {\n            ap = new ApplicationProperties(apMap);\n        }\n        Footer footer = null;\n        if (footerMap != null) {\n            footer = new Footer(footerMap);\n        }\n\n        return (ProtonJMessage) org.apache.qpid.proton.message.Message.Factory.create(header, da, ma, props, ap, body, footer);\n    }"
        ]
    ],
    "dce2b61f870245a0c12b634d12cd0fa3a8a60daa": [
        [
            "TransportConnection::service(Command)",
            " 328  \n 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335 -\n 336  \n 337  \n 338 -\n 339  \n 340  \n 341  \n 342  \n 343  \n 344  \n 345  \n 346  \n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  ",
            "    @Override\n    public Response service(Command command) {\n        MDC.put(\"activemq.connector\", connector.getUri().toString());\n        Response response = null;\n        boolean responseRequired = command.isResponseRequired();\n        int commandId = command.getCommandId();\n        try {\n            if (!pendingStop) {\n                response = command.visit(this);\n            } else {\n                response = new ExceptionResponse(transportException.get());\n            }\n        } catch (Throwable e) {\n            if (SERVICELOG.isDebugEnabled() && e.getClass() != BrokerStoppedException.class) {\n                SERVICELOG.debug(\"Error occured while processing \" + (responseRequired ? \"sync\" : \"async\")\n                        + \" command: \" + command + \", exception: \" + e, e);\n            }\n\n            if (e instanceof SuppressReplyException || (e.getCause() instanceof SuppressReplyException)) {\n                LOG.info(\"Suppressing reply to: \" + command + \" on: \" + e + \", cause: \" + e.getCause());\n                responseRequired = false;\n            }\n\n            if (responseRequired) {\n                if (e instanceof SecurityException || e.getCause() instanceof SecurityException) {\n                    SERVICELOG.warn(\"Security Error occurred on connection to: {}, {}\",\n                            transport.getRemoteAddress(), e.getMessage());\n                }\n                response = new ExceptionResponse(e);\n            } else {\n                forceRollbackOnlyOnFailedAsyncTransactionOp(e, command);\n                serviceException(e);\n            }\n        }\n        if (responseRequired) {\n            if (response == null) {\n                response = new Response();\n            }\n            response.setCorrelationId(commandId);\n        }\n        // The context may have been flagged so that the response is not\n        // sent.\n        if (context != null) {\n            if (context.isDontSendReponse()) {\n                context.setDontSendReponse(false);\n                response = null;\n            }\n            context = null;\n        }\n        MDC.remove(\"activemq.connector\");\n        return response;\n    }",
            " 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324 +\n 325 +\n 326 +\n 327 +\n 328  \n 329  \n 330 +\n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344  \n 345  \n 346  \n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  ",
            "    @Override\n    public Response service(Command command) {\n        MDC.put(\"activemq.connector\", connector.getUri().toString());\n        Response response = null;\n        boolean responseRequired = command.isResponseRequired();\n        int commandId = command.getCommandId();\n        try {\n            if (brokerService.isStopping()) {\n                response = responseRequired ? new ExceptionResponse(\n                    new BrokerStoppedException(\"Broker \" + brokerService + \" is being stopped\")) : null;\n            } else if (!pendingStop) {\n                response = command.visit(this);\n            } else {\n                response = responseRequired ? new ExceptionResponse(transportException.get()) : null;\n            }\n        } catch (Throwable e) {\n            if (SERVICELOG.isDebugEnabled() && e.getClass() != BrokerStoppedException.class) {\n                SERVICELOG.debug(\"Error occured while processing \" + (responseRequired ? \"sync\" : \"async\")\n                        + \" command: \" + command + \", exception: \" + e, e);\n            }\n\n            if (e instanceof SuppressReplyException || (e.getCause() instanceof SuppressReplyException)) {\n                LOG.info(\"Suppressing reply to: \" + command + \" on: \" + e + \", cause: \" + e.getCause());\n                responseRequired = false;\n            }\n\n            if (responseRequired) {\n                if (e instanceof SecurityException || e.getCause() instanceof SecurityException) {\n                    SERVICELOG.warn(\"Security Error occurred on connection to: {}, {}\",\n                            transport.getRemoteAddress(), e.getMessage());\n                }\n                response = new ExceptionResponse(e);\n            } else {\n                forceRollbackOnlyOnFailedAsyncTransactionOp(e, command);\n                serviceException(e);\n            }\n        }\n        if (responseRequired) {\n            if (response == null) {\n                response = new Response();\n            }\n            response.setCorrelationId(commandId);\n        }\n        // The context may have been flagged so that the response is not\n        // sent.\n        if (context != null) {\n            if (context.isDontSendReponse()) {\n                context.setDontSendReponse(false);\n                response = null;\n            }\n            context = null;\n        }\n        MDC.remove(\"activemq.connector\");\n        return response;\n    }"
        ],
        [
            "TransportConnection::TransportConnection(TransportConnector,Transport,Broker,TaskRunnerFactory,TaskRunnerFactory)",
            " 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199 -\n 200 -\n 201 -\n 202 -\n 203 -\n 204 -\n 205 -\n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  ",
            "    /**\n     * @param taskRunnerFactory - can be null if you want direct dispatch to the transport\n     *                          else commands are sent async.\n     * @param stopTaskRunnerFactory - can <b>not</b> be null, used for stopping this connection.\n     */\n    public TransportConnection(TransportConnector connector, final Transport transport, Broker broker,\n                               TaskRunnerFactory taskRunnerFactory, TaskRunnerFactory stopTaskRunnerFactory) {\n        this.connector = connector;\n        this.broker = broker;\n        this.brokerService = broker.getBrokerService();\n\n        RegionBroker rb = (RegionBroker) broker.getAdaptor(RegionBroker.class);\n        brokerConnectionStates = rb.getConnectionStates();\n        if (connector != null) {\n            this.statistics.setParent(connector.getStatistics());\n            this.messageAuthorizationPolicy = connector.getMessageAuthorizationPolicy();\n        }\n        this.taskRunnerFactory = taskRunnerFactory;\n        this.stopTaskRunnerFactory = stopTaskRunnerFactory;\n        this.transport = transport;\n        if( this.transport instanceof BrokerServiceAware ) {\n            ((BrokerServiceAware)this.transport).setBrokerService(brokerService);\n        }\n        this.transport.setTransportListener(new DefaultTransportListener() {\n            @Override\n            public void onCommand(Object o) {\n                serviceLock.readLock().lock();\n                try {\n                    if (!(o instanceof Command)) {\n                        throw new RuntimeException(\"Protocol violation - Command corrupted: \" + o.toString());\n                    }\n                    Command command = (Command) o;\n                    if (!brokerService.isStopping()) {\n                        Response response = service(command);\n                        if (response != null && !brokerService.isStopping()) {\n                            dispatchSync(response);\n                        }\n                    } else {\n                        throw new BrokerStoppedException(\"Broker \" + brokerService + \" is being stopped\");\n                    }\n                } finally {\n                    serviceLock.readLock().unlock();\n                }\n            }\n\n            @Override\n            public void onException(IOException exception) {\n                serviceLock.readLock().lock();\n                try {\n                    serviceTransportException(exception);\n                } finally {\n                    serviceLock.readLock().unlock();\n                }\n            }\n        });\n        connected = true;\n    }",
            " 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192 +\n 193 +\n 194 +\n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  ",
            "    /**\n     * @param taskRunnerFactory - can be null if you want direct dispatch to the transport\n     *                          else commands are sent async.\n     * @param stopTaskRunnerFactory - can <b>not</b> be null, used for stopping this connection.\n     */\n    public TransportConnection(TransportConnector connector, final Transport transport, Broker broker,\n                               TaskRunnerFactory taskRunnerFactory, TaskRunnerFactory stopTaskRunnerFactory) {\n        this.connector = connector;\n        this.broker = broker;\n        this.brokerService = broker.getBrokerService();\n\n        RegionBroker rb = (RegionBroker) broker.getAdaptor(RegionBroker.class);\n        brokerConnectionStates = rb.getConnectionStates();\n        if (connector != null) {\n            this.statistics.setParent(connector.getStatistics());\n            this.messageAuthorizationPolicy = connector.getMessageAuthorizationPolicy();\n        }\n        this.taskRunnerFactory = taskRunnerFactory;\n        this.stopTaskRunnerFactory = stopTaskRunnerFactory;\n        this.transport = transport;\n        if( this.transport instanceof BrokerServiceAware ) {\n            ((BrokerServiceAware)this.transport).setBrokerService(brokerService);\n        }\n        this.transport.setTransportListener(new DefaultTransportListener() {\n            @Override\n            public void onCommand(Object o) {\n                serviceLock.readLock().lock();\n                try {\n                    if (!(o instanceof Command)) {\n                        throw new RuntimeException(\"Protocol violation - Command corrupted: \" + o.toString());\n                    }\n                    Command command = (Command) o;\n                    Response response = service(command);\n                    if (response != null) {\n                        dispatchSync(response);\n                    }\n                } finally {\n                    serviceLock.readLock().unlock();\n                }\n            }\n\n            @Override\n            public void onException(IOException exception) {\n                serviceLock.readLock().lock();\n                try {\n                    serviceTransportException(exception);\n                } finally {\n                    serviceLock.readLock().unlock();\n                }\n            }\n        });\n        connected = true;\n    }"
        ],
        [
            "TransportConnection::getActiveTransactionCount()",
            " 464  \n 465  \n 466  \n 467  \n 468 -\n 469 -\n 470 -\n 471 -\n 472  \n 473  \n 474  ",
            "    @Override\n    public int getActiveTransactionCount() {\n        int rc = 0;\n        for (TransportConnectionState cs : connectionStateRegister.listConnectionStates()) {\n            Collection<TransactionState> transactions = cs.getTransactionStates();\n            for (TransactionState transaction : transactions) {\n                rc++;\n            }\n        }\n        return rc;\n    }",
            " 456  \n 457  \n 458  \n 459  \n 460 +\n 461  \n 462  \n 463  ",
            "    @Override\n    public int getActiveTransactionCount() {\n        int rc = 0;\n        for (TransportConnectionState cs : connectionStateRegister.listConnectionStates()) {\n            rc += cs.getTransactionStates().size();\n        }\n        return rc;\n    }"
        ]
    ],
    "a0c42a61dd1af5a6f0d3a65862310dd9728d4ffa": [
        [
            "MessageDatabase::updateIndex(Transaction,KahaUpdateMessageCommand,Location)",
            "1366  \n1367  \n1368  \n1369  \n1370  \n1371  \n1372 -\n1373  \n1374  \n1375  \n1376  \n1377  \n1378  \n1379  \n1380  \n1381  \n1382  \n1383  ",
            "    void updateIndex(Transaction tx, KahaUpdateMessageCommand updateMessageCommand, Location location) throws IOException {\n        KahaAddMessageCommand command = updateMessageCommand.getMessage();\n        StoredDestination sd = getStoredDestination(command.getDestination(), tx);\n\n        Long id = sd.messageIdIndex.get(tx, command.getMessageId());\n        if (id != null) {\n            sd.orderIndex.put(\n                    tx,\n                    command.getPrioritySupported() ? command.getPriority() : javax.jms.Message.DEFAULT_PRIORITY,\n                    id,\n                    new MessageKeys(command.getMessageId(), location)\n            );\n            sd.locationIndex.put(tx, location, id);\n        } else {\n            LOG.warn(\"Non existent message update attempt rejected. Destination: {}://{}, Message id: {}\", command.getDestination().getType(), command.getDestination().getName(), command.getMessageId());\n        }\n        metadata.lastUpdate = location;\n    }",
            "1366  \n1367  \n1368  \n1369  \n1370  \n1371  \n1372 +\n1373  \n1374  \n1375  \n1376  \n1377  \n1378  \n1379 +\n1380 +\n1381 +\n1382  \n1383  \n1384  \n1385  \n1386  ",
            "    void updateIndex(Transaction tx, KahaUpdateMessageCommand updateMessageCommand, Location location) throws IOException {\n        KahaAddMessageCommand command = updateMessageCommand.getMessage();\n        StoredDestination sd = getStoredDestination(command.getDestination(), tx);\n\n        Long id = sd.messageIdIndex.get(tx, command.getMessageId());\n        if (id != null) {\n            MessageKeys previousKeys = sd.orderIndex.put(\n                    tx,\n                    command.getPrioritySupported() ? command.getPriority() : javax.jms.Message.DEFAULT_PRIORITY,\n                    id,\n                    new MessageKeys(command.getMessageId(), location)\n            );\n            sd.locationIndex.put(tx, location, id);\n            if(previousKeys != null) {\n                sd.locationIndex.remove(tx, previousKeys.location);\n            }\n        } else {\n            LOG.warn(\"Non existent message update attempt rejected. Destination: {}://{}, Message id: {}\", command.getDestination().getType(), command.getDestination().getName(), command.getMessageId());\n        }\n        metadata.lastUpdate = location;\n    }"
        ]
    ],
    "8ca6341d401027a9f1517e6ddc78cc29f91be30f": [
        [
            "WSServlet::doGet(HttpServletRequest,HttpServletResponse)",
            "  46 -\n  47 -\n  48 -\n  49  ",
            "    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n        throws ServletException ,IOException  {\n        getServletContext().getNamedDispatcher(\"default\").forward(request,response);\n    }",
            "  48  \n  49 +\n  50 +\n  51  ",
            "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        getServletContext().getNamedDispatcher(\"default\").forward(request, response);\n    }"
        ],
        [
            "WSServlet::configure(WebSocketServletFactory)",
            "  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69 -\n  70  ",
            "    public void configure(WebSocketServletFactory factory) {\n        factory.setCreator(new WebSocketCreator() {\n            @Override\n            public Object createWebSocket(ServletUpgradeRequest req, ServletUpgradeResponse resp) {\n                WebSocketListener socket;\n                if (req.getSubProtocols().contains(\"mqtt\")) {\n                    socket = new MQTTSocket();\n                } else {\n                    socket = new StompSocket();\n                }\n                return socket;\n            }\n        });\n        \n    }",
            "  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66 +\n  67  \n  68  \n  69 +\n  70  \n  71 +\n  72  \n  73  \n  74  \n  75  ",
            "    @Override\n    public void configure(WebSocketServletFactory factory) {\n        factory.setCreator(new WebSocketCreator() {\n            @Override\n            public Object createWebSocket(ServletUpgradeRequest req, ServletUpgradeResponse resp) {\n                WebSocketListener socket;\n                if (req.getSubProtocols().contains(\"mqtt\")) {\n                    socket = new MQTTSocket();\n                    resp.setAcceptedSubProtocol(\"mqtt\");\n                } else {\n                    socket = new StompSocket();\n                    resp.setAcceptedSubProtocol(\"stomp\");\n                }\n                listener.onAccept((Transport) socket);\n                return socket;\n            }\n        });\n    }"
        ],
        [
            "WSServlet::init()",
            "  38  \n  39  \n  40 -\n  41  \n  42  \n  43  \n  44  ",
            "    public void init() throws ServletException {\n        super.init();\n        listener = (TransportAcceptListener)getServletContext().getAttribute(\"acceptListener\");\n        if (listener == null) {\n            throw new ServletException(\"No such attribute 'acceptListener' available in the ServletContext\");\n        }\n    }",
            "  39  \n  40  \n  41  \n  42 +\n  43  \n  44  \n  45  \n  46  ",
            "    @Override\n    public void init() throws ServletException {\n        super.init();\n        listener = (TransportAcceptListener) getServletContext().getAttribute(\"acceptListener\");\n        if (listener == null) {\n            throw new ServletException(\"No such attribute 'acceptListener' available in the ServletContext\");\n        }\n    }"
        ]
    ],
    "037f91d61e0e632bc6b3b32c91b8cf58d8b673ae": [
        [
            "AmqpConnection::doOpenCompletion()",
            " 469  \n 470  \n 471  \n 472  \n 473  \n 474  \n 475 -\n 476 -\n 477  \n 478  \n 479  \n 480  \n 481  \n 482  \n 483  \n 484  \n 485 -\n 486  \n 487  \n 488  \n 489  \n 490  \n 491  \n 492  \n 493  \n 494  \n 495  \n 496  \n 497  \n 498  \n 499  \n 500  \n 501 -\n 502  \n 503  \n 504  \n 505  \n 506  ",
            "    @Override\n    protected void doOpenCompletion() {\n        // If the remote indicates that a close is pending, don't open.\n        if (!getEndpoint().getRemoteProperties().containsKey(CONNECTION_OPEN_FAILED)) {\n\n            if (!isIdleProcessingDisabled()) {\n                long nextKeepAliveTime = protonTransport.tick(System.currentTimeMillis());\n                if (nextKeepAliveTime > 0) {\n\n                    getScheduler().schedule(new Runnable() {\n\n                        @Override\n                        public void run() {\n                            try {\n                                if (getEndpoint().getLocalState() != EndpointState.CLOSED) {\n                                    LOG.debug(\"Client performing next idle check\");\n                                    long rescheduleAt = protonTransport.tick(System.currentTimeMillis()) - System.currentTimeMillis();\n                                    pumpToProtonTransport();\n                                    if (protonTransport.isClosed()) {\n                                        LOG.debug(\"Transport closed after inactivity check.\");\n                                        throw new InactivityIOException(\"Channel was inactive for to long\");\n                                    }\n\n                                    if (rescheduleAt > 0) {\n                                        getScheduler().schedule(this, rescheduleAt, TimeUnit.MILLISECONDS);\n                                    }\n                                }\n                            } catch (Exception e) {\n                                transport.close();\n                                fireClientException(e);\n                            }\n                        }\n                    }, nextKeepAliveTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n                }\n            }\n            super.doOpenCompletion();\n        }\n    }",
            " 469  \n 470  \n 471  \n 472  \n 473  \n 474  \n 475 +\n 476 +\n 477 +\n 478 +\n 479  \n 480  \n 481  \n 482  \n 483  \n 484  \n 485  \n 486  \n 487 +\n 488 +\n 489 +\n 490  \n 491  \n 492  \n 493  \n 494  \n 495  \n 496  \n 497  \n 498  \n 499  \n 500  \n 501  \n 502  \n 503  \n 504  \n 505 +\n 506  \n 507  \n 508  \n 509  \n 510  ",
            "    @Override\n    protected void doOpenCompletion() {\n        // If the remote indicates that a close is pending, don't open.\n        if (!getEndpoint().getRemoteProperties().containsKey(CONNECTION_OPEN_FAILED)) {\n\n            if (!isIdleProcessingDisabled()) {\n                // Using nano time since it is not related to the wall clock, which may change\n                long initialNow = TimeUnit.NANOSECONDS.toMillis(System.nanoTime());\n                long initialKeepAliveDeadline = protonTransport.tick(initialNow);\n                if (initialKeepAliveDeadline > 0) {\n\n                    getScheduler().schedule(new Runnable() {\n\n                        @Override\n                        public void run() {\n                            try {\n                                if (getEndpoint().getLocalState() != EndpointState.CLOSED) {\n                                    LOG.debug(\"Client performing next idle check\");\n                                    // Using nano time since it is not related to the wall clock, which may change\n                                    long now = TimeUnit.NANOSECONDS.toMillis(System.nanoTime());\n                                    long rescheduleAt = protonTransport.tick(now) - now;\n                                    pumpToProtonTransport();\n                                    if (protonTransport.isClosed()) {\n                                        LOG.debug(\"Transport closed after inactivity check.\");\n                                        throw new InactivityIOException(\"Channel was inactive for to long\");\n                                    }\n\n                                    if (rescheduleAt > 0) {\n                                        getScheduler().schedule(this, rescheduleAt, TimeUnit.MILLISECONDS);\n                                    }\n                                }\n                            } catch (Exception e) {\n                                transport.close();\n                                fireClientException(e);\n                            }\n                        }\n                    }, initialKeepAliveDeadline - initialNow, TimeUnit.MILLISECONDS);\n                }\n            }\n            super.doOpenCompletion();\n        }\n    }"
        ],
        [
            "AmqpConnection::keepAlive()",
            " 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248 -\n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  ",
            "    @Override\n    public long keepAlive() throws IOException {\n        long rescheduleAt = 0l;\n\n        LOG.trace(\"Performing connection:{} keep-alive processing\", amqpTransport.getRemoteAddress());\n\n        if (protonConnection.getLocalState() != EndpointState.CLOSED) {\n            rescheduleAt = protonTransport.tick(System.currentTimeMillis()) - System.currentTimeMillis();\n            pumpProtonToSocket();\n            if (protonTransport.isClosed()) {\n                rescheduleAt = 0;\n                LOG.debug(\"Transport closed after inactivity check.\");\n                throw new InactivityIOException(\"Channel was inactive for to long\");\n            }\n        }\n\n        LOG.trace(\"Connection:{} keep alive processing done, next update in {} milliseconds.\",\n                  amqpTransport.getRemoteAddress(), rescheduleAt);\n\n        return rescheduleAt;\n    }",
            " 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249 +\n 250 +\n 251 +\n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  ",
            "    @Override\n    public long keepAlive() throws IOException {\n        long rescheduleAt = 0l;\n\n        LOG.trace(\"Performing connection:{} keep-alive processing\", amqpTransport.getRemoteAddress());\n\n        if (protonConnection.getLocalState() != EndpointState.CLOSED) {\n            // Using nano time since it is not related to the wall clock, which may change\n            long now = TimeUnit.NANOSECONDS.toMillis(System.nanoTime());\n            rescheduleAt = protonTransport.tick(now) - now;\n            pumpProtonToSocket();\n            if (protonTransport.isClosed()) {\n                rescheduleAt = 0;\n                LOG.debug(\"Transport closed after inactivity check.\");\n                throw new InactivityIOException(\"Channel was inactive for to long\");\n            }\n        }\n\n        LOG.trace(\"Connection:{} keep alive processing done, next update in {} milliseconds.\",\n                  amqpTransport.getRemoteAddress(), rescheduleAt);\n\n        return rescheduleAt;\n    }"
        ],
        [
            "AmqpConnection::configureInactivityMonitor()",
            " 807  \n 808  \n 809  \n 810  \n 811  \n 812  \n 813  \n 814  \n 815  \n 816 -\n 817  \n 818 -\n 819 -\n 820  \n 821  \n 822  \n 823  ",
            "    private void configureInactivityMonitor() {\n        AmqpInactivityMonitor monitor = amqpTransport.getInactivityMonitor();\n        if (monitor == null) {\n            return;\n        }\n\n        // If either end has idle timeout requirements then the tick method\n        // will give us a deadline on the next time we need to tick() in order\n        // to meet those obligations.\n        long nextIdleCheck = protonTransport.tick(System.currentTimeMillis());\n        if (nextIdleCheck > 0) {\n            LOG.trace(\"Connection keep-alive processing starts at: {}\", new Date(nextIdleCheck));\n            monitor.startKeepAliveTask(nextIdleCheck - System.currentTimeMillis());\n        } else {\n            LOG.trace(\"Connection does not require keep-alive processing\");\n        }\n    }",
            " 810  \n 811  \n 812  \n 813  \n 814  \n 815  \n 816  \n 817  \n 818  \n 819 +\n 820 +\n 821 +\n 822  \n 823 +\n 824 +\n 825 +\n 826  \n 827  \n 828  \n 829  ",
            "    private void configureInactivityMonitor() {\n        AmqpInactivityMonitor monitor = amqpTransport.getInactivityMonitor();\n        if (monitor == null) {\n            return;\n        }\n\n        // If either end has idle timeout requirements then the tick method\n        // will give us a deadline on the next time we need to tick() in order\n        // to meet those obligations.\n        // Using nano time since it is not related to the wall clock, which may change\n        long now = TimeUnit.NANOSECONDS.toMillis(System.nanoTime());\n        long nextIdleCheck = protonTransport.tick(now);\n        if (nextIdleCheck > 0) {\n            long delay = nextIdleCheck - now;\n            LOG.trace(\"Connection keep-alive processing starts in: {}\", delay);\n            monitor.startKeepAliveTask(delay);\n        } else {\n            LOG.trace(\"Connection does not require keep-alive processing\");\n        }\n    }"
        ]
    ]
}