{
    "709e445d9967ac28b6869fb1949df20b1f953e7e": [
        [
            "VariableScopeVisitor::visitConstructorCallExpression(ConstructorCallExpression)",
            " 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564  \n 565  \n 566  \n 567  \n 568  \n 569  \n 570  \n 571  ",
            "    public void visitConstructorCallExpression(ConstructorCallExpression call) {\n        isSpecialConstructorCall = call.isSpecialCall();\n        super.visitConstructorCallExpression(call);\n        isSpecialConstructorCall = false;\n        if (!call.isUsingAnonymousInnerClass()) return;\n\n        pushState();\n        InnerClassNode innerClass = (InnerClassNode) call.getType();\n        innerClass.setVariableScope(currentScope);\n        for (MethodNode method : innerClass.getMethods()) {\n            Parameter[] parameters = method.getParameters();\n            if (parameters.length == 0) parameters = null; // null means no implicit \"it\"\n            ClosureExpression cl = new ClosureExpression(parameters, method.getCode());\n            visitClosureExpression(cl);\n        }\n\n        for (FieldNode field : innerClass.getFields()) {\n            final Expression expression = field.getInitialExpression();\n            if (expression != null) {\n                expression.visit(this);\n            }\n        }\n\n        for (Statement statement : innerClass.getObjectInitializerStatements()) {\n            statement.visit(this);\n        }\n        markClosureSharedVariables();\n        popState();\n    }",
            " 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561 +\n 562  \n 563 +\n 564 +\n 565 +\n 566 +\n 567 +\n 568 +\n 569 +\n 570  \n 571  \n 572 +\n 573  \n 574  \n 575  \n 576  \n 577  \n 578  \n 579  \n 580  ",
            "    public void visitConstructorCallExpression(ConstructorCallExpression call) {\n        isSpecialConstructorCall = call.isSpecialCall();\n        super.visitConstructorCallExpression(call);\n        isSpecialConstructorCall = false;\n        if (!call.isUsingAnonymousInnerClass()) return;\n\n        pushState();\n        InnerClassNode innerClass = (InnerClassNode) call.getType();\n        innerClass.setVariableScope(currentScope);\n        for (MethodNode method : innerClass.getMethods()) {\n            Parameter[] parameters = method.getParameters();\n            if (parameters.length == 0) parameters = null; // null means no implicit \"it\"\n            ClosureExpression cl = new ClosureExpression(parameters, method.getCode());\n            visitClosureExpression(cl);\n        }\n\n        for (FieldNode field : innerClass.getFields()) {\n            final Expression expression = field.getInitialExpression();\n            pushState(field.isStatic());\n            if (expression != null) {\n                if (expression instanceof VariableExpression) {\n                    VariableExpression vexp = (VariableExpression) expression;\n                    if (vexp.getAccessedVariable() instanceof Parameter) {\n                        // workaround for GROOVY-6834: accessing a parameter which is not yet seen in scope\n                        continue;\n                    }\n                }\n                expression.visit(this);\n            }\n            popState();\n        }\n\n        for (Statement statement : innerClass.getObjectInitializerStatements()) {\n            statement.visit(this);\n        }\n        markClosureSharedVariables();\n        popState();\n    }"
        ],
        [
            "InnerClassVisitor::visitConstructorCallExpression(ConstructorCallExpression)",
            " 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  ",
            "    @Override\n    public void visitConstructorCallExpression(ConstructorCallExpression call) {\n        super.visitConstructorCallExpression(call);\n        if (!call.isUsingAnonymousInnerClass()) {\n            passThisReference(call);\n            return;\n        }\n\n        InnerClassNode innerClass = (InnerClassNode) call.getType();\n        if (!innerClass.getDeclaredConstructors().isEmpty()) return;\n        if ((innerClass.getModifiers() & ACC_STATIC) != 0) return;\n\n        VariableScope scope = innerClass.getVariableScope();\n        if (scope == null) return;\n\n        // expressions = constructor call arguments\n        List<Expression> expressions = ((TupleExpression) call.getArguments()).getExpressions();\n        // block = init code for the constructor we produce\n        BlockStatement block = new BlockStatement();\n        // parameters = parameters of the constructor\n        final int additionalParamCount = 1 + scope.getReferencedLocalVariablesCount();\n        List<Parameter> parameters = new ArrayList<Parameter>(expressions.size() + additionalParamCount);\n        // superCallArguments = arguments for the super call == the constructor call arguments\n        List<Expression> superCallArguments = new ArrayList<Expression>(expressions.size());\n\n        // first we add a super() call for all expressions given in the \n        // constructor call expression\n        int pCount = additionalParamCount;\n        for (Expression expr : expressions) {\n            pCount++;\n            // add one parameter for each expression in the\n            // constructor call\n            Parameter param = new Parameter(ClassHelper.OBJECT_TYPE, \"p\" + pCount);\n            parameters.add(param);\n            // add to super call\n            superCallArguments.add(new VariableExpression(param));\n        }\n\n        // add the super call\n        ConstructorCallExpression cce = new ConstructorCallExpression(\n                ClassNode.SUPER,\n                new TupleExpression(superCallArguments)\n        );\n\n        block.addStatement(new ExpressionStatement(cce));\n\n        // we need to add \"this\" to access unknown methods/properties\n        // this is saved in a field named this$0\n        pCount = 0;\n        expressions.add(pCount, VariableExpression.THIS_EXPRESSION);\n        boolean isStatic = isStaticThis(innerClass,scope);\n        ClassNode outerClassType = getClassNode(innerClass.getOuterClass(), isStatic);\n        if (!isStatic && inClosure) outerClassType = ClassHelper.CLOSURE_TYPE;\n        outerClassType = outerClassType.getPlainNodeReference();\n        Parameter thisParameter = new Parameter(outerClassType, \"p\" + pCount);\n        parameters.add(pCount, thisParameter);\n\n        thisField = innerClass.addField(\"this$0\", PUBLIC_SYNTHETIC, outerClassType, null);\n        addFieldInit(thisParameter, thisField, block);\n\n        // for each shared variable we add a reference and save it as field\n        for (Iterator it = scope.getReferencedLocalVariablesIterator(); it.hasNext();) {\n            pCount++;\n            org.codehaus.groovy.ast.Variable var = (org.codehaus.groovy.ast.Variable) it.next();\n            VariableExpression ve = new VariableExpression(var);\n            ve.setClosureSharedVariable(true);\n            ve.setUseReferenceDirectly(true);\n            expressions.add(pCount, ve);\n\n            ClassNode rawReferenceType = ClassHelper.REFERENCE_TYPE.getPlainNodeReference();\n            Parameter p = new Parameter(rawReferenceType, \"p\" + pCount);\n            parameters.add(pCount, p);\n            p.setOriginType(var.getOriginType());\n            final VariableExpression initial = new VariableExpression(p);\n            initial.setUseReferenceDirectly(true);\n            final FieldNode pField = innerClass.addFieldFirst(ve.getName(), PUBLIC_SYNTHETIC,rawReferenceType, initial);\n            pField.setHolder(true);\n            pField.setOriginType(ClassHelper.getWrapper(var.getOriginType()));\n        }\n\n        innerClass.addConstructor(ACC_SYNTHETIC, parameters.toArray(new Parameter[0]), ClassNode.EMPTY_ARRAY, block);\n    }",
            " 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217 +\n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  ",
            "    @Override\n    public void visitConstructorCallExpression(ConstructorCallExpression call) {\n        super.visitConstructorCallExpression(call);\n        if (!call.isUsingAnonymousInnerClass()) {\n            passThisReference(call);\n            return;\n        }\n\n        InnerClassNode innerClass = (InnerClassNode) call.getType();\n        if (!innerClass.getDeclaredConstructors().isEmpty()) return;\n        if ((innerClass.getModifiers() & ACC_STATIC) != 0) return;\n\n        VariableScope scope = innerClass.getVariableScope();\n        if (scope == null) return;\n\n        // expressions = constructor call arguments\n        List<Expression> expressions = ((TupleExpression) call.getArguments()).getExpressions();\n        // block = init code for the constructor we produce\n        BlockStatement block = new BlockStatement();\n        // parameters = parameters of the constructor\n        final int additionalParamCount = 1 + scope.getReferencedLocalVariablesCount();\n        List<Parameter> parameters = new ArrayList<Parameter>(expressions.size() + additionalParamCount);\n        // superCallArguments = arguments for the super call == the constructor call arguments\n        List<Expression> superCallArguments = new ArrayList<Expression>(expressions.size());\n\n        // first we add a super() call for all expressions given in the \n        // constructor call expression\n        int pCount = additionalParamCount;\n        for (Expression expr : expressions) {\n            pCount++;\n            // add one parameter for each expression in the\n            // constructor call\n            Parameter param = new Parameter(ClassHelper.OBJECT_TYPE, \"p\" + pCount);\n            parameters.add(param);\n            // add to super call\n            superCallArguments.add(new VariableExpression(param));\n        }\n\n        // add the super call\n        ConstructorCallExpression cce = new ConstructorCallExpression(\n                ClassNode.SUPER,\n                new TupleExpression(superCallArguments)\n        );\n\n        block.addStatement(new ExpressionStatement(cce));\n\n        // we need to add \"this\" to access unknown methods/properties\n        // this is saved in a field named this$0\n        pCount = 0;\n        expressions.add(pCount, VariableExpression.THIS_EXPRESSION);\n        boolean isStatic = isStaticThis(innerClass,scope);\n        ClassNode outerClassType = getClassNode(innerClass.getOuterClass(), isStatic);\n        if (!isStatic && inClosure) outerClassType = ClassHelper.CLOSURE_TYPE;\n        outerClassType = outerClassType.getPlainNodeReference();\n        Parameter thisParameter = new Parameter(outerClassType, \"p\" + pCount);\n        parameters.add(pCount, thisParameter);\n\n        thisField = innerClass.addField(\"this$0\", PUBLIC_SYNTHETIC, outerClassType, null);\n        addFieldInit(thisParameter, thisField, block);\n\n        // for each shared variable we add a reference and save it as field\n        for (Iterator it = scope.getReferencedLocalVariablesIterator(); it.hasNext();) {\n            pCount++;\n            org.codehaus.groovy.ast.Variable var = (org.codehaus.groovy.ast.Variable) it.next();\n            VariableExpression ve = new VariableExpression(var);\n            ve.setClosureSharedVariable(true);\n            ve.setUseReferenceDirectly(true);\n            expressions.add(pCount, ve);\n\n            ClassNode rawReferenceType = ClassHelper.REFERENCE_TYPE.getPlainNodeReference();\n            Parameter p = new Parameter(rawReferenceType, \"p\" + pCount);\n            parameters.add(pCount, p);\n            p.setOriginType(var.getOriginType());\n            final VariableExpression initial = new VariableExpression(p);\n            initial.setSynthetic(true);\n            initial.setUseReferenceDirectly(true);\n            final FieldNode pField = innerClass.addFieldFirst(ve.getName(), PUBLIC_SYNTHETIC,rawReferenceType, initial);\n            pField.setHolder(true);\n            pField.setOriginType(ClassHelper.getWrapper(var.getOriginType()));\n        }\n\n        innerClass.addConstructor(ACC_SYNTHETIC, parameters.toArray(new Parameter[0]), ClassNode.EMPTY_ARRAY, block);\n    }"
        ]
    ],
    "f95a3e45363e7e219d4b6d89bfc6d65715532095": [
        [
            "WideningCategories::keepLowestCommonInterfaces(List,List)",
            " 444  \n 445  \n 446  \n 447  \n 448  \n 449  \n 450  \n 451  \n 452  \n 453 -\n 454  \n 455  \n 456  \n 457  \n 458  \n 459  \n 460  ",
            "    /**\n     * Given the list of interfaces implemented by two class nodes, returns the list of the most specific common\n     * implemented interfaces.\n     * @param fromA\n     * @param fromB\n     * @return the list of the most specific common implemented interfaces\n     */\n    private static List<ClassNode> keepLowestCommonInterfaces(List<ClassNode> fromA, List<ClassNode> fromB) {\n        if (fromA==null||fromB==null) return EMPTY_CLASSNODE_LIST;\n        HashSet<ClassNode> common = new HashSet<ClassNode>(fromA);\n        common.retainAll(fromB);\n        List<ClassNode> result = new ArrayList<ClassNode>(common.size());\n        for (ClassNode classNode : common) {\n            addMostSpecificInterface(classNode, result);\n        }\n        return result;\n    }",
            " 444  \n 445  \n 446  \n 447  \n 448  \n 449  \n 450  \n 451  \n 452  \n 453 +\n 454  \n 455  \n 456  \n 457  \n 458  \n 459  \n 460  ",
            "    /**\n     * Given the list of interfaces implemented by two class nodes, returns the list of the most specific common\n     * implemented interfaces.\n     * @param fromA\n     * @param fromB\n     * @return the list of the most specific common implemented interfaces\n     */\n    private static List<ClassNode> keepLowestCommonInterfaces(List<ClassNode> fromA, List<ClassNode> fromB) {\n        if (fromA==null||fromB==null) return EMPTY_CLASSNODE_LIST;\n        Set<ClassNode> common = new HashSet<ClassNode>(fromA);\n        common.retainAll(fromB);\n        List<ClassNode> result = new ArrayList<ClassNode>(common.size());\n        for (ClassNode classNode : common) {\n            addMostSpecificInterface(classNode, result);\n        }\n        return result;\n    }"
        ],
        [
            "GroovyScriptEngine::ScriptClassLoader::doParseClass(GroovyCodeSource)",
            " 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253 -\n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  ",
            "        private Class doParseClass(GroovyCodeSource codeSource) {\n            // local is kept as hard reference to avoid garbage collection\n            ThreadLocal<LocalData> localTh = getLocalData();\n            LocalData localData = new LocalData();\n            localTh.set(localData);\n            StringSetMap cache = localData.dependencyCache;\n            \n            // we put the old dependencies into local cache so createCompilationUnit\n            // can pick it up. We put that entry under the name \".\"\n            ScriptCacheEntry origEntry = scriptCache.get(codeSource.getName());\n            Set<String> origDep = null;\n            if (origEntry != null) origDep = origEntry.dependencies;\n            if (origDep != null) {\n                HashSet<String> newDep = new HashSet<String>(origDep.size());\n                for (String depName : origDep) {\n                    ScriptCacheEntry dep = scriptCache.get(depName);\n                    try{\n                        if (origEntry==dep || GroovyScriptEngine.this.isSourceNewer(dep)) {\n                            newDep.add(depName);\n                        }\n                    } catch (ResourceException re) {\n                        \n                    }\n                }\n                cache.put(\".\", newDep);\n            }\n\n            Class answer = super.parseClass(codeSource, false);\n\n            cache.makeTransitiveHull();\n            long time = getCurrentTime();\n            Set<String> entryNames = new HashSet<String>();\n            for (Map.Entry<String, Set<String>> entry : cache.entrySet()) {\n                String className = entry.getKey();\n                Class clazz = getClassCacheEntry(className);\n                if (clazz == null) continue;\n\n                String entryName = getPath(clazz, localData.precompiledEntries);\n                if (entryNames.contains(entryName)) continue;\n                entryNames.add(entryName);\n                Set<String> value = convertToPaths(entry.getValue(), localData.precompiledEntries);\n                long lastModified;\n                try {\n                    lastModified = getLastModified(entryName);\n                } catch (ResourceException e) {\n                    lastModified = time;\n                }\n                ScriptCacheEntry cacheEntry = new ScriptCacheEntry(clazz, lastModified, time, value, false);\n                scriptCache.put(entryName, cacheEntry);\n            }\n            cache.clear();\n            localTh.set(null);\n            return answer;\n        }",
            " 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253 +\n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  ",
            "        private Class doParseClass(GroovyCodeSource codeSource) {\n            // local is kept as hard reference to avoid garbage collection\n            ThreadLocal<LocalData> localTh = getLocalData();\n            LocalData localData = new LocalData();\n            localTh.set(localData);\n            StringSetMap cache = localData.dependencyCache;\n            \n            // we put the old dependencies into local cache so createCompilationUnit\n            // can pick it up. We put that entry under the name \".\"\n            ScriptCacheEntry origEntry = scriptCache.get(codeSource.getName());\n            Set<String> origDep = null;\n            if (origEntry != null) origDep = origEntry.dependencies;\n            if (origDep != null) {\n                Set<String> newDep = new HashSet<String>(origDep.size());\n                for (String depName : origDep) {\n                    ScriptCacheEntry dep = scriptCache.get(depName);\n                    try{\n                        if (origEntry==dep || GroovyScriptEngine.this.isSourceNewer(dep)) {\n                            newDep.add(depName);\n                        }\n                    } catch (ResourceException re) {\n                        \n                    }\n                }\n                cache.put(\".\", newDep);\n            }\n\n            Class answer = super.parseClass(codeSource, false);\n\n            cache.makeTransitiveHull();\n            long time = getCurrentTime();\n            Set<String> entryNames = new HashSet<String>();\n            for (Map.Entry<String, Set<String>> entry : cache.entrySet()) {\n                String className = entry.getKey();\n                Class clazz = getClassCacheEntry(className);\n                if (clazz == null) continue;\n\n                String entryName = getPath(clazz, localData.precompiledEntries);\n                if (entryNames.contains(entryName)) continue;\n                entryNames.add(entryName);\n                Set<String> value = convertToPaths(entry.getValue(), localData.precompiledEntries);\n                long lastModified;\n                try {\n                    lastModified = getLastModified(entryName);\n                } catch (ResourceException e) {\n                    lastModified = time;\n                }\n                ScriptCacheEntry cacheEntry = new ScriptCacheEntry(clazz, lastModified, time, value, false);\n                scriptCache.put(entryName, cacheEntry);\n            }\n            cache.clear();\n            localTh.set(null);\n            return answer;\n        }"
        ],
        [
            "CharBuf::arraycopy(char,int,char,int,int)",
            " 613 -\n 614  \n 615  \n 616  \n 617  ",
            "    private final static void arraycopy(final char[] src, final int srcPos, final char[] dest, final int destPos, final int length) {\n\n        sysstemarraycopy(src, srcPos, dest, destPos, length);\n\n    }",
            " 613 +\n 614  \n 615  \n 616  \n 617  ",
            "    private static final void arraycopy(final char[] src, final int srcPos, final char[] dest, final int destPos, final int length) {\n\n        sysstemarraycopy(src, srcPos, dest, destPos, length);\n\n    }"
        ],
        [
            "GroovyClassLoader::addClasspath(String)",
            " 887  \n 888  \n 889  \n 890  \n 891  \n 892  \n 893  \n 894  \n 895  \n 896  \n 897  \n 898  \n 899  \n 900  \n 901  \n 902  \n 903  \n 904  \n 905  \n 906 -\n 907  \n 908  \n 909  \n 910  \n 911  \n 912  \n 913  \n 914  \n 915  \n 916  \n 917  \n 918  \n 919  \n 920  \n 921  \n 922  \n 923  \n 924  \n 925  \n 926  \n 927  \n 928  \n 929  \n 930  ",
            "    /**\n     * adds a classpath to this classloader.\n     *\n     * @param path is a jar file or a directory.\n     * @see #addURL(URL)\n     */\n    public void addClasspath(final String path) {\n        AccessController.doPrivileged(new PrivilegedAction<Void>() {\n            public Void run() {\n                try {\n                    // As the java.net.URL Javadoc says, the recommended way to get a URL is via URI.\n                    // http://docs.oracle.com/javase/7/docs/api/java/net/URL.html\n                    // \"Note, the URI class does perform escaping of its component fields in certain circumstances.\n                    // The recommended way to manage the encoding and decoding of URLs is to use URI, and to convert\n                    // between these two classes using toURI() and URI.toURL().\"\n                    // A possibly better approach here is to construct a URI and then resolve it against\n                    // a URI for the current working directory.\n                    // But we use this string match for now so everyone can see it doesn't hurt file-only classpaths.\n                    URI newURI;\n                    if (!uriPattern.matcher(path).matches()) {\n                        newURI = new File(path).toURI();\n                    } else {\n                        newURI = new URI(path);\n                    }\n                    URL[] urls = getURLs();\n                    for (URL url : urls) {\n                        // Do not use URL.equals.  It uses the network to resolve names and compares ip addresses!\n                        // That is a violation of RFC and just plain evil.\n                        // http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html\n                        // http://docs.oracle.com/javase/7/docs/api/java/net/URL.html#equals(java.lang.Object)\n                        // \"Since hosts comparison requires name resolution, this operation is a blocking operation.\n                        // Note: The defined behavior for equals is known to be inconsistent with virtual hosting in HTTP.\"\n                        if (newURI.equals(url.toURI())) return null;\n                    }\n                    addURL(newURI.toURL());\n                } catch (MalformedURLException e) {\n                    //TODO: fail through ?\n                } catch (URISyntaxException e) {\n                    // Just doing the same thing...\n                }\n                return null;\n            }\n        });\n    }",
            " 887  \n 888  \n 889  \n 890  \n 891  \n 892  \n 893  \n 894  \n 895  \n 896  \n 897  \n 898  \n 899  \n 900  \n 901  \n 902  \n 903  \n 904  \n 905  \n 906 +\n 907  \n 908  \n 909  \n 910  \n 911  \n 912  \n 913  \n 914  \n 915  \n 916  \n 917  \n 918  \n 919  \n 920  \n 921  \n 922  \n 923  \n 924  \n 925  \n 926  \n 927  \n 928  \n 929  \n 930  ",
            "    /**\n     * adds a classpath to this classloader.\n     *\n     * @param path is a jar file or a directory.\n     * @see #addURL(URL)\n     */\n    public void addClasspath(final String path) {\n        AccessController.doPrivileged(new PrivilegedAction<Void>() {\n            public Void run() {\n                try {\n                    // As the java.net.URL Javadoc says, the recommended way to get a URL is via URI.\n                    // http://docs.oracle.com/javase/7/docs/api/java/net/URL.html\n                    // \"Note, the URI class does perform escaping of its component fields in certain circumstances.\n                    // The recommended way to manage the encoding and decoding of URLs is to use URI, and to convert\n                    // between these two classes using toURI() and URI.toURL().\"\n                    // A possibly better approach here is to construct a URI and then resolve it against\n                    // a URI for the current working directory.\n                    // But we use this string match for now so everyone can see it doesn't hurt file-only classpaths.\n                    URI newURI;\n                    if (!URI_PATTERN.matcher(path).matches()) {\n                        newURI = new File(path).toURI();\n                    } else {\n                        newURI = new URI(path);\n                    }\n                    URL[] urls = getURLs();\n                    for (URL url : urls) {\n                        // Do not use URL.equals.  It uses the network to resolve names and compares ip addresses!\n                        // That is a violation of RFC and just plain evil.\n                        // http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html\n                        // http://docs.oracle.com/javase/7/docs/api/java/net/URL.html#equals(java.lang.Object)\n                        // \"Since hosts comparison requires name resolution, this operation is a blocking operation.\n                        // Note: The defined behavior for equals is known to be inconsistent with virtual hosting in HTTP.\"\n                        if (newURI.equals(url.toURI())) return null;\n                    }\n                    addURL(newURI.toURL());\n                } catch (MalformedURLException e) {\n                    //TODO: fail through ?\n                } catch (URISyntaxException e) {\n                    // Just doing the same thing...\n                }\n                return null;\n            }\n        });\n    }"
        ],
        [
            "fasta::selectRandom(frequency)",
            "  70 -\n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  ",
            "    public final static byte selectRandom(frequency[] a) {\n        int len = a.length;\n        double r = random(1.0);\n        for (int i = 0; i < len; i++)\n            if (r < a[i].p)\n                return a[i].c;\n        return a[len - 1].c;\n    }",
            "  70 +\n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  ",
            "    public static final byte selectRandom(frequency[] a) {\n        int len = a.length;\n        double r = random(1.0);\n        for (int i = 0; i < len; i++)\n            if (r < a[i].p)\n                return a[i].c;\n        return a[len - 1].c;\n    }"
        ],
        [
            "CharBuf::sysstemarraycopy(char,int,char,int,int)",
            " 608 -\n 609  \n 610  \n 611  ",
            "    private final static void sysstemarraycopy(final char[] src, final int srcPos, final char[] dest, final int destPos, final int length) {\n        System.arraycopy(src, srcPos, dest, destPos, length);\n\n    }",
            " 608 +\n 609  \n 610  \n 611  ",
            "    private static final void sysstemarraycopy(final char[] src, final int srcPos, final char[] dest, final int destPos, final int length) {\n        System.arraycopy(src, srcPos, dest, destPos, length);\n\n    }"
        ],
        [
            "GenericsUtils::extractPlaceholders(ClassNode)",
            " 113  \n 114 -\n 115  \n 116  \n 117  ",
            "    public static Map<String, GenericsType> extractPlaceholders(ClassNode cn) {\n        HashMap<String, GenericsType> ret = new HashMap<String, GenericsType>();\n        extractPlaceholders(cn, ret);\n        return ret;\n    }",
            " 113  \n 114 +\n 115  \n 116  \n 117  ",
            "    public static Map<String, GenericsType> extractPlaceholders(ClassNode cn) {\n        Map<String, GenericsType> ret = new HashMap<String, GenericsType>();\n        extractPlaceholders(cn, ret);\n        return ret;\n    }"
        ],
        [
            "ClassNode::MapOfLists::put(Object,MethodNode)",
            " 105  \n 106  \n 107  \n 108  \n 109 -\n 110  \n 111  \n 112  \n 113  ",
            "        public void put(Object key, MethodNode value) {\n            if (map.containsKey(key)) {\n                get(key).add(value);\n            } else {\n                ArrayList<MethodNode> list = new ArrayList<MethodNode>(2);\n                list.add(value);\n                map.put(key, list);\n            }\n        }",
            " 105  \n 106  \n 107  \n 108  \n 109 +\n 110  \n 111  \n 112  \n 113  ",
            "        public void put(Object key, MethodNode value) {\n            if (map.containsKey(key)) {\n                get(key).add(value);\n            } else {\n                List<MethodNode> list = new ArrayList<MethodNode>(2);\n                list.add(value);\n                map.put(key, list);\n            }\n        }"
        ],
        [
            "MetaClassImpl::chooseMethodInternal(String,Object,Class)",
            "2933  \n2934  \n2935  \n2936  \n2937  \n2938  \n2939  \n2940  \n2941  \n2942  \n2943  \n2944  \n2945  \n2946  \n2947  \n2948  \n2949  \n2950  \n2951  \n2952  \n2953  \n2954  \n2955  \n2956  \n2957  \n2958  \n2959  \n2960  \n2961  \n2962  \n2963  \n2964  \n2965  \n2966  \n2967  \n2968  \n2969  \n2970  \n2971  \n2972 -\n2973  \n2974  \n2975  \n2976  \n2977  \n2978  \n2979  \n2980  \n2981  \n2982  \n2983  \n2984  \n2985  \n2986  \n2987  \n2988  \n2989  \n2990  \n2991  ",
            "    private Object chooseMethodInternal(String methodName, Object methodOrList, Class[] arguments) {\n        if (methodOrList instanceof MetaMethod) {\n            if (((ParameterTypes) methodOrList).isValidMethod(arguments)) {\n                return methodOrList;\n            }\n            return null;\n        }\n\n        FastArray methods = (FastArray) methodOrList;\n        if (methods==null) return null;\n        int methodCount = methods.size();\n        if (methodCount <= 0) {\n            return null;\n        } else if (methodCount == 1) {\n            Object method = methods.get(0);\n            if (((ParameterTypes) method).isValidMethod(arguments)) {\n                return method;\n            }\n            return null;\n        }\n        Object answer;\n        if (arguments == null || arguments.length == 0) {\n            answer = MetaClassHelper.chooseEmptyMethodParams(methods);\n        } else {\n            Object matchingMethods = null;\n\n            final int len = methods.size;\n            Object data[] = methods.getArray();\n            for (int i = 0; i != len; ++i) {\n                Object method = data[i];\n\n                // making this false helps find matches\n                if (((ParameterTypes) method).isValidMethod(arguments)) {\n                    if (matchingMethods == null)\n                      matchingMethods = method;\n                    else\n                        if (matchingMethods instanceof ArrayList)\n                          ((ArrayList)matchingMethods).add(method);\n                        else {\n                            ArrayList arr = new ArrayList(4);\n                            arr.add(matchingMethods);\n                            arr.add(method);\n                            matchingMethods = arr;\n                        }\n                }\n            }\n            if (matchingMethods == null) {\n                return null;\n            } else if (!(matchingMethods instanceof ArrayList)) {\n                return matchingMethods;\n            }\n            return chooseMostSpecificParams(methodName, (List) matchingMethods, arguments);\n\n        }\n        if (answer != null) {\n            return answer;\n        }\n        throw new MethodSelectionException(methodName, methods, arguments);\n    }",
            "2933  \n2934  \n2935  \n2936  \n2937  \n2938  \n2939  \n2940  \n2941  \n2942  \n2943  \n2944  \n2945  \n2946  \n2947  \n2948  \n2949  \n2950  \n2951  \n2952  \n2953  \n2954  \n2955  \n2956  \n2957  \n2958  \n2959  \n2960  \n2961  \n2962  \n2963  \n2964  \n2965  \n2966  \n2967  \n2968  \n2969  \n2970  \n2971  \n2972 +\n2973  \n2974  \n2975  \n2976  \n2977  \n2978  \n2979  \n2980  \n2981  \n2982  \n2983  \n2984  \n2985  \n2986  \n2987  \n2988  \n2989  \n2990  \n2991  ",
            "    private Object chooseMethodInternal(String methodName, Object methodOrList, Class[] arguments) {\n        if (methodOrList instanceof MetaMethod) {\n            if (((ParameterTypes) methodOrList).isValidMethod(arguments)) {\n                return methodOrList;\n            }\n            return null;\n        }\n\n        FastArray methods = (FastArray) methodOrList;\n        if (methods==null) return null;\n        int methodCount = methods.size();\n        if (methodCount <= 0) {\n            return null;\n        } else if (methodCount == 1) {\n            Object method = methods.get(0);\n            if (((ParameterTypes) method).isValidMethod(arguments)) {\n                return method;\n            }\n            return null;\n        }\n        Object answer;\n        if (arguments == null || arguments.length == 0) {\n            answer = MetaClassHelper.chooseEmptyMethodParams(methods);\n        } else {\n            Object matchingMethods = null;\n\n            final int len = methods.size;\n            Object data[] = methods.getArray();\n            for (int i = 0; i != len; ++i) {\n                Object method = data[i];\n\n                // making this false helps find matches\n                if (((ParameterTypes) method).isValidMethod(arguments)) {\n                    if (matchingMethods == null)\n                      matchingMethods = method;\n                    else\n                        if (matchingMethods instanceof ArrayList)\n                          ((ArrayList)matchingMethods).add(method);\n                        else {\n                            List arr = new ArrayList(4);\n                            arr.add(matchingMethods);\n                            arr.add(method);\n                            matchingMethods = arr;\n                        }\n                }\n            }\n            if (matchingMethods == null) {\n                return null;\n            } else if (!(matchingMethods instanceof ArrayList)) {\n                return matchingMethods;\n            }\n            return chooseMostSpecificParams(methodName, (List) matchingMethods, arguments);\n\n        }\n        if (answer != null) {\n            return answer;\n        }\n        throw new MethodSelectionException(methodName, methods, arguments);\n    }"
        ],
        [
            "MetaClassImpl::MetaClassImpl(Class,MetaMethod)",
            " 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171 -\n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  ",
            "    public MetaClassImpl(final Class theClass, MetaMethod [] add) {\n        this.theClass = theClass;\n        theCachedClass = ReflectionCache.getCachedClass(theClass);\n        this.isGroovyObject = GroovyObject.class.isAssignableFrom(theClass);\n        this.isMap = Map.class.isAssignableFrom(theClass);\n        this.registry = GroovySystem.getMetaClassRegistry();\n        metaMethodIndex = new MetaMethodIndex(theCachedClass);\n        final MetaMethod[] metaMethods = theCachedClass.getNewMetaMethods();\n        if (add != null && !(add.length == 0)) {\n            ArrayList<MetaMethod> arr = new ArrayList<MetaMethod>();\n            arr.addAll(Arrays.asList(metaMethods));\n            arr.addAll(Arrays.asList(add));\n            myNewMetaMethods = arr.toArray(new MetaMethod[arr.size()]);\n            additionalMetaMethods = metaMethods;\n        }\n        else {\n            myNewMetaMethods = metaMethods;\n            additionalMetaMethods = EMPTY;\n        }\n    }",
            " 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171 +\n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  ",
            "    public MetaClassImpl(final Class theClass, MetaMethod [] add) {\n        this.theClass = theClass;\n        theCachedClass = ReflectionCache.getCachedClass(theClass);\n        this.isGroovyObject = GroovyObject.class.isAssignableFrom(theClass);\n        this.isMap = Map.class.isAssignableFrom(theClass);\n        this.registry = GroovySystem.getMetaClassRegistry();\n        metaMethodIndex = new MetaMethodIndex(theCachedClass);\n        final MetaMethod[] metaMethods = theCachedClass.getNewMetaMethods();\n        if (add != null && !(add.length == 0)) {\n            List<MetaMethod> arr = new ArrayList<MetaMethod>();\n            arr.addAll(Arrays.asList(metaMethods));\n            arr.addAll(Arrays.asList(add));\n            myNewMetaMethods = arr.toArray(new MetaMethod[arr.size()]);\n            additionalMetaMethods = metaMethods;\n        }\n        else {\n            myNewMetaMethods = metaMethods;\n            additionalMetaMethods = EMPTY;\n        }\n    }"
        ],
        [
            "MetaClassImpl::getPropName(String)",
            "2282  \n2283 -\n2284  \n2285  \n2286  \n2287 -\n2288  \n2289  \n2290  \n2291 -\n2292  \n2293  \n2294  ",
            "    private String getPropName(String methodName) {\n        String name = propNames.get(methodName);\n        if (name != null)\n            return name;\n\n        synchronized (propNames) {\n            // assume \"is\" or \"[gs]et\"\n            String stripped = methodName.startsWith(\"is\") ? methodName.substring(2) : methodName.substring(3);\n            String propName = java.beans.Introspector.decapitalize(stripped);\n            propNames.put(methodName, propName);\n            return propName;\n        }\n    }",
            "2282  \n2283 +\n2284  \n2285  \n2286  \n2287 +\n2288  \n2289  \n2290  \n2291 +\n2292  \n2293  \n2294  ",
            "    private String getPropName(String methodName) {\n        String name = PROP_NAMES.get(methodName);\n        if (name != null)\n            return name;\n\n        synchronized (PROP_NAMES) {\n            // assume \"is\" or \"[gs]et\"\n            String stripped = methodName.startsWith(\"is\") ? methodName.substring(2) : methodName.substring(3);\n            String propName = java.beans.Introspector.decapitalize(stripped);\n            PROP_NAMES.put(methodName, propName);\n            return propName;\n        }\n    }"
        ]
    ],
    "cd4a75c21ed44ada2b741bd822c1be5b8f4801b9": [
        [
            "StaticCompilationVisitor::addPrivateBridgeMethods(ClassNode)",
            " 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206 -\n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242 -\n 243  ",
            "    /**\n     * This method is used to add \"bridge\" methods for private methods of an inner/outer\n     * class, so that the outer class is capable of calling them. It does basically\n     * the same job as access$000 like methods in Java.\n     *\n     * @param node an inner/outer class node for which to generate bridge methods\n     */\n    @SuppressWarnings(\"unchecked\")\n    private void addPrivateBridgeMethods(final ClassNode node) {\n        Set<ASTNode> accessedMethods = (Set<ASTNode>) node.getNodeMetaData(StaticTypesMarker.PV_METHODS_ACCESS);\n        if (accessedMethods==null) return;\n        List<MethodNode> methods = new ArrayList<MethodNode>(node.getMethods());\n        Map<MethodNode, MethodNode> privateBridgeMethods = (Map<MethodNode, MethodNode>) node.getNodeMetaData(PRIVATE_BRIDGE_METHODS);\n        if (privateBridgeMethods!=null) {\n            // private bridge methods already added\n            return;\n        }\n        privateBridgeMethods = new HashMap<MethodNode, MethodNode>();\n        int i=-1;\n        final int access = Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC;\n        for (MethodNode method : methods) {\n            if (accessedMethods.contains(method)) {\n                i++;\n                Parameter[] methodParameters = method.getParameters();\n                Parameter[] newParams = new Parameter[methodParameters.length+1];\n                System.arraycopy(methodParameters, 0, newParams, 1, methodParameters.length);\n                newParams[0] = new Parameter(node.getPlainNodeReference(), \"$that\");\n                Expression arguments;\n                if (method.getParameters()==null || method.getParameters().length==0) {\n                    arguments = ArgumentListExpression.EMPTY_ARGUMENTS;\n                } else {\n                    List<Expression> args = new LinkedList<Expression>();\n                    for (Parameter parameter : methodParameters) {\n                        args.add(new VariableExpression(parameter));\n                    }\n                    arguments = new ArgumentListExpression(args);\n                }\n                Expression receiver = method.isStatic()?new ClassExpression(node):new VariableExpression(newParams[0]);\n                MethodCallExpression mce = new MethodCallExpression(receiver, method.getName(), arguments);\n                mce.setMethodTarget(method);\n\n                ExpressionStatement returnStatement = new ExpressionStatement(mce);\n                MethodNode bridge = node.addMethod(\"access$\"+i, access, method.getReturnType(), newParams, method.getExceptions(), returnStatement);\n                privateBridgeMethods.put(method, bridge);\n                bridge.addAnnotation(new AnnotationNode(COMPILESTATIC_CLASSNODE));\n            }\n        }\n        node.setNodeMetaData(PRIVATE_BRIDGE_METHODS, privateBridgeMethods);\n    }",
            " 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206 +\n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242 +\n 243 +\n 244 +\n 245  ",
            "    /**\n     * This method is used to add \"bridge\" methods for private methods of an inner/outer\n     * class, so that the outer class is capable of calling them. It does basically\n     * the same job as access$000 like methods in Java.\n     *\n     * @param node an inner/outer class node for which to generate bridge methods\n     */\n    @SuppressWarnings(\"unchecked\")\n    private void addPrivateBridgeMethods(final ClassNode node) {\n        Set<ASTNode> accessedMethods = (Set<ASTNode>) node.getNodeMetaData(StaticTypesMarker.PV_METHODS_ACCESS);\n        if (accessedMethods==null) return;\n        List<MethodNode> methods = new ArrayList<MethodNode>(node.getAllDeclaredMethods());\n        Map<MethodNode, MethodNode> privateBridgeMethods = (Map<MethodNode, MethodNode>) node.getNodeMetaData(PRIVATE_BRIDGE_METHODS);\n        if (privateBridgeMethods!=null) {\n            // private bridge methods already added\n            return;\n        }\n        privateBridgeMethods = new HashMap<MethodNode, MethodNode>();\n        int i=-1;\n        final int access = Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC;\n        for (MethodNode method : methods) {\n            if (accessedMethods.contains(method)) {\n                i++;\n                Parameter[] methodParameters = method.getParameters();\n                Parameter[] newParams = new Parameter[methodParameters.length+1];\n                System.arraycopy(methodParameters, 0, newParams, 1, methodParameters.length);\n                newParams[0] = new Parameter(node.getPlainNodeReference(), \"$that\");\n                Expression arguments;\n                if (method.getParameters()==null || method.getParameters().length==0) {\n                    arguments = ArgumentListExpression.EMPTY_ARGUMENTS;\n                } else {\n                    List<Expression> args = new LinkedList<Expression>();\n                    for (Parameter parameter : methodParameters) {\n                        args.add(new VariableExpression(parameter));\n                    }\n                    arguments = new ArgumentListExpression(args);\n                }\n                Expression receiver = method.isStatic()?new ClassExpression(node):new VariableExpression(newParams[0]);\n                MethodCallExpression mce = new MethodCallExpression(receiver, method.getName(), arguments);\n                mce.setMethodTarget(method);\n\n                ExpressionStatement returnStatement = new ExpressionStatement(mce);\n                MethodNode bridge = node.addMethod(\"access$\"+i, access, method.getReturnType(), newParams, method.getExceptions(), returnStatement);\n                privateBridgeMethods.put(method, bridge);\n                bridge.addAnnotation(new AnnotationNode(COMPILESTATIC_CLASSNODE));\n            }\n        }\n        if (!privateBridgeMethods.isEmpty()) {\n            node.setNodeMetaData(PRIVATE_BRIDGE_METHODS, privateBridgeMethods);\n        }\n    }"
        ],
        [
            "StaticInvocationWriter::writeDirectMethodCall(MethodNode,boolean,Expression,TupleExpression)",
            " 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220 -\n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  ",
            "    @Override\n    protected boolean writeDirectMethodCall(final MethodNode target, final boolean implicitThis, final Expression receiver, final TupleExpression args) {\n        if (target==null) return false;\n\n        if (target instanceof ExtensionMethodNode) {\n            ExtensionMethodNode emn = (ExtensionMethodNode) target;\n            MethodNode node = emn.getExtensionMethodNode();\n            String methodName = target.getName();\n\n            MethodVisitor mv = controller.getMethodVisitor();\n            int argumentsToRemove = 0;\n            List<Expression> argumentList = new LinkedList<Expression>(args.getExpressions());\n\n            if (emn.isStaticExtension()) {\n                // it's a static extension method\n                argumentList.add(0, ConstantExpression.NULL);\n            } else {\n                argumentList.add(0, receiver);\n            }\n\n            Parameter[] parameters = node.getParameters();\n            loadArguments(argumentList, parameters);\n\n            String owner = BytecodeHelper.getClassInternalName(node.getDeclaringClass());\n            String desc = BytecodeHelper.getMethodDescriptor(target.getReturnType(), parameters);\n            mv.visitMethodInsn(INVOKESTATIC, owner, methodName, desc, false);\n            ClassNode ret = target.getReturnType().redirect();\n            if (ret == ClassHelper.VOID_TYPE) {\n                ret = ClassHelper.OBJECT_TYPE;\n                mv.visitInsn(ACONST_NULL);\n            }\n            argumentsToRemove += argumentList.size();\n            controller.getOperandStack().remove(argumentsToRemove);\n            controller.getOperandStack().push(ret);\n            return true;\n        } else {\n            if (target == StaticTypeCheckingVisitor.CLOSURE_CALL_VARGS) {\n                // wrap arguments into an array\n                ArrayExpression arr = new ArrayExpression(ClassHelper.OBJECT_TYPE, args.getExpressions());\n                return super.writeDirectMethodCall(target, implicitThis, receiver, new ArgumentListExpression(arr));\n            }\n            ClassNode classNode = controller.getClassNode();\n            if (classNode.isDerivedFrom(ClassHelper.CLOSURE_TYPE)\n                    && controller.isInClosure()\n                    && !(target.isPublic() || target.isProtected())\n                    && target.getDeclaringClass() != classNode) {\n                if (!tryBridgeMethod(target, receiver, implicitThis, args)) {\n                    // replace call with an invoker helper call\n                    ArrayExpression arr = new ArrayExpression(ClassHelper.OBJECT_TYPE, args.getExpressions());\n                    MethodCallExpression mce = new MethodCallExpression(\n                            INVOKERHELER_RECEIVER,\n                            target.isStatic() ? \"invokeStaticMethod\" : \"invokeMethodSafe\",\n                            new ArgumentListExpression(\n                                    target.isStatic() ?\n                                            new ClassExpression(target.getDeclaringClass()) :\n                                            receiver,\n                                    new ConstantExpression(target.getName()),\n                                    arr\n                            )\n                    );\n                    mce.setMethodTarget(target.isStatic() ? INVOKERHELPER_INVOKESTATICMETHOD : INVOKERHELPER_INVOKEMETHOD);\n                    mce.visit(controller.getAcg());\n                    return true;\n                }\n                return true;\n            }\n            if (target.isPrivate()) {\n                ClassNode declaringClass = target.getDeclaringClass();\n                if ((isPrivateBridgeMethodsCallAllowed(declaringClass, classNode) || isPrivateBridgeMethodsCallAllowed(classNode, declaringClass))\n                        && declaringClass.getNodeMetaData(PRIVATE_BRIDGE_METHODS) != null\n                        && !declaringClass.equals(classNode)) {\n                    if (tryBridgeMethod(target, receiver, implicitThis, args)) {\n                        return true;\n                    } else if (declaringClass != classNode) {\n                        controller.getSourceUnit().addError(new SyntaxException(\"Cannot call private method \" + (target.isStatic() ? \"static \" : \"\") +\n                                declaringClass.toString(false) + \"#\" + target.getName() + \" from class \" + classNode.toString(false), receiver.getLineNumber(), receiver.getColumnNumber(), receiver.getLastLineNumber(), receiver.getLastColumnNumber()));\n                    }\n                }\n                if (declaringClass != classNode) {\n                    controller.getSourceUnit().addError(new SyntaxException(\"Cannot call private method \" + (target.isStatic() ? \"static \" : \"\") +\n                                                        declaringClass.toString(false) + \"#\" + target.getName() + \" from class \" + classNode.toString(false), receiver.getLineNumber(), receiver.getColumnNumber(), receiver.getLastLineNumber(), receiver.getLastColumnNumber()));\n                }\n            }\n            if (receiver != null) {\n                if (!(receiver instanceof VariableExpression) || !((VariableExpression) receiver).isSuperExpression()) {\n                    // in order to avoid calls to castToType, which is the dynamic behaviour, we make sure that we call CHECKCAST instead\n                    // then replace the top operand type\n                    Expression checkCastReceiver = new CheckcastReceiverExpression(receiver, target);\n                    return super.writeDirectMethodCall(target, implicitThis, checkCastReceiver, args);\n                }\n            }\n            return super.writeDirectMethodCall(target, implicitThis, receiver, args);\n        }\n    }",
            " 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229 +\n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  ",
            "    @Override\n    protected boolean writeDirectMethodCall(final MethodNode target, final boolean implicitThis, final Expression receiver, final TupleExpression args) {\n        if (target==null) return false;\n\n        if (target instanceof ExtensionMethodNode) {\n            ExtensionMethodNode emn = (ExtensionMethodNode) target;\n            MethodNode node = emn.getExtensionMethodNode();\n            String methodName = target.getName();\n\n            MethodVisitor mv = controller.getMethodVisitor();\n            int argumentsToRemove = 0;\n            List<Expression> argumentList = new LinkedList<Expression>(args.getExpressions());\n\n            if (emn.isStaticExtension()) {\n                // it's a static extension method\n                argumentList.add(0, ConstantExpression.NULL);\n            } else {\n                argumentList.add(0, receiver);\n            }\n\n            Parameter[] parameters = node.getParameters();\n            loadArguments(argumentList, parameters);\n\n            String owner = BytecodeHelper.getClassInternalName(node.getDeclaringClass());\n            String desc = BytecodeHelper.getMethodDescriptor(target.getReturnType(), parameters);\n            mv.visitMethodInsn(INVOKESTATIC, owner, methodName, desc, false);\n            ClassNode ret = target.getReturnType().redirect();\n            if (ret == ClassHelper.VOID_TYPE) {\n                ret = ClassHelper.OBJECT_TYPE;\n                mv.visitInsn(ACONST_NULL);\n            }\n            argumentsToRemove += argumentList.size();\n            controller.getOperandStack().remove(argumentsToRemove);\n            controller.getOperandStack().push(ret);\n            return true;\n        } else {\n            if (target == StaticTypeCheckingVisitor.CLOSURE_CALL_VARGS) {\n                // wrap arguments into an array\n                ArrayExpression arr = new ArrayExpression(ClassHelper.OBJECT_TYPE, args.getExpressions());\n                return super.writeDirectMethodCall(target, implicitThis, receiver, new ArgumentListExpression(arr));\n            }\n            ClassNode classNode = controller.getClassNode();\n            if (classNode.isDerivedFrom(ClassHelper.CLOSURE_TYPE)\n                    && controller.isInClosure()\n                    && !target.isPublic()\n                    && target.getDeclaringClass() != classNode) {\n                if (!tryBridgeMethod(target, receiver, implicitThis, args)) {\n                    // replace call with an invoker helper call\n                    ArrayExpression arr = new ArrayExpression(ClassHelper.OBJECT_TYPE, args.getExpressions());\n                    MethodCallExpression mce = new MethodCallExpression(\n                            INVOKERHELER_RECEIVER,\n                            target.isStatic() ? \"invokeStaticMethod\" : \"invokeMethodSafe\",\n                            new ArgumentListExpression(\n                                    target.isStatic() ?\n                                            new ClassExpression(target.getDeclaringClass()) :\n                                            receiver,\n                                    new ConstantExpression(target.getName()),\n                                    arr\n                            )\n                    );\n                    mce.setMethodTarget(target.isStatic() ? INVOKERHELPER_INVOKESTATICMETHOD : INVOKERHELPER_INVOKEMETHOD);\n                    mce.visit(controller.getAcg());\n                    return true;\n                }\n                return true;\n            }\n            if (target.isPrivate()) {\n                ClassNode declaringClass = target.getDeclaringClass();\n                if ((isPrivateBridgeMethodsCallAllowed(declaringClass, classNode) || isPrivateBridgeMethodsCallAllowed(classNode, declaringClass))\n                        && declaringClass.getNodeMetaData(PRIVATE_BRIDGE_METHODS) != null\n                        && !declaringClass.equals(classNode)) {\n                    if (tryBridgeMethod(target, receiver, implicitThis, args)) {\n                        return true;\n                    } else if (declaringClass != classNode) {\n                        controller.getSourceUnit().addError(new SyntaxException(\"Cannot call private method \" + (target.isStatic() ? \"static \" : \"\") +\n                                declaringClass.toString(false) + \"#\" + target.getName() + \" from class \" + classNode.toString(false), receiver.getLineNumber(), receiver.getColumnNumber(), receiver.getLastLineNumber(), receiver.getLastColumnNumber()));\n                    }\n                }\n                if (declaringClass != classNode) {\n                    controller.getSourceUnit().addError(new SyntaxException(\"Cannot call private method \" + (target.isStatic() ? \"static \" : \"\") +\n                                                        declaringClass.toString(false) + \"#\" + target.getName() + \" from class \" + classNode.toString(false), receiver.getLineNumber(), receiver.getColumnNumber(), receiver.getLastLineNumber(), receiver.getLastColumnNumber()));\n                }\n            }\n            if (receiver != null) {\n                if (!(receiver instanceof VariableExpression) || !((VariableExpression) receiver).isSuperExpression()) {\n                    // in order to avoid calls to castToType, which is the dynamic behaviour, we make sure that we call CHECKCAST instead\n                    // then replace the top operand type\n                    Expression checkCastReceiver = new CheckcastReceiverExpression(receiver, target);\n                    return super.writeDirectMethodCall(target, implicitThis, checkCastReceiver, args);\n                }\n            }\n            return super.writeDirectMethodCall(target, implicitThis, receiver, args);\n        }\n    }"
        ],
        [
            "StaticInvocationWriter::tryBridgeMethod(MethodNode,Expression,boolean,TupleExpression)",
            " 151  \n 152  \n 153  \n 154  \n 155 -\n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  ",
            "    /**\n     * Attempts to make a direct method call on a bridge method, if it exists.\n     */\n    protected boolean tryBridgeMethod(MethodNode target, Expression receiver, boolean implicitThis, TupleExpression args) {\n        Map<MethodNode, MethodNode> bridges = target.getDeclaringClass().redirect().getNodeMetaData(PRIVATE_BRIDGE_METHODS);\n        MethodNode bridge = bridges==null?null:bridges.get(target);\n        if (bridge != null) {\n            Expression fixedReceiver = receiver;\n            ClassNode classNode = implicitThis?controller.getClassNode():null;\n            ClassNode declaringClass = bridge.getDeclaringClass();\n            if (implicitThis && !controller.isInClosure()\n                    && !classNode.isDerivedFrom(declaringClass)\n                    && !classNode.implementsInterface(declaringClass)\n                    && classNode instanceof InnerClassNode) {\n                fixedReceiver = new PropertyExpression(new ClassExpression(classNode.getOuterClass()), \"this\");\n            }\n            ArgumentListExpression newArgs = new ArgumentListExpression(target.isStatic()?new ConstantExpression(null):fixedReceiver);\n            for (Expression expression : args.getExpressions()) {\n                newArgs.addExpression(expression);\n            }\n            return writeDirectMethodCall(bridge, implicitThis, fixedReceiver, newArgs);\n        }\n        return false;\n    }",
            " 151  \n 152  \n 153  \n 154  \n 155 +\n 156 +\n 157 +\n 158 +\n 159 +\n 160 +\n 161 +\n 162 +\n 163 +\n 164 +\n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  ",
            "    /**\n     * Attempts to make a direct method call on a bridge method, if it exists.\n     */\n    protected boolean tryBridgeMethod(MethodNode target, Expression receiver, boolean implicitThis, TupleExpression args) {\n        ClassNode lookupClassNode;\n        if (target.isProtected()) {\n            lookupClassNode = controller.getClassNode();\n            if (controller.isInClosure()) {\n                lookupClassNode = lookupClassNode.getOuterClass();\n            }\n        } else {\n            lookupClassNode = target.getDeclaringClass().redirect();\n        }\n        Map<MethodNode, MethodNode> bridges = lookupClassNode.getNodeMetaData(PRIVATE_BRIDGE_METHODS);\n        MethodNode bridge = bridges==null?null:bridges.get(target);\n        if (bridge != null) {\n            Expression fixedReceiver = receiver;\n            ClassNode classNode = implicitThis?controller.getClassNode():null;\n            ClassNode declaringClass = bridge.getDeclaringClass();\n            if (implicitThis && !controller.isInClosure()\n                    && !classNode.isDerivedFrom(declaringClass)\n                    && !classNode.implementsInterface(declaringClass)\n                    && classNode instanceof InnerClassNode) {\n                fixedReceiver = new PropertyExpression(new ClassExpression(classNode.getOuterClass()), \"this\");\n            }\n            ArgumentListExpression newArgs = new ArgumentListExpression(target.isStatic()?new ConstantExpression(null):fixedReceiver);\n            for (Expression expression : args.getExpressions()) {\n                newArgs.addExpression(expression);\n            }\n            return writeDirectMethodCall(bridge, implicitThis, fixedReceiver, newArgs);\n        }\n        return false;\n    }"
        ],
        [
            "StaticTypeCheckingVisitor::checkOrMarkPrivateAccess(MethodNode)",
            " 344  \n 345  \n 346  \n 347  \n 348 -\n 349 -\n 350 -\n 351 -\n 352  \n 353  ",
            "    /**\n     * Given a method node, checks if we are calling a private method from an inner class.\n     */\n    private void checkOrMarkPrivateAccess(MethodNode mn) {\n        if (mn!=null && Modifier.isPrivate(mn.getModifiers()) &&\n            (mn.getDeclaringClass() != typeCheckingContext.getEnclosingClassNode() || typeCheckingContext.getEnclosingClosure()!=null) &&\n            mn.getDeclaringClass().getModule() == typeCheckingContext.getEnclosingClassNode().getModule()) {\n            addPrivateFieldOrMethodAccess(mn.getDeclaringClass(), StaticTypesMarker.PV_METHODS_ACCESS, mn);\n        }\n    }",
            " 344  \n 345  \n 346  \n 347  \n 348 +\n 349 +\n 350 +\n 351 +\n 352 +\n 353 +\n 354 +\n 355 +\n 356 +\n 357 +\n 358 +\n 359 +\n 360 +\n 361 +\n 362 +\n 363 +\n 364  \n 365  ",
            "    /**\n     * Given a method node, checks if we are calling a private method from an inner class.\n     */\n    private void checkOrMarkPrivateAccess(MethodNode mn) {\n        if (mn==null) {\n            return;\n        }\n        ClassNode declaringClass = mn.getDeclaringClass();\n        ClassNode enclosingClassNode = typeCheckingContext.getEnclosingClassNode();\n        if (declaringClass != enclosingClassNode || typeCheckingContext.getEnclosingClosure() != null) {\n            int mods = mn.getModifiers();\n            boolean sameModule = declaringClass.getModule() == enclosingClassNode.getModule();\n            String packageName = declaringClass.getPackageName();\n            if (packageName==null) {\n                packageName = \"\";\n            }\n            if ((Modifier.isPrivate(mods) && sameModule)\n                    || (Modifier.isProtected(mods) && !packageName.equals(enclosingClassNode.getPackageName()))) {\n                addPrivateFieldOrMethodAccess(sameModule? declaringClass : enclosingClassNode, StaticTypesMarker.PV_METHODS_ACCESS, mn);\n            }\n        }\n    }"
        ]
    ],
    "8e7893897e61380f56b4aaa6e828b90b35c8d63b": [
        [
            "StaticInvocationWriter::CheckcastReceiverExpression::visit(GroovyCodeVisitor)",
            " 594  \n 595  \n 596  \n 597  \n 598  \n 599 -\n 600 -\n 601 -\n 602 -\n 603 -\n 604 -\n 605  \n 606  \n 607  \n 608  \n 609  \n 610  \n 611  \n 612  \n 613  \n 614  \n 615  \n 616  \n 617  \n 618  \n 619  \n 620  \n 621  ",
            "        @Override\n        public void visit(final GroovyCodeVisitor visitor) {\n            receiver.visit(visitor);\n            if (visitor instanceof AsmClassGenerator) {\n                ClassNode topOperand = controller.getOperandStack().getTopOperand();\n                ClassNode type;\n                if (target instanceof ExtensionMethodNode) {\n                    type = ((ExtensionMethodNode) target).getExtensionMethodNode().getDeclaringClass();\n                } else {\n                    type = target.getDeclaringClass();\n                }\n                if (ClassHelper.GSTRING_TYPE.equals(topOperand) && ClassHelper.STRING_TYPE.equals(type)) {\n                    // perform regular type conversion\n                    controller.getOperandStack().doGroovyCast(type);\n                    return;\n                }\n                if (ClassHelper.isPrimitiveType(topOperand) && !ClassHelper.isPrimitiveType(type)) {\n                    controller.getOperandStack().box();\n                } else if (!ClassHelper.isPrimitiveType(topOperand) && ClassHelper.isPrimitiveType(type)) {\n                    controller.getOperandStack().doGroovyCast(type);\n                }\n                if (StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(topOperand, type)) return;\n                controller.getMethodVisitor().visitTypeInsn(CHECKCAST, type.isArray() ?\n                        BytecodeHelper.getTypeDescription(type) :\n                        BytecodeHelper.getClassInternalName(type.getName()));\n                controller.getOperandStack().replace(type);\n            }\n        }",
            " 599  \n 600  \n 601  \n 602  \n 603  \n 604 +\n 605  \n 606  \n 607  \n 608  \n 609  \n 610  \n 611  \n 612  \n 613  \n 614  \n 615  \n 616  \n 617  \n 618  \n 619  \n 620  \n 621  ",
            "        @Override\n        public void visit(final GroovyCodeVisitor visitor) {\n            receiver.visit(visitor);\n            if (visitor instanceof AsmClassGenerator) {\n                ClassNode topOperand = controller.getOperandStack().getTopOperand();\n                ClassNode type = getType();\n                if (ClassHelper.GSTRING_TYPE.equals(topOperand) && ClassHelper.STRING_TYPE.equals(type)) {\n                    // perform regular type conversion\n                    controller.getOperandStack().doGroovyCast(type);\n                    return;\n                }\n                if (ClassHelper.isPrimitiveType(topOperand) && !ClassHelper.isPrimitiveType(type)) {\n                    controller.getOperandStack().box();\n                } else if (!ClassHelper.isPrimitiveType(topOperand) && ClassHelper.isPrimitiveType(type)) {\n                    controller.getOperandStack().doGroovyCast(type);\n                }\n                if (StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(topOperand, type)) return;\n                controller.getMethodVisitor().visitTypeInsn(CHECKCAST, type.isArray() ?\n                        BytecodeHelper.getTypeDescription(type) :\n                        BytecodeHelper.getClassInternalName(type.getName()));\n                controller.getOperandStack().replace(type);\n            }\n        }"
        ],
        [
            "StaticInvocationWriter::CheckcastReceiverExpression::getType()",
            " 623  \n 624  \n 625 -\n 626  ",
            "        @Override\n        public ClassNode getType() {\n            return controller.getTypeChooser().resolveType(receiver, controller.getClassNode());\n        }",
            " 623  \n 624  \n 625 +\n 626 +\n 627 +\n 628 +\n 629 +\n 630 +\n 631 +\n 632 +\n 633 +\n 634 +\n 635 +\n 636 +\n 637 +\n 638 +\n 639 +\n 640 +\n 641 +\n 642 +\n 643 +\n 644  ",
            "        @Override\n        public ClassNode getType() {\n            if (resolvedType!=null) {\n                return resolvedType;\n            }\n            ClassNode type;\n            if (target instanceof ExtensionMethodNode) {\n                type = ((ExtensionMethodNode) target).getExtensionMethodNode().getDeclaringClass();\n            } else {\n                type = getWrapper(controller.getTypeChooser().resolveType(receiver, controller.getClassNode()));\n                ClassNode declaringClass = target.getDeclaringClass();\n                if (type.getClass() != ClassNode.class && type.getClass() !=InnerClassNode.class) {\n                    type = declaringClass; // ex: LUB type\n                }\n                if (OBJECT_TYPE.equals(type) && !OBJECT_TYPE.equals(declaringClass)) {\n                    // can happen for compiler rewritten code, where type information is missing\n                    type = declaringClass;\n                }\n            }\n            resolvedType = type;\n            return type;\n        }"
        ],
        [
            "StaticTypesClosureWriter::createDirectCallMethod(ClassNode,MethodNode)",
            "  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83 -\n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98 -\n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  ",
            "    private void createDirectCallMethod(final ClassNode closureClass, final MethodNode doCallMethod) {\n        // in case there is no \"call\" method on the closure, we can create a \"fast invocation\" paths\n        // to avoid going through ClosureMetaClass by call(Object...) method\n\n        // we can't have a specialized version of call(Object...) because the dispatch logic in ClosureMetaClass\n        // is too complex!\n\n        // call(Object)\n        Parameter args = new Parameter(ClassHelper.OBJECT_TYPE, \"args\");\n        MethodCallExpression doCall1arg = new MethodCallExpression(\n                new VariableExpression(\"this\"),\n                \"doCall\",\n                new ArgumentListExpression(new VariableExpression(args))\n        );\n        doCall1arg.setImplicitThis(true);\n        doCall1arg.setMethodTarget(doCallMethod);\n        closureClass.addMethod(\n                new MethodNode(\"call\",\n                        Opcodes.ACC_PUBLIC,\n                        ClassHelper.OBJECT_TYPE,\n                        new Parameter[]{args},\n                        ClassNode.EMPTY_ARRAY,\n                        new ReturnStatement(doCall1arg)));\n\n        // call()\n        MethodCallExpression doCallNoArgs = new MethodCallExpression(new VariableExpression(\"this\"), \"doCall\", new ArgumentListExpression(new ConstantExpression(null)));\n        doCallNoArgs.setImplicitThis(true);\n        doCallNoArgs.setMethodTarget(doCallMethod);\n        closureClass.addMethod(\n                new MethodNode(\"call\",\n                        Opcodes.ACC_PUBLIC,\n                        ClassHelper.OBJECT_TYPE,\n                        Parameter.EMPTY_ARRAY,\n                        ClassNode.EMPTY_ARRAY,\n                        new ReturnStatement(doCallNoArgs)));\n    }",
            "  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83 +\n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98 +\n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  ",
            "    private void createDirectCallMethod(final ClassNode closureClass, final MethodNode doCallMethod) {\n        // in case there is no \"call\" method on the closure, we can create a \"fast invocation\" paths\n        // to avoid going through ClosureMetaClass by call(Object...) method\n\n        // we can't have a specialized version of call(Object...) because the dispatch logic in ClosureMetaClass\n        // is too complex!\n\n        // call(Object)\n        Parameter args = new Parameter(ClassHelper.OBJECT_TYPE, \"args\");\n        MethodCallExpression doCall1arg = new MethodCallExpression(\n                new VariableExpression(\"this\", closureClass),\n                \"doCall\",\n                new ArgumentListExpression(new VariableExpression(args))\n        );\n        doCall1arg.setImplicitThis(true);\n        doCall1arg.setMethodTarget(doCallMethod);\n        closureClass.addMethod(\n                new MethodNode(\"call\",\n                        Opcodes.ACC_PUBLIC,\n                        ClassHelper.OBJECT_TYPE,\n                        new Parameter[]{args},\n                        ClassNode.EMPTY_ARRAY,\n                        new ReturnStatement(doCall1arg)));\n\n        // call()\n        MethodCallExpression doCallNoArgs = new MethodCallExpression(new VariableExpression(\"this\", closureClass), \"doCall\", new ArgumentListExpression(new ConstantExpression(null)));\n        doCallNoArgs.setImplicitThis(true);\n        doCallNoArgs.setMethodTarget(doCallMethod);\n        closureClass.addMethod(\n                new MethodNode(\"call\",\n                        Opcodes.ACC_PUBLIC,\n                        ClassHelper.OBJECT_TYPE,\n                        Parameter.EMPTY_ARRAY,\n                        ClassNode.EMPTY_ARRAY,\n                        new ReturnStatement(doCallNoArgs)));\n    }"
        ],
        [
            "InvocationWriter::writeDirectMethodCall(MethodNode,boolean,Expression,TupleExpression)",
            " 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155 -\n 156 -\n 157  \n 158  \n 159  \n 160 -\n 161 -\n 162 -\n 163 -\n 164 -\n 165 -\n 166 -\n 167 -\n 168 -\n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  ",
            "    protected boolean writeDirectMethodCall(MethodNode target, boolean implicitThis,  Expression receiver, TupleExpression args) {\n        if (target==null) return false;\n        \n        String methodName = target.getName();\n        CompileStack compileStack = controller.getCompileStack();\n        OperandStack operandStack = controller.getOperandStack();\n        ClassNode declaringClass = target.getDeclaringClass();\n        ClassNode classNode = controller.getClassNode();\n\n        MethodVisitor mv = controller.getMethodVisitor();\n        int opcode = INVOKEVIRTUAL;\n        if (target.isStatic()) {\n            opcode = INVOKESTATIC;\n        } else if (target.isPrivate() || ((receiver instanceof VariableExpression && ((VariableExpression) receiver).isSuperExpression()))) {\n            opcode = INVOKESPECIAL;\n        } else if (declaringClass.isInterface()) {\n            opcode = INVOKEINTERFACE;\n        }\n\n        // handle receiver\n        int argumentsToRemove = 0;\n        if (opcode!=INVOKESTATIC) {\n            if (receiver!=null) {\n                // load receiver if not static invocation\n                // todo: fix inner class case\n                if (implicitThis\n                        && !classNode.isDerivedFrom(declaringClass)\n                        && !classNode.implementsInterface(declaringClass)\n                        && classNode instanceof InnerClassNode) {\n                    // we are calling an outer class method\n                    compileStack.pushImplicitThis(false);\n                    if (controller.isInClosure()) {\n                        new VariableExpression(\"thisObject\").visit(controller.getAcg());\n                    } else {\n                        Expression expr = new PropertyExpression(new ClassExpression(declaringClass), \"this\");\n                        expr.visit(controller.getAcg());\n                    }\n                } else {\n                    compileStack.pushImplicitThis(implicitThis);\n                    receiver.visit(controller.getAcg());\n                }\n                operandStack.doGroovyCast(declaringClass);\n                compileStack.popImplicitThis();\n                argumentsToRemove++;\n            } else {\n                mv.visitIntInsn(ALOAD,0);\n            }\n        }\n\n        int stackSize = operandStack.getStackLength();\n        loadArguments(args.getExpressions(), target.getParameters());\n\n\n        String owner = BytecodeHelper.getClassInternalName(declaringClass);\n        ClassNode receiverType = receiver!=null?controller.getTypeChooser().resolveType(receiver, classNode):target.getDeclaringClass();\n        if (opcode==INVOKEVIRTUAL\n                && target.isPublic()\n                && (!Modifier.isPublic(declaringClass.getModifiers())\n                && !receiverType.equals(declaringClass))\n                && receiverType.isDerivedFrom(declaringClass)\n                && !receiverType.getPackageName().equals(classNode.getPackageName())) {\n            // package private class, public method\n            // see GROOVY-6962\n            owner = BytecodeHelper.getClassInternalName(receiverType);\n        }\n        String desc = BytecodeHelper.getMethodDescriptor(target.getReturnType(), target.getParameters());\n        mv.visitMethodInsn(opcode, owner, methodName, desc, opcode == INVOKEINTERFACE);\n        ClassNode ret = target.getReturnType().redirect();\n        if (ret==ClassHelper.VOID_TYPE) {\n            ret = ClassHelper.OBJECT_TYPE;\n            mv.visitInsn(ACONST_NULL);\n        }\n        argumentsToRemove += (operandStack.getStackLength()-stackSize);\n        controller.getOperandStack().remove(argumentsToRemove);\n        controller.getOperandStack().push(ret);\n        return true;\n    }",
            " 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152 +\n 153 +\n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161 +\n 162 +\n 163 +\n 164 +\n 165 +\n 166 +\n 167 +\n 168 +\n 169 +\n 170 +\n 171 +\n 172 +\n 173 +\n 174 +\n 175 +\n 176 +\n 177 +\n 178 +\n 179 +\n 180 +\n 181 +\n 182  \n 183 +\n 184 +\n 185 +\n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  ",
            "    protected boolean writeDirectMethodCall(MethodNode target, boolean implicitThis,  Expression receiver, TupleExpression args) {\n        if (target==null) return false;\n        \n        String methodName = target.getName();\n        CompileStack compileStack = controller.getCompileStack();\n        OperandStack operandStack = controller.getOperandStack();\n        ClassNode declaringClass = target.getDeclaringClass();\n        ClassNode classNode = controller.getClassNode();\n\n        MethodVisitor mv = controller.getMethodVisitor();\n        int opcode = INVOKEVIRTUAL;\n        if (target.isStatic()) {\n            opcode = INVOKESTATIC;\n        } else if (target.isPrivate() || ((receiver instanceof VariableExpression && ((VariableExpression) receiver).isSuperExpression()))) {\n            opcode = INVOKESPECIAL;\n        } else if (declaringClass.isInterface()) {\n            opcode = INVOKEINTERFACE;\n        }\n\n        // handle receiver\n        int argumentsToRemove = 0;\n        if (opcode!=INVOKESTATIC) {\n            if (receiver!=null) {\n                // load receiver if not static invocation\n                // todo: fix inner class case\n                if (implicitThis\n                        && !classNode.isDerivedFrom(declaringClass)\n                        && !classNode.implementsInterface(declaringClass)\n                        && classNode instanceof InnerClassNode) {\n                    // we are calling an outer class method\n                    compileStack.pushImplicitThis(false);\n                    if (controller.isInClosure()) {\n                        new VariableExpression(\"thisObject\").visit(controller.getAcg());\n                    } else {\n                        Expression expr = new PropertyExpression(new ClassExpression(declaringClass), \"this\");\n                        expr.visit(controller.getAcg());\n                    }\n                } else {\n                    compileStack.pushImplicitThis(implicitThis);\n                    receiver.visit(controller.getAcg());\n                }\n                operandStack.doGroovyCast(declaringClass);\n                compileStack.popImplicitThis();\n                argumentsToRemove++;\n            } else {\n                mv.visitIntInsn(ALOAD,0);\n                operandStack.push(classNode);\n                argumentsToRemove++;\n            }\n        }\n\n        int stackSize = operandStack.getStackLength();\n\n        String owner = BytecodeHelper.getClassInternalName(declaringClass);\n        ClassNode receiverType = receiver!=null?controller.getTypeChooser().resolveType(receiver, classNode):target.getDeclaringClass();\n        if (opcode == INVOKEVIRTUAL) {\n            if (!receiverType.equals(declaringClass)\n                    && !receiverType.isArray()\n                    && !receiverType.isInterface()\n                    && !ClassHelper.isPrimitiveType(receiverType) // e.g int.getClass()\n                    && receiverType.isDerivedFrom(declaringClass)) {\n\n                owner = BytecodeHelper.getClassInternalName(receiverType);\n                ClassNode top = operandStack.getTopOperand();\n                if (!receiverType.equals(top)) {\n                    mv.visitTypeInsn(CHECKCAST, owner);\n                }\n            } else if (target.isPublic()\n                    && (!Modifier.isPublic(declaringClass.getModifiers())\n                    && !receiverType.equals(declaringClass))\n                    && receiverType.isDerivedFrom(declaringClass)\n                    && !receiverType.getPackageName().equals(classNode.getPackageName())) {\n                // package private class, public method\n                // see GROOVY-6962\n                owner = BytecodeHelper.getClassInternalName(receiverType);\n            }\n        }\n\n        loadArguments(args.getExpressions(), target.getParameters());\n\n        String desc = BytecodeHelper.getMethodDescriptor(target.getReturnType(), target.getParameters());\n        mv.visitMethodInsn(opcode, owner, methodName, desc, opcode == INVOKEINTERFACE);\n        ClassNode ret = target.getReturnType().redirect();\n        if (ret==ClassHelper.VOID_TYPE) {\n            ret = ClassHelper.OBJECT_TYPE;\n            mv.visitInsn(ACONST_NULL);\n        }\n        argumentsToRemove += (operandStack.getStackLength()-stackSize);\n        controller.getOperandStack().remove(argumentsToRemove);\n        controller.getOperandStack().push(ret);\n        return true;\n    }"
        ]
    ],
    "b819ed0644994afaefadd6f47ffec6adffde68af": [
        [
            "ClassCompletionVerifier::checkNoStaticMethodWithSameSignatureAsNonStatic(ClassNode)",
            "  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93 -\n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  ",
            "    private void checkNoStaticMethodWithSameSignatureAsNonStatic(final ClassNode node) {\n        Map<String, MethodNode> result = new HashMap<String, MethodNode>();\n        // add in unimplemented abstract methods from the interfaces\n        for (ClassNode iface : node.getInterfaces()) {\n            Map<String, MethodNode> ifaceMethodsMap = iface.getDeclaredMethodsMap();\n            for (String methSig : ifaceMethodsMap.keySet()) {\n                if (!result.containsKey(methSig)) {\n                    MethodNode methNode = ifaceMethodsMap.get(methSig);\n                    result.put(methSig, methNode);\n                }\n            }\n        }\n        for (MethodNode methodNode : node.getMethods()) {\n            MethodNode mn = result.get(methodNode.getTypeDescriptor());\n            if (mn!=null && methodNode.isStatic() && !methodNode.isStaticConstructor()) {\n                ClassNode cn = mn.getDeclaringClass().getOuterClass();\n                if (cn==null || !Traits.isTrait(cn)) {\n                    addError(\"Method '\" + mn.getName() + \"' is already defined in \" + getDescription(node) + \". You cannot have \" +\n                            \"both a static and a non static method with the same signature\", methodNode);\n                }\n            }\n            result.put(methodNode.getTypeDescriptor(), methodNode);\n        }\n    }",
            "  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93 +\n  94 +\n  95 +\n  96 +\n  97 +\n  98 +\n  99 +\n 100 +\n 101 +\n 102 +\n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  ",
            "    private void checkNoStaticMethodWithSameSignatureAsNonStatic(final ClassNode node) {\n        Map<String, MethodNode> result = new HashMap<String, MethodNode>();\n        // add in unimplemented abstract methods from the interfaces\n        for (ClassNode iface : node.getInterfaces()) {\n            Map<String, MethodNode> ifaceMethodsMap = iface.getDeclaredMethodsMap();\n            for (String methSig : ifaceMethodsMap.keySet()) {\n                if (!result.containsKey(methSig)) {\n                    MethodNode methNode = ifaceMethodsMap.get(methSig);\n                    result.put(methSig, methNode);\n                }\n            }\n        }\n        for (MethodNode methodNode : node.getMethods()) {\n            MethodNode mn = result.get(methodNode.getTypeDescriptor());\n            if (mn!=null && methodNode.isStatic() && !methodNode.isStaticConstructor()) {\n                ClassNode declaringClass = mn.getDeclaringClass();\n                ClassNode cn = declaringClass.getOuterClass();\n                if (cn==null && declaringClass.isResolved()) {\n                    // in case of a precompiled class, the outerclass is unknown\n                    Class typeClass = declaringClass.getTypeClass();\n                    typeClass = typeClass.getEnclosingClass();\n                    if (typeClass!=null) {\n                        cn = ClassHelper.make(typeClass);\n                    }\n                }\n                if (cn==null || !Traits.isTrait(cn)) {\n                    addError(\"Method '\" + mn.getName() + \"' is already defined in \" + getDescription(node) + \". You cannot have \" +\n                            \"both a static and a non static method with the same signature\", methodNode);\n                }\n            }\n            result.put(methodNode.getTypeDescriptor(), methodNode);\n        }\n    }"
        ],
        [
            "Verifier::addInitialization(ClassNode,ConstructorNode)",
            " 895  \n 896  \n 897  \n 898  \n 899  \n 900  \n 901  \n 902  \n 903  \n 904  \n 905  \n 906  \n 907  \n 908  \n 909  \n 910  \n 911  \n 912  \n 913  \n 914  \n 915  \n 916  \n 917  \n 918  \n 919  \n 920  \n 921  \n 922  \n 923  \n 924 -\n 925 -\n 926 -\n 927  \n 928  \n 929  \n 930  \n 931  \n 932  \n 933  \n 934  \n 935  \n 936  \n 937  \n 938  \n 939  \n 940  \n 941  \n 942  \n 943  \n 944  \n 945  \n 946  \n 947  \n 948  \n 949  \n 950  \n 951  \n 952  \n 953  \n 954  \n 955  \n 956  \n 957  \n 958  \n 959  \n 960  \n 961  \n 962  \n 963  \n 964  \n 965  \n 966  \n 967  \n 968  \n 969  \n 970  \n 971  \n 972  \n 973  \n 974  \n 975  ",
            "    protected void addInitialization(ClassNode node, ConstructorNode constructorNode) {\n        Statement firstStatement = constructorNode.getFirstStatement();\n        // if some transformation decided to generate constructor then it probably knows who it does\n        if (firstStatement instanceof BytecodeSequence)\n            return;\n\n        ConstructorCallExpression first = getFirstIfSpecialConstructorCall(firstStatement);\n\n        // in case of this(...) let the other constructor do the init\n        if (first != null && (first.isThisCall())) return;\n\n        List<Statement> statements = new ArrayList<Statement>();\n        List<Statement> staticStatements = new ArrayList<Statement>();\n        final boolean isEnum = node.isEnum();\n        List<Statement> initStmtsAfterEnumValuesInit = new ArrayList<Statement>();\n        Set<String> explicitStaticPropsInEnum = new HashSet<String>();\n        if (isEnum) {\n            for (PropertyNode propNode : node.getProperties()) {\n                if (!propNode.isSynthetic() && propNode.getField().isStatic()) {\n                    explicitStaticPropsInEnum.add(propNode.getField().getName());\n                }\n            }\n            for (FieldNode fieldNode : node.getFields()) {\n                if (!fieldNode.isSynthetic() && fieldNode.isStatic() && fieldNode.getType() != node) {\n                    explicitStaticPropsInEnum.add(fieldNode.getName());\n                }\n            }\n        }\n\n        for (FieldNode fn : node.getFields()) {\n            addFieldInitialization(statements, staticStatements, fn, isEnum,\n                    initStmtsAfterEnumValuesInit, explicitStaticPropsInEnum);\n        }\n\n        statements.addAll(node.getObjectInitializerStatements());\n\n        Statement code = constructorNode.getCode();\n        BlockStatement block = new BlockStatement();\n        List<Statement> otherStatements = block.getStatements();\n        if (code instanceof BlockStatement) {\n            block = (BlockStatement) code;\n            otherStatements = block.getStatements();\n        } else if (code != null) {\n            otherStatements.add(code);\n        }\n        if (!otherStatements.isEmpty()) {\n            if (first != null) {\n                // it is super(..) since this(..) is already covered\n                otherStatements.remove(0);\n                statements.add(0, firstStatement);\n            }\n            Statement stmtThis$0 = getImplicitThis$0StmtIfInnerClass(otherStatements);\n            if (stmtThis$0 != null) {\n                // since there can be field init statements that depend on method/property dispatching\n                // that uses this$0, it needs to bubble up before the super call itself (GROOVY-4471)\n                statements.add(0, stmtThis$0);\n            }\n            statements.addAll(otherStatements);\n        }\n        BlockStatement newBlock = new BlockStatement(statements, block.getVariableScope());\n        newBlock.setSourcePosition(block);\n        constructorNode.setCode(newBlock);\n\n\n\n        if (!staticStatements.isEmpty()) {\n            if (isEnum) {\n                /*\n                 * GROOVY-3161: initialize statements for explicitly declared static fields\n                 * inside an enum should come after enum values are initialized\n                 */\n                staticStatements.removeAll(initStmtsAfterEnumValuesInit);\n                node.addStaticInitializerStatements(staticStatements, true);\n                if (!initStmtsAfterEnumValuesInit.isEmpty()) {\n                    node.positionStmtsAfterEnumInitStmts(initStmtsAfterEnumValuesInit);\n                }\n            } else {\n                node.addStaticInitializerStatements(staticStatements, true);\n            }\n        }\n    }",
            " 895  \n 896  \n 897  \n 898  \n 899  \n 900  \n 901  \n 902  \n 903  \n 904  \n 905  \n 906  \n 907  \n 908  \n 909  \n 910  \n 911  \n 912  \n 913  \n 914  \n 915  \n 916  \n 917  \n 918  \n 919  \n 920  \n 921  \n 922  \n 923  \n 924 +\n 925 +\n 926 +\n 927 +\n 928 +\n 929  \n 930  \n 931  \n 932  \n 933  \n 934  \n 935  \n 936  \n 937  \n 938  \n 939  \n 940  \n 941  \n 942  \n 943  \n 944  \n 945  \n 946  \n 947  \n 948  \n 949  \n 950  \n 951  \n 952  \n 953  \n 954  \n 955  \n 956  \n 957  \n 958  \n 959  \n 960  \n 961  \n 962  \n 963  \n 964  \n 965  \n 966  \n 967  \n 968  \n 969  \n 970  \n 971  \n 972  \n 973  \n 974  \n 975  \n 976  \n 977  ",
            "    protected void addInitialization(ClassNode node, ConstructorNode constructorNode) {\n        Statement firstStatement = constructorNode.getFirstStatement();\n        // if some transformation decided to generate constructor then it probably knows who it does\n        if (firstStatement instanceof BytecodeSequence)\n            return;\n\n        ConstructorCallExpression first = getFirstIfSpecialConstructorCall(firstStatement);\n\n        // in case of this(...) let the other constructor do the init\n        if (first != null && (first.isThisCall())) return;\n\n        List<Statement> statements = new ArrayList<Statement>();\n        List<Statement> staticStatements = new ArrayList<Statement>();\n        final boolean isEnum = node.isEnum();\n        List<Statement> initStmtsAfterEnumValuesInit = new ArrayList<Statement>();\n        Set<String> explicitStaticPropsInEnum = new HashSet<String>();\n        if (isEnum) {\n            for (PropertyNode propNode : node.getProperties()) {\n                if (!propNode.isSynthetic() && propNode.getField().isStatic()) {\n                    explicitStaticPropsInEnum.add(propNode.getField().getName());\n                }\n            }\n            for (FieldNode fieldNode : node.getFields()) {\n                if (!fieldNode.isSynthetic() && fieldNode.isStatic() && fieldNode.getType() != node) {\n                    explicitStaticPropsInEnum.add(fieldNode.getName());\n                }\n            }\n        }\n\n        if (!Traits.isTrait(node)) {\n            for (FieldNode fn : node.getFields()) {\n                addFieldInitialization(statements, staticStatements, fn, isEnum,\n                        initStmtsAfterEnumValuesInit, explicitStaticPropsInEnum);\n            }\n        }\n\n        statements.addAll(node.getObjectInitializerStatements());\n\n        Statement code = constructorNode.getCode();\n        BlockStatement block = new BlockStatement();\n        List<Statement> otherStatements = block.getStatements();\n        if (code instanceof BlockStatement) {\n            block = (BlockStatement) code;\n            otherStatements = block.getStatements();\n        } else if (code != null) {\n            otherStatements.add(code);\n        }\n        if (!otherStatements.isEmpty()) {\n            if (first != null) {\n                // it is super(..) since this(..) is already covered\n                otherStatements.remove(0);\n                statements.add(0, firstStatement);\n            }\n            Statement stmtThis$0 = getImplicitThis$0StmtIfInnerClass(otherStatements);\n            if (stmtThis$0 != null) {\n                // since there can be field init statements that depend on method/property dispatching\n                // that uses this$0, it needs to bubble up before the super call itself (GROOVY-4471)\n                statements.add(0, stmtThis$0);\n            }\n            statements.addAll(otherStatements);\n        }\n        BlockStatement newBlock = new BlockStatement(statements, block.getVariableScope());\n        newBlock.setSourcePosition(block);\n        constructorNode.setCode(newBlock);\n\n\n\n        if (!staticStatements.isEmpty()) {\n            if (isEnum) {\n                /*\n                 * GROOVY-3161: initialize statements for explicitly declared static fields\n                 * inside an enum should come after enum values are initialized\n                 */\n                staticStatements.removeAll(initStmtsAfterEnumValuesInit);\n                node.addStaticInitializerStatements(staticStatements, true);\n                if (!initStmtsAfterEnumValuesInit.isEmpty()) {\n                    node.positionStmtsAfterEnumInitStmts(initStmtsAfterEnumValuesInit);\n                }\n            } else {\n                node.addStaticInitializerStatements(staticStatements, true);\n            }\n        }\n    }"
        ],
        [
            "TraitComposer::applyTrait(ClassNode,ClassNode,TraitHelpersTuple)",
            " 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187 -\n 188 -\n 189 -\n 190 -\n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260 -\n 261  \n 262  \n 263  \n 264  \n 265  ",
            "    private static void applyTrait(final ClassNode trait, final ClassNode cNode, final TraitHelpersTuple helpers) {\n        ClassNode helperClassNode = helpers.getHelper();\n        ClassNode fieldHelperClassNode = helpers.getFieldHelper();\n        Map<String,ClassNode> genericsSpec = GenericsUtils.createGenericsSpec(cNode);\n        genericsSpec = GenericsUtils.createGenericsSpec(trait, genericsSpec);\n\n        for (MethodNode methodNode : helperClassNode.getAllDeclaredMethods()) {\n            String name = methodNode.getName();\n            Parameter[] helperMethodParams = methodNode.getParameters();\n            boolean isAbstract = methodNode.isAbstract();\n            if (!isAbstract && helperMethodParams.length > 0 && ((methodNode.getModifiers() & Opcodes.ACC_STATIC) == Opcodes.ACC_STATIC) && !name.contains(\"$\")) {\n                ArgumentListExpression argList = new ArgumentListExpression();\n                argList.addExpression(new VariableExpression(\"this\"));\n                Parameter[] origParams = new Parameter[helperMethodParams.length - 1];\n                Parameter[] params = new Parameter[helperMethodParams.length - 1];\n                System.arraycopy(methodNode.getParameters(), 1, params, 0, params.length);\n                Map<String,ClassNode> methodGenericsSpec = new LinkedHashMap<String, ClassNode>(genericsSpec);\n                MethodNode originalMethod = trait.getMethod(name, params);\n                // Original method may be null in case of a private method\n                GenericsType[] originalMethodGenericsTypes = originalMethod!=null?originalMethod.getGenericsTypes():null;\n                if (originalMethodGenericsTypes!=null) {\n                    for (GenericsType type : originalMethodGenericsTypes) {\n                        String gtTypeName = type.getName();\n                        if (!methodGenericsSpec.containsKey(gtTypeName)) {\n                            methodGenericsSpec.put(gtTypeName, type.getType());\n                        }\n                    }\n                }\n                for (int i = 1; i < helperMethodParams.length; i++) {\n                    Parameter parameter = helperMethodParams[i];\n                    ClassNode originType = parameter.getOriginType();\n                    ClassNode fixedType = correctToGenericsSpecRecurse(methodGenericsSpec, originType);\n                    Parameter newParam = new Parameter(fixedType, \"arg\" + i);\n                    List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n                    List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n                    GeneralUtils.copyAnnotatedNodeAnnotations(parameter, copied, notCopied);\n                    newParam.addAnnotations(copied);\n                    params[i - 1] = newParam;\n                    origParams[i-1] = parameter;\n                    argList.addExpression(new VariableExpression(params[i - 1]));\n                }\n                createForwarderMethod(trait, cNode, methodNode, originalMethod, helperClassNode, methodGenericsSpec, helperMethodParams, origParams, params, argList);\n            }\n        }\n        cNode.addObjectInitializerStatements(new ExpressionStatement(\n                new MethodCallExpression(\n                        new ClassExpression(helperClassNode),\n                        Traits.INIT_METHOD,\n                        new ArgumentListExpression(new VariableExpression(\"this\")))\n        ));\n        cNode.addStaticInitializerStatements(Collections.<Statement>singletonList(new ExpressionStatement(\n                new MethodCallExpression(\n                        new ClassExpression(helperClassNode),\n                        Traits.STATIC_INIT_METHOD,\n                        new ArgumentListExpression(new VariableExpression(\"this\")))\n        )), false);\n        if (fieldHelperClassNode != null && !cNode.declaresInterface(fieldHelperClassNode)) {\n            // we should implement the field helper interface too\n            cNode.addInterface(fieldHelperClassNode);\n            // implementation of methods\n            List<MethodNode> declaredMethods = fieldHelperClassNode.getAllDeclaredMethods();\n            Collections.sort(declaredMethods, GETTER_FIRST_COMPARATOR);\n            for (MethodNode methodNode : declaredMethods) {\n                String fieldName = methodNode.getName();\n                if (fieldName.endsWith(Traits.DIRECT_GETTER_SUFFIX) || fieldName.endsWith(Traits.DIRECT_SETTER_SUFFIX)) {\n                    int suffixIdx = fieldName.lastIndexOf(\"$\");\n                    fieldName = fieldName.substring(0, suffixIdx);\n                    String operation = methodNode.getName().substring(suffixIdx + 1);\n                    boolean getter = \"get\".equals(operation);\n                    ClassNode returnType = correctToGenericsSpecRecurse(genericsSpec, methodNode.getReturnType());\n                    int isStatic = 0;\n                    boolean publicField = true;\n                    FieldNode helperField = fieldHelperClassNode.getField(Traits.FIELD_PREFIX + Traits.PUBLIC_FIELD_PREFIX + fieldName);\n                    if (helperField==null) {\n                        publicField = false;\n                        helperField = fieldHelperClassNode.getField(Traits.FIELD_PREFIX + Traits.PRIVATE_FIELD_PREFIX + fieldName);\n                    }\n                    if (helperField==null) {\n                        publicField = true;\n                        // try to find a static one\n                        helperField = fieldHelperClassNode.getField(Traits.STATIC_FIELD_PREFIX+Traits.PUBLIC_FIELD_PREFIX+fieldName);\n                        if (helperField==null) {\n                            publicField = false;\n                            helperField = fieldHelperClassNode.getField(Traits.STATIC_FIELD_PREFIX+Traits.PRIVATE_FIELD_PREFIX +fieldName);\n                        }\n                        isStatic = Opcodes.ACC_STATIC;\n                    }\n                    if (getter) {\n                        // add field\n                        if (helperField!=null) {\n                            List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n                            List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n                            GeneralUtils.copyAnnotatedNodeAnnotations(helperField, copied, notCopied);\n                            FieldNode fieldNode = cNode.addField(fieldName, (publicField?Opcodes.ACC_PUBLIC:Opcodes.ACC_PRIVATE) | isStatic, returnType, null);\n                            fieldNode.addAnnotations(copied);\n                        }\n                    }\n                    Parameter[] newParams;\n                    if (getter) {\n                        newParams = Parameter.EMPTY_ARRAY;\n                    } else {\n                        ClassNode originType = methodNode.getParameters()[0].getOriginType();\n                        ClassNode fixedType = originType.isGenericsPlaceHolder()?ClassHelper.OBJECT_TYPE:correctToGenericsSpecRecurse(genericsSpec, originType);\n                        newParams = new Parameter[]{new Parameter(fixedType, \"val\")};\n                    }\n\n                    Expression fieldExpr = new VariableExpression(cNode.getField(fieldName));\n                    Statement body =\n                            getter ? new ReturnStatement(fieldExpr) :\n                                    new ExpressionStatement(\n                                            new BinaryExpression(\n                                                    fieldExpr,\n                                                    Token.newSymbol(Types.EQUAL, 0, 0),\n                                                    new VariableExpression(newParams[0])\n                                            )\n                                    );\n                    MethodNode impl = new MethodNode(\n                            methodNode.getName(),\n                            Opcodes.ACC_PUBLIC | isStatic,\n                            returnType,\n                            newParams,\n                            ClassNode.EMPTY_ARRAY,\n                            body\n                    );\n                    impl.addAnnotation(new AnnotationNode(COMPILESTATIC_CLASSNODE));\n                    cNode.addMethod(impl);\n                }\n            }\n        }\n    }",
            " 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188 +\n 189 +\n 190 +\n 191 +\n 192 +\n 193 +\n 194 +\n 195 +\n 196 +\n 197  \n 198 +\n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268 +\n 269 +\n 270 +\n 271  \n 272  \n 273  \n 274  \n 275  ",
            "    private static void applyTrait(final ClassNode trait, final ClassNode cNode, final TraitHelpersTuple helpers) {\n        ClassNode helperClassNode = helpers.getHelper();\n        ClassNode fieldHelperClassNode = helpers.getFieldHelper();\n        Map<String,ClassNode> genericsSpec = GenericsUtils.createGenericsSpec(cNode);\n        genericsSpec = GenericsUtils.createGenericsSpec(trait, genericsSpec);\n\n        for (MethodNode methodNode : helperClassNode.getAllDeclaredMethods()) {\n            String name = methodNode.getName();\n            Parameter[] helperMethodParams = methodNode.getParameters();\n            boolean isAbstract = methodNode.isAbstract();\n            if (!isAbstract && helperMethodParams.length > 0 && ((methodNode.getModifiers() & Opcodes.ACC_STATIC) == Opcodes.ACC_STATIC) && !name.contains(\"$\")) {\n                ArgumentListExpression argList = new ArgumentListExpression();\n                argList.addExpression(new VariableExpression(\"this\"));\n                Parameter[] origParams = new Parameter[helperMethodParams.length - 1];\n                Parameter[] params = new Parameter[helperMethodParams.length - 1];\n                System.arraycopy(methodNode.getParameters(), 1, params, 0, params.length);\n                Map<String,ClassNode> methodGenericsSpec = new LinkedHashMap<String, ClassNode>(genericsSpec);\n                MethodNode originalMethod = trait.getMethod(name, params);\n                // Original method may be null in case of a private method\n                GenericsType[] originalMethodGenericsTypes = originalMethod!=null?originalMethod.getGenericsTypes():null;\n                if (originalMethodGenericsTypes!=null) {\n                    for (GenericsType type : originalMethodGenericsTypes) {\n                        String gtTypeName = type.getName();\n                        if (!methodGenericsSpec.containsKey(gtTypeName)) {\n                            methodGenericsSpec.put(gtTypeName, type.getType());\n                        }\n                    }\n                }\n                for (int i = 1; i < helperMethodParams.length; i++) {\n                    Parameter parameter = helperMethodParams[i];\n                    ClassNode originType = parameter.getOriginType();\n                    ClassNode fixedType = correctToGenericsSpecRecurse(methodGenericsSpec, originType);\n                    Parameter newParam = new Parameter(fixedType, \"arg\" + i);\n                    List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n                    List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n                    GeneralUtils.copyAnnotatedNodeAnnotations(parameter, copied, notCopied);\n                    newParam.addAnnotations(copied);\n                    params[i - 1] = newParam;\n                    origParams[i-1] = parameter;\n                    argList.addExpression(new VariableExpression(params[i - 1]));\n                }\n                createForwarderMethod(trait, cNode, methodNode, originalMethod, helperClassNode, methodGenericsSpec, helperMethodParams, origParams, params, argList);\n            }\n        }\n        cNode.addObjectInitializerStatements(new ExpressionStatement(\n                new MethodCallExpression(\n                        new ClassExpression(helperClassNode),\n                        Traits.INIT_METHOD,\n                        new ArgumentListExpression(new VariableExpression(\"this\")))\n        ));\n        MethodCallExpression staticInitCall = new MethodCallExpression(\n                new ClassExpression(helperClassNode),\n                Traits.STATIC_INIT_METHOD,\n                new ArgumentListExpression(new ClassExpression(cNode)));\n        MethodNode staticInitMethod = new MethodNode(\n                Traits.STATIC_INIT_METHOD, Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC, ClassHelper.VOID_TYPE,\n                new Parameter[] {new Parameter(ClassHelper.CLASS_Type,\"clazz\")}, ClassNode.EMPTY_ARRAY, EmptyStatement.INSTANCE);\n        staticInitMethod.setDeclaringClass(helperClassNode);\n        staticInitCall.setMethodTarget(staticInitMethod);\n        cNode.addStaticInitializerStatements(Collections.<Statement>singletonList(new ExpressionStatement(\n                staticInitCall\n        )), false);\n        if (fieldHelperClassNode != null && !cNode.declaresInterface(fieldHelperClassNode)) {\n            // we should implement the field helper interface too\n            cNode.addInterface(fieldHelperClassNode);\n            // implementation of methods\n            List<MethodNode> declaredMethods = fieldHelperClassNode.getAllDeclaredMethods();\n            Collections.sort(declaredMethods, GETTER_FIRST_COMPARATOR);\n            for (MethodNode methodNode : declaredMethods) {\n                String fieldName = methodNode.getName();\n                if (fieldName.endsWith(Traits.DIRECT_GETTER_SUFFIX) || fieldName.endsWith(Traits.DIRECT_SETTER_SUFFIX)) {\n                    int suffixIdx = fieldName.lastIndexOf(\"$\");\n                    fieldName = fieldName.substring(0, suffixIdx);\n                    String operation = methodNode.getName().substring(suffixIdx + 1);\n                    boolean getter = \"get\".equals(operation);\n                    ClassNode returnType = correctToGenericsSpecRecurse(genericsSpec, methodNode.getReturnType());\n                    int isStatic = 0;\n                    boolean publicField = true;\n                    FieldNode helperField = fieldHelperClassNode.getField(Traits.FIELD_PREFIX + Traits.PUBLIC_FIELD_PREFIX + fieldName);\n                    if (helperField==null) {\n                        publicField = false;\n                        helperField = fieldHelperClassNode.getField(Traits.FIELD_PREFIX + Traits.PRIVATE_FIELD_PREFIX + fieldName);\n                    }\n                    if (helperField==null) {\n                        publicField = true;\n                        // try to find a static one\n                        helperField = fieldHelperClassNode.getField(Traits.STATIC_FIELD_PREFIX+Traits.PUBLIC_FIELD_PREFIX+fieldName);\n                        if (helperField==null) {\n                            publicField = false;\n                            helperField = fieldHelperClassNode.getField(Traits.STATIC_FIELD_PREFIX+Traits.PRIVATE_FIELD_PREFIX +fieldName);\n                        }\n                        isStatic = Opcodes.ACC_STATIC;\n                    }\n                    if (getter) {\n                        // add field\n                        if (helperField!=null) {\n                            List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n                            List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n                            GeneralUtils.copyAnnotatedNodeAnnotations(helperField, copied, notCopied);\n                            FieldNode fieldNode = cNode.addField(fieldName, (publicField?Opcodes.ACC_PUBLIC:Opcodes.ACC_PRIVATE) | isStatic, returnType, null);\n                            fieldNode.addAnnotations(copied);\n                        }\n                    }\n                    Parameter[] newParams;\n                    if (getter) {\n                        newParams = Parameter.EMPTY_ARRAY;\n                    } else {\n                        ClassNode originType = methodNode.getParameters()[0].getOriginType();\n                        ClassNode fixedType = originType.isGenericsPlaceHolder()?ClassHelper.OBJECT_TYPE:correctToGenericsSpecRecurse(genericsSpec, originType);\n                        newParams = new Parameter[]{new Parameter(fixedType, \"val\")};\n                    }\n\n                    Expression fieldExpr = new VariableExpression(cNode.getField(fieldName));\n                    Statement body =\n                            getter ? new ReturnStatement(fieldExpr) :\n                                    new ExpressionStatement(\n                                            new BinaryExpression(\n                                                    fieldExpr,\n                                                    Token.newSymbol(Types.EQUAL, 0, 0),\n                                                    new VariableExpression(newParams[0])\n                                            )\n                                    );\n                    MethodNode impl = new MethodNode(\n                            methodNode.getName(),\n                            Opcodes.ACC_PUBLIC | isStatic,\n                            returnType,\n                            newParams,\n                            ClassNode.EMPTY_ARRAY,\n                            body\n                    );\n                    AnnotationNode an = new AnnotationNode(COMPILESTATIC_CLASSNODE);\n                    impl.addAnnotation(an);\n                    cNode.addTransform(StaticCompileTransformation.class, an);\n                    cNode.addMethod(impl);\n                }\n            }\n        }\n    }"
        ],
        [
            "TraitASTTransformation::createInitMethod(boolean,ClassNode,ClassNode)",
            " 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  ",
            "    private MethodNode createInitMethod(final boolean isStatic, final ClassNode cNode, final ClassNode helper) {\n        MethodNode initializer = new MethodNode(\n                isStatic?Traits.STATIC_INIT_METHOD:Traits.INIT_METHOD,\n                ACC_STATIC | ACC_PUBLIC | ACC_SYNTHETIC,\n                ClassHelper.VOID_TYPE,\n                new Parameter[]{createSelfParameter(cNode, isStatic)},\n                ClassNode.EMPTY_ARRAY,\n                new BlockStatement()\n        );\n        fixGenerics(initializer, cNode);\n        helper.addMethod(initializer);\n        return initializer;\n    }",
            " 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230 +\n 231 +\n 232 +\n 233 +\n 234  \n 235  ",
            "    private MethodNode createInitMethod(final boolean isStatic, final ClassNode cNode, final ClassNode helper) {\n        MethodNode initializer = new MethodNode(\n                isStatic?Traits.STATIC_INIT_METHOD:Traits.INIT_METHOD,\n                ACC_STATIC | ACC_PUBLIC | ACC_SYNTHETIC,\n                ClassHelper.VOID_TYPE,\n                new Parameter[]{createSelfParameter(cNode, isStatic)},\n                ClassNode.EMPTY_ARRAY,\n                new BlockStatement()\n        );\n        fixGenerics(initializer, cNode);\n        helper.addMethod(initializer);\n        AnnotationNode an = new AnnotationNode(TraitComposer.COMPILESTATIC_CLASSNODE);\n        initializer.addAnnotation(an);\n        cNode.addTransform(StaticCompileTransformation.class, an);\n\n        return initializer;\n    }"
        ],
        [
            "Verifier::moveOptimizedConstantsInitialization(ClassNode)",
            "1403  \n1404 -\n1405  \n1406  \n1407  \n1408  \n1409  \n1410  \n1411  \n1412  \n1413  \n1414  \n1415  \n1416  \n1417  \n1418  \n1419  \n1420  \n1421  \n1422  \n1423  \n1424  \n1425  \n1426  \n1427  \n1428  \n1429  \n1430  \n1431  \n1432  \n1433  \n1434  \n1435  \n1436  \n1437  ",
            "    private boolean moveOptimizedConstantsInitialization(final ClassNode node) {\n        if (node.isInterface()) return false;\n\n        final int mods = Opcodes.ACC_STATIC|Opcodes.ACC_SYNTHETIC| Opcodes.ACC_PUBLIC;\n        String name = SWAP_INIT;\n        BlockStatement methodCode = new BlockStatement();\n\n        methodCode.addStatement(new SwapInitStatement());\n        boolean swapInitRequired = false;\n        for (FieldNode fn : node.getFields()) {\n            if (!fn.isStatic() || !fn.isSynthetic() || !fn.getName().startsWith(\"$const$\")) continue;\n            if (fn.getInitialExpression()==null) continue;\n            final FieldExpression fe = new FieldExpression(fn);\n            if (fn.getType().equals(ClassHelper.REFERENCE_TYPE)) fe.setUseReferenceDirectly(true);\n            ConstantExpression init = (ConstantExpression) fn.getInitialExpression();\n            ExpressionStatement statement =\n                    new ExpressionStatement(\n                            new BinaryExpression(\n                                    fe,\n                                    Token.newSymbol(Types.EQUAL, fn.getLineNumber(), fn.getColumnNumber()),\n                                    init));\n            fn.setInitialValueExpression(null);\n            init.setConstantName(null);\n            methodCode.addStatement(statement);\n            swapInitRequired = true;\n        }\n\n        if (swapInitRequired) {\n            node.addSyntheticMethod(\n                    name, mods, ClassHelper.VOID_TYPE,\n                    Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, methodCode);\n        }\n\n        return swapInitRequired;\n    }",
            "1405  \n1406 +\n1407  \n1408  \n1409  \n1410  \n1411  \n1412  \n1413  \n1414  \n1415  \n1416  \n1417  \n1418  \n1419  \n1420  \n1421  \n1422  \n1423  \n1424  \n1425  \n1426  \n1427  \n1428  \n1429  \n1430  \n1431  \n1432  \n1433  \n1434  \n1435  \n1436  \n1437  \n1438  \n1439  ",
            "    private boolean moveOptimizedConstantsInitialization(final ClassNode node) {\n        if (node.isInterface() && !Traits.isTrait(node)) return false;\n\n        final int mods = Opcodes.ACC_STATIC|Opcodes.ACC_SYNTHETIC| Opcodes.ACC_PUBLIC;\n        String name = SWAP_INIT;\n        BlockStatement methodCode = new BlockStatement();\n\n        methodCode.addStatement(new SwapInitStatement());\n        boolean swapInitRequired = false;\n        for (FieldNode fn : node.getFields()) {\n            if (!fn.isStatic() || !fn.isSynthetic() || !fn.getName().startsWith(\"$const$\")) continue;\n            if (fn.getInitialExpression()==null) continue;\n            final FieldExpression fe = new FieldExpression(fn);\n            if (fn.getType().equals(ClassHelper.REFERENCE_TYPE)) fe.setUseReferenceDirectly(true);\n            ConstantExpression init = (ConstantExpression) fn.getInitialExpression();\n            ExpressionStatement statement =\n                    new ExpressionStatement(\n                            new BinaryExpression(\n                                    fe,\n                                    Token.newSymbol(Types.EQUAL, fn.getLineNumber(), fn.getColumnNumber()),\n                                    init));\n            fn.setInitialValueExpression(null);\n            init.setConstantName(null);\n            methodCode.addStatement(statement);\n            swapInitRequired = true;\n        }\n\n        if (swapInitRequired) {\n            node.addSyntheticMethod(\n                    name, mods, ClassHelper.VOID_TYPE,\n                    Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, methodCode);\n        }\n\n        return swapInitRequired;\n    }"
        ],
        [
            "TraitASTTransformation::processField(FieldNode,MethodNode,MethodNode,ClassNode,ClassNode,Set)",
            " 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360 -\n 361 -\n 362 -\n 363 -\n 364 -\n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405  ",
            "    private void processField(final FieldNode field, final MethodNode initializer, final MethodNode staticInitializer, final ClassNode fieldHelper, final ClassNode trait, final Set<String> knownFields) {\n        Expression initialExpression = field.getInitialExpression();\n        MethodNode selectedMethod = field.isStatic()?staticInitializer:initializer;\n        if (initialExpression != null) {\n            VariableExpression thisObject = new VariableExpression(selectedMethod.getParameters()[0]);\n            ExpressionStatement initCode = new ExpressionStatement(initialExpression);\n            processBody(thisObject, selectedMethod, initCode, trait, fieldHelper, knownFields);\n            BlockStatement code = (BlockStatement) selectedMethod.getCode();\n            MethodCallExpression mce = new MethodCallExpression(\n                    new CastExpression(createReceiverType(field.isStatic(), fieldHelper), thisObject),\n                    Traits.helperSetterName(field),\n                    initCode.getExpression()\n            );\n            mce.setImplicitThis(false);\n            mce.setSourcePosition(initialExpression);\n            code.addStatement(new ExpressionStatement(mce));\n        }\n        // define setter/getter helper methods\n        fieldHelper.addMethod(\n                Traits.helperSetterName(field),\n                ACC_PUBLIC | ACC_ABSTRACT,\n                field.getOriginType(),\n                new Parameter[]{new Parameter(field.getOriginType(), \"val\")},\n                ClassNode.EMPTY_ARRAY,\n                null\n        );\n        fieldHelper.addMethod(\n                Traits.helperGetterName(field),\n                ACC_PUBLIC | ACC_ABSTRACT,\n                field.getOriginType(),\n                Parameter.EMPTY_ARRAY,\n                ClassNode.EMPTY_ARRAY,\n                null\n        );\n\n        // dummy fields are only used to carry annotations if instance field\n        // and to differentiate from static fields otherwise\n        String dummyFieldName = (field.isStatic() ? Traits.STATIC_FIELD_PREFIX : Traits.FIELD_PREFIX) +\n                (field.isPublic()? Traits.PUBLIC_FIELD_PREFIX : Traits.PRIVATE_FIELD_PREFIX)+\n                Traits.remappedFieldName(field.getOwner(), field.getName());\n        FieldNode dummyField = new FieldNode(\n                dummyFieldName,\n                ACC_STATIC | ACC_PUBLIC | ACC_FINAL | ACC_SYNTHETIC,\n                field.getOriginType(),\n                fieldHelper,\n                null\n        );\n        // copy annotations from field to dummy field\n        List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n        List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n        GeneralUtils.copyAnnotatedNodeAnnotations(field, copied, notCopied);\n        dummyField.addAnnotations(copied);\n        fieldHelper.addField(dummyField);\n    }",
            " 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371 +\n 372 +\n 373 +\n 374 +\n 375 +\n 376 +\n 377 +\n 378 +\n 379 +\n 380 +\n 381 +\n 382 +\n 383 +\n 384 +\n 385 +\n 386 +\n 387 +\n 388 +\n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  \n 423  \n 424  \n 425  \n 426  \n 427  \n 428  \n 429  ",
            "    private void processField(final FieldNode field, final MethodNode initializer, final MethodNode staticInitializer, final ClassNode fieldHelper, final ClassNode trait, final Set<String> knownFields) {\n        Expression initialExpression = field.getInitialExpression();\n        MethodNode selectedMethod = field.isStatic()?staticInitializer:initializer;\n        if (initialExpression != null) {\n            VariableExpression thisObject = new VariableExpression(selectedMethod.getParameters()[0]);\n            ExpressionStatement initCode = new ExpressionStatement(initialExpression);\n            processBody(thisObject, selectedMethod, initCode, trait, fieldHelper, knownFields);\n            BlockStatement code = (BlockStatement) selectedMethod.getCode();\n            MethodCallExpression mce;\n            if (field.isStatic()) {\n                mce = new MethodCallExpression(\n                        new ClassExpression(INVOKERHELPER_CLASSNODE),\n                        \"invokeStaticMethod\",\n                        new ArgumentListExpression(\n                                thisObject,\n                                new ConstantExpression(Traits.helperSetterName(field)),\n                                initCode.getExpression()\n                        )\n                );\n            } else {\n                mce = new MethodCallExpression(\n                        new CastExpression(createReceiverType(field.isStatic(), fieldHelper), thisObject),\n                        Traits.helperSetterName(field),\n                        initCode.getExpression()\n                );\n            }\n            mce.setImplicitThis(false);\n            mce.setSourcePosition(initialExpression);\n            code.addStatement(new ExpressionStatement(mce));\n        }\n        // define setter/getter helper methods\n        fieldHelper.addMethod(\n                Traits.helperSetterName(field),\n                ACC_PUBLIC | ACC_ABSTRACT,\n                field.getOriginType(),\n                new Parameter[]{new Parameter(field.getOriginType(), \"val\")},\n                ClassNode.EMPTY_ARRAY,\n                null\n        );\n        fieldHelper.addMethod(\n                Traits.helperGetterName(field),\n                ACC_PUBLIC | ACC_ABSTRACT,\n                field.getOriginType(),\n                Parameter.EMPTY_ARRAY,\n                ClassNode.EMPTY_ARRAY,\n                null\n        );\n\n        // dummy fields are only used to carry annotations if instance field\n        // and to differentiate from static fields otherwise\n        String dummyFieldName = (field.isStatic() ? Traits.STATIC_FIELD_PREFIX : Traits.FIELD_PREFIX) +\n                (field.isPublic()? Traits.PUBLIC_FIELD_PREFIX : Traits.PRIVATE_FIELD_PREFIX)+\n                Traits.remappedFieldName(field.getOwner(), field.getName());\n        FieldNode dummyField = new FieldNode(\n                dummyFieldName,\n                ACC_STATIC | ACC_PUBLIC | ACC_FINAL | ACC_SYNTHETIC,\n                field.getOriginType(),\n                fieldHelper,\n                null\n        );\n        // copy annotations from field to dummy field\n        List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n        List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n        GeneralUtils.copyAnnotatedNodeAnnotations(field, copied, notCopied);\n        dummyField.addAnnotations(copied);\n        fieldHelper.addField(dummyField);\n    }"
        ]
    ],
    "da41632bf05527d7860d0790e762c383ab9c2270": [
        [
            "MetaClassImpl::connectMultimethods(List,CachedClass)",
            " 632 -\n 633  \n 634  \n 635 -\n 636 -\n 637  \n 638  \n 639  \n 640  \n 641  \n 642  \n 643  \n 644  \n 645  \n 646  \n 647 -\n 648  \n 649  ",
            "    private void connectMultimethods(List superClasses, CachedClass firstGroovyClass) {\n        superClasses = DefaultGroovyMethods.reverse(superClasses);\n        MetaMethodIndex.Header last = null;\n        for (Iterator iter = superClasses.iterator(); iter.hasNext();) {\n            CachedClass c = (CachedClass) iter.next();\n            MetaMethodIndex.Header methodIndex = metaMethodIndex.getHeader(c.getTheClass());\n            // We don't copy DGM methods to superclasses' indexes\n            // The reason we can do that is particular set of DGM methods in use,\n            // if at some point we will define DGM method for some Groovy class or\n            // for a class derived from such, we will need to revise this condition.\n            // It saves us a lot of space and some noticeable time\n            if (last != null) metaMethodIndex.copyNonPrivateNonNewMetaMethods(last, methodIndex);\n            last = methodIndex;\n\n            if (c == firstGroovyClass)\n              break;\n        }\n    }",
            " 632 +\n 633  \n 634  \n 635 +\n 636  \n 637  \n 638  \n 639  \n 640  \n 641  \n 642  \n 643  \n 644  \n 645  \n 646 +\n 647  \n 648  ",
            "    private void connectMultimethods(List<CachedClass> superClasses, CachedClass firstGroovyClass) {\n        superClasses = DefaultGroovyMethods.reverse(superClasses);\n        MetaMethodIndex.Header last = null;\n        for (final CachedClass c : superClasses) {\n            MetaMethodIndex.Header methodIndex = metaMethodIndex.getHeader(c.getTheClass());\n            // We don't copy DGM methods to superclasses' indexes\n            // The reason we can do that is particular set of DGM methods in use,\n            // if at some point we will define DGM method for some Groovy class or\n            // for a class derived from such, we will need to revise this condition.\n            // It saves us a lot of space and some noticeable time\n            if (last != null) metaMethodIndex.copyNonPrivateNonNewMetaMethods(last, methodIndex);\n            last = methodIndex;\n\n            if (c == firstGroovyClass)\n                break;\n        }\n    }"
        ],
        [
            "ExpandoMetaClass::registerBeanPropertyForMethod(MetaMethod,String,boolean,boolean)",
            " 951  \n 952  \n 953  \n 954  \n 955  \n 956  \n 957  \n 958  \n 959  \n 960  \n 961  \n 962  \n 963  \n 964  \n 965  \n 966  \n 967  \n 968  \n 969  \n 970  \n 971  \n 972  \n 973  \n 974  \n 975  ",
            "    private void registerBeanPropertyForMethod(MetaMethod metaMethod, String propertyName, boolean getter, boolean isStatic) {\n        Map<String, MetaProperty> propertyCache = isStatic ? staticBeanPropertyCache : beanPropertyCache;\n        MetaBeanProperty beanProperty = (MetaBeanProperty) propertyCache.get(propertyName);\n        if (beanProperty == null) {\n            if (getter)\n                beanProperty = new MetaBeanProperty(propertyName, Object.class, metaMethod, null);\n            else\n                beanProperty = new MetaBeanProperty(propertyName, Object.class, null, metaMethod);\n\n            propertyCache.put(propertyName, beanProperty);\n        } else {\n            if (getter) {\n                MetaMethod setterMethod = beanProperty.getSetter();\n                Class type = setterMethod != null ? setterMethod.getParameterTypes()[0].getTheClass() : Object.class;\n                beanProperty = new MetaBeanProperty(propertyName, type, metaMethod, setterMethod);\n                propertyCache.put(propertyName, beanProperty);\n            } else {\n                MetaMethod getterMethod = beanProperty.getGetter();\n                beanProperty = new MetaBeanProperty(propertyName, metaMethod.getParameterTypes()[0].getTheClass(), getterMethod, metaMethod);\n                propertyCache.put(propertyName, beanProperty);\n            }\n        }\n        expandoProperties.put(beanProperty.getName(), beanProperty);\n        addMetaBeanProperty(beanProperty);\n    }",
            " 951  \n 952  \n 953  \n 954 +\n 955 +\n 956 +\n 957 +\n 958 +\n 959 +\n 960  \n 961  \n 962  \n 963  \n 964  \n 965  \n 966  \n 967  \n 968  \n 969  \n 970  \n 971  \n 972  \n 973  \n 974  \n 975  \n 976  \n 977  \n 978  \n 979  \n 980  \n 981  ",
            "    private void registerBeanPropertyForMethod(MetaMethod metaMethod, String propertyName, boolean getter, boolean isStatic) {\n        Map<String, MetaProperty> propertyCache = isStatic ? staticBeanPropertyCache : beanPropertyCache;\n        MetaBeanProperty beanProperty = (MetaBeanProperty) propertyCache.get(propertyName);\n        if (beanProperty==null) {\n            MetaProperty metaProperty = super.getMetaProperty(propertyName);\n            if (metaProperty instanceof MetaBeanProperty) {\n                beanProperty = (MetaBeanProperty) metaProperty;\n            }\n        }\n        if (beanProperty == null) {\n            if (getter)\n                beanProperty = new MetaBeanProperty(propertyName, Object.class, metaMethod, null);\n            else\n                beanProperty = new MetaBeanProperty(propertyName, Object.class, null, metaMethod);\n\n            propertyCache.put(propertyName, beanProperty);\n        } else {\n            if (getter) {\n                MetaMethod setterMethod = beanProperty.getSetter();\n                Class type = setterMethod != null ? setterMethod.getParameterTypes()[0].getTheClass() : Object.class;\n                beanProperty = new MetaBeanProperty(propertyName, type, metaMethod, setterMethod);\n                propertyCache.put(propertyName, beanProperty);\n            } else {\n                MetaMethod getterMethod = beanProperty.getGetter();\n                beanProperty = new MetaBeanProperty(propertyName, metaMethod.getParameterTypes()[0].getTheClass(), getterMethod, metaMethod);\n                propertyCache.put(propertyName, beanProperty);\n            }\n        }\n        expandoProperties.put(beanProperty.getName(), beanProperty);\n        addMetaBeanProperty(beanProperty);\n    }"
        ],
        [
            "MetaClassImpl::populateMethods(LinkedList,CachedClass)",
            " 351 -\n 352 -\n 353  \n 354  \n 355  \n 356  \n 357 -\n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380 -\n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  ",
            "    private void populateMethods(LinkedList superClasses, CachedClass firstGroovySuper) {\n        Iterator iter = superClasses.iterator();\n\n        MetaMethodIndex.Header header = metaMethodIndex.getHeader(firstGroovySuper.getTheClass());\n        CachedClass c;\n        for (; iter.hasNext();) {\n            c = (CachedClass) iter.next();\n\n            CachedMethod[] cachedMethods = c.getMethods();\n            for (CachedMethod metaMethod : cachedMethods) {\n                addToAllMethodsIfPublic(metaMethod);\n                if (!metaMethod.isPrivate() || c == firstGroovySuper)\n                    addMetaMethodToIndex(metaMethod, header);\n            }\n\n            MetaMethod[] cachedMethods1 = getNewMetaMethods(c);\n            for (final MetaMethod method : cachedMethods1) {\n                if (!newGroovyMethodsSet.contains(method)) {\n                    newGroovyMethodsSet.add(method);\n                    addMetaMethodToIndex(method, header);\n                }\n            }\n\n            if (c == firstGroovySuper)\n              break;\n        }\n\n        MetaMethodIndex.Header last = header;\n        for (;iter.hasNext();) {\n            c = (CachedClass) iter.next();\n            header = metaMethodIndex.getHeader(c.getTheClass());\n\n            if (last != null) {\n                metaMethodIndex.copyNonPrivateMethods(last, header);\n            }\n            last = header;\n\n            for (CachedMethod metaMethod : c.getMethods()) {\n                addToAllMethodsIfPublic(metaMethod);\n                addMetaMethodToIndex(metaMethod, header);\n            }\n\n            for (final MetaMethod method : getNewMetaMethods(c)) {\n                if (method.getName().equals(\"<init>\") && !method.getDeclaringClass().equals(theCachedClass)) continue;\n                if (!newGroovyMethodsSet.contains(method)) {\n                    newGroovyMethodsSet.add(method);\n                    addMetaMethodToIndex(method, header);\n                }\n            }\n        }\n    }",
            " 351 +\n 352  \n 353  \n 354  \n 355 +\n 356  \n 357 +\n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380 +\n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  ",
            "    private void populateMethods(LinkedList<CachedClass> superClasses, CachedClass firstGroovySuper) {\n\n        MetaMethodIndex.Header header = metaMethodIndex.getHeader(firstGroovySuper.getTheClass());\n        CachedClass c;\n        Iterator<CachedClass> iter = superClasses.iterator();\n        for (; iter.hasNext();) {\n            c = iter.next();\n\n            CachedMethod[] cachedMethods = c.getMethods();\n            for (CachedMethod metaMethod : cachedMethods) {\n                addToAllMethodsIfPublic(metaMethod);\n                if (!metaMethod.isPrivate() || c == firstGroovySuper)\n                    addMetaMethodToIndex(metaMethod, header);\n            }\n\n            MetaMethod[] cachedMethods1 = getNewMetaMethods(c);\n            for (final MetaMethod method : cachedMethods1) {\n                if (!newGroovyMethodsSet.contains(method)) {\n                    newGroovyMethodsSet.add(method);\n                    addMetaMethodToIndex(method, header);\n                }\n            }\n\n            if (c == firstGroovySuper)\n              break;\n        }\n\n        MetaMethodIndex.Header last = header;\n        for (;iter.hasNext();) {\n            c = iter.next();\n            header = metaMethodIndex.getHeader(c.getTheClass());\n\n            if (last != null) {\n                metaMethodIndex.copyNonPrivateMethods(last, header);\n            }\n            last = header;\n\n            for (CachedMethod metaMethod : c.getMethods()) {\n                addToAllMethodsIfPublic(metaMethod);\n                addMetaMethodToIndex(metaMethod, header);\n            }\n\n            for (final MetaMethod method : getNewMetaMethods(c)) {\n                if (method.getName().equals(\"<init>\") && !method.getDeclaringClass().equals(theCachedClass)) continue;\n                if (!newGroovyMethodsSet.contains(method)) {\n                    newGroovyMethodsSet.add(method);\n                    addMetaMethodToIndex(method, header);\n                }\n            }\n        }\n    }"
        ],
        [
            "MetaClassImpl::fillMethodIndex()",
            " 327  \n 328  \n 329  \n 330  \n 331  \n 332 -\n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344  \n 345  \n 346  \n 347  \n 348  \n 349  ",
            "    /**\n     * Fills the method index\n     */\n    private void fillMethodIndex() {\n        mainClassMethodHeader = metaMethodIndex.getHeader(theClass);\n        LinkedList superClasses = getSuperClasses();\n        CachedClass firstGroovySuper = calcFirstGroovySuperClass(superClasses);\n\n        Set<CachedClass> interfaces = theCachedClass.getInterfaces();\n        addInterfaceMethods(interfaces);\n\n        populateMethods(superClasses, firstGroovySuper);\n\n        inheritInterfaceNewMetaMethods(interfaces);\n        if (isGroovyObject) {\n          metaMethodIndex.copyMethodsToSuper();\n\n          connectMultimethods(superClasses, firstGroovySuper);\n          removeMultimethodsOverloadedWithPrivateMethods();\n\n          replaceWithMOPCalls(theCachedClass.mopMethods);\n        }\n    }",
            " 327  \n 328  \n 329  \n 330  \n 331  \n 332 +\n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344  \n 345  \n 346  \n 347  \n 348  \n 349  ",
            "    /**\n     * Fills the method index\n     */\n    private void fillMethodIndex() {\n        mainClassMethodHeader = metaMethodIndex.getHeader(theClass);\n        LinkedList<CachedClass> superClasses = getSuperClasses();\n        CachedClass firstGroovySuper = calcFirstGroovySuperClass(superClasses);\n\n        Set<CachedClass> interfaces = theCachedClass.getInterfaces();\n        addInterfaceMethods(interfaces);\n\n        populateMethods(superClasses, firstGroovySuper);\n\n        inheritInterfaceNewMetaMethods(interfaces);\n        if (isGroovyObject) {\n          metaMethodIndex.copyMethodsToSuper();\n\n          connectMultimethods(superClasses, firstGroovySuper);\n          removeMultimethodsOverloadedWithPrivateMethods();\n\n          replaceWithMOPCalls(theCachedClass.mopMethods);\n        }\n    }"
        ]
    ],
    "272cf4f36bc0a0af2d52faa4a34d033c20fbdc25": [
        [
            "JavaStubGenerator::printImports(PrintWriter,ClassNode)",
            " 909  \n 910  \n 911  \n 912  \n 913  \n 914  \n 915  \n 916  \n 917  \n 918  \n 919  \n 920  \n 921  \n 922  \n 923  \n 924  \n 925  \n 926  \n 927  \n 928  \n 929  \n 930  \n 931  \n 932  \n 933  \n 934  ",
            "    private void printImports(PrintWriter out, ClassNode classNode) {\n        List<String> imports = new ArrayList<String>();\n\n        ModuleNode moduleNode = classNode.getModule();\n        for (ImportNode importNode : moduleNode.getStarImports()) {\n            imports.add(importNode.getPackageName());\n        }\n\n        for (ImportNode imp : moduleNode.getImports()) {\n            if (imp.getAlias() == null)\n                imports.add(imp.getType().getName());\n        }\n\n        imports.addAll(Arrays.asList(ResolveVisitor.DEFAULT_IMPORTS));\n\n        for (String imp : imports) {\n            String s = new StringBuilder()\n                    .append(\"import \")\n                    .append(imp)\n                    .append((imp.charAt(imp.length() - 1) == '.') ? \"*;\" : \";\")\n                    .toString()\n                    .replace('$', '.');\n            out.println(s);\n        }\n        out.println();\n    }",
            " 909  \n 910  \n 911  \n 912  \n 913  \n 914  \n 915  \n 916  \n 917  \n 918  \n 919  \n 920  \n 921  \n 922  \n 923  \n 924 +\n 925 +\n 926 +\n 927 +\n 928 +\n 929 +\n 930 +\n 931 +\n 932  \n 933  \n 934  \n 935  \n 936  \n 937  \n 938  \n 939  \n 940  \n 941  \n 942  ",
            "    private void printImports(PrintWriter out, ClassNode classNode) {\n        List<String> imports = new ArrayList<String>();\n\n        ModuleNode moduleNode = classNode.getModule();\n        for (ImportNode importNode : moduleNode.getStarImports()) {\n            imports.add(importNode.getPackageName());\n        }\n\n        for (ImportNode imp : moduleNode.getImports()) {\n            if (imp.getAlias() == null)\n                imports.add(imp.getType().getName());\n        }\n\n        imports.addAll(Arrays.asList(ResolveVisitor.DEFAULT_IMPORTS));\n\n        for (Map.Entry<String, ImportNode> entry : moduleNode.getStaticImports().entrySet()) {\n            imports.add(\"static \"+entry.getValue().getType().getName()+\".\"+entry.getKey());\n        }\n\n        for (Map.Entry<String, ImportNode> entry : moduleNode.getStaticStarImports().entrySet()) {\n            imports.add(\"static \"+entry.getValue().getType().getName()+\".\");\n        }\n\n        for (String imp : imports) {\n            String s = new StringBuilder()\n                    .append(\"import \")\n                    .append(imp)\n                    .append((imp.charAt(imp.length() - 1) == '.') ? \"*;\" : \";\")\n                    .toString()\n                    .replace('$', '.');\n            out.println(s);\n        }\n        out.println();\n    }"
        ]
    ],
    "eb1a2b029278b707a2a989ddfaf3cd8b800888d2": [
        [
            "TraitASTTransformation::processField(FieldNode,MethodNode,MethodNode,ClassNode,ClassNode,Set)",
            " 388  \n 389  \n 390  \n 391 -\n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419 -\n 420 -\n 421 -\n 422 -\n 423 -\n 424 -\n 425 -\n 426 -\n 427  \n 428  \n 429  \n 430  \n 431  \n 432  \n 433  \n 434  \n 435  \n 436  \n 437  \n 438 -\n 439 -\n 440 -\n 441  \n 442  \n 443  \n 444  \n 445  \n 446 -\n 447  \n 448  \n 449  \n 450  \n 451  \n 452  \n 453  \n 454  ",
            "    private void processField(final FieldNode field, final MethodNode initializer, final MethodNode staticInitializer, final ClassNode fieldHelper, final ClassNode trait, final Set<String> knownFields) {\n        Expression initialExpression = field.getInitialExpression();\n        MethodNode selectedMethod = field.isStatic()?staticInitializer:initializer;\n        if (initialExpression != null) {\n            VariableExpression thisObject = new VariableExpression(selectedMethod.getParameters()[0]);\n            ExpressionStatement initCode = new ExpressionStatement(initialExpression);\n            processBody(thisObject, selectedMethod, initCode, trait, fieldHelper, knownFields);\n            BlockStatement code = (BlockStatement) selectedMethod.getCode();\n            MethodCallExpression mce;\n            if (field.isStatic()) {\n                mce = new MethodCallExpression(\n                        new ClassExpression(INVOKERHELPER_CLASSNODE),\n                        \"invokeStaticMethod\",\n                        new ArgumentListExpression(\n                                thisObject,\n                                new ConstantExpression(Traits.helperSetterName(field)),\n                                initCode.getExpression()\n                        )\n                );\n            } else {\n                mce = new MethodCallExpression(\n                        new CastExpression(createReceiverType(field.isStatic(), fieldHelper), thisObject),\n                        Traits.helperSetterName(field),\n                        new CastExpression(field.getOriginType(),initCode.getExpression())\n                );\n            }\n            mce.setImplicitThis(false);\n            mce.setSourcePosition(initialExpression);\n            code.addStatement(new ExpressionStatement(mce));\n        }\n        // define setter/getter helper methods\n        fieldHelper.addMethod(\n                Traits.helperSetterName(field),\n                ACC_PUBLIC | ACC_ABSTRACT,\n                field.getOriginType(),\n                new Parameter[]{new Parameter(field.getOriginType(), \"val\")},\n                ClassNode.EMPTY_ARRAY,\n                null\n        );\n        fieldHelper.addMethod(\n                Traits.helperGetterName(field),\n                ACC_PUBLIC | ACC_ABSTRACT,\n                field.getOriginType(),\n                Parameter.EMPTY_ARRAY,\n                ClassNode.EMPTY_ARRAY,\n                null\n        );\n\n        // dummy fields are only used to carry annotations if instance field\n        // and to differentiate from static fields otherwise\n        String dummyFieldName = (field.isStatic() ? Traits.STATIC_FIELD_PREFIX : Traits.FIELD_PREFIX) +\n                (field.isPublic()? Traits.PUBLIC_FIELD_PREFIX : Traits.PRIVATE_FIELD_PREFIX)+\n                Traits.remappedFieldName(field.getOwner(), field.getName());\n        FieldNode dummyField = new FieldNode(\n                dummyFieldName,\n                ACC_STATIC | ACC_PUBLIC | ACC_FINAL | ACC_SYNTHETIC,\n                field.getOriginType(),\n                fieldHelper,\n                null\n        );\n        // copy annotations from field to dummy field\n        List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n        List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n        GeneralUtils.copyAnnotatedNodeAnnotations(field, copied, notCopied);\n        dummyField.addAnnotations(copied);\n        fieldHelper.addField(dummyField);\n    }",
            " 388  \n 389  \n 390  \n 391 +\n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419 +\n 420 +\n 421 +\n 422 +\n 423 +\n 424 +\n 425 +\n 426 +\n 427 +\n 428 +\n 429  \n 430  \n 431  \n 432  \n 433  \n 434  \n 435  \n 436  \n 437  \n 438  \n 439  \n 440 +\n 441 +\n 442  \n 443  \n 444  \n 445  \n 446  \n 447 +\n 448  \n 449  \n 450  \n 451  \n 452  \n 453  \n 454  \n 455  ",
            "    private void processField(final FieldNode field, final MethodNode initializer, final MethodNode staticInitializer, final ClassNode fieldHelper, final ClassNode trait, final Set<String> knownFields) {\n        Expression initialExpression = field.getInitialExpression();\n        MethodNode selectedMethod = field.isStatic()?staticInitializer:initializer;\n        if (initialExpression != null && !field.isFinal()) {\n            VariableExpression thisObject = new VariableExpression(selectedMethod.getParameters()[0]);\n            ExpressionStatement initCode = new ExpressionStatement(initialExpression);\n            processBody(thisObject, selectedMethod, initCode, trait, fieldHelper, knownFields);\n            BlockStatement code = (BlockStatement) selectedMethod.getCode();\n            MethodCallExpression mce;\n            if (field.isStatic()) {\n                mce = new MethodCallExpression(\n                        new ClassExpression(INVOKERHELPER_CLASSNODE),\n                        \"invokeStaticMethod\",\n                        new ArgumentListExpression(\n                                thisObject,\n                                new ConstantExpression(Traits.helperSetterName(field)),\n                                initCode.getExpression()\n                        )\n                );\n            } else {\n                mce = new MethodCallExpression(\n                        new CastExpression(createReceiverType(field.isStatic(), fieldHelper), thisObject),\n                        Traits.helperSetterName(field),\n                        new CastExpression(field.getOriginType(),initCode.getExpression())\n                );\n            }\n            mce.setImplicitThis(false);\n            mce.setSourcePosition(initialExpression);\n            code.addStatement(new ExpressionStatement(mce));\n        }\n        // define setter/getter helper methods\n        if (!Modifier.isFinal(field.getModifiers())) {\n            fieldHelper.addMethod(\n                    Traits.helperSetterName(field),\n                    ACC_PUBLIC | ACC_ABSTRACT,\n                    field.getOriginType(),\n                    new Parameter[]{new Parameter(field.getOriginType(), \"val\")},\n                    ClassNode.EMPTY_ARRAY,\n                    null\n            );\n        }\n        fieldHelper.addMethod(\n                Traits.helperGetterName(field),\n                ACC_PUBLIC | ACC_ABSTRACT,\n                field.getOriginType(),\n                Parameter.EMPTY_ARRAY,\n                ClassNode.EMPTY_ARRAY,\n                null\n        );\n\n        // dummy fields are only used to carry annotations if instance field\n        // and to differentiate from static fields otherwise\n        int mods = field.getModifiers() & Traits.FIELD_PREFIX_MASK;\n        String dummyFieldName = String.format(\"$0x%04x\", mods) + Traits.remappedFieldName(field.getOwner(), field.getName());\n        FieldNode dummyField = new FieldNode(\n                dummyFieldName,\n                ACC_STATIC | ACC_PUBLIC | ACC_FINAL | ACC_SYNTHETIC,\n                field.getOriginType(),\n                fieldHelper,\n                field.isFinal() ? initialExpression : null\n        );\n        // copy annotations from field to dummy field\n        List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n        List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n        GeneralUtils.copyAnnotatedNodeAnnotations(field, copied, notCopied);\n        dummyField.addAnnotations(copied);\n        fieldHelper.addField(dummyField);\n    }"
        ],
        [
            "TraitComposer::applyTrait(ClassNode,ClassNode,TraitHelpersTuple)",
            " 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235 -\n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248 -\n 249  \n 250 -\n 251 -\n 252  \n 253  \n 254  \n 255 -\n 256  \n 257  \n 258 -\n 259 -\n 260 -\n 261 -\n 262 -\n 263 -\n 264 -\n 265 -\n 266 -\n 267 -\n 268 -\n 269 -\n 270  \n 271  \n 272  \n 273  ",
            "    private static void applyTrait(final ClassNode trait, final ClassNode cNode, final TraitHelpersTuple helpers) {\n        ClassNode helperClassNode = helpers.getHelper();\n        ClassNode fieldHelperClassNode = helpers.getFieldHelper();\n        Map<String,ClassNode> genericsSpec = GenericsUtils.createGenericsSpec(cNode);\n        genericsSpec = GenericsUtils.createGenericsSpec(trait, genericsSpec);\n\n        for (MethodNode methodNode : helperClassNode.getAllDeclaredMethods()) {\n            String name = methodNode.getName();\n            Parameter[] helperMethodParams = methodNode.getParameters();\n            boolean isAbstract = methodNode.isAbstract();\n            if (!isAbstract && helperMethodParams.length > 0 && ((methodNode.getModifiers() & Opcodes.ACC_STATIC) == Opcodes.ACC_STATIC) && (!name.contains(\"$\") || (methodNode.getModifiers() & Opcodes.ACC_SYNTHETIC) == 0)) {\n                ArgumentListExpression argList = new ArgumentListExpression();\n                argList.addExpression(new VariableExpression(\"this\"));\n                Parameter[] origParams = new Parameter[helperMethodParams.length - 1];\n                Parameter[] params = new Parameter[helperMethodParams.length - 1];\n                System.arraycopy(methodNode.getParameters(), 1, params, 0, params.length);\n                Map<String,ClassNode> methodGenericsSpec = new LinkedHashMap<String, ClassNode>(genericsSpec);\n                MethodNode originalMethod = trait.getMethod(name, params);\n                // Original method may be null for the case of private or static methods\n                if (originalMethod!=null) {\n                    methodGenericsSpec = GenericsUtils.addMethodGenerics(originalMethod, methodGenericsSpec);\n                }\n                for (int i = 1; i < helperMethodParams.length; i++) {\n                    Parameter parameter = helperMethodParams[i];\n                    ClassNode originType = parameter.getOriginType();\n                    ClassNode fixedType = correctToGenericsSpecRecurse(methodGenericsSpec, originType);\n                    Parameter newParam = new Parameter(fixedType, \"arg\" + i);\n                    List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n                    List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n                    GeneralUtils.copyAnnotatedNodeAnnotations(parameter, copied, notCopied);\n                    newParam.addAnnotations(copied);\n                    params[i - 1] = newParam;\n                    origParams[i-1] = parameter;\n                    argList.addExpression(new VariableExpression(params[i - 1]));\n                }\n                createForwarderMethod(trait, cNode, methodNode, originalMethod, helperClassNode, methodGenericsSpec, helperMethodParams, origParams, params, argList);\n            }\n        }\n        cNode.addObjectInitializerStatements(new ExpressionStatement(\n                new MethodCallExpression(\n                        new ClassExpression(helperClassNode),\n                        Traits.INIT_METHOD,\n                        new ArgumentListExpression(new VariableExpression(\"this\")))\n        ));\n        MethodCallExpression staticInitCall = new MethodCallExpression(\n                new ClassExpression(helperClassNode),\n                Traits.STATIC_INIT_METHOD,\n                new ArgumentListExpression(new ClassExpression(cNode)));\n        MethodNode staticInitMethod = new MethodNode(\n                Traits.STATIC_INIT_METHOD, Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC, ClassHelper.VOID_TYPE,\n                new Parameter[] {new Parameter(ClassHelper.CLASS_Type,\"clazz\")}, ClassNode.EMPTY_ARRAY, EmptyStatement.INSTANCE);\n        staticInitMethod.setDeclaringClass(helperClassNode);\n        staticInitCall.setMethodTarget(staticInitMethod);\n        cNode.addStaticInitializerStatements(Collections.<Statement>singletonList(new ExpressionStatement(\n                staticInitCall\n        )), false);\n        if (fieldHelperClassNode != null && !cNode.declaresInterface(fieldHelperClassNode)) {\n            // we should implement the field helper interface too\n            cNode.addInterface(fieldHelperClassNode);\n            // implementation of methods\n            List<MethodNode> declaredMethods = new LinkedList<MethodNode>();\n            for (MethodNode declaredMethod : fieldHelperClassNode.getAllDeclaredMethods()) {\n                if (declaredMethod.getName().endsWith(Traits.DIRECT_GETTER_SUFFIX)) {\n                    declaredMethods.add(0, declaredMethod);\n                } else {\n                    declaredMethods.add(declaredMethod);\n                }\n            }\n            for (MethodNode methodNode : declaredMethods) {\n                String fieldName = methodNode.getName();\n                if (fieldName.endsWith(Traits.DIRECT_GETTER_SUFFIX) || fieldName.endsWith(Traits.DIRECT_SETTER_SUFFIX)) {\n                    int suffixIdx = fieldName.lastIndexOf(\"$\");\n                    fieldName = fieldName.substring(0, suffixIdx);\n                    String operation = methodNode.getName().substring(suffixIdx + 1);\n                    boolean getter = \"get\".equals(operation);\n                    ClassNode returnType = correctToGenericsSpecRecurse(genericsSpec, methodNode.getReturnType());\n                    int isStatic = 0;\n                    boolean publicField = true;\n                    FieldNode helperField = fieldHelperClassNode.getField(Traits.FIELD_PREFIX + Traits.PUBLIC_FIELD_PREFIX + fieldName);\n                    if (helperField==null) {\n                        publicField = false;\n                        helperField = fieldHelperClassNode.getField(Traits.FIELD_PREFIX + Traits.PRIVATE_FIELD_PREFIX + fieldName);\n                    }\n                    if (helperField==null) {\n                        publicField = true;\n                        // try to find a static one\n                        helperField = fieldHelperClassNode.getField(Traits.STATIC_FIELD_PREFIX+Traits.PUBLIC_FIELD_PREFIX+fieldName);\n                        if (helperField==null) {\n                            publicField = false;\n                            helperField = fieldHelperClassNode.getField(Traits.STATIC_FIELD_PREFIX+Traits.PRIVATE_FIELD_PREFIX +fieldName);\n                        }\n                        isStatic = Opcodes.ACC_STATIC;\n                    }\n                    if (getter) {\n                        // add field\n                        if (helperField!=null) {\n                            List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n                            List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n                            GeneralUtils.copyAnnotatedNodeAnnotations(helperField, copied, notCopied);\n                            FieldNode fieldNode = cNode.addField(fieldName, (publicField?Opcodes.ACC_PUBLIC:Opcodes.ACC_PRIVATE) | isStatic, returnType, null);\n                            fieldNode.addAnnotations(copied);\n                        }\n                    }\n                    Parameter[] newParams;\n                    if (getter) {\n                        newParams = Parameter.EMPTY_ARRAY;\n                    } else {\n                        ClassNode originType = methodNode.getParameters()[0].getOriginType();\n                        ClassNode fixedType = originType.isGenericsPlaceHolder()?ClassHelper.OBJECT_TYPE:correctToGenericsSpecRecurse(genericsSpec, originType);\n                        newParams = new Parameter[]{new Parameter(fixedType, \"val\")};\n                    }\n\n                    Expression fieldExpr = new VariableExpression(cNode.getField(fieldName));\n                    Statement body =\n                            getter ? new ReturnStatement(fieldExpr) :\n                                    new ExpressionStatement(\n                                            new BinaryExpression(\n                                                    fieldExpr,\n                                                    Token.newSymbol(Types.EQUAL, 0, 0),\n                                                    new VariableExpression(newParams[0])\n                                            )\n                                    );\n                    MethodNode impl = new MethodNode(\n                            methodNode.getName(),\n                            Opcodes.ACC_PUBLIC | isStatic,\n                            returnType,\n                            newParams,\n                            ClassNode.EMPTY_ARRAY,\n                            body\n                    );\n                    AnnotationNode an = new AnnotationNode(COMPILESTATIC_CLASSNODE);\n                    impl.addAnnotation(an);\n                    cNode.addTransform(StaticCompileTransformation.class, an);\n                    cNode.addMethod(impl);\n                }\n            }\n        }\n    }",
            " 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214 +\n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230 +\n 231  \n 232  \n 233 +\n 234 +\n 235 +\n 236 +\n 237 +\n 238 +\n 239 +\n 240 +\n 241 +\n 242 +\n 243 +\n 244 +\n 245 +\n 246 +\n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253 +\n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266 +\n 267  \n 268 +\n 269 +\n 270  \n 271  \n 272  \n 273 +\n 274  \n 275  \n 276 +\n 277 +\n 278 +\n 279 +\n 280 +\n 281 +\n 282 +\n 283 +\n 284 +\n 285 +\n 286 +\n 287 +\n 288 +\n 289 +\n 290  \n 291  \n 292  \n 293  ",
            "    private static void applyTrait(final ClassNode trait, final ClassNode cNode, final TraitHelpersTuple helpers) {\n        ClassNode helperClassNode = helpers.getHelper();\n        ClassNode fieldHelperClassNode = helpers.getFieldHelper();\n        Map<String,ClassNode> genericsSpec = GenericsUtils.createGenericsSpec(cNode);\n        genericsSpec = GenericsUtils.createGenericsSpec(trait, genericsSpec);\n\n        for (MethodNode methodNode : helperClassNode.getAllDeclaredMethods()) {\n            String name = methodNode.getName();\n            Parameter[] helperMethodParams = methodNode.getParameters();\n            boolean isAbstract = methodNode.isAbstract();\n            if (!isAbstract && helperMethodParams.length > 0 && ((methodNode.getModifiers() & Opcodes.ACC_STATIC) == Opcodes.ACC_STATIC) && (!name.contains(\"$\") || (methodNode.getModifiers() & Opcodes.ACC_SYNTHETIC) == 0)) {\n                ArgumentListExpression argList = new ArgumentListExpression();\n                argList.addExpression(new VariableExpression(\"this\"));\n                Parameter[] origParams = new Parameter[helperMethodParams.length - 1];\n                Parameter[] params = new Parameter[helperMethodParams.length - 1];\n                System.arraycopy(methodNode.getParameters(), 1, params, 0, params.length);\n                Map<String,ClassNode> methodGenericsSpec = new LinkedHashMap<String, ClassNode>(genericsSpec);\n                MethodNode originalMethod = trait.getMethod(name, params);\n                // Original method may be null for the case of private or static methods\n                if (originalMethod!=null) {\n                    methodGenericsSpec = GenericsUtils.addMethodGenerics(originalMethod, methodGenericsSpec);\n                }\n                for (int i = 1; i < helperMethodParams.length; i++) {\n                    Parameter parameter = helperMethodParams[i];\n                    ClassNode originType = parameter.getOriginType();\n                    ClassNode fixedType = correctToGenericsSpecRecurse(methodGenericsSpec, originType);\n                    Parameter newParam = new Parameter(fixedType, \"arg\" + i);\n                    List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n                    List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n                    GeneralUtils.copyAnnotatedNodeAnnotations(parameter, copied, notCopied);\n                    newParam.addAnnotations(copied);\n                    params[i - 1] = newParam;\n                    origParams[i-1] = parameter;\n                    argList.addExpression(new VariableExpression(params[i - 1]));\n                }\n                createForwarderMethod(trait, cNode, methodNode, originalMethod, helperClassNode, methodGenericsSpec, helperMethodParams, origParams, params, argList);\n            }\n        }\n        cNode.addObjectInitializerStatements(new ExpressionStatement(\n                new MethodCallExpression(\n                        new ClassExpression(helperClassNode),\n                        Traits.INIT_METHOD,\n                        new ArgumentListExpression(new VariableExpression(\"this\")))\n        ));\n        MethodCallExpression staticInitCall = new MethodCallExpression(\n                new ClassExpression(helperClassNode),\n                Traits.STATIC_INIT_METHOD,\n                new ArgumentListExpression(new ClassExpression(cNode)));\n        MethodNode staticInitMethod = new MethodNode(\n                Traits.STATIC_INIT_METHOD, Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC, ClassHelper.VOID_TYPE,\n                new Parameter[] {new Parameter(ClassHelper.CLASS_Type,\"clazz\")}, ClassNode.EMPTY_ARRAY, EmptyStatement.INSTANCE);\n        staticInitMethod.setDeclaringClass(helperClassNode);\n        staticInitCall.setMethodTarget(staticInitMethod);\n        cNode.addStaticInitializerStatements(Collections.<Statement>singletonList(new ExpressionStatement(\n                staticInitCall\n        )), false);\n        if (fieldHelperClassNode != null && !cNode.declaresInterface(fieldHelperClassNode)) {\n            // we should implement the field helper interface too\n            cNode.addInterface(fieldHelperClassNode);\n            // implementation of methods\n            List<MethodNode> declaredMethods = new LinkedList<MethodNode>();\n            for (MethodNode declaredMethod : fieldHelperClassNode.getAllDeclaredMethods()) {\n                if (declaredMethod.getName().endsWith(Traits.DIRECT_GETTER_SUFFIX)) {\n                    declaredMethods.add(0, declaredMethod);\n                } else {\n                    declaredMethods.add(declaredMethod);\n                }\n            }\n            for (MethodNode methodNode : declaredMethods) {\n                String fieldName = methodNode.getName();\n                if (fieldName.endsWith(Traits.DIRECT_GETTER_SUFFIX) || fieldName.endsWith(Traits.DIRECT_SETTER_SUFFIX)) {\n                    int suffixIdx = fieldName.lastIndexOf(\"$\");\n                    fieldName = fieldName.substring(0, suffixIdx);\n                    String operation = methodNode.getName().substring(suffixIdx + 1);\n                    boolean getter = \"get\".equals(operation);\n                    ClassNode returnType = correctToGenericsSpecRecurse(genericsSpec, methodNode.getReturnType());\n                    int fieldMods = 0;\n                    int isStatic = 0;\n                    boolean publicField = true;\n                    FieldNode helperField = fieldHelperClassNode.getField(Traits.FIELD_PREFIX + Traits.PUBLIC_FIELD_PREFIX + fieldName);\n                    if (helperField==null) {\n                        publicField = false;\n                        helperField = fieldHelperClassNode.getField(Traits.FIELD_PREFIX + Traits.PRIVATE_FIELD_PREFIX + fieldName);\n                    }\n                    if (helperField==null) {\n                        publicField = true;\n                        // try to find a static one\n                        helperField = fieldHelperClassNode.getField(Traits.STATIC_FIELD_PREFIX+Traits.PUBLIC_FIELD_PREFIX+fieldName);\n                        if (helperField==null) {\n                            publicField = false;\n                            helperField = fieldHelperClassNode.getField(Traits.STATIC_FIELD_PREFIX+Traits.PRIVATE_FIELD_PREFIX +fieldName);\n                        }\n                        fieldMods = fieldMods | Opcodes.ACC_STATIC;\n                        isStatic = Opcodes.ACC_STATIC;\n                    }\n                    if (helperField == null) {\n                        fieldMods = 0;\n                        isStatic = 0;\n                        for (Integer mod : Traits.FIELD_PREFIXES) {\n                            helperField = fieldHelperClassNode.getField(String.format(\"$0x%04x\", mod) + fieldName);\n                            if (helperField != null) {\n                                if ((mod & Opcodes.ACC_STATIC) != 0) isStatic = Opcodes.ACC_STATIC;\n                                fieldMods = fieldMods | mod;\n                                break;\n                            }\n                        }\n                    } else {\n                        fieldMods = fieldMods | (publicField?Opcodes.ACC_PUBLIC:Opcodes.ACC_PRIVATE);\n                    }\n                    if (getter) {\n                        // add field\n                        if (helperField!=null) {\n                            List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n                            List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n                            GeneralUtils.copyAnnotatedNodeAnnotations(helperField, copied, notCopied);\n                            FieldNode fieldNode = cNode.addField(fieldName, fieldMods, returnType, (fieldMods & Opcodes.ACC_FINAL) == 0 ? null : helperField.getInitialExpression());\n                            fieldNode.addAnnotations(copied);\n                        }\n                    }\n                    Parameter[] newParams;\n                    if (getter) {\n                        newParams = Parameter.EMPTY_ARRAY;\n                    } else {\n                        ClassNode originType = methodNode.getParameters()[0].getOriginType();\n                        ClassNode fixedType = originType.isGenericsPlaceHolder()?ClassHelper.OBJECT_TYPE:correctToGenericsSpecRecurse(genericsSpec, originType);\n                        newParams = new Parameter[]{new Parameter(fixedType, \"val\")};\n                    }\n\n                    Expression fieldExpr = varX(cNode.getField(fieldName));\n                    Statement body =\n                            getter ? returnS(fieldExpr) :\n                                    stmt(\n                                            new BinaryExpression(\n                                                    fieldExpr,\n                                                    Token.newSymbol(Types.EQUAL, 0, 0),\n                                                    varX(newParams[0])\n                                            )\n                                    );\n                    if (getter || (fieldMods & Opcodes.ACC_FINAL) == 0) {\n                        MethodNode impl = new MethodNode(\n                                methodNode.getName(),\n                                Opcodes.ACC_PUBLIC | isStatic,\n                                returnType,\n                                newParams,\n                                ClassNode.EMPTY_ARRAY,\n                                body\n                        );\n                        AnnotationNode an = new AnnotationNode(COMPILESTATIC_CLASSNODE);\n                        impl.addAnnotation(an);\n                        cNode.addTransform(StaticCompileTransformation.class, an);\n                        cNode.addMethod(impl);\n                    }\n                }\n            }\n        }\n    }"
        ]
    ]
}