{
    "79672357b53369b6db262059edce614a6ee65de3": [
        [
            "StaticInvocationWriter::tryBridgeMethod(MethodNode,Expression,boolean,TupleExpression)",
            " 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155 -\n 156  \n 157  \n 158  \n 159 -\n 160  \n 161  \n 162  ",
            "    /**\n     * Attempts to make a direct method call on a bridge method, if it exists.\n     */\n    protected boolean tryBridgeMethod(MethodNode target, Expression receiver, boolean implicitThis, TupleExpression args) {\n        Map<MethodNode, MethodNode> bridges = target.getDeclaringClass().redirect().getNodeMetaData(PRIVATE_BRIDGE_METHODS);\n        MethodNode bridge = bridges==null?null:bridges.get(target);\n        if (bridge != null) {\n            ArgumentListExpression newArgs = new ArgumentListExpression(target.isStatic()?new ConstantExpression(null):receiver);\n            for (Expression expression : args.getExpressions()) {\n                newArgs.addExpression(expression);\n            }\n            return writeDirectMethodCall(bridge, implicitThis, receiver, newArgs);\n        }\n        return false;\n    }",
            " 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155 +\n 156 +\n 157 +\n 158 +\n 159 +\n 160 +\n 161 +\n 162 +\n 163 +\n 164 +\n 165  \n 166  \n 167  \n 168 +\n 169  \n 170  \n 171  ",
            "    /**\n     * Attempts to make a direct method call on a bridge method, if it exists.\n     */\n    protected boolean tryBridgeMethod(MethodNode target, Expression receiver, boolean implicitThis, TupleExpression args) {\n        Map<MethodNode, MethodNode> bridges = target.getDeclaringClass().redirect().getNodeMetaData(PRIVATE_BRIDGE_METHODS);\n        MethodNode bridge = bridges==null?null:bridges.get(target);\n        if (bridge != null) {\n            Expression fixedReceiver = receiver;\n            ClassNode classNode = implicitThis?controller.getClassNode():null;\n            ClassNode declaringClass = bridge.getDeclaringClass();\n            if (implicitThis && !controller.isInClosure()\n                    && !classNode.isDerivedFrom(declaringClass)\n                    && !classNode.implementsInterface(declaringClass)\n                    && classNode instanceof InnerClassNode) {\n                fixedReceiver = new PropertyExpression(new ClassExpression(classNode.getOuterClass()), \"this\");\n            }\n            ArgumentListExpression newArgs = new ArgumentListExpression(target.isStatic()?new ConstantExpression(null):fixedReceiver);\n            for (Expression expression : args.getExpressions()) {\n                newArgs.addExpression(expression);\n            }\n            return writeDirectMethodCall(bridge, implicitThis, fixedReceiver, newArgs);\n        }\n        return false;\n    }"
        ]
    ],
    "709e445d9967ac28b6869fb1949df20b1f953e7e": [
        [
            "VariableScopeVisitor::visitConstructorCallExpression(ConstructorCallExpression)",
            " 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564  \n 565  \n 566  \n 567  \n 568  \n 569  \n 570  \n 571  ",
            "    public void visitConstructorCallExpression(ConstructorCallExpression call) {\n        isSpecialConstructorCall = call.isSpecialCall();\n        super.visitConstructorCallExpression(call);\n        isSpecialConstructorCall = false;\n        if (!call.isUsingAnonymousInnerClass()) return;\n\n        pushState();\n        InnerClassNode innerClass = (InnerClassNode) call.getType();\n        innerClass.setVariableScope(currentScope);\n        for (MethodNode method : innerClass.getMethods()) {\n            Parameter[] parameters = method.getParameters();\n            if (parameters.length == 0) parameters = null; // null means no implicit \"it\"\n            ClosureExpression cl = new ClosureExpression(parameters, method.getCode());\n            visitClosureExpression(cl);\n        }\n\n        for (FieldNode field : innerClass.getFields()) {\n            final Expression expression = field.getInitialExpression();\n            if (expression != null) {\n                expression.visit(this);\n            }\n        }\n\n        for (Statement statement : innerClass.getObjectInitializerStatements()) {\n            statement.visit(this);\n        }\n        markClosureSharedVariables();\n        popState();\n    }",
            " 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561 +\n 562  \n 563 +\n 564 +\n 565 +\n 566 +\n 567 +\n 568 +\n 569 +\n 570  \n 571  \n 572 +\n 573  \n 574  \n 575  \n 576  \n 577  \n 578  \n 579  \n 580  ",
            "    public void visitConstructorCallExpression(ConstructorCallExpression call) {\n        isSpecialConstructorCall = call.isSpecialCall();\n        super.visitConstructorCallExpression(call);\n        isSpecialConstructorCall = false;\n        if (!call.isUsingAnonymousInnerClass()) return;\n\n        pushState();\n        InnerClassNode innerClass = (InnerClassNode) call.getType();\n        innerClass.setVariableScope(currentScope);\n        for (MethodNode method : innerClass.getMethods()) {\n            Parameter[] parameters = method.getParameters();\n            if (parameters.length == 0) parameters = null; // null means no implicit \"it\"\n            ClosureExpression cl = new ClosureExpression(parameters, method.getCode());\n            visitClosureExpression(cl);\n        }\n\n        for (FieldNode field : innerClass.getFields()) {\n            final Expression expression = field.getInitialExpression();\n            pushState(field.isStatic());\n            if (expression != null) {\n                if (expression instanceof VariableExpression) {\n                    VariableExpression vexp = (VariableExpression) expression;\n                    if (vexp.getAccessedVariable() instanceof Parameter) {\n                        // workaround for GROOVY-6834: accessing a parameter which is not yet seen in scope\n                        continue;\n                    }\n                }\n                expression.visit(this);\n            }\n            popState();\n        }\n\n        for (Statement statement : innerClass.getObjectInitializerStatements()) {\n            statement.visit(this);\n        }\n        markClosureSharedVariables();\n        popState();\n    }"
        ],
        [
            "InnerClassVisitor::visitConstructorCallExpression(ConstructorCallExpression)",
            " 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  ",
            "    @Override\n    public void visitConstructorCallExpression(ConstructorCallExpression call) {\n        super.visitConstructorCallExpression(call);\n        if (!call.isUsingAnonymousInnerClass()) {\n            passThisReference(call);\n            return;\n        }\n\n        InnerClassNode innerClass = (InnerClassNode) call.getType();\n        if (!innerClass.getDeclaredConstructors().isEmpty()) return;\n        if ((innerClass.getModifiers() & ACC_STATIC) != 0) return;\n\n        VariableScope scope = innerClass.getVariableScope();\n        if (scope == null) return;\n\n        // expressions = constructor call arguments\n        List<Expression> expressions = ((TupleExpression) call.getArguments()).getExpressions();\n        // block = init code for the constructor we produce\n        BlockStatement block = new BlockStatement();\n        // parameters = parameters of the constructor\n        final int additionalParamCount = 1 + scope.getReferencedLocalVariablesCount();\n        List<Parameter> parameters = new ArrayList<Parameter>(expressions.size() + additionalParamCount);\n        // superCallArguments = arguments for the super call == the constructor call arguments\n        List<Expression> superCallArguments = new ArrayList<Expression>(expressions.size());\n\n        // first we add a super() call for all expressions given in the \n        // constructor call expression\n        int pCount = additionalParamCount;\n        for (Expression expr : expressions) {\n            pCount++;\n            // add one parameter for each expression in the\n            // constructor call\n            Parameter param = new Parameter(ClassHelper.OBJECT_TYPE, \"p\" + pCount);\n            parameters.add(param);\n            // add to super call\n            superCallArguments.add(new VariableExpression(param));\n        }\n\n        // add the super call\n        ConstructorCallExpression cce = new ConstructorCallExpression(\n                ClassNode.SUPER,\n                new TupleExpression(superCallArguments)\n        );\n\n        block.addStatement(new ExpressionStatement(cce));\n\n        // we need to add \"this\" to access unknown methods/properties\n        // this is saved in a field named this$0\n        pCount = 0;\n        expressions.add(pCount, VariableExpression.THIS_EXPRESSION);\n        boolean isStatic = isStaticThis(innerClass,scope);\n        ClassNode outerClassType = getClassNode(innerClass.getOuterClass(), isStatic);\n        if (!isStatic && inClosure) outerClassType = ClassHelper.CLOSURE_TYPE;\n        outerClassType = outerClassType.getPlainNodeReference();\n        Parameter thisParameter = new Parameter(outerClassType, \"p\" + pCount);\n        parameters.add(pCount, thisParameter);\n\n        thisField = innerClass.addField(\"this$0\", PUBLIC_SYNTHETIC, outerClassType, null);\n        addFieldInit(thisParameter, thisField, block);\n\n        // for each shared variable we add a reference and save it as field\n        for (Iterator it = scope.getReferencedLocalVariablesIterator(); it.hasNext();) {\n            pCount++;\n            org.codehaus.groovy.ast.Variable var = (org.codehaus.groovy.ast.Variable) it.next();\n            VariableExpression ve = new VariableExpression(var);\n            ve.setClosureSharedVariable(true);\n            ve.setUseReferenceDirectly(true);\n            expressions.add(pCount, ve);\n\n            ClassNode rawReferenceType = ClassHelper.REFERENCE_TYPE.getPlainNodeReference();\n            Parameter p = new Parameter(rawReferenceType, \"p\" + pCount);\n            parameters.add(pCount, p);\n            p.setOriginType(var.getOriginType());\n            final VariableExpression initial = new VariableExpression(p);\n            initial.setUseReferenceDirectly(true);\n            final FieldNode pField = innerClass.addFieldFirst(ve.getName(), PUBLIC_SYNTHETIC,rawReferenceType, initial);\n            pField.setHolder(true);\n            pField.setOriginType(ClassHelper.getWrapper(var.getOriginType()));\n        }\n\n        innerClass.addConstructor(ACC_SYNTHETIC, parameters.toArray(new Parameter[0]), ClassNode.EMPTY_ARRAY, block);\n    }",
            " 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217 +\n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  ",
            "    @Override\n    public void visitConstructorCallExpression(ConstructorCallExpression call) {\n        super.visitConstructorCallExpression(call);\n        if (!call.isUsingAnonymousInnerClass()) {\n            passThisReference(call);\n            return;\n        }\n\n        InnerClassNode innerClass = (InnerClassNode) call.getType();\n        if (!innerClass.getDeclaredConstructors().isEmpty()) return;\n        if ((innerClass.getModifiers() & ACC_STATIC) != 0) return;\n\n        VariableScope scope = innerClass.getVariableScope();\n        if (scope == null) return;\n\n        // expressions = constructor call arguments\n        List<Expression> expressions = ((TupleExpression) call.getArguments()).getExpressions();\n        // block = init code for the constructor we produce\n        BlockStatement block = new BlockStatement();\n        // parameters = parameters of the constructor\n        final int additionalParamCount = 1 + scope.getReferencedLocalVariablesCount();\n        List<Parameter> parameters = new ArrayList<Parameter>(expressions.size() + additionalParamCount);\n        // superCallArguments = arguments for the super call == the constructor call arguments\n        List<Expression> superCallArguments = new ArrayList<Expression>(expressions.size());\n\n        // first we add a super() call for all expressions given in the \n        // constructor call expression\n        int pCount = additionalParamCount;\n        for (Expression expr : expressions) {\n            pCount++;\n            // add one parameter for each expression in the\n            // constructor call\n            Parameter param = new Parameter(ClassHelper.OBJECT_TYPE, \"p\" + pCount);\n            parameters.add(param);\n            // add to super call\n            superCallArguments.add(new VariableExpression(param));\n        }\n\n        // add the super call\n        ConstructorCallExpression cce = new ConstructorCallExpression(\n                ClassNode.SUPER,\n                new TupleExpression(superCallArguments)\n        );\n\n        block.addStatement(new ExpressionStatement(cce));\n\n        // we need to add \"this\" to access unknown methods/properties\n        // this is saved in a field named this$0\n        pCount = 0;\n        expressions.add(pCount, VariableExpression.THIS_EXPRESSION);\n        boolean isStatic = isStaticThis(innerClass,scope);\n        ClassNode outerClassType = getClassNode(innerClass.getOuterClass(), isStatic);\n        if (!isStatic && inClosure) outerClassType = ClassHelper.CLOSURE_TYPE;\n        outerClassType = outerClassType.getPlainNodeReference();\n        Parameter thisParameter = new Parameter(outerClassType, \"p\" + pCount);\n        parameters.add(pCount, thisParameter);\n\n        thisField = innerClass.addField(\"this$0\", PUBLIC_SYNTHETIC, outerClassType, null);\n        addFieldInit(thisParameter, thisField, block);\n\n        // for each shared variable we add a reference and save it as field\n        for (Iterator it = scope.getReferencedLocalVariablesIterator(); it.hasNext();) {\n            pCount++;\n            org.codehaus.groovy.ast.Variable var = (org.codehaus.groovy.ast.Variable) it.next();\n            VariableExpression ve = new VariableExpression(var);\n            ve.setClosureSharedVariable(true);\n            ve.setUseReferenceDirectly(true);\n            expressions.add(pCount, ve);\n\n            ClassNode rawReferenceType = ClassHelper.REFERENCE_TYPE.getPlainNodeReference();\n            Parameter p = new Parameter(rawReferenceType, \"p\" + pCount);\n            parameters.add(pCount, p);\n            p.setOriginType(var.getOriginType());\n            final VariableExpression initial = new VariableExpression(p);\n            initial.setSynthetic(true);\n            initial.setUseReferenceDirectly(true);\n            final FieldNode pField = innerClass.addFieldFirst(ve.getName(), PUBLIC_SYNTHETIC,rawReferenceType, initial);\n            pField.setHolder(true);\n            pField.setOriginType(ClassHelper.getWrapper(var.getOriginType()));\n        }\n\n        innerClass.addConstructor(ACC_SYNTHETIC, parameters.toArray(new Parameter[0]), ClassNode.EMPTY_ARRAY, block);\n    }"
        ]
    ],
    "02e9f85250015563ad21198794f60c7ee412012a": [
        [
            "StaticTypeCheckingSupport::getMaximumInterfaceDistance(ClassNode,ClassNode)",
            " 833  \n 834  \n 835  \n 836  \n 837  \n 838  \n 839  \n 840 -\n 841  \n 842  \n 843  \n 844  \n 845  \n 846 -\n 847  \n 848  \n 849  \n 850  \n 851  \n 852  \n 853  ",
            "    private static int getMaximumInterfaceDistance(ClassNode c, ClassNode interfaceClass) {\n        // -1 means a mismatch\n        if (c == null) return -1;\n        // 0 means a direct match\n        if (c.equals(interfaceClass)) return 0;\n        ClassNode[] interfaces = c.getInterfaces();\n        int max = -1;\n        for (ClassNode anInterface : interfaces) {\n            int sub = getMaximumInterfaceDistance(anInterface, interfaceClass);\n            // we need to keep the -1 to track the mismatch, a +1\n            // by any means could let it look like a direct match\n            // we want to add one, because there is an interface between\n            // the interface we search for and the interface we are in.\n            if (sub != -1) sub++;\n            // we are interested in the longest path only\n            max = Math.max(max, sub);\n        }\n        // we do not add one for super classes, only for interfaces\n        int superClassMax = getMaximumInterfaceDistance(c.getSuperClass(), interfaceClass);\n        return Math.max(max, superClassMax);\n    }",
            " 833  \n 834  \n 835  \n 836  \n 837  \n 838  \n 839  \n 840 +\n 841 +\n 842  \n 843  \n 844  \n 845  \n 846  \n 847 +\n 848 +\n 849 +\n 850  \n 851  \n 852  \n 853  \n 854  \n 855  \n 856  ",
            "    private static int getMaximumInterfaceDistance(ClassNode c, ClassNode interfaceClass) {\n        // -1 means a mismatch\n        if (c == null) return -1;\n        // 0 means a direct match\n        if (c.equals(interfaceClass)) return 0;\n        ClassNode[] interfaces = c.getInterfaces();\n        int max = -1;\n        for (int i = 0; i < interfaces.length; i++) {\n            final ClassNode anInterface = interfaces[i];\n            int sub = getMaximumInterfaceDistance(anInterface, interfaceClass);\n            // we need to keep the -1 to track the mismatch, a +1\n            // by any means could let it look like a direct match\n            // we want to add one, because there is an interface between\n            // the interface we search for and the interface we are in.\n            if (sub != -1) {\n                sub+=(i+1); // GROOVY-6970: Make sure we can choose between equivalent methods\n            }\n            // we are interested in the longest path only\n            max = Math.max(max, sub);\n        }\n        // we do not add one for super classes, only for interfaces\n        int superClassMax = getMaximumInterfaceDistance(c.getSuperClass(), interfaceClass);\n        return Math.max(max, superClassMax);\n    }"
        ],
        [
            "StaticTypeCheckingSupport::chooseBestMethod(ClassNode,Collection,ClassNode)",
            " 912  \n 913  \n 914  \n 915  \n 916  \n 917  \n 918  \n 919  \n 920  \n 921  \n 922  \n 923  \n 924  \n 925  \n 926  \n 927  \n 928  \n 929  \n 930  \n 931  \n 932  \n 933  \n 934  \n 935  \n 936  \n 937  \n 938  \n 939  \n 940  \n 941  \n 942  \n 943  \n 944  \n 945  \n 946  \n 947  \n 948  \n 949  \n 950  \n 951  \n 952  \n 953  \n 954  \n 955  \n 956  \n 957  \n 958  \n 959  \n 960  \n 961  \n 962  \n 963  \n 964  \n 965  \n 966  \n 967  \n 968  \n 969  \n 970  \n 971  \n 972  \n 973  \n 974  \n 975  \n 976  \n 977  \n 978  \n 979  \n 980  \n 981  \n 982  \n 983  \n 984  \n 985  \n 986  \n 987  \n 988  \n 989  \n 990  \n 991  \n 992  \n 993  \n 994  \n 995  \n 996  \n 997  \n 998  \n 999  \n1000  \n1001  \n1002  \n1003  \n1004  \n1005  \n1006  \n1007  \n1008  \n1009  \n1010  \n1011  \n1012  \n1013  \n1014  \n1015  \n1016  \n1017  \n1018  \n1019  \n1020  \n1021  \n1022  \n1023  \n1024  \n1025  \n1026  \n1027  \n1028  \n1029  \n1030  \n1031  \n1032  \n1033  \n1034  \n1035  \n1036  \n1037  ",
            "    /**\n     * Given a list of candidate methods, returns the one which best matches the argument types\n     *\n     * @param receiver\n     * @param methods candidate methods\n     * @param args argument types\n     * @return the list of methods which best matches the argument types. It is still possible that multiple\n     * methods match the argument types.\n     */\n    public static List<MethodNode> chooseBestMethod(final ClassNode receiver, Collection<MethodNode> methods, ClassNode... args) {\n        if (methods.isEmpty()) return Collections.emptyList();\n        if (isUsingUncheckedGenerics(receiver)) {\n            ClassNode raw = makeRawType(receiver);\n            return chooseBestMethod(raw, methods, args);\n        }\n        List<MethodNode> bestChoices = new LinkedList<MethodNode>();\n        int bestDist = Integer.MAX_VALUE;\n        Collection<MethodNode> choicesLeft = removeCovariants(methods);\n        for (MethodNode candidateNode : choicesLeft) {\n            ClassNode declaringClass = candidateNode.getDeclaringClass();\n            ClassNode actualReceiver = receiver!=null?receiver: declaringClass;\n            final ClassNode declaringClassForDistance = declaringClass;\n            final ClassNode actualReceiverForDistance = actualReceiver;\n            MethodNode safeNode = candidateNode;\n            ClassNode[] safeArgs = args;\n            boolean isExtensionMethodNode = candidateNode instanceof ExtensionMethodNode;\n            if (isExtensionMethodNode) {\n                safeArgs = new ClassNode[args.length+1];\n                System.arraycopy(args, 0, safeArgs, 1, args.length);\n                safeArgs[0] = receiver;\n                safeNode = ((ExtensionMethodNode) candidateNode).getExtensionMethodNode();\n                declaringClass = safeNode.getDeclaringClass();\n                actualReceiver = declaringClass;\n            }\n\n            // todo : corner case\n            /*\n                class B extends A {}\n\n                Animal foo(A o) {...}\n                Person foo(B i){...}\n\n                B  a = new B()\n                Person p = foo(b)\n             */\n\n            Parameter[] params = makeRawTypes(safeNode.getParameters());\n            if (params.length == safeArgs.length) {\n                int allPMatch = allParametersAndArgumentsMatch(params, safeArgs);\n                boolean firstParamMatches = true;\n                // check first parameters\n                if (safeArgs.length > 0) {\n                    Parameter[] firstParams = new Parameter[params.length - 1];\n                    System.arraycopy(params, 0, firstParams, 0, firstParams.length);\n                    firstParamMatches = allParametersAndArgumentsMatch(firstParams, safeArgs) >= 0;\n                }\n                int lastArgMatch = isVargs(params) && firstParamMatches?lastArgMatchesVarg(params, safeArgs):-1;\n                if (lastArgMatch>=0) {\n                    lastArgMatch += 256-params.length; // ensure exact matches are preferred over vargs\n                }\n                int dist = allPMatch>=0?Math.max(allPMatch, lastArgMatch):lastArgMatch;\n                if (dist>=0 && !actualReceiverForDistance.equals(declaringClassForDistance)) dist+=getDistance(actualReceiverForDistance, declaringClassForDistance);\n                if (dist>=0 && !isExtensionMethodNode) {\n                    dist++;\n                }\n                if (dist>=0 && dist<bestDist) {\n                    bestChoices.clear();\n                    bestChoices.add(candidateNode);\n                    bestDist = dist;\n                } else if (dist>=0 && dist==bestDist) {\n                    bestChoices.add(candidateNode);\n                }\n            } else if (isVargs(params)) {\n                boolean firstParamMatches = true;\n                int dist = -1;\n                // check first parameters\n                if (safeArgs.length > 0) {\n                    Parameter[] firstParams = new Parameter[params.length - 1];\n                    System.arraycopy(params, 0, firstParams, 0, firstParams.length);\n                    dist = allParametersAndArgumentsMatch(firstParams, safeArgs);\n                    firstParamMatches =  dist >= 0;\n                } else {\n                    dist = 0;\n                }\n                if (firstParamMatches) {\n                    // there are three case for vargs\n                    // (1) varg part is left out\n                    if (params.length == safeArgs.length + 1) {\n                        if (dist>=0) {\n                            dist += 256-params.length; // ensure exact matches are preferred over vargs\n                        }\n                        if (bestDist > 1+dist) {\n                            bestChoices.clear();\n                            bestChoices.add(candidateNode);\n                            bestDist = 1+dist; // 1+dist to discriminate foo(Object,String) vs foo(Object,String, Object...)\n                        }\n                    } else {\n                        // (2) last argument is put in the vargs array\n                        //      that case is handled above already\n                        // (3) there is more than one argument for the vargs array\n                        int excessArgumentsDistance = excessArgumentsMatchesVargsParameter(params, safeArgs);\n                        if (excessArgumentsDistance < 0) continue;\n                        dist += excessArgumentsDistance;\n                        if (dist >= 0 && !actualReceiverForDistance.equals(declaringClassForDistance)) dist+=getDistance(actualReceiverForDistance, declaringClassForDistance);\n                        // varargs methods must not be preferred to methods without varargs\n                        // for example :\n                        // int sum(int x) should be preferred to int sum(int x, int... y)\n                        dist+=256-params.length;\n                        if (dist>=0 && !isExtensionMethodNode) {\n                            dist++;\n                        }\n                        if (params.length < safeArgs.length && dist >= 0) {\n                            if (dist >= 0 && dist < bestDist) {\n                                bestChoices.clear();\n                                bestChoices.add(candidateNode);\n                                bestDist = dist;\n                            } else if (dist >= 0 && dist == bestDist) {\n                                bestChoices.add(candidateNode);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return bestChoices;\n    }",
            " 915  \n 916  \n 917  \n 918  \n 919  \n 920  \n 921  \n 922  \n 923  \n 924  \n 925  \n 926  \n 927  \n 928  \n 929  \n 930  \n 931  \n 932  \n 933  \n 934  \n 935  \n 936  \n 937  \n 938  \n 939  \n 940  \n 941  \n 942  \n 943  \n 944  \n 945  \n 946  \n 947  \n 948  \n 949  \n 950  \n 951  \n 952  \n 953  \n 954  \n 955  \n 956  \n 957  \n 958  \n 959  \n 960  \n 961  \n 962  \n 963  \n 964  \n 965  \n 966  \n 967  \n 968  \n 969  \n 970  \n 971  \n 972  \n 973  \n 974  \n 975  \n 976  \n 977  \n 978  \n 979  \n 980  \n 981  \n 982  \n 983  \n 984  \n 985  \n 986  \n 987  \n 988  \n 989  \n 990  \n 991  \n 992  \n 993  \n 994  \n 995  \n 996  \n 997  \n 998  \n 999  \n1000  \n1001  \n1002  \n1003  \n1004  \n1005  \n1006  \n1007  \n1008  \n1009  \n1010  \n1011  \n1012  \n1013  \n1014  \n1015  \n1016  \n1017  \n1018  \n1019  \n1020  \n1021  \n1022  \n1023  \n1024  \n1025  \n1026  \n1027  \n1028  \n1029  \n1030  \n1031  \n1032  \n1033  \n1034  \n1035  \n1036  \n1037  \n1038  \n1039 +\n1040 +\n1041 +\n1042 +\n1043 +\n1044 +\n1045 +\n1046 +\n1047 +\n1048 +\n1049 +\n1050 +\n1051  \n1052  ",
            "    /**\n     * Given a list of candidate methods, returns the one which best matches the argument types\n     *\n     * @param receiver\n     * @param methods candidate methods\n     * @param args argument types\n     * @return the list of methods which best matches the argument types. It is still possible that multiple\n     * methods match the argument types.\n     */\n    public static List<MethodNode> chooseBestMethod(final ClassNode receiver, Collection<MethodNode> methods, ClassNode... args) {\n        if (methods.isEmpty()) return Collections.emptyList();\n        if (isUsingUncheckedGenerics(receiver)) {\n            ClassNode raw = makeRawType(receiver);\n            return chooseBestMethod(raw, methods, args);\n        }\n        List<MethodNode> bestChoices = new LinkedList<MethodNode>();\n        int bestDist = Integer.MAX_VALUE;\n        Collection<MethodNode> choicesLeft = removeCovariants(methods);\n        for (MethodNode candidateNode : choicesLeft) {\n            ClassNode declaringClass = candidateNode.getDeclaringClass();\n            ClassNode actualReceiver = receiver!=null?receiver: declaringClass;\n            final ClassNode declaringClassForDistance = declaringClass;\n            final ClassNode actualReceiverForDistance = actualReceiver;\n            MethodNode safeNode = candidateNode;\n            ClassNode[] safeArgs = args;\n            boolean isExtensionMethodNode = candidateNode instanceof ExtensionMethodNode;\n            if (isExtensionMethodNode) {\n                safeArgs = new ClassNode[args.length+1];\n                System.arraycopy(args, 0, safeArgs, 1, args.length);\n                safeArgs[0] = receiver;\n                safeNode = ((ExtensionMethodNode) candidateNode).getExtensionMethodNode();\n                declaringClass = safeNode.getDeclaringClass();\n                actualReceiver = declaringClass;\n            }\n\n            // todo : corner case\n            /*\n                class B extends A {}\n\n                Animal foo(A o) {...}\n                Person foo(B i){...}\n\n                B  a = new B()\n                Person p = foo(b)\n             */\n\n            Parameter[] params = makeRawTypes(safeNode.getParameters());\n            if (params.length == safeArgs.length) {\n                int allPMatch = allParametersAndArgumentsMatch(params, safeArgs);\n                boolean firstParamMatches = true;\n                // check first parameters\n                if (safeArgs.length > 0) {\n                    Parameter[] firstParams = new Parameter[params.length - 1];\n                    System.arraycopy(params, 0, firstParams, 0, firstParams.length);\n                    firstParamMatches = allParametersAndArgumentsMatch(firstParams, safeArgs) >= 0;\n                }\n                int lastArgMatch = isVargs(params) && firstParamMatches?lastArgMatchesVarg(params, safeArgs):-1;\n                if (lastArgMatch>=0) {\n                    lastArgMatch += 256-params.length; // ensure exact matches are preferred over vargs\n                }\n                int dist = allPMatch>=0?Math.max(allPMatch, lastArgMatch):lastArgMatch;\n                if (dist>=0 && !actualReceiverForDistance.equals(declaringClassForDistance)) dist+=getDistance(actualReceiverForDistance, declaringClassForDistance);\n                if (dist>=0 && !isExtensionMethodNode) {\n                    dist++;\n                }\n                if (dist>=0 && dist<bestDist) {\n                    bestChoices.clear();\n                    bestChoices.add(candidateNode);\n                    bestDist = dist;\n                } else if (dist>=0 && dist==bestDist) {\n                    bestChoices.add(candidateNode);\n                }\n            } else if (isVargs(params)) {\n                boolean firstParamMatches = true;\n                int dist = -1;\n                // check first parameters\n                if (safeArgs.length > 0) {\n                    Parameter[] firstParams = new Parameter[params.length - 1];\n                    System.arraycopy(params, 0, firstParams, 0, firstParams.length);\n                    dist = allParametersAndArgumentsMatch(firstParams, safeArgs);\n                    firstParamMatches =  dist >= 0;\n                } else {\n                    dist = 0;\n                }\n                if (firstParamMatches) {\n                    // there are three case for vargs\n                    // (1) varg part is left out\n                    if (params.length == safeArgs.length + 1) {\n                        if (dist>=0) {\n                            dist += 256-params.length; // ensure exact matches are preferred over vargs\n                        }\n                        if (bestDist > 1+dist) {\n                            bestChoices.clear();\n                            bestChoices.add(candidateNode);\n                            bestDist = 1+dist; // 1+dist to discriminate foo(Object,String) vs foo(Object,String, Object...)\n                        }\n                    } else {\n                        // (2) last argument is put in the vargs array\n                        //      that case is handled above already\n                        // (3) there is more than one argument for the vargs array\n                        int excessArgumentsDistance = excessArgumentsMatchesVargsParameter(params, safeArgs);\n                        if (excessArgumentsDistance < 0) continue;\n                        dist += excessArgumentsDistance;\n                        if (dist >= 0 && !actualReceiverForDistance.equals(declaringClassForDistance)) dist+=getDistance(actualReceiverForDistance, declaringClassForDistance);\n                        // varargs methods must not be preferred to methods without varargs\n                        // for example :\n                        // int sum(int x) should be preferred to int sum(int x, int... y)\n                        dist+=256-params.length;\n                        if (dist>=0 && !isExtensionMethodNode) {\n                            dist++;\n                        }\n                        if (params.length < safeArgs.length && dist >= 0) {\n                            if (dist >= 0 && dist < bestDist) {\n                                bestChoices.clear();\n                                bestChoices.add(candidateNode);\n                                bestDist = dist;\n                            } else if (dist >= 0 && dist == bestDist) {\n                                bestChoices.add(candidateNode);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (bestChoices.size()>1) {\n            // GROOVY-6849: prefer extension methods in case of ambiguity\n            List<MethodNode> onlyExtensionMethods = new LinkedList<MethodNode>();\n            for (MethodNode choice : bestChoices) {\n                if (choice instanceof ExtensionMethodNode) {\n                    onlyExtensionMethods.add(choice);\n                }\n            }\n            if (onlyExtensionMethods.size()==1) {\n                return onlyExtensionMethods;\n            }\n        }\n        return bestChoices;\n    }"
        ]
    ],
    "e2b1e727e70dc97bcf3d29993ff320e2fa80af69": [
        [
            "JavaStubGenerator::printMethods(PrintWriter,ClassNode,boolean)",
            " 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  ",
            "    private void printMethods(PrintWriter out, ClassNode classNode, boolean isEnum) {\n        if (!isEnum) printConstructors(out, classNode);\n\n        @SuppressWarnings(\"unchecked\")\n        List<MethodNode> methods = (List) propertyMethods.clone();\n        methods.addAll(classNode.getMethods());\n        for (MethodNode method : methods) {\n            if (isEnum && method.isSynthetic()) {\n                // skip values() method and valueOf(String)\n                String name = method.getName();\n                Parameter[] params = method.getParameters();\n                if (name.equals(\"values\") && params.length == 0) continue;\n                if (name.equals(\"valueOf\") &&\n                        params.length == 1 &&\n                        params[0].getType().equals(ClassHelper.STRING_TYPE)) {\n                    continue;\n                }\n            }\n            printMethod(out, classNode, method);\n        }\n    }",
            " 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283 +\n 284 +\n 285 +\n 286 +\n 287 +\n 288 +\n 289 +\n 290 +\n 291 +\n 292 +\n 293 +\n 294 +\n 295 +\n 296  ",
            "    private void printMethods(PrintWriter out, ClassNode classNode, boolean isEnum) {\n        if (!isEnum) printConstructors(out, classNode);\n\n        @SuppressWarnings(\"unchecked\")\n        List<MethodNode> methods = (List) propertyMethods.clone();\n        methods.addAll(classNode.getMethods());\n        for (MethodNode method : methods) {\n            if (isEnum && method.isSynthetic()) {\n                // skip values() method and valueOf(String)\n                String name = method.getName();\n                Parameter[] params = method.getParameters();\n                if (name.equals(\"values\") && params.length == 0) continue;\n                if (name.equals(\"valueOf\") &&\n                        params.length == 1 &&\n                        params[0].getType().equals(ClassHelper.STRING_TYPE)) {\n                    continue;\n                }\n            }\n            printMethod(out, classNode, method);\n        }\n\n        for (ClassNode node : classNode.getInterfaces()) {\n            if (Traits.isTrait(node)) {\n                List<MethodNode> traitMethods = node.getMethods();\n                for (MethodNode traitMethod : traitMethods) {\n                    MethodNode method = classNode.getMethod(traitMethod.getName(), traitMethod.getParameters());\n                    if (method == null) {\n                        printMethod(out, classNode, traitMethod);\n                    }\n                }\n            }\n        }\n\n    }"
        ]
    ],
    "b819ed0644994afaefadd6f47ffec6adffde68af": [
        [
            "Verifier::addInitialization(ClassNode,ConstructorNode)",
            " 895  \n 896  \n 897  \n 898  \n 899  \n 900  \n 901  \n 902  \n 903  \n 904  \n 905  \n 906  \n 907  \n 908  \n 909  \n 910  \n 911  \n 912  \n 913  \n 914  \n 915  \n 916  \n 917  \n 918  \n 919  \n 920  \n 921  \n 922  \n 923  \n 924 -\n 925 -\n 926 -\n 927  \n 928  \n 929  \n 930  \n 931  \n 932  \n 933  \n 934  \n 935  \n 936  \n 937  \n 938  \n 939  \n 940  \n 941  \n 942  \n 943  \n 944  \n 945  \n 946  \n 947  \n 948  \n 949  \n 950  \n 951  \n 952  \n 953  \n 954  \n 955  \n 956  \n 957  \n 958  \n 959  \n 960  \n 961  \n 962  \n 963  \n 964  \n 965  \n 966  \n 967  \n 968  \n 969  \n 970  \n 971  \n 972  \n 973  \n 974  \n 975  ",
            "    protected void addInitialization(ClassNode node, ConstructorNode constructorNode) {\n        Statement firstStatement = constructorNode.getFirstStatement();\n        // if some transformation decided to generate constructor then it probably knows who it does\n        if (firstStatement instanceof BytecodeSequence)\n            return;\n\n        ConstructorCallExpression first = getFirstIfSpecialConstructorCall(firstStatement);\n\n        // in case of this(...) let the other constructor do the init\n        if (first != null && (first.isThisCall())) return;\n\n        List<Statement> statements = new ArrayList<Statement>();\n        List<Statement> staticStatements = new ArrayList<Statement>();\n        final boolean isEnum = node.isEnum();\n        List<Statement> initStmtsAfterEnumValuesInit = new ArrayList<Statement>();\n        Set<String> explicitStaticPropsInEnum = new HashSet<String>();\n        if (isEnum) {\n            for (PropertyNode propNode : node.getProperties()) {\n                if (!propNode.isSynthetic() && propNode.getField().isStatic()) {\n                    explicitStaticPropsInEnum.add(propNode.getField().getName());\n                }\n            }\n            for (FieldNode fieldNode : node.getFields()) {\n                if (!fieldNode.isSynthetic() && fieldNode.isStatic() && fieldNode.getType() != node) {\n                    explicitStaticPropsInEnum.add(fieldNode.getName());\n                }\n            }\n        }\n\n        for (FieldNode fn : node.getFields()) {\n            addFieldInitialization(statements, staticStatements, fn, isEnum,\n                    initStmtsAfterEnumValuesInit, explicitStaticPropsInEnum);\n        }\n\n        statements.addAll(node.getObjectInitializerStatements());\n\n        Statement code = constructorNode.getCode();\n        BlockStatement block = new BlockStatement();\n        List<Statement> otherStatements = block.getStatements();\n        if (code instanceof BlockStatement) {\n            block = (BlockStatement) code;\n            otherStatements = block.getStatements();\n        } else if (code != null) {\n            otherStatements.add(code);\n        }\n        if (!otherStatements.isEmpty()) {\n            if (first != null) {\n                // it is super(..) since this(..) is already covered\n                otherStatements.remove(0);\n                statements.add(0, firstStatement);\n            }\n            Statement stmtThis$0 = getImplicitThis$0StmtIfInnerClass(otherStatements);\n            if (stmtThis$0 != null) {\n                // since there can be field init statements that depend on method/property dispatching\n                // that uses this$0, it needs to bubble up before the super call itself (GROOVY-4471)\n                statements.add(0, stmtThis$0);\n            }\n            statements.addAll(otherStatements);\n        }\n        BlockStatement newBlock = new BlockStatement(statements, block.getVariableScope());\n        newBlock.setSourcePosition(block);\n        constructorNode.setCode(newBlock);\n\n\n\n        if (!staticStatements.isEmpty()) {\n            if (isEnum) {\n                /*\n                 * GROOVY-3161: initialize statements for explicitly declared static fields\n                 * inside an enum should come after enum values are initialized\n                 */\n                staticStatements.removeAll(initStmtsAfterEnumValuesInit);\n                node.addStaticInitializerStatements(staticStatements, true);\n                if (!initStmtsAfterEnumValuesInit.isEmpty()) {\n                    node.positionStmtsAfterEnumInitStmts(initStmtsAfterEnumValuesInit);\n                }\n            } else {\n                node.addStaticInitializerStatements(staticStatements, true);\n            }\n        }\n    }",
            " 895  \n 896  \n 897  \n 898  \n 899  \n 900  \n 901  \n 902  \n 903  \n 904  \n 905  \n 906  \n 907  \n 908  \n 909  \n 910  \n 911  \n 912  \n 913  \n 914  \n 915  \n 916  \n 917  \n 918  \n 919  \n 920  \n 921  \n 922  \n 923  \n 924 +\n 925 +\n 926 +\n 927 +\n 928 +\n 929  \n 930  \n 931  \n 932  \n 933  \n 934  \n 935  \n 936  \n 937  \n 938  \n 939  \n 940  \n 941  \n 942  \n 943  \n 944  \n 945  \n 946  \n 947  \n 948  \n 949  \n 950  \n 951  \n 952  \n 953  \n 954  \n 955  \n 956  \n 957  \n 958  \n 959  \n 960  \n 961  \n 962  \n 963  \n 964  \n 965  \n 966  \n 967  \n 968  \n 969  \n 970  \n 971  \n 972  \n 973  \n 974  \n 975  \n 976  \n 977  ",
            "    protected void addInitialization(ClassNode node, ConstructorNode constructorNode) {\n        Statement firstStatement = constructorNode.getFirstStatement();\n        // if some transformation decided to generate constructor then it probably knows who it does\n        if (firstStatement instanceof BytecodeSequence)\n            return;\n\n        ConstructorCallExpression first = getFirstIfSpecialConstructorCall(firstStatement);\n\n        // in case of this(...) let the other constructor do the init\n        if (first != null && (first.isThisCall())) return;\n\n        List<Statement> statements = new ArrayList<Statement>();\n        List<Statement> staticStatements = new ArrayList<Statement>();\n        final boolean isEnum = node.isEnum();\n        List<Statement> initStmtsAfterEnumValuesInit = new ArrayList<Statement>();\n        Set<String> explicitStaticPropsInEnum = new HashSet<String>();\n        if (isEnum) {\n            for (PropertyNode propNode : node.getProperties()) {\n                if (!propNode.isSynthetic() && propNode.getField().isStatic()) {\n                    explicitStaticPropsInEnum.add(propNode.getField().getName());\n                }\n            }\n            for (FieldNode fieldNode : node.getFields()) {\n                if (!fieldNode.isSynthetic() && fieldNode.isStatic() && fieldNode.getType() != node) {\n                    explicitStaticPropsInEnum.add(fieldNode.getName());\n                }\n            }\n        }\n\n        if (!Traits.isTrait(node)) {\n            for (FieldNode fn : node.getFields()) {\n                addFieldInitialization(statements, staticStatements, fn, isEnum,\n                        initStmtsAfterEnumValuesInit, explicitStaticPropsInEnum);\n            }\n        }\n\n        statements.addAll(node.getObjectInitializerStatements());\n\n        Statement code = constructorNode.getCode();\n        BlockStatement block = new BlockStatement();\n        List<Statement> otherStatements = block.getStatements();\n        if (code instanceof BlockStatement) {\n            block = (BlockStatement) code;\n            otherStatements = block.getStatements();\n        } else if (code != null) {\n            otherStatements.add(code);\n        }\n        if (!otherStatements.isEmpty()) {\n            if (first != null) {\n                // it is super(..) since this(..) is already covered\n                otherStatements.remove(0);\n                statements.add(0, firstStatement);\n            }\n            Statement stmtThis$0 = getImplicitThis$0StmtIfInnerClass(otherStatements);\n            if (stmtThis$0 != null) {\n                // since there can be field init statements that depend on method/property dispatching\n                // that uses this$0, it needs to bubble up before the super call itself (GROOVY-4471)\n                statements.add(0, stmtThis$0);\n            }\n            statements.addAll(otherStatements);\n        }\n        BlockStatement newBlock = new BlockStatement(statements, block.getVariableScope());\n        newBlock.setSourcePosition(block);\n        constructorNode.setCode(newBlock);\n\n\n\n        if (!staticStatements.isEmpty()) {\n            if (isEnum) {\n                /*\n                 * GROOVY-3161: initialize statements for explicitly declared static fields\n                 * inside an enum should come after enum values are initialized\n                 */\n                staticStatements.removeAll(initStmtsAfterEnumValuesInit);\n                node.addStaticInitializerStatements(staticStatements, true);\n                if (!initStmtsAfterEnumValuesInit.isEmpty()) {\n                    node.positionStmtsAfterEnumInitStmts(initStmtsAfterEnumValuesInit);\n                }\n            } else {\n                node.addStaticInitializerStatements(staticStatements, true);\n            }\n        }\n    }"
        ],
        [
            "TraitComposer::applyTrait(ClassNode,ClassNode,TraitHelpersTuple)",
            " 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187 -\n 188 -\n 189 -\n 190 -\n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260 -\n 261  \n 262  \n 263  \n 264  \n 265  ",
            "    private static void applyTrait(final ClassNode trait, final ClassNode cNode, final TraitHelpersTuple helpers) {\n        ClassNode helperClassNode = helpers.getHelper();\n        ClassNode fieldHelperClassNode = helpers.getFieldHelper();\n        Map<String,ClassNode> genericsSpec = GenericsUtils.createGenericsSpec(cNode);\n        genericsSpec = GenericsUtils.createGenericsSpec(trait, genericsSpec);\n\n        for (MethodNode methodNode : helperClassNode.getAllDeclaredMethods()) {\n            String name = methodNode.getName();\n            Parameter[] helperMethodParams = methodNode.getParameters();\n            boolean isAbstract = methodNode.isAbstract();\n            if (!isAbstract && helperMethodParams.length > 0 && ((methodNode.getModifiers() & Opcodes.ACC_STATIC) == Opcodes.ACC_STATIC) && !name.contains(\"$\")) {\n                ArgumentListExpression argList = new ArgumentListExpression();\n                argList.addExpression(new VariableExpression(\"this\"));\n                Parameter[] origParams = new Parameter[helperMethodParams.length - 1];\n                Parameter[] params = new Parameter[helperMethodParams.length - 1];\n                System.arraycopy(methodNode.getParameters(), 1, params, 0, params.length);\n                Map<String,ClassNode> methodGenericsSpec = new LinkedHashMap<String, ClassNode>(genericsSpec);\n                MethodNode originalMethod = trait.getMethod(name, params);\n                // Original method may be null in case of a private method\n                GenericsType[] originalMethodGenericsTypes = originalMethod!=null?originalMethod.getGenericsTypes():null;\n                if (originalMethodGenericsTypes!=null) {\n                    for (GenericsType type : originalMethodGenericsTypes) {\n                        String gtTypeName = type.getName();\n                        if (!methodGenericsSpec.containsKey(gtTypeName)) {\n                            methodGenericsSpec.put(gtTypeName, type.getType());\n                        }\n                    }\n                }\n                for (int i = 1; i < helperMethodParams.length; i++) {\n                    Parameter parameter = helperMethodParams[i];\n                    ClassNode originType = parameter.getOriginType();\n                    ClassNode fixedType = correctToGenericsSpecRecurse(methodGenericsSpec, originType);\n                    Parameter newParam = new Parameter(fixedType, \"arg\" + i);\n                    List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n                    List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n                    GeneralUtils.copyAnnotatedNodeAnnotations(parameter, copied, notCopied);\n                    newParam.addAnnotations(copied);\n                    params[i - 1] = newParam;\n                    origParams[i-1] = parameter;\n                    argList.addExpression(new VariableExpression(params[i - 1]));\n                }\n                createForwarderMethod(trait, cNode, methodNode, originalMethod, helperClassNode, methodGenericsSpec, helperMethodParams, origParams, params, argList);\n            }\n        }\n        cNode.addObjectInitializerStatements(new ExpressionStatement(\n                new MethodCallExpression(\n                        new ClassExpression(helperClassNode),\n                        Traits.INIT_METHOD,\n                        new ArgumentListExpression(new VariableExpression(\"this\")))\n        ));\n        cNode.addStaticInitializerStatements(Collections.<Statement>singletonList(new ExpressionStatement(\n                new MethodCallExpression(\n                        new ClassExpression(helperClassNode),\n                        Traits.STATIC_INIT_METHOD,\n                        new ArgumentListExpression(new VariableExpression(\"this\")))\n        )), false);\n        if (fieldHelperClassNode != null && !cNode.declaresInterface(fieldHelperClassNode)) {\n            // we should implement the field helper interface too\n            cNode.addInterface(fieldHelperClassNode);\n            // implementation of methods\n            List<MethodNode> declaredMethods = fieldHelperClassNode.getAllDeclaredMethods();\n            Collections.sort(declaredMethods, GETTER_FIRST_COMPARATOR);\n            for (MethodNode methodNode : declaredMethods) {\n                String fieldName = methodNode.getName();\n                if (fieldName.endsWith(Traits.DIRECT_GETTER_SUFFIX) || fieldName.endsWith(Traits.DIRECT_SETTER_SUFFIX)) {\n                    int suffixIdx = fieldName.lastIndexOf(\"$\");\n                    fieldName = fieldName.substring(0, suffixIdx);\n                    String operation = methodNode.getName().substring(suffixIdx + 1);\n                    boolean getter = \"get\".equals(operation);\n                    ClassNode returnType = correctToGenericsSpecRecurse(genericsSpec, methodNode.getReturnType());\n                    int isStatic = 0;\n                    boolean publicField = true;\n                    FieldNode helperField = fieldHelperClassNode.getField(Traits.FIELD_PREFIX + Traits.PUBLIC_FIELD_PREFIX + fieldName);\n                    if (helperField==null) {\n                        publicField = false;\n                        helperField = fieldHelperClassNode.getField(Traits.FIELD_PREFIX + Traits.PRIVATE_FIELD_PREFIX + fieldName);\n                    }\n                    if (helperField==null) {\n                        publicField = true;\n                        // try to find a static one\n                        helperField = fieldHelperClassNode.getField(Traits.STATIC_FIELD_PREFIX+Traits.PUBLIC_FIELD_PREFIX+fieldName);\n                        if (helperField==null) {\n                            publicField = false;\n                            helperField = fieldHelperClassNode.getField(Traits.STATIC_FIELD_PREFIX+Traits.PRIVATE_FIELD_PREFIX +fieldName);\n                        }\n                        isStatic = Opcodes.ACC_STATIC;\n                    }\n                    if (getter) {\n                        // add field\n                        if (helperField!=null) {\n                            List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n                            List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n                            GeneralUtils.copyAnnotatedNodeAnnotations(helperField, copied, notCopied);\n                            FieldNode fieldNode = cNode.addField(fieldName, (publicField?Opcodes.ACC_PUBLIC:Opcodes.ACC_PRIVATE) | isStatic, returnType, null);\n                            fieldNode.addAnnotations(copied);\n                        }\n                    }\n                    Parameter[] newParams;\n                    if (getter) {\n                        newParams = Parameter.EMPTY_ARRAY;\n                    } else {\n                        ClassNode originType = methodNode.getParameters()[0].getOriginType();\n                        ClassNode fixedType = originType.isGenericsPlaceHolder()?ClassHelper.OBJECT_TYPE:correctToGenericsSpecRecurse(genericsSpec, originType);\n                        newParams = new Parameter[]{new Parameter(fixedType, \"val\")};\n                    }\n\n                    Expression fieldExpr = new VariableExpression(cNode.getField(fieldName));\n                    Statement body =\n                            getter ? new ReturnStatement(fieldExpr) :\n                                    new ExpressionStatement(\n                                            new BinaryExpression(\n                                                    fieldExpr,\n                                                    Token.newSymbol(Types.EQUAL, 0, 0),\n                                                    new VariableExpression(newParams[0])\n                                            )\n                                    );\n                    MethodNode impl = new MethodNode(\n                            methodNode.getName(),\n                            Opcodes.ACC_PUBLIC | isStatic,\n                            returnType,\n                            newParams,\n                            ClassNode.EMPTY_ARRAY,\n                            body\n                    );\n                    impl.addAnnotation(new AnnotationNode(COMPILESTATIC_CLASSNODE));\n                    cNode.addMethod(impl);\n                }\n            }\n        }\n    }",
            " 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188 +\n 189 +\n 190 +\n 191 +\n 192 +\n 193 +\n 194 +\n 195 +\n 196 +\n 197  \n 198 +\n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268 +\n 269 +\n 270 +\n 271  \n 272  \n 273  \n 274  \n 275  ",
            "    private static void applyTrait(final ClassNode trait, final ClassNode cNode, final TraitHelpersTuple helpers) {\n        ClassNode helperClassNode = helpers.getHelper();\n        ClassNode fieldHelperClassNode = helpers.getFieldHelper();\n        Map<String,ClassNode> genericsSpec = GenericsUtils.createGenericsSpec(cNode);\n        genericsSpec = GenericsUtils.createGenericsSpec(trait, genericsSpec);\n\n        for (MethodNode methodNode : helperClassNode.getAllDeclaredMethods()) {\n            String name = methodNode.getName();\n            Parameter[] helperMethodParams = methodNode.getParameters();\n            boolean isAbstract = methodNode.isAbstract();\n            if (!isAbstract && helperMethodParams.length > 0 && ((methodNode.getModifiers() & Opcodes.ACC_STATIC) == Opcodes.ACC_STATIC) && !name.contains(\"$\")) {\n                ArgumentListExpression argList = new ArgumentListExpression();\n                argList.addExpression(new VariableExpression(\"this\"));\n                Parameter[] origParams = new Parameter[helperMethodParams.length - 1];\n                Parameter[] params = new Parameter[helperMethodParams.length - 1];\n                System.arraycopy(methodNode.getParameters(), 1, params, 0, params.length);\n                Map<String,ClassNode> methodGenericsSpec = new LinkedHashMap<String, ClassNode>(genericsSpec);\n                MethodNode originalMethod = trait.getMethod(name, params);\n                // Original method may be null in case of a private method\n                GenericsType[] originalMethodGenericsTypes = originalMethod!=null?originalMethod.getGenericsTypes():null;\n                if (originalMethodGenericsTypes!=null) {\n                    for (GenericsType type : originalMethodGenericsTypes) {\n                        String gtTypeName = type.getName();\n                        if (!methodGenericsSpec.containsKey(gtTypeName)) {\n                            methodGenericsSpec.put(gtTypeName, type.getType());\n                        }\n                    }\n                }\n                for (int i = 1; i < helperMethodParams.length; i++) {\n                    Parameter parameter = helperMethodParams[i];\n                    ClassNode originType = parameter.getOriginType();\n                    ClassNode fixedType = correctToGenericsSpecRecurse(methodGenericsSpec, originType);\n                    Parameter newParam = new Parameter(fixedType, \"arg\" + i);\n                    List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n                    List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n                    GeneralUtils.copyAnnotatedNodeAnnotations(parameter, copied, notCopied);\n                    newParam.addAnnotations(copied);\n                    params[i - 1] = newParam;\n                    origParams[i-1] = parameter;\n                    argList.addExpression(new VariableExpression(params[i - 1]));\n                }\n                createForwarderMethod(trait, cNode, methodNode, originalMethod, helperClassNode, methodGenericsSpec, helperMethodParams, origParams, params, argList);\n            }\n        }\n        cNode.addObjectInitializerStatements(new ExpressionStatement(\n                new MethodCallExpression(\n                        new ClassExpression(helperClassNode),\n                        Traits.INIT_METHOD,\n                        new ArgumentListExpression(new VariableExpression(\"this\")))\n        ));\n        MethodCallExpression staticInitCall = new MethodCallExpression(\n                new ClassExpression(helperClassNode),\n                Traits.STATIC_INIT_METHOD,\n                new ArgumentListExpression(new ClassExpression(cNode)));\n        MethodNode staticInitMethod = new MethodNode(\n                Traits.STATIC_INIT_METHOD, Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC, ClassHelper.VOID_TYPE,\n                new Parameter[] {new Parameter(ClassHelper.CLASS_Type,\"clazz\")}, ClassNode.EMPTY_ARRAY, EmptyStatement.INSTANCE);\n        staticInitMethod.setDeclaringClass(helperClassNode);\n        staticInitCall.setMethodTarget(staticInitMethod);\n        cNode.addStaticInitializerStatements(Collections.<Statement>singletonList(new ExpressionStatement(\n                staticInitCall\n        )), false);\n        if (fieldHelperClassNode != null && !cNode.declaresInterface(fieldHelperClassNode)) {\n            // we should implement the field helper interface too\n            cNode.addInterface(fieldHelperClassNode);\n            // implementation of methods\n            List<MethodNode> declaredMethods = fieldHelperClassNode.getAllDeclaredMethods();\n            Collections.sort(declaredMethods, GETTER_FIRST_COMPARATOR);\n            for (MethodNode methodNode : declaredMethods) {\n                String fieldName = methodNode.getName();\n                if (fieldName.endsWith(Traits.DIRECT_GETTER_SUFFIX) || fieldName.endsWith(Traits.DIRECT_SETTER_SUFFIX)) {\n                    int suffixIdx = fieldName.lastIndexOf(\"$\");\n                    fieldName = fieldName.substring(0, suffixIdx);\n                    String operation = methodNode.getName().substring(suffixIdx + 1);\n                    boolean getter = \"get\".equals(operation);\n                    ClassNode returnType = correctToGenericsSpecRecurse(genericsSpec, methodNode.getReturnType());\n                    int isStatic = 0;\n                    boolean publicField = true;\n                    FieldNode helperField = fieldHelperClassNode.getField(Traits.FIELD_PREFIX + Traits.PUBLIC_FIELD_PREFIX + fieldName);\n                    if (helperField==null) {\n                        publicField = false;\n                        helperField = fieldHelperClassNode.getField(Traits.FIELD_PREFIX + Traits.PRIVATE_FIELD_PREFIX + fieldName);\n                    }\n                    if (helperField==null) {\n                        publicField = true;\n                        // try to find a static one\n                        helperField = fieldHelperClassNode.getField(Traits.STATIC_FIELD_PREFIX+Traits.PUBLIC_FIELD_PREFIX+fieldName);\n                        if (helperField==null) {\n                            publicField = false;\n                            helperField = fieldHelperClassNode.getField(Traits.STATIC_FIELD_PREFIX+Traits.PRIVATE_FIELD_PREFIX +fieldName);\n                        }\n                        isStatic = Opcodes.ACC_STATIC;\n                    }\n                    if (getter) {\n                        // add field\n                        if (helperField!=null) {\n                            List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n                            List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n                            GeneralUtils.copyAnnotatedNodeAnnotations(helperField, copied, notCopied);\n                            FieldNode fieldNode = cNode.addField(fieldName, (publicField?Opcodes.ACC_PUBLIC:Opcodes.ACC_PRIVATE) | isStatic, returnType, null);\n                            fieldNode.addAnnotations(copied);\n                        }\n                    }\n                    Parameter[] newParams;\n                    if (getter) {\n                        newParams = Parameter.EMPTY_ARRAY;\n                    } else {\n                        ClassNode originType = methodNode.getParameters()[0].getOriginType();\n                        ClassNode fixedType = originType.isGenericsPlaceHolder()?ClassHelper.OBJECT_TYPE:correctToGenericsSpecRecurse(genericsSpec, originType);\n                        newParams = new Parameter[]{new Parameter(fixedType, \"val\")};\n                    }\n\n                    Expression fieldExpr = new VariableExpression(cNode.getField(fieldName));\n                    Statement body =\n                            getter ? new ReturnStatement(fieldExpr) :\n                                    new ExpressionStatement(\n                                            new BinaryExpression(\n                                                    fieldExpr,\n                                                    Token.newSymbol(Types.EQUAL, 0, 0),\n                                                    new VariableExpression(newParams[0])\n                                            )\n                                    );\n                    MethodNode impl = new MethodNode(\n                            methodNode.getName(),\n                            Opcodes.ACC_PUBLIC | isStatic,\n                            returnType,\n                            newParams,\n                            ClassNode.EMPTY_ARRAY,\n                            body\n                    );\n                    AnnotationNode an = new AnnotationNode(COMPILESTATIC_CLASSNODE);\n                    impl.addAnnotation(an);\n                    cNode.addTransform(StaticCompileTransformation.class, an);\n                    cNode.addMethod(impl);\n                }\n            }\n        }\n    }"
        ],
        [
            "ClassCompletionVerifier::checkNoStaticMethodWithSameSignatureAsNonStatic(ClassNode)",
            "  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93 -\n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  ",
            "    private void checkNoStaticMethodWithSameSignatureAsNonStatic(final ClassNode node) {\n        Map<String, MethodNode> result = new HashMap<String, MethodNode>();\n        // add in unimplemented abstract methods from the interfaces\n        for (ClassNode iface : node.getInterfaces()) {\n            Map<String, MethodNode> ifaceMethodsMap = iface.getDeclaredMethodsMap();\n            for (String methSig : ifaceMethodsMap.keySet()) {\n                if (!result.containsKey(methSig)) {\n                    MethodNode methNode = ifaceMethodsMap.get(methSig);\n                    result.put(methSig, methNode);\n                }\n            }\n        }\n        for (MethodNode methodNode : node.getMethods()) {\n            MethodNode mn = result.get(methodNode.getTypeDescriptor());\n            if (mn!=null && methodNode.isStatic() && !methodNode.isStaticConstructor()) {\n                ClassNode cn = mn.getDeclaringClass().getOuterClass();\n                if (cn==null || !Traits.isTrait(cn)) {\n                    addError(\"Method '\" + mn.getName() + \"' is already defined in \" + getDescription(node) + \". You cannot have \" +\n                            \"both a static and a non static method with the same signature\", methodNode);\n                }\n            }\n            result.put(methodNode.getTypeDescriptor(), methodNode);\n        }\n    }",
            "  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93 +\n  94 +\n  95 +\n  96 +\n  97 +\n  98 +\n  99 +\n 100 +\n 101 +\n 102 +\n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  ",
            "    private void checkNoStaticMethodWithSameSignatureAsNonStatic(final ClassNode node) {\n        Map<String, MethodNode> result = new HashMap<String, MethodNode>();\n        // add in unimplemented abstract methods from the interfaces\n        for (ClassNode iface : node.getInterfaces()) {\n            Map<String, MethodNode> ifaceMethodsMap = iface.getDeclaredMethodsMap();\n            for (String methSig : ifaceMethodsMap.keySet()) {\n                if (!result.containsKey(methSig)) {\n                    MethodNode methNode = ifaceMethodsMap.get(methSig);\n                    result.put(methSig, methNode);\n                }\n            }\n        }\n        for (MethodNode methodNode : node.getMethods()) {\n            MethodNode mn = result.get(methodNode.getTypeDescriptor());\n            if (mn!=null && methodNode.isStatic() && !methodNode.isStaticConstructor()) {\n                ClassNode declaringClass = mn.getDeclaringClass();\n                ClassNode cn = declaringClass.getOuterClass();\n                if (cn==null && declaringClass.isResolved()) {\n                    // in case of a precompiled class, the outerclass is unknown\n                    Class typeClass = declaringClass.getTypeClass();\n                    typeClass = typeClass.getEnclosingClass();\n                    if (typeClass!=null) {\n                        cn = ClassHelper.make(typeClass);\n                    }\n                }\n                if (cn==null || !Traits.isTrait(cn)) {\n                    addError(\"Method '\" + mn.getName() + \"' is already defined in \" + getDescription(node) + \". You cannot have \" +\n                            \"both a static and a non static method with the same signature\", methodNode);\n                }\n            }\n            result.put(methodNode.getTypeDescriptor(), methodNode);\n        }\n    }"
        ],
        [
            "TraitASTTransformation::processField(FieldNode,MethodNode,MethodNode,ClassNode,ClassNode,Set)",
            " 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360 -\n 361 -\n 362 -\n 363 -\n 364 -\n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405  ",
            "    private void processField(final FieldNode field, final MethodNode initializer, final MethodNode staticInitializer, final ClassNode fieldHelper, final ClassNode trait, final Set<String> knownFields) {\n        Expression initialExpression = field.getInitialExpression();\n        MethodNode selectedMethod = field.isStatic()?staticInitializer:initializer;\n        if (initialExpression != null) {\n            VariableExpression thisObject = new VariableExpression(selectedMethod.getParameters()[0]);\n            ExpressionStatement initCode = new ExpressionStatement(initialExpression);\n            processBody(thisObject, selectedMethod, initCode, trait, fieldHelper, knownFields);\n            BlockStatement code = (BlockStatement) selectedMethod.getCode();\n            MethodCallExpression mce = new MethodCallExpression(\n                    new CastExpression(createReceiverType(field.isStatic(), fieldHelper), thisObject),\n                    Traits.helperSetterName(field),\n                    initCode.getExpression()\n            );\n            mce.setImplicitThis(false);\n            mce.setSourcePosition(initialExpression);\n            code.addStatement(new ExpressionStatement(mce));\n        }\n        // define setter/getter helper methods\n        fieldHelper.addMethod(\n                Traits.helperSetterName(field),\n                ACC_PUBLIC | ACC_ABSTRACT,\n                field.getOriginType(),\n                new Parameter[]{new Parameter(field.getOriginType(), \"val\")},\n                ClassNode.EMPTY_ARRAY,\n                null\n        );\n        fieldHelper.addMethod(\n                Traits.helperGetterName(field),\n                ACC_PUBLIC | ACC_ABSTRACT,\n                field.getOriginType(),\n                Parameter.EMPTY_ARRAY,\n                ClassNode.EMPTY_ARRAY,\n                null\n        );\n\n        // dummy fields are only used to carry annotations if instance field\n        // and to differentiate from static fields otherwise\n        String dummyFieldName = (field.isStatic() ? Traits.STATIC_FIELD_PREFIX : Traits.FIELD_PREFIX) +\n                (field.isPublic()? Traits.PUBLIC_FIELD_PREFIX : Traits.PRIVATE_FIELD_PREFIX)+\n                Traits.remappedFieldName(field.getOwner(), field.getName());\n        FieldNode dummyField = new FieldNode(\n                dummyFieldName,\n                ACC_STATIC | ACC_PUBLIC | ACC_FINAL | ACC_SYNTHETIC,\n                field.getOriginType(),\n                fieldHelper,\n                null\n        );\n        // copy annotations from field to dummy field\n        List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n        List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n        GeneralUtils.copyAnnotatedNodeAnnotations(field, copied, notCopied);\n        dummyField.addAnnotations(copied);\n        fieldHelper.addField(dummyField);\n    }",
            " 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371 +\n 372 +\n 373 +\n 374 +\n 375 +\n 376 +\n 377 +\n 378 +\n 379 +\n 380 +\n 381 +\n 382 +\n 383 +\n 384 +\n 385 +\n 386 +\n 387 +\n 388 +\n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  \n 423  \n 424  \n 425  \n 426  \n 427  \n 428  \n 429  ",
            "    private void processField(final FieldNode field, final MethodNode initializer, final MethodNode staticInitializer, final ClassNode fieldHelper, final ClassNode trait, final Set<String> knownFields) {\n        Expression initialExpression = field.getInitialExpression();\n        MethodNode selectedMethod = field.isStatic()?staticInitializer:initializer;\n        if (initialExpression != null) {\n            VariableExpression thisObject = new VariableExpression(selectedMethod.getParameters()[0]);\n            ExpressionStatement initCode = new ExpressionStatement(initialExpression);\n            processBody(thisObject, selectedMethod, initCode, trait, fieldHelper, knownFields);\n            BlockStatement code = (BlockStatement) selectedMethod.getCode();\n            MethodCallExpression mce;\n            if (field.isStatic()) {\n                mce = new MethodCallExpression(\n                        new ClassExpression(INVOKERHELPER_CLASSNODE),\n                        \"invokeStaticMethod\",\n                        new ArgumentListExpression(\n                                thisObject,\n                                new ConstantExpression(Traits.helperSetterName(field)),\n                                initCode.getExpression()\n                        )\n                );\n            } else {\n                mce = new MethodCallExpression(\n                        new CastExpression(createReceiverType(field.isStatic(), fieldHelper), thisObject),\n                        Traits.helperSetterName(field),\n                        initCode.getExpression()\n                );\n            }\n            mce.setImplicitThis(false);\n            mce.setSourcePosition(initialExpression);\n            code.addStatement(new ExpressionStatement(mce));\n        }\n        // define setter/getter helper methods\n        fieldHelper.addMethod(\n                Traits.helperSetterName(field),\n                ACC_PUBLIC | ACC_ABSTRACT,\n                field.getOriginType(),\n                new Parameter[]{new Parameter(field.getOriginType(), \"val\")},\n                ClassNode.EMPTY_ARRAY,\n                null\n        );\n        fieldHelper.addMethod(\n                Traits.helperGetterName(field),\n                ACC_PUBLIC | ACC_ABSTRACT,\n                field.getOriginType(),\n                Parameter.EMPTY_ARRAY,\n                ClassNode.EMPTY_ARRAY,\n                null\n        );\n\n        // dummy fields are only used to carry annotations if instance field\n        // and to differentiate from static fields otherwise\n        String dummyFieldName = (field.isStatic() ? Traits.STATIC_FIELD_PREFIX : Traits.FIELD_PREFIX) +\n                (field.isPublic()? Traits.PUBLIC_FIELD_PREFIX : Traits.PRIVATE_FIELD_PREFIX)+\n                Traits.remappedFieldName(field.getOwner(), field.getName());\n        FieldNode dummyField = new FieldNode(\n                dummyFieldName,\n                ACC_STATIC | ACC_PUBLIC | ACC_FINAL | ACC_SYNTHETIC,\n                field.getOriginType(),\n                fieldHelper,\n                null\n        );\n        // copy annotations from field to dummy field\n        List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n        List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n        GeneralUtils.copyAnnotatedNodeAnnotations(field, copied, notCopied);\n        dummyField.addAnnotations(copied);\n        fieldHelper.addField(dummyField);\n    }"
        ],
        [
            "Verifier::moveOptimizedConstantsInitialization(ClassNode)",
            "1403  \n1404 -\n1405  \n1406  \n1407  \n1408  \n1409  \n1410  \n1411  \n1412  \n1413  \n1414  \n1415  \n1416  \n1417  \n1418  \n1419  \n1420  \n1421  \n1422  \n1423  \n1424  \n1425  \n1426  \n1427  \n1428  \n1429  \n1430  \n1431  \n1432  \n1433  \n1434  \n1435  \n1436  \n1437  ",
            "    private boolean moveOptimizedConstantsInitialization(final ClassNode node) {\n        if (node.isInterface()) return false;\n\n        final int mods = Opcodes.ACC_STATIC|Opcodes.ACC_SYNTHETIC| Opcodes.ACC_PUBLIC;\n        String name = SWAP_INIT;\n        BlockStatement methodCode = new BlockStatement();\n\n        methodCode.addStatement(new SwapInitStatement());\n        boolean swapInitRequired = false;\n        for (FieldNode fn : node.getFields()) {\n            if (!fn.isStatic() || !fn.isSynthetic() || !fn.getName().startsWith(\"$const$\")) continue;\n            if (fn.getInitialExpression()==null) continue;\n            final FieldExpression fe = new FieldExpression(fn);\n            if (fn.getType().equals(ClassHelper.REFERENCE_TYPE)) fe.setUseReferenceDirectly(true);\n            ConstantExpression init = (ConstantExpression) fn.getInitialExpression();\n            ExpressionStatement statement =\n                    new ExpressionStatement(\n                            new BinaryExpression(\n                                    fe,\n                                    Token.newSymbol(Types.EQUAL, fn.getLineNumber(), fn.getColumnNumber()),\n                                    init));\n            fn.setInitialValueExpression(null);\n            init.setConstantName(null);\n            methodCode.addStatement(statement);\n            swapInitRequired = true;\n        }\n\n        if (swapInitRequired) {\n            node.addSyntheticMethod(\n                    name, mods, ClassHelper.VOID_TYPE,\n                    Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, methodCode);\n        }\n\n        return swapInitRequired;\n    }",
            "1405  \n1406 +\n1407  \n1408  \n1409  \n1410  \n1411  \n1412  \n1413  \n1414  \n1415  \n1416  \n1417  \n1418  \n1419  \n1420  \n1421  \n1422  \n1423  \n1424  \n1425  \n1426  \n1427  \n1428  \n1429  \n1430  \n1431  \n1432  \n1433  \n1434  \n1435  \n1436  \n1437  \n1438  \n1439  ",
            "    private boolean moveOptimizedConstantsInitialization(final ClassNode node) {\n        if (node.isInterface() && !Traits.isTrait(node)) return false;\n\n        final int mods = Opcodes.ACC_STATIC|Opcodes.ACC_SYNTHETIC| Opcodes.ACC_PUBLIC;\n        String name = SWAP_INIT;\n        BlockStatement methodCode = new BlockStatement();\n\n        methodCode.addStatement(new SwapInitStatement());\n        boolean swapInitRequired = false;\n        for (FieldNode fn : node.getFields()) {\n            if (!fn.isStatic() || !fn.isSynthetic() || !fn.getName().startsWith(\"$const$\")) continue;\n            if (fn.getInitialExpression()==null) continue;\n            final FieldExpression fe = new FieldExpression(fn);\n            if (fn.getType().equals(ClassHelper.REFERENCE_TYPE)) fe.setUseReferenceDirectly(true);\n            ConstantExpression init = (ConstantExpression) fn.getInitialExpression();\n            ExpressionStatement statement =\n                    new ExpressionStatement(\n                            new BinaryExpression(\n                                    fe,\n                                    Token.newSymbol(Types.EQUAL, fn.getLineNumber(), fn.getColumnNumber()),\n                                    init));\n            fn.setInitialValueExpression(null);\n            init.setConstantName(null);\n            methodCode.addStatement(statement);\n            swapInitRequired = true;\n        }\n\n        if (swapInitRequired) {\n            node.addSyntheticMethod(\n                    name, mods, ClassHelper.VOID_TYPE,\n                    Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, methodCode);\n        }\n\n        return swapInitRequired;\n    }"
        ],
        [
            "TraitASTTransformation::createInitMethod(boolean,ClassNode,ClassNode)",
            " 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  ",
            "    private MethodNode createInitMethod(final boolean isStatic, final ClassNode cNode, final ClassNode helper) {\n        MethodNode initializer = new MethodNode(\n                isStatic?Traits.STATIC_INIT_METHOD:Traits.INIT_METHOD,\n                ACC_STATIC | ACC_PUBLIC | ACC_SYNTHETIC,\n                ClassHelper.VOID_TYPE,\n                new Parameter[]{createSelfParameter(cNode, isStatic)},\n                ClassNode.EMPTY_ARRAY,\n                new BlockStatement()\n        );\n        fixGenerics(initializer, cNode);\n        helper.addMethod(initializer);\n        return initializer;\n    }",
            " 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230 +\n 231 +\n 232 +\n 233 +\n 234  \n 235  ",
            "    private MethodNode createInitMethod(final boolean isStatic, final ClassNode cNode, final ClassNode helper) {\n        MethodNode initializer = new MethodNode(\n                isStatic?Traits.STATIC_INIT_METHOD:Traits.INIT_METHOD,\n                ACC_STATIC | ACC_PUBLIC | ACC_SYNTHETIC,\n                ClassHelper.VOID_TYPE,\n                new Parameter[]{createSelfParameter(cNode, isStatic)},\n                ClassNode.EMPTY_ARRAY,\n                new BlockStatement()\n        );\n        fixGenerics(initializer, cNode);\n        helper.addMethod(initializer);\n        AnnotationNode an = new AnnotationNode(TraitComposer.COMPILESTATIC_CLASSNODE);\n        initializer.addAnnotation(an);\n        cNode.addTransform(StaticCompileTransformation.class, an);\n\n        return initializer;\n    }"
        ]
    ],
    "da41632bf05527d7860d0790e762c383ab9c2270": [
        [
            "MetaClassImpl::populateMethods(LinkedList,CachedClass)",
            " 351 -\n 352 -\n 353  \n 354  \n 355  \n 356  \n 357 -\n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380 -\n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  ",
            "    private void populateMethods(LinkedList superClasses, CachedClass firstGroovySuper) {\n        Iterator iter = superClasses.iterator();\n\n        MetaMethodIndex.Header header = metaMethodIndex.getHeader(firstGroovySuper.getTheClass());\n        CachedClass c;\n        for (; iter.hasNext();) {\n            c = (CachedClass) iter.next();\n\n            CachedMethod[] cachedMethods = c.getMethods();\n            for (CachedMethod metaMethod : cachedMethods) {\n                addToAllMethodsIfPublic(metaMethod);\n                if (!metaMethod.isPrivate() || c == firstGroovySuper)\n                    addMetaMethodToIndex(metaMethod, header);\n            }\n\n            MetaMethod[] cachedMethods1 = getNewMetaMethods(c);\n            for (final MetaMethod method : cachedMethods1) {\n                if (!newGroovyMethodsSet.contains(method)) {\n                    newGroovyMethodsSet.add(method);\n                    addMetaMethodToIndex(method, header);\n                }\n            }\n\n            if (c == firstGroovySuper)\n              break;\n        }\n\n        MetaMethodIndex.Header last = header;\n        for (;iter.hasNext();) {\n            c = (CachedClass) iter.next();\n            header = metaMethodIndex.getHeader(c.getTheClass());\n\n            if (last != null) {\n                metaMethodIndex.copyNonPrivateMethods(last, header);\n            }\n            last = header;\n\n            for (CachedMethod metaMethod : c.getMethods()) {\n                addToAllMethodsIfPublic(metaMethod);\n                addMetaMethodToIndex(metaMethod, header);\n            }\n\n            for (final MetaMethod method : getNewMetaMethods(c)) {\n                if (method.getName().equals(\"<init>\") && !method.getDeclaringClass().equals(theCachedClass)) continue;\n                if (!newGroovyMethodsSet.contains(method)) {\n                    newGroovyMethodsSet.add(method);\n                    addMetaMethodToIndex(method, header);\n                }\n            }\n        }\n    }",
            " 351 +\n 352  \n 353  \n 354  \n 355 +\n 356  \n 357 +\n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380 +\n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  ",
            "    private void populateMethods(LinkedList<CachedClass> superClasses, CachedClass firstGroovySuper) {\n\n        MetaMethodIndex.Header header = metaMethodIndex.getHeader(firstGroovySuper.getTheClass());\n        CachedClass c;\n        Iterator<CachedClass> iter = superClasses.iterator();\n        for (; iter.hasNext();) {\n            c = iter.next();\n\n            CachedMethod[] cachedMethods = c.getMethods();\n            for (CachedMethod metaMethod : cachedMethods) {\n                addToAllMethodsIfPublic(metaMethod);\n                if (!metaMethod.isPrivate() || c == firstGroovySuper)\n                    addMetaMethodToIndex(metaMethod, header);\n            }\n\n            MetaMethod[] cachedMethods1 = getNewMetaMethods(c);\n            for (final MetaMethod method : cachedMethods1) {\n                if (!newGroovyMethodsSet.contains(method)) {\n                    newGroovyMethodsSet.add(method);\n                    addMetaMethodToIndex(method, header);\n                }\n            }\n\n            if (c == firstGroovySuper)\n              break;\n        }\n\n        MetaMethodIndex.Header last = header;\n        for (;iter.hasNext();) {\n            c = iter.next();\n            header = metaMethodIndex.getHeader(c.getTheClass());\n\n            if (last != null) {\n                metaMethodIndex.copyNonPrivateMethods(last, header);\n            }\n            last = header;\n\n            for (CachedMethod metaMethod : c.getMethods()) {\n                addToAllMethodsIfPublic(metaMethod);\n                addMetaMethodToIndex(metaMethod, header);\n            }\n\n            for (final MetaMethod method : getNewMetaMethods(c)) {\n                if (method.getName().equals(\"<init>\") && !method.getDeclaringClass().equals(theCachedClass)) continue;\n                if (!newGroovyMethodsSet.contains(method)) {\n                    newGroovyMethodsSet.add(method);\n                    addMetaMethodToIndex(method, header);\n                }\n            }\n        }\n    }"
        ],
        [
            "MetaClassImpl::fillMethodIndex()",
            " 327  \n 328  \n 329  \n 330  \n 331  \n 332 -\n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344  \n 345  \n 346  \n 347  \n 348  \n 349  ",
            "    /**\n     * Fills the method index\n     */\n    private void fillMethodIndex() {\n        mainClassMethodHeader = metaMethodIndex.getHeader(theClass);\n        LinkedList superClasses = getSuperClasses();\n        CachedClass firstGroovySuper = calcFirstGroovySuperClass(superClasses);\n\n        Set<CachedClass> interfaces = theCachedClass.getInterfaces();\n        addInterfaceMethods(interfaces);\n\n        populateMethods(superClasses, firstGroovySuper);\n\n        inheritInterfaceNewMetaMethods(interfaces);\n        if (isGroovyObject) {\n          metaMethodIndex.copyMethodsToSuper();\n\n          connectMultimethods(superClasses, firstGroovySuper);\n          removeMultimethodsOverloadedWithPrivateMethods();\n\n          replaceWithMOPCalls(theCachedClass.mopMethods);\n        }\n    }",
            " 327  \n 328  \n 329  \n 330  \n 331  \n 332 +\n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344  \n 345  \n 346  \n 347  \n 348  \n 349  ",
            "    /**\n     * Fills the method index\n     */\n    private void fillMethodIndex() {\n        mainClassMethodHeader = metaMethodIndex.getHeader(theClass);\n        LinkedList<CachedClass> superClasses = getSuperClasses();\n        CachedClass firstGroovySuper = calcFirstGroovySuperClass(superClasses);\n\n        Set<CachedClass> interfaces = theCachedClass.getInterfaces();\n        addInterfaceMethods(interfaces);\n\n        populateMethods(superClasses, firstGroovySuper);\n\n        inheritInterfaceNewMetaMethods(interfaces);\n        if (isGroovyObject) {\n          metaMethodIndex.copyMethodsToSuper();\n\n          connectMultimethods(superClasses, firstGroovySuper);\n          removeMultimethodsOverloadedWithPrivateMethods();\n\n          replaceWithMOPCalls(theCachedClass.mopMethods);\n        }\n    }"
        ],
        [
            "MetaClassImpl::connectMultimethods(List,CachedClass)",
            " 632 -\n 633  \n 634  \n 635 -\n 636 -\n 637  \n 638  \n 639  \n 640  \n 641  \n 642  \n 643  \n 644  \n 645  \n 646  \n 647 -\n 648  \n 649  ",
            "    private void connectMultimethods(List superClasses, CachedClass firstGroovyClass) {\n        superClasses = DefaultGroovyMethods.reverse(superClasses);\n        MetaMethodIndex.Header last = null;\n        for (Iterator iter = superClasses.iterator(); iter.hasNext();) {\n            CachedClass c = (CachedClass) iter.next();\n            MetaMethodIndex.Header methodIndex = metaMethodIndex.getHeader(c.getTheClass());\n            // We don't copy DGM methods to superclasses' indexes\n            // The reason we can do that is particular set of DGM methods in use,\n            // if at some point we will define DGM method for some Groovy class or\n            // for a class derived from such, we will need to revise this condition.\n            // It saves us a lot of space and some noticeable time\n            if (last != null) metaMethodIndex.copyNonPrivateNonNewMetaMethods(last, methodIndex);\n            last = methodIndex;\n\n            if (c == firstGroovyClass)\n              break;\n        }\n    }",
            " 632 +\n 633  \n 634  \n 635 +\n 636  \n 637  \n 638  \n 639  \n 640  \n 641  \n 642  \n 643  \n 644  \n 645  \n 646 +\n 647  \n 648  ",
            "    private void connectMultimethods(List<CachedClass> superClasses, CachedClass firstGroovyClass) {\n        superClasses = DefaultGroovyMethods.reverse(superClasses);\n        MetaMethodIndex.Header last = null;\n        for (final CachedClass c : superClasses) {\n            MetaMethodIndex.Header methodIndex = metaMethodIndex.getHeader(c.getTheClass());\n            // We don't copy DGM methods to superclasses' indexes\n            // The reason we can do that is particular set of DGM methods in use,\n            // if at some point we will define DGM method for some Groovy class or\n            // for a class derived from such, we will need to revise this condition.\n            // It saves us a lot of space and some noticeable time\n            if (last != null) metaMethodIndex.copyNonPrivateNonNewMetaMethods(last, methodIndex);\n            last = methodIndex;\n\n            if (c == firstGroovyClass)\n                break;\n        }\n    }"
        ],
        [
            "ExpandoMetaClass::registerBeanPropertyForMethod(MetaMethod,String,boolean,boolean)",
            " 951  \n 952  \n 953  \n 954  \n 955  \n 956  \n 957  \n 958  \n 959  \n 960  \n 961  \n 962  \n 963  \n 964  \n 965  \n 966  \n 967  \n 968  \n 969  \n 970  \n 971  \n 972  \n 973  \n 974  \n 975  ",
            "    private void registerBeanPropertyForMethod(MetaMethod metaMethod, String propertyName, boolean getter, boolean isStatic) {\n        Map<String, MetaProperty> propertyCache = isStatic ? staticBeanPropertyCache : beanPropertyCache;\n        MetaBeanProperty beanProperty = (MetaBeanProperty) propertyCache.get(propertyName);\n        if (beanProperty == null) {\n            if (getter)\n                beanProperty = new MetaBeanProperty(propertyName, Object.class, metaMethod, null);\n            else\n                beanProperty = new MetaBeanProperty(propertyName, Object.class, null, metaMethod);\n\n            propertyCache.put(propertyName, beanProperty);\n        } else {\n            if (getter) {\n                MetaMethod setterMethod = beanProperty.getSetter();\n                Class type = setterMethod != null ? setterMethod.getParameterTypes()[0].getTheClass() : Object.class;\n                beanProperty = new MetaBeanProperty(propertyName, type, metaMethod, setterMethod);\n                propertyCache.put(propertyName, beanProperty);\n            } else {\n                MetaMethod getterMethod = beanProperty.getGetter();\n                beanProperty = new MetaBeanProperty(propertyName, metaMethod.getParameterTypes()[0].getTheClass(), getterMethod, metaMethod);\n                propertyCache.put(propertyName, beanProperty);\n            }\n        }\n        expandoProperties.put(beanProperty.getName(), beanProperty);\n        addMetaBeanProperty(beanProperty);\n    }",
            " 951  \n 952  \n 953  \n 954 +\n 955 +\n 956 +\n 957 +\n 958 +\n 959 +\n 960  \n 961  \n 962  \n 963  \n 964  \n 965  \n 966  \n 967  \n 968  \n 969  \n 970  \n 971  \n 972  \n 973  \n 974  \n 975  \n 976  \n 977  \n 978  \n 979  \n 980  \n 981  ",
            "    private void registerBeanPropertyForMethod(MetaMethod metaMethod, String propertyName, boolean getter, boolean isStatic) {\n        Map<String, MetaProperty> propertyCache = isStatic ? staticBeanPropertyCache : beanPropertyCache;\n        MetaBeanProperty beanProperty = (MetaBeanProperty) propertyCache.get(propertyName);\n        if (beanProperty==null) {\n            MetaProperty metaProperty = super.getMetaProperty(propertyName);\n            if (metaProperty instanceof MetaBeanProperty) {\n                beanProperty = (MetaBeanProperty) metaProperty;\n            }\n        }\n        if (beanProperty == null) {\n            if (getter)\n                beanProperty = new MetaBeanProperty(propertyName, Object.class, metaMethod, null);\n            else\n                beanProperty = new MetaBeanProperty(propertyName, Object.class, null, metaMethod);\n\n            propertyCache.put(propertyName, beanProperty);\n        } else {\n            if (getter) {\n                MetaMethod setterMethod = beanProperty.getSetter();\n                Class type = setterMethod != null ? setterMethod.getParameterTypes()[0].getTheClass() : Object.class;\n                beanProperty = new MetaBeanProperty(propertyName, type, metaMethod, setterMethod);\n                propertyCache.put(propertyName, beanProperty);\n            } else {\n                MetaMethod getterMethod = beanProperty.getGetter();\n                beanProperty = new MetaBeanProperty(propertyName, metaMethod.getParameterTypes()[0].getTheClass(), getterMethod, metaMethod);\n                propertyCache.put(propertyName, beanProperty);\n            }\n        }\n        expandoProperties.put(beanProperty.getName(), beanProperty);\n        addMetaBeanProperty(beanProperty);\n    }"
        ]
    ],
    "a1d85c855699239e076c8c7bc5c62399a1e3a0e7": [
        [
            "StaticTypesStatementWriter::writeIteratorBasedForEachLoop(CompileStack,OperandStack,MethodVisitor,ForStatement,Expression,ClassNode,Parameter)",
            " 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237 -\n 238  ",
            "    private void writeIteratorBasedForEachLoop(\n            CompileStack compileStack,\n            OperandStack operandStack,\n            MethodVisitor mv,\n            ForStatement loop,\n            Expression collectionExpression,\n            ClassNode collectionType,\n            Parameter loopVariable) {\n        // Declare the loop counter.\n        BytecodeVariable variable = compileStack.defineVariable(loopVariable, false);\n\n        if (StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(collectionType, ITERABLE_CLASSNODE)) {\n            MethodCallExpression iterator = new MethodCallExpression(collectionExpression, \"iterator\", new ArgumentListExpression());\n            iterator.setMethodTarget(collectionType.getMethod(\"iterator\", Parameter.EMPTY_ARRAY));\n            iterator.setImplicitThis(false);\n            iterator.visit(controller.getAcg());\n        } else {\n            collectionExpression.visit(controller.getAcg());\n            mv.visitMethodInsn(INVOKESTATIC, \"org/codehaus/groovy/runtime/DefaultGroovyMethods\", \"iterator\", \"(Ljava/lang/Object;)Ljava/util/Iterator;\", false);\n            operandStack.replace(ClassHelper.Iterator_TYPE);\n        }\n\n        // Then get the iterator and generate the loop control\n\n        int iteratorIdx = compileStack.defineTemporaryVariable(\"iterator\", ClassHelper.Iterator_TYPE, true);\n\n        Label continueLabel = compileStack.getContinueLabel();\n        Label breakLabel = compileStack.getBreakLabel();\n\n        mv.visitLabel(continueLabel);\n        mv.visitVarInsn(ALOAD, iteratorIdx);\n        writeIteratorHasNext(mv);\n        // note: ifeq tests for ==0, a boolean is 0 if it is false\n        mv.visitJumpInsn(IFEQ, breakLabel);\n\n        mv.visitVarInsn(ALOAD, iteratorIdx);\n        writeIteratorNext(mv);\n        operandStack.push(ClassHelper.OBJECT_TYPE);\n        operandStack.storeVar(variable);\n\n        // Generate the loop body\n        loop.getLoopBlock().visit(controller.getAcg());\n\n        mv.visitJumpInsn(GOTO, continueLabel);\n        mv.visitLabel(breakLabel);\n\n    }",
            " 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237 +\n 238  ",
            "    private void writeIteratorBasedForEachLoop(\n            CompileStack compileStack,\n            OperandStack operandStack,\n            MethodVisitor mv,\n            ForStatement loop,\n            Expression collectionExpression,\n            ClassNode collectionType,\n            Parameter loopVariable) {\n        // Declare the loop counter.\n        BytecodeVariable variable = compileStack.defineVariable(loopVariable, false);\n\n        if (StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(collectionType, ITERABLE_CLASSNODE)) {\n            MethodCallExpression iterator = new MethodCallExpression(collectionExpression, \"iterator\", new ArgumentListExpression());\n            iterator.setMethodTarget(collectionType.getMethod(\"iterator\", Parameter.EMPTY_ARRAY));\n            iterator.setImplicitThis(false);\n            iterator.visit(controller.getAcg());\n        } else {\n            collectionExpression.visit(controller.getAcg());\n            mv.visitMethodInsn(INVOKESTATIC, \"org/codehaus/groovy/runtime/DefaultGroovyMethods\", \"iterator\", \"(Ljava/lang/Object;)Ljava/util/Iterator;\", false);\n            operandStack.replace(ClassHelper.Iterator_TYPE);\n        }\n\n        // Then get the iterator and generate the loop control\n\n        int iteratorIdx = compileStack.defineTemporaryVariable(\"iterator\", ClassHelper.Iterator_TYPE, true);\n\n        Label continueLabel = compileStack.getContinueLabel();\n        Label breakLabel = compileStack.getBreakLabel();\n\n        mv.visitLabel(continueLabel);\n        mv.visitVarInsn(ALOAD, iteratorIdx);\n        writeIteratorHasNext(mv);\n        // note: ifeq tests for ==0, a boolean is 0 if it is false\n        mv.visitJumpInsn(IFEQ, breakLabel);\n\n        mv.visitVarInsn(ALOAD, iteratorIdx);\n        writeIteratorNext(mv);\n        operandStack.push(ClassHelper.OBJECT_TYPE);\n        operandStack.storeVar(variable);\n\n        // Generate the loop body\n        loop.getLoopBlock().visit(controller.getAcg());\n\n        mv.visitJumpInsn(GOTO, continueLabel);\n        mv.visitLabel(breakLabel);\n        compileStack.removeVar(iteratorIdx);\n    }"
        ],
        [
            "StatementWriter::writeReturn(ReturnStatement)",
            " 567  \n 568  \n 569  \n 570  \n 571  \n 572  \n 573  \n 574  \n 575  \n 576  \n 577  \n 578  \n 579  \n 580  \n 581  \n 582  \n 583  \n 584  \n 585  \n 586  \n 587  \n 588  \n 589  \n 590  \n 591  \n 592  \n 593  \n 594  \n 595  \n 596  \n 597  \n 598  ",
            "    public void writeReturn(ReturnStatement statement) {\n        controller.getAcg().onLineNumber(statement, \"visitReturnStatement\");\n        writeStatementLabel(statement);\n        MethodVisitor mv = controller.getMethodVisitor();\n        OperandStack operandStack = controller.getOperandStack();\n        ClassNode returnType = controller.getReturnType();\n\n        if (returnType == ClassHelper.VOID_TYPE) {\n            if (!(statement.isReturningNullOrVoid())) {\n                //TODO: move to Verifier\n                controller.getAcg().throwException(\"Cannot use return statement with an expression on a method that returns void\");\n            }\n            controller.getCompileStack().applyBlockRecorder();\n            mv.visitInsn(RETURN);\n            return;\n        }\n\n        Expression expression = statement.getExpression();\n        expression.visit(controller.getAcg());\n\n        operandStack.doGroovyCast(returnType);\n\n        if (controller.getCompileStack().hasBlockRecorder()) {\n            ClassNode type = operandStack.getTopOperand();\n            int returnValueIdx = controller.getCompileStack().defineTemporaryVariable(\"returnValue\", returnType, true);\n            controller.getCompileStack().applyBlockRecorder();\n            operandStack.load(type, returnValueIdx);\n        }\n\n        BytecodeHelper.doReturn(mv, returnType);\n        operandStack.remove(1);\n    }",
            " 571  \n 572  \n 573  \n 574  \n 575  \n 576  \n 577  \n 578  \n 579  \n 580  \n 581  \n 582  \n 583  \n 584  \n 585  \n 586  \n 587  \n 588  \n 589  \n 590  \n 591  \n 592  \n 593  \n 594  \n 595  \n 596  \n 597  \n 598 +\n 599  \n 600  \n 601  \n 602  \n 603  ",
            "    public void writeReturn(ReturnStatement statement) {\n        controller.getAcg().onLineNumber(statement, \"visitReturnStatement\");\n        writeStatementLabel(statement);\n        MethodVisitor mv = controller.getMethodVisitor();\n        OperandStack operandStack = controller.getOperandStack();\n        ClassNode returnType = controller.getReturnType();\n\n        if (returnType == ClassHelper.VOID_TYPE) {\n            if (!(statement.isReturningNullOrVoid())) {\n                //TODO: move to Verifier\n                controller.getAcg().throwException(\"Cannot use return statement with an expression on a method that returns void\");\n            }\n            controller.getCompileStack().applyBlockRecorder();\n            mv.visitInsn(RETURN);\n            return;\n        }\n\n        Expression expression = statement.getExpression();\n        expression.visit(controller.getAcg());\n\n        operandStack.doGroovyCast(returnType);\n\n        if (controller.getCompileStack().hasBlockRecorder()) {\n            ClassNode type = operandStack.getTopOperand();\n            int returnValueIdx = controller.getCompileStack().defineTemporaryVariable(\"returnValue\", returnType, true);\n            controller.getCompileStack().applyBlockRecorder();\n            operandStack.load(type, returnValueIdx);\n            controller.getCompileStack().removeVar(returnValueIdx);\n        }\n\n        BytecodeHelper.doReturn(mv, returnType);\n        operandStack.remove(1);\n    }"
        ],
        [
            "StatementWriter::writeSwitch(SwitchStatement)",
            " 419  \n 420  \n 421  \n 422  \n 423  \n 424  \n 425  \n 426  \n 427  \n 428 -\n 429  \n 430  \n 431  \n 432  \n 433  \n 434  \n 435  \n 436  \n 437  \n 438  \n 439  \n 440  \n 441  \n 442  \n 443  \n 444  \n 445  \n 446  \n 447  \n 448  ",
            "    public void writeSwitch(SwitchStatement statement) {\n        controller.getAcg().onLineNumber(statement, \"visitSwitch\");\n        writeStatementLabel(statement);\n\n        statement.getExpression().visit(controller.getAcg());\n\n        // switch does not have a continue label. use its parent's for continue\n        Label breakLabel = controller.getCompileStack().pushSwitch();\n\n        int switchVariableIndex = controller.getCompileStack().defineTemporaryVariable(\"switch\", true);\n\n        List caseStatements = statement.getCaseStatements();\n        int caseCount = caseStatements.size();\n        Label[] labels = new Label[caseCount + 1];\n        for (int i = 0; i < caseCount; i++) {\n            labels[i] = new Label();\n        }\n\n        int i = 0;\n        for (Iterator iter = caseStatements.iterator(); iter.hasNext(); i++) {\n            CaseStatement caseStatement = (CaseStatement) iter.next();\n            writeCaseStatement(caseStatement, switchVariableIndex, labels[i], labels[i + 1]);\n        }\n\n        statement.getDefaultStatement().visit(controller.getAcg());\n\n        controller.getMethodVisitor().visitLabel(breakLabel);\n\n        controller.getCompileStack().pop();   \n    }",
            " 421  \n 422  \n 423  \n 424  \n 425  \n 426  \n 427  \n 428  \n 429  \n 430 +\n 431  \n 432  \n 433  \n 434  \n 435  \n 436  \n 437  \n 438  \n 439  \n 440  \n 441  \n 442  \n 443  \n 444  \n 445  \n 446  \n 447  \n 448  \n 449 +\n 450  \n 451  ",
            "    public void writeSwitch(SwitchStatement statement) {\n        controller.getAcg().onLineNumber(statement, \"visitSwitch\");\n        writeStatementLabel(statement);\n\n        statement.getExpression().visit(controller.getAcg());\n\n        // switch does not have a continue label. use its parent's for continue\n        Label breakLabel = controller.getCompileStack().pushSwitch();\n\n        final int switchVariableIndex = controller.getCompileStack().defineTemporaryVariable(\"switch\", true);\n\n        List caseStatements = statement.getCaseStatements();\n        int caseCount = caseStatements.size();\n        Label[] labels = new Label[caseCount + 1];\n        for (int i = 0; i < caseCount; i++) {\n            labels[i] = new Label();\n        }\n\n        int i = 0;\n        for (Iterator iter = caseStatements.iterator(); iter.hasNext(); i++) {\n            CaseStatement caseStatement = (CaseStatement) iter.next();\n            writeCaseStatement(caseStatement, switchVariableIndex, labels[i], labels[i + 1]);\n        }\n\n        statement.getDefaultStatement().visit(controller.getAcg());\n\n        controller.getMethodVisitor().visitLabel(breakLabel);\n\n        controller.getCompileStack().removeVar(switchVariableIndex);\n        controller.getCompileStack().pop();   \n    }"
        ],
        [
            "StatementWriter::writeSynchronized(SynchronizedStatement)",
            " 502  \n 503  \n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512  \n 513  \n 514  \n 515  \n 516  \n 517  \n 518  \n 519  \n 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528  \n 529  \n 530  \n 531  \n 532  \n 533  \n 534  \n 535  \n 536  \n 537  \n 538  \n 539  \n 540  \n 541  \n 542  \n 543  \n 544  \n 545  ",
            "    public void writeSynchronized(SynchronizedStatement statement) {\n        controller.getAcg().onLineNumber(statement, \"visitSynchronizedStatement\");\n        writeStatementLabel(statement);\n        final MethodVisitor mv = controller.getMethodVisitor();\n        CompileStack compileStack = controller.getCompileStack();\n\n        statement.getExpression().visit(controller.getAcg());\n        controller.getOperandStack().box();\n        final int index = compileStack.defineTemporaryVariable(\"synchronized\", ClassHelper.OBJECT_TYPE, true);\n\n        final Label synchronizedStart = new Label();\n        final Label synchronizedEnd = new Label();\n        final Label catchAll = new Label();\n\n        mv.visitVarInsn(ALOAD, index);\n        mv.visitInsn(MONITORENTER);\n        mv.visitLabel(synchronizedStart);\n        // place holder for \"empty\" synchronized blocks, for example\n        // if there is only a break/continue.\n        mv.visitInsn(NOP);\n\n        Runnable finallyPart = new Runnable() {\n            public void run() {\n                mv.visitVarInsn(ALOAD, index);\n                mv.visitInsn(MONITOREXIT);\n            }\n        };\n        BlockRecorder fb = new BlockRecorder(finallyPart);\n        fb.startRange(synchronizedStart);\n        compileStack.pushBlockRecorder(fb);\n        statement.getCode().visit(controller.getAcg());\n\n        fb.closeRange(catchAll);\n        compileStack.writeExceptionTable(fb, catchAll, null);\n        compileStack.pop(); //pop fb\n\n        finallyPart.run();\n        mv.visitJumpInsn(GOTO, synchronizedEnd);\n        mv.visitLabel(catchAll);\n        finallyPart.run();\n        mv.visitInsn(ATHROW);\n\n        mv.visitLabel(synchronizedEnd);\n    }",
            " 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512  \n 513  \n 514  \n 515  \n 516  \n 517  \n 518  \n 519  \n 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528  \n 529  \n 530  \n 531  \n 532  \n 533  \n 534  \n 535  \n 536  \n 537  \n 538  \n 539  \n 540  \n 541  \n 542  \n 543  \n 544  \n 545  \n 546  \n 547  \n 548 +\n 549  ",
            "    public void writeSynchronized(SynchronizedStatement statement) {\n        controller.getAcg().onLineNumber(statement, \"visitSynchronizedStatement\");\n        writeStatementLabel(statement);\n        final MethodVisitor mv = controller.getMethodVisitor();\n        CompileStack compileStack = controller.getCompileStack();\n\n        statement.getExpression().visit(controller.getAcg());\n        controller.getOperandStack().box();\n        final int index = compileStack.defineTemporaryVariable(\"synchronized\", ClassHelper.OBJECT_TYPE, true);\n\n        final Label synchronizedStart = new Label();\n        final Label synchronizedEnd = new Label();\n        final Label catchAll = new Label();\n\n        mv.visitVarInsn(ALOAD, index);\n        mv.visitInsn(MONITORENTER);\n        mv.visitLabel(synchronizedStart);\n        // place holder for \"empty\" synchronized blocks, for example\n        // if there is only a break/continue.\n        mv.visitInsn(NOP);\n\n        Runnable finallyPart = new Runnable() {\n            public void run() {\n                mv.visitVarInsn(ALOAD, index);\n                mv.visitInsn(MONITOREXIT);\n            }\n        };\n        BlockRecorder fb = new BlockRecorder(finallyPart);\n        fb.startRange(synchronizedStart);\n        compileStack.pushBlockRecorder(fb);\n        statement.getCode().visit(controller.getAcg());\n\n        fb.closeRange(catchAll);\n        compileStack.writeExceptionTable(fb, catchAll, null);\n        compileStack.pop(); //pop fb\n\n        finallyPart.run();\n        mv.visitJumpInsn(GOTO, synchronizedEnd);\n        mv.visitLabel(catchAll);\n        finallyPart.run();\n        mv.visitInsn(ATHROW);\n\n        mv.visitLabel(synchronizedEnd);\n        compileStack.removeVar(index);\n    }"
        ],
        [
            "StatementWriter::writeForInLoop(ForStatement)",
            " 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  ",
            "    protected void writeForInLoop(ForStatement loop) {\n        controller.getAcg().onLineNumber(loop,\"visitForLoop\");\n        writeStatementLabel(loop);\n        \n        CompileStack compileStack = controller.getCompileStack();\n        MethodVisitor mv = controller.getMethodVisitor();\n        OperandStack operandStack = controller.getOperandStack();\n\n        compileStack.pushLoop(loop.getVariableScope(), loop.getStatementLabels());\n\n        // Declare the loop counter.\n        BytecodeVariable variable = compileStack.defineVariable(loop.getVariable(), false);\n\n        // Then get the iterator and generate the loop control\n        MethodCallExpression iterator = new MethodCallExpression(loop.getCollectionExpression(), \"iterator\", new ArgumentListExpression());\n        iterator.visit(controller.getAcg());\n        operandStack.doGroovyCast(ClassHelper.Iterator_TYPE);\n\n        final int iteratorIdx = compileStack.defineTemporaryVariable(\"iterator\", ClassHelper.Iterator_TYPE, true);\n\n        Label continueLabel = compileStack.getContinueLabel();\n        Label breakLabel = compileStack.getBreakLabel();\n\n        mv.visitLabel(continueLabel);\n        mv.visitVarInsn(ALOAD, iteratorIdx);\n        writeIteratorHasNext(mv);\n        // note: ifeq tests for ==0, a boolean is 0 if it is false\n        mv.visitJumpInsn(IFEQ, breakLabel);\n\n        mv.visitVarInsn(ALOAD, iteratorIdx);\n        writeIteratorNext(mv);\n        operandStack.push(ClassHelper.OBJECT_TYPE);\n        operandStack.storeVar(variable);\n\n        // Generate the loop body\n        loop.getLoopBlock().visit(controller.getAcg());\n\n        mv.visitJumpInsn(GOTO, continueLabel);\n        mv.visitLabel(breakLabel);\n\n        compileStack.pop();\n    }",
            " 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148 +\n 149  \n 150  ",
            "    protected void writeForInLoop(ForStatement loop) {\n        controller.getAcg().onLineNumber(loop,\"visitForLoop\");\n        writeStatementLabel(loop);\n        \n        CompileStack compileStack = controller.getCompileStack();\n        MethodVisitor mv = controller.getMethodVisitor();\n        OperandStack operandStack = controller.getOperandStack();\n\n        compileStack.pushLoop(loop.getVariableScope(), loop.getStatementLabels());\n\n        // Declare the loop counter.\n        BytecodeVariable variable = compileStack.defineVariable(loop.getVariable(), false);\n\n        // Then get the iterator and generate the loop control\n        MethodCallExpression iterator = new MethodCallExpression(loop.getCollectionExpression(), \"iterator\", new ArgumentListExpression());\n        iterator.visit(controller.getAcg());\n        operandStack.doGroovyCast(ClassHelper.Iterator_TYPE);\n\n        final int iteratorIdx = compileStack.defineTemporaryVariable(\"iterator\", ClassHelper.Iterator_TYPE, true);\n\n        Label continueLabel = compileStack.getContinueLabel();\n        Label breakLabel = compileStack.getBreakLabel();\n\n        mv.visitLabel(continueLabel);\n        mv.visitVarInsn(ALOAD, iteratorIdx);\n        writeIteratorHasNext(mv);\n        // note: ifeq tests for ==0, a boolean is 0 if it is false\n        mv.visitJumpInsn(IFEQ, breakLabel);\n\n        mv.visitVarInsn(ALOAD, iteratorIdx);\n        writeIteratorNext(mv);\n        operandStack.push(ClassHelper.OBJECT_TYPE);\n        operandStack.storeVar(variable);\n\n        // Generate the loop body\n        loop.getLoopBlock().visit(controller.getAcg());\n\n        mv.visitJumpInsn(GOTO, continueLabel);\n        mv.visitLabel(breakLabel);\n\n        compileStack.removeVar(iteratorIdx);\n        compileStack.pop();\n    }"
        ],
        [
            "StatementWriter::writeTryCatchFinally(TryCatchStatement)",
            " 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344  \n 345  \n 346  \n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393  \n 394 -\n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  ",
            "    public void writeTryCatchFinally(TryCatchStatement statement) {\n        controller.getAcg().onLineNumber(statement, \"visitTryCatchFinally\");\n        writeStatementLabel(statement);\n        \n        MethodVisitor mv = controller.getMethodVisitor();\n        CompileStack compileStack = controller.getCompileStack();\n        OperandStack operandStack = controller.getOperandStack();\n\n        Statement tryStatement = statement.getTryStatement();\n        final Statement finallyStatement = statement.getFinallyStatement();\n\n        // start try block, label needed for exception table\n        Label tryStart = new Label();\n        mv.visitLabel(tryStart);\n        BlockRecorder tryBlock = makeBlockRecorder(finallyStatement);\n        tryBlock.startRange(tryStart);\n\n        tryStatement.visit(controller.getAcg());\n\n        // goto finally part\n        Label finallyStart = new Label();\n        mv.visitJumpInsn(GOTO, finallyStart);\n\n        Label tryEnd = new Label();\n        mv.visitLabel(tryEnd);\n        tryBlock.closeRange(tryEnd);\n        // pop for \"makeBlockRecorder(finallyStatement)\"\n        controller.getCompileStack().pop();\n\n        BlockRecorder catches = makeBlockRecorder(finallyStatement);\n        for (CatchStatement catchStatement : statement.getCatchStatements()) {\n            ClassNode exceptionType = catchStatement.getExceptionType();\n            String exceptionTypeInternalName = BytecodeHelper.getClassInternalName(exceptionType);\n\n            // start catch block, label needed for exception table\n            Label catchStart = new Label();\n            mv.visitLabel(catchStart);\n            catches.startRange(catchStart);\n\n            // create exception variable and store the exception\n            Parameter exceptionVariable = catchStatement.getVariable();\n            compileStack.pushState();\n            compileStack.defineVariable(exceptionVariable, true);\n            // handle catch body\n            catchStatement.visit(controller.getAcg());\n            // place holder to avoid problems with empty catch blocks\n            mv.visitInsn(NOP);\n            // pop for the variable\n            controller.getCompileStack().pop();\n\n            // end of catch\n            Label catchEnd = new Label();\n            mv.visitLabel(catchEnd);\n            catches.closeRange(catchEnd);\n\n            // goto finally start\n            mv.visitJumpInsn(GOTO, finallyStart);\n            compileStack.writeExceptionTable(tryBlock, catchStart, exceptionTypeInternalName);\n        }\n\n        // Label used to handle exceptions in catches and regularly\n        // visited finals.\n        Label catchAny = new Label();\n\n        // add \"catch any\" block to exception table for try part we do this \n        // after the exception blocks, because else this one would supersede\n        // any of those otherwise\n        compileStack.writeExceptionTable(tryBlock, catchAny, null);\n        // same for the catch parts\n        compileStack.writeExceptionTable(catches, catchAny, null);\n\n        // pop for \"makeBlockRecorder(catches)\"\n        compileStack.pop();\n\n        // start finally\n        mv.visitLabel(finallyStart);\n        finallyStatement.visit(controller.getAcg());\n        mv.visitInsn(NOP);  //**\n\n        // goto after all-catching block\n        Label skipCatchAll = new Label();\n        mv.visitJumpInsn(GOTO, skipCatchAll);\n\n        // start a block catching any Exception\n        mv.visitLabel(catchAny);\n        //store exception\n        //TODO: maybe define a Throwable and use it here instead of Object\n        operandStack.push(ClassHelper.OBJECT_TYPE);\n        int anyExceptionIndex = compileStack.defineTemporaryVariable(\"exception\", true);\n\n        finallyStatement.visit(controller.getAcg());\n\n        // load the exception and rethrow it\n        mv.visitVarInsn(ALOAD, anyExceptionIndex);\n        mv.visitInsn(ATHROW);\n\n        mv.visitLabel(skipCatchAll);\n    }",
            " 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344  \n 345  \n 346  \n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395 +\n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404 +\n 405  ",
            "    public void writeTryCatchFinally(TryCatchStatement statement) {\n        controller.getAcg().onLineNumber(statement, \"visitTryCatchFinally\");\n        writeStatementLabel(statement);\n        \n        MethodVisitor mv = controller.getMethodVisitor();\n        CompileStack compileStack = controller.getCompileStack();\n        OperandStack operandStack = controller.getOperandStack();\n\n        Statement tryStatement = statement.getTryStatement();\n        final Statement finallyStatement = statement.getFinallyStatement();\n\n        // start try block, label needed for exception table\n        Label tryStart = new Label();\n        mv.visitLabel(tryStart);\n        BlockRecorder tryBlock = makeBlockRecorder(finallyStatement);\n        tryBlock.startRange(tryStart);\n\n        tryStatement.visit(controller.getAcg());\n\n        // goto finally part\n        Label finallyStart = new Label();\n        mv.visitJumpInsn(GOTO, finallyStart);\n\n        Label tryEnd = new Label();\n        mv.visitLabel(tryEnd);\n        tryBlock.closeRange(tryEnd);\n        // pop for \"makeBlockRecorder(finallyStatement)\"\n        controller.getCompileStack().pop();\n\n        BlockRecorder catches = makeBlockRecorder(finallyStatement);\n        for (CatchStatement catchStatement : statement.getCatchStatements()) {\n            ClassNode exceptionType = catchStatement.getExceptionType();\n            String exceptionTypeInternalName = BytecodeHelper.getClassInternalName(exceptionType);\n\n            // start catch block, label needed for exception table\n            Label catchStart = new Label();\n            mv.visitLabel(catchStart);\n            catches.startRange(catchStart);\n\n            // create exception variable and store the exception\n            Parameter exceptionVariable = catchStatement.getVariable();\n            compileStack.pushState();\n            compileStack.defineVariable(exceptionVariable, true);\n            // handle catch body\n            catchStatement.visit(controller.getAcg());\n            // place holder to avoid problems with empty catch blocks\n            mv.visitInsn(NOP);\n            // pop for the variable\n            controller.getCompileStack().pop();\n\n            // end of catch\n            Label catchEnd = new Label();\n            mv.visitLabel(catchEnd);\n            catches.closeRange(catchEnd);\n\n            // goto finally start\n            mv.visitJumpInsn(GOTO, finallyStart);\n            compileStack.writeExceptionTable(tryBlock, catchStart, exceptionTypeInternalName);\n        }\n\n        // Label used to handle exceptions in catches and regularly\n        // visited finals.\n        Label catchAny = new Label();\n\n        // add \"catch any\" block to exception table for try part we do this \n        // after the exception blocks, because else this one would supersede\n        // any of those otherwise\n        compileStack.writeExceptionTable(tryBlock, catchAny, null);\n        // same for the catch parts\n        compileStack.writeExceptionTable(catches, catchAny, null);\n\n        // pop for \"makeBlockRecorder(catches)\"\n        compileStack.pop();\n\n        // start finally\n        mv.visitLabel(finallyStart);\n        finallyStatement.visit(controller.getAcg());\n        mv.visitInsn(NOP);  //**\n\n        // goto after all-catching block\n        Label skipCatchAll = new Label();\n        mv.visitJumpInsn(GOTO, skipCatchAll);\n\n        // start a block catching any Exception\n        mv.visitLabel(catchAny);\n        //store exception\n        //TODO: maybe define a Throwable and use it here instead of Object\n        operandStack.push(ClassHelper.OBJECT_TYPE);\n        final int anyExceptionIndex = compileStack.defineTemporaryVariable(\"exception\", true);\n\n        finallyStatement.visit(controller.getAcg());\n\n        // load the exception and rethrow it\n        mv.visitVarInsn(ALOAD, anyExceptionIndex);\n        mv.visitInsn(ATHROW);\n\n        mv.visitLabel(skipCatchAll);\n        compileStack.removeVar(anyExceptionIndex);\n    }"
        ],
        [
            "StaticInvocationWriter::makeCall(Expression,Expression,Expression,Expression,MethodCallerMultiAdapter,boolean,boolean,boolean)",
            " 430  \n 431  \n 432  \n 433  \n 434  \n 435  \n 436  \n 437  \n 438  \n 439  \n 440  \n 441  \n 442  \n 443  \n 444  \n 445  \n 446  \n 447  \n 448  \n 449  \n 450  \n 451  \n 452  \n 453  \n 454  \n 455  \n 456  \n 457  \n 458  \n 459  \n 460  \n 461  \n 462  \n 463  \n 464  \n 465  \n 466  \n 467  \n 468  \n 469  \n 470  \n 471  \n 472  \n 473  \n 474  \n 475  \n 476  \n 477  \n 478  \n 479  \n 480  \n 481  \n 482  \n 483  \n 484  \n 485  \n 486  \n 487  \n 488  \n 489  \n 490  \n 491  \n 492  \n 493  \n 494  \n 495  \n 496  \n 497  \n 498  \n 499  \n 500  \n 501  \n 502  \n 503  \n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512  \n 513  \n 514  \n 515  \n 516  \n 517  \n 518  \n 519  \n 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528  \n 529  \n 530  \n 531  \n 532  \n 533  \n 534  \n 535  \n 536  \n 537  \n 538  \n 539  \n 540  \n 541  \n 542  \n 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  ",
            "    @Override\n    public void makeCall(final Expression origin, final Expression receiver, final Expression message, final Expression arguments, final MethodCallerMultiAdapter adapter, final boolean safe, final boolean spreadSafe, final boolean implicitThis) {\n        ClassNode dynamicCallReturnType = origin.getNodeMetaData(StaticTypesMarker.DYNAMIC_RESOLUTION);\n        if (dynamicCallReturnType !=null) {\n            StaticTypesWriterController staticController = (StaticTypesWriterController) controller;\n            if (origin instanceof MethodCallExpression) {\n                ((MethodCallExpression) origin).setMethodTarget(null);\n            }\n            InvocationWriter dynamicInvocationWriter = staticController.getRegularInvocationWriter();\n            dynamicInvocationWriter.\n                    makeCall(origin, receiver, message, arguments, adapter, safe, spreadSafe, implicitThis);\n            return;\n        }\n        if (tryImplicitReceiver(origin, message, arguments, adapter, safe, spreadSafe, implicitThis)) {\n            return;\n        }\n        // if call is spread safe, replace it with a for in loop\n        if (spreadSafe && origin instanceof MethodCallExpression) {\n            MethodVisitor mv = controller.getMethodVisitor();\n            CompileStack compileStack = controller.getCompileStack();\n            TypeChooser typeChooser = controller.getTypeChooser();\n            OperandStack operandStack = controller.getOperandStack();\n            ClassNode classNode = controller.getClassNode();\n            int counter = labelCounter.incrementAndGet();\n\n            // create an empty arraylist\n            VariableExpression result = new VariableExpression(\n                    \"spreadresult\" + counter,\n                    StaticCompilationVisitor.ARRAYLIST_CLASSNODE\n            );\n            ConstructorCallExpression cce = new ConstructorCallExpression(StaticCompilationVisitor.ARRAYLIST_CLASSNODE, ArgumentListExpression.EMPTY_ARGUMENTS);\n            cce.setNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET, StaticCompilationVisitor.ARRAYLIST_CONSTRUCTOR);\n            DeclarationExpression declr = new DeclarationExpression(\n                    result,\n                    Token.newSymbol(\"=\", origin.getLineNumber(), origin.getColumnNumber()),\n                    cce\n            );\n            declr.visit(controller.getAcg());\n            operandStack.pop();\n            // if (receiver != null)\n            receiver.visit(controller.getAcg());\n            Label ifnull = compileStack.createLocalLabel(\"ifnull_\" + counter);\n            mv.visitJumpInsn(IFNULL, ifnull);\n            operandStack.remove(1); // receiver consumed by if()\n            Label nonull = compileStack.createLocalLabel(\"nonull_\" + counter);\n            mv.visitLabel(nonull);\n            ClassNode componentType = StaticTypeCheckingVisitor.inferLoopElementType(typeChooser.resolveType(receiver, classNode));\n            Parameter iterator = new Parameter(componentType, \"for$it$\" + counter);\n            VariableExpression iteratorAsVar = new VariableExpression(iterator);\n            MethodCallExpression origMCE = (MethodCallExpression) origin;\n            MethodCallExpression newMCE = new MethodCallExpression(\n                    iteratorAsVar,\n                    origMCE.getMethodAsString(),\n                    origMCE.getArguments()\n            );\n            newMCE.setImplicitThis(false);\n            newMCE.setMethodTarget(origMCE.getMethodTarget());\n            newMCE.setSafe(true);\n            MethodCallExpression add = new MethodCallExpression(\n                    result,\n                    \"add\",\n                    newMCE\n            );\n            add.setImplicitThis(false);\n            add.setMethodTarget(StaticCompilationVisitor.ARRAYLIST_ADD_METHOD);\n            // for (e in receiver) { result.add(e?.method(arguments) }\n            ForStatement stmt = new ForStatement(\n                    iterator,\n                    receiver,\n                    new ExpressionStatement(add)\n            );\n            stmt.visit(controller.getAcg());\n            // else { empty list }\n            mv.visitLabel(ifnull);\n\n            // end of if/else\n            // return result list\n            result.visit(controller.getAcg());\n        } else if (safe && origin instanceof MethodCallExpression) {\n            // wrap call in an IFNULL check\n            MethodVisitor mv = controller.getMethodVisitor();\n            CompileStack compileStack = controller.getCompileStack();\n            OperandStack operandStack = controller.getOperandStack();\n            int counter = labelCounter.incrementAndGet();\n            // if (receiver != null)\n            ExpressionAsVariableSlot slot = new ExpressionAsVariableSlot(controller, receiver);\n            slot.visit(controller.getAcg());\n            operandStack.box();\n            Label ifnull = compileStack.createLocalLabel(\"ifnull_\" + counter);\n            mv.visitJumpInsn(IFNULL, ifnull);\n            operandStack.remove(1); // receiver consumed by if()\n            Label nonull = compileStack.createLocalLabel(\"nonull_\" + counter);\n            mv.visitLabel(nonull);\n            MethodCallExpression origMCE = (MethodCallExpression) origin;\n            MethodCallExpression newMCE = new MethodCallExpression(\n                    new VariableSlotLoader(slot.getType(), slot.getIndex(), controller.getOperandStack()),\n                    origMCE.getMethodAsString(),\n                    origMCE.getArguments()\n            );\n            MethodNode methodTarget = origMCE.getMethodTarget();\n            newMCE.setMethodTarget(methodTarget);\n            newMCE.setSafe(false);\n            newMCE.setImplicitThis(origMCE.isImplicitThis());\n            newMCE.setSourcePosition(origMCE);\n            newMCE.visit(controller.getAcg());\n            compileStack.removeVar(slot.getIndex());\n            ClassNode returnType = operandStack.getTopOperand();\n            if (ClassHelper.isPrimitiveType(returnType) && !ClassHelper.VOID_TYPE.equals(returnType)) {\n                operandStack.box();\n            }\n            Label endof = compileStack.createLocalLabel(\"endof_\" + counter);\n            mv.visitJumpInsn(GOTO, endof);\n            mv.visitLabel(ifnull);\n            // else { null }\n            mv.visitInsn(ACONST_NULL);\n            mv.visitLabel(endof);\n        } else {\n            if ((adapter == AsmClassGenerator.getGroovyObjectField\n                    || adapter == AsmClassGenerator.getField ) && origin instanceof AttributeExpression) {\n                String pname = ((PropertyExpression) origin).getPropertyAsString();\n                CallSiteWriter callSiteWriter = controller.getCallSiteWriter();\n                if (pname!=null && callSiteWriter instanceof StaticTypesCallSiteWriter) {\n                    StaticTypesCallSiteWriter stcsw = (StaticTypesCallSiteWriter) callSiteWriter;\n                    TypeChooser typeChooser = controller.getTypeChooser();\n                    if (stcsw.makeGetField(receiver, typeChooser.resolveType(receiver, controller.getClassNode()), pname, safe, false, true)) {\n                        return;\n                    }\n                }\n            }\n            super.makeCall(origin, receiver, message, arguments, adapter, safe, spreadSafe, implicitThis);\n        }\n    }",
            " 431  \n 432  \n 433  \n 434  \n 435  \n 436  \n 437  \n 438  \n 439  \n 440  \n 441  \n 442  \n 443  \n 444  \n 445  \n 446  \n 447  \n 448  \n 449 +\n 450 +\n 451 +\n 452 +\n 453 +\n 454 +\n 455 +\n 456  \n 457  \n 458  \n 459  \n 460  \n 461  \n 462  \n 463  \n 464  \n 465  \n 466  \n 467  \n 468  \n 469  \n 470  \n 471  \n 472  \n 473  \n 474  \n 475  \n 476  \n 477  \n 478  \n 479  \n 480  \n 481  \n 482  \n 483  \n 484  \n 485  \n 486  \n 487  \n 488  \n 489  \n 490  \n 491  \n 492  \n 493  \n 494  \n 495  \n 496  \n 497  \n 498  \n 499  \n 500  \n 501  \n 502  \n 503  \n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512  \n 513  \n 514  \n 515  \n 516  \n 517  \n 518  \n 519  \n 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528  \n 529  \n 530  \n 531  \n 532  \n 533  \n 534  \n 535  \n 536  \n 537  \n 538  \n 539  \n 540  \n 541  \n 542  \n 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564  \n 565  \n 566  \n 567  \n 568  \n 569  ",
            "    @Override\n    public void makeCall(final Expression origin, final Expression receiver, final Expression message, final Expression arguments, final MethodCallerMultiAdapter adapter, final boolean safe, final boolean spreadSafe, final boolean implicitThis) {\n        ClassNode dynamicCallReturnType = origin.getNodeMetaData(StaticTypesMarker.DYNAMIC_RESOLUTION);\n        if (dynamicCallReturnType !=null) {\n            StaticTypesWriterController staticController = (StaticTypesWriterController) controller;\n            if (origin instanceof MethodCallExpression) {\n                ((MethodCallExpression) origin).setMethodTarget(null);\n            }\n            InvocationWriter dynamicInvocationWriter = staticController.getRegularInvocationWriter();\n            dynamicInvocationWriter.\n                    makeCall(origin, receiver, message, arguments, adapter, safe, spreadSafe, implicitThis);\n            return;\n        }\n        if (tryImplicitReceiver(origin, message, arguments, adapter, safe, spreadSafe, implicitThis)) {\n            return;\n        }\n        // if call is spread safe, replace it with a for in loop\n        if (spreadSafe && origin instanceof MethodCallExpression) {\n            // List literals should not be visited twice, avoid by using a temporary variable for the receiver\n            if (receiver instanceof ListExpression) {\n                TemporaryVariableExpression tmp = new TemporaryVariableExpression(receiver);\n                makeCall(origin, tmp, message, arguments, adapter, true, true, false);\n                tmp.remove(controller);\n                return;\n            }\n            MethodVisitor mv = controller.getMethodVisitor();\n            CompileStack compileStack = controller.getCompileStack();\n            TypeChooser typeChooser = controller.getTypeChooser();\n            OperandStack operandStack = controller.getOperandStack();\n            ClassNode classNode = controller.getClassNode();\n            int counter = labelCounter.incrementAndGet();\n\n            // create an empty arraylist\n            VariableExpression result = new VariableExpression(\n                    \"spreadresult\" + counter,\n                    StaticCompilationVisitor.ARRAYLIST_CLASSNODE\n            );\n            ConstructorCallExpression cce = new ConstructorCallExpression(StaticCompilationVisitor.ARRAYLIST_CLASSNODE, ArgumentListExpression.EMPTY_ARGUMENTS);\n            cce.setNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET, StaticCompilationVisitor.ARRAYLIST_CONSTRUCTOR);\n            DeclarationExpression declr = new DeclarationExpression(\n                    result,\n                    Token.newSymbol(\"=\", origin.getLineNumber(), origin.getColumnNumber()),\n                    cce\n            );\n            declr.visit(controller.getAcg());\n            operandStack.pop();\n            // if (receiver != null)\n            receiver.visit(controller.getAcg());\n            Label ifnull = compileStack.createLocalLabel(\"ifnull_\" + counter);\n            mv.visitJumpInsn(IFNULL, ifnull);\n            operandStack.remove(1); // receiver consumed by if()\n            Label nonull = compileStack.createLocalLabel(\"nonull_\" + counter);\n            mv.visitLabel(nonull);\n            ClassNode componentType = StaticTypeCheckingVisitor.inferLoopElementType(typeChooser.resolveType(receiver, classNode));\n            Parameter iterator = new Parameter(componentType, \"for$it$\" + counter);\n            VariableExpression iteratorAsVar = new VariableExpression(iterator);\n            MethodCallExpression origMCE = (MethodCallExpression) origin;\n            MethodCallExpression newMCE = new MethodCallExpression(\n                    iteratorAsVar,\n                    origMCE.getMethodAsString(),\n                    origMCE.getArguments()\n            );\n            newMCE.setImplicitThis(false);\n            newMCE.setMethodTarget(origMCE.getMethodTarget());\n            newMCE.setSafe(true);\n            MethodCallExpression add = new MethodCallExpression(\n                    result,\n                    \"add\",\n                    newMCE\n            );\n            add.setImplicitThis(false);\n            add.setMethodTarget(StaticCompilationVisitor.ARRAYLIST_ADD_METHOD);\n            // for (e in receiver) { result.add(e?.method(arguments) }\n            ForStatement stmt = new ForStatement(\n                    iterator,\n                    receiver,\n                    new ExpressionStatement(add)\n            );\n            stmt.visit(controller.getAcg());\n            // else { empty list }\n            mv.visitLabel(ifnull);\n\n            // end of if/else\n            // return result list\n            result.visit(controller.getAcg());\n        } else if (safe && origin instanceof MethodCallExpression) {\n            // wrap call in an IFNULL check\n            MethodVisitor mv = controller.getMethodVisitor();\n            CompileStack compileStack = controller.getCompileStack();\n            OperandStack operandStack = controller.getOperandStack();\n            int counter = labelCounter.incrementAndGet();\n            // if (receiver != null)\n            ExpressionAsVariableSlot slot = new ExpressionAsVariableSlot(controller, receiver);\n            slot.visit(controller.getAcg());\n            operandStack.box();\n            Label ifnull = compileStack.createLocalLabel(\"ifnull_\" + counter);\n            mv.visitJumpInsn(IFNULL, ifnull);\n            operandStack.remove(1); // receiver consumed by if()\n            Label nonull = compileStack.createLocalLabel(\"nonull_\" + counter);\n            mv.visitLabel(nonull);\n            MethodCallExpression origMCE = (MethodCallExpression) origin;\n            MethodCallExpression newMCE = new MethodCallExpression(\n                    new VariableSlotLoader(slot.getType(), slot.getIndex(), controller.getOperandStack()),\n                    origMCE.getMethodAsString(),\n                    origMCE.getArguments()\n            );\n            MethodNode methodTarget = origMCE.getMethodTarget();\n            newMCE.setMethodTarget(methodTarget);\n            newMCE.setSafe(false);\n            newMCE.setImplicitThis(origMCE.isImplicitThis());\n            newMCE.setSourcePosition(origMCE);\n            newMCE.visit(controller.getAcg());\n            compileStack.removeVar(slot.getIndex());\n            ClassNode returnType = operandStack.getTopOperand();\n            if (ClassHelper.isPrimitiveType(returnType) && !ClassHelper.VOID_TYPE.equals(returnType)) {\n                operandStack.box();\n            }\n            Label endof = compileStack.createLocalLabel(\"endof_\" + counter);\n            mv.visitJumpInsn(GOTO, endof);\n            mv.visitLabel(ifnull);\n            // else { null }\n            mv.visitInsn(ACONST_NULL);\n            mv.visitLabel(endof);\n        } else {\n            if ((adapter == AsmClassGenerator.getGroovyObjectField\n                    || adapter == AsmClassGenerator.getField ) && origin instanceof AttributeExpression) {\n                String pname = ((PropertyExpression) origin).getPropertyAsString();\n                CallSiteWriter callSiteWriter = controller.getCallSiteWriter();\n                if (pname!=null && callSiteWriter instanceof StaticTypesCallSiteWriter) {\n                    StaticTypesCallSiteWriter stcsw = (StaticTypesCallSiteWriter) callSiteWriter;\n                    TypeChooser typeChooser = controller.getTypeChooser();\n                    if (stcsw.makeGetField(receiver, typeChooser.resolveType(receiver, controller.getClassNode()), pname, safe, false, true)) {\n                        return;\n                    }\n                }\n            }\n            super.makeCall(origin, receiver, message, arguments, adapter, safe, spreadSafe, implicitThis);\n        }\n    }"
        ]
    ],
    "eb1a2b029278b707a2a989ddfaf3cd8b800888d2": [
        [
            "TraitComposer::applyTrait(ClassNode,ClassNode,TraitHelpersTuple)",
            " 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235 -\n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248 -\n 249  \n 250 -\n 251 -\n 252  \n 253  \n 254  \n 255 -\n 256  \n 257  \n 258 -\n 259 -\n 260 -\n 261 -\n 262 -\n 263 -\n 264 -\n 265 -\n 266 -\n 267 -\n 268 -\n 269 -\n 270  \n 271  \n 272  \n 273  ",
            "    private static void applyTrait(final ClassNode trait, final ClassNode cNode, final TraitHelpersTuple helpers) {\n        ClassNode helperClassNode = helpers.getHelper();\n        ClassNode fieldHelperClassNode = helpers.getFieldHelper();\n        Map<String,ClassNode> genericsSpec = GenericsUtils.createGenericsSpec(cNode);\n        genericsSpec = GenericsUtils.createGenericsSpec(trait, genericsSpec);\n\n        for (MethodNode methodNode : helperClassNode.getAllDeclaredMethods()) {\n            String name = methodNode.getName();\n            Parameter[] helperMethodParams = methodNode.getParameters();\n            boolean isAbstract = methodNode.isAbstract();\n            if (!isAbstract && helperMethodParams.length > 0 && ((methodNode.getModifiers() & Opcodes.ACC_STATIC) == Opcodes.ACC_STATIC) && (!name.contains(\"$\") || (methodNode.getModifiers() & Opcodes.ACC_SYNTHETIC) == 0)) {\n                ArgumentListExpression argList = new ArgumentListExpression();\n                argList.addExpression(new VariableExpression(\"this\"));\n                Parameter[] origParams = new Parameter[helperMethodParams.length - 1];\n                Parameter[] params = new Parameter[helperMethodParams.length - 1];\n                System.arraycopy(methodNode.getParameters(), 1, params, 0, params.length);\n                Map<String,ClassNode> methodGenericsSpec = new LinkedHashMap<String, ClassNode>(genericsSpec);\n                MethodNode originalMethod = trait.getMethod(name, params);\n                // Original method may be null for the case of private or static methods\n                if (originalMethod!=null) {\n                    methodGenericsSpec = GenericsUtils.addMethodGenerics(originalMethod, methodGenericsSpec);\n                }\n                for (int i = 1; i < helperMethodParams.length; i++) {\n                    Parameter parameter = helperMethodParams[i];\n                    ClassNode originType = parameter.getOriginType();\n                    ClassNode fixedType = correctToGenericsSpecRecurse(methodGenericsSpec, originType);\n                    Parameter newParam = new Parameter(fixedType, \"arg\" + i);\n                    List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n                    List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n                    GeneralUtils.copyAnnotatedNodeAnnotations(parameter, copied, notCopied);\n                    newParam.addAnnotations(copied);\n                    params[i - 1] = newParam;\n                    origParams[i-1] = parameter;\n                    argList.addExpression(new VariableExpression(params[i - 1]));\n                }\n                createForwarderMethod(trait, cNode, methodNode, originalMethod, helperClassNode, methodGenericsSpec, helperMethodParams, origParams, params, argList);\n            }\n        }\n        cNode.addObjectInitializerStatements(new ExpressionStatement(\n                new MethodCallExpression(\n                        new ClassExpression(helperClassNode),\n                        Traits.INIT_METHOD,\n                        new ArgumentListExpression(new VariableExpression(\"this\")))\n        ));\n        MethodCallExpression staticInitCall = new MethodCallExpression(\n                new ClassExpression(helperClassNode),\n                Traits.STATIC_INIT_METHOD,\n                new ArgumentListExpression(new ClassExpression(cNode)));\n        MethodNode staticInitMethod = new MethodNode(\n                Traits.STATIC_INIT_METHOD, Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC, ClassHelper.VOID_TYPE,\n                new Parameter[] {new Parameter(ClassHelper.CLASS_Type,\"clazz\")}, ClassNode.EMPTY_ARRAY, EmptyStatement.INSTANCE);\n        staticInitMethod.setDeclaringClass(helperClassNode);\n        staticInitCall.setMethodTarget(staticInitMethod);\n        cNode.addStaticInitializerStatements(Collections.<Statement>singletonList(new ExpressionStatement(\n                staticInitCall\n        )), false);\n        if (fieldHelperClassNode != null && !cNode.declaresInterface(fieldHelperClassNode)) {\n            // we should implement the field helper interface too\n            cNode.addInterface(fieldHelperClassNode);\n            // implementation of methods\n            List<MethodNode> declaredMethods = new LinkedList<MethodNode>();\n            for (MethodNode declaredMethod : fieldHelperClassNode.getAllDeclaredMethods()) {\n                if (declaredMethod.getName().endsWith(Traits.DIRECT_GETTER_SUFFIX)) {\n                    declaredMethods.add(0, declaredMethod);\n                } else {\n                    declaredMethods.add(declaredMethod);\n                }\n            }\n            for (MethodNode methodNode : declaredMethods) {\n                String fieldName = methodNode.getName();\n                if (fieldName.endsWith(Traits.DIRECT_GETTER_SUFFIX) || fieldName.endsWith(Traits.DIRECT_SETTER_SUFFIX)) {\n                    int suffixIdx = fieldName.lastIndexOf(\"$\");\n                    fieldName = fieldName.substring(0, suffixIdx);\n                    String operation = methodNode.getName().substring(suffixIdx + 1);\n                    boolean getter = \"get\".equals(operation);\n                    ClassNode returnType = correctToGenericsSpecRecurse(genericsSpec, methodNode.getReturnType());\n                    int isStatic = 0;\n                    boolean publicField = true;\n                    FieldNode helperField = fieldHelperClassNode.getField(Traits.FIELD_PREFIX + Traits.PUBLIC_FIELD_PREFIX + fieldName);\n                    if (helperField==null) {\n                        publicField = false;\n                        helperField = fieldHelperClassNode.getField(Traits.FIELD_PREFIX + Traits.PRIVATE_FIELD_PREFIX + fieldName);\n                    }\n                    if (helperField==null) {\n                        publicField = true;\n                        // try to find a static one\n                        helperField = fieldHelperClassNode.getField(Traits.STATIC_FIELD_PREFIX+Traits.PUBLIC_FIELD_PREFIX+fieldName);\n                        if (helperField==null) {\n                            publicField = false;\n                            helperField = fieldHelperClassNode.getField(Traits.STATIC_FIELD_PREFIX+Traits.PRIVATE_FIELD_PREFIX +fieldName);\n                        }\n                        isStatic = Opcodes.ACC_STATIC;\n                    }\n                    if (getter) {\n                        // add field\n                        if (helperField!=null) {\n                            List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n                            List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n                            GeneralUtils.copyAnnotatedNodeAnnotations(helperField, copied, notCopied);\n                            FieldNode fieldNode = cNode.addField(fieldName, (publicField?Opcodes.ACC_PUBLIC:Opcodes.ACC_PRIVATE) | isStatic, returnType, null);\n                            fieldNode.addAnnotations(copied);\n                        }\n                    }\n                    Parameter[] newParams;\n                    if (getter) {\n                        newParams = Parameter.EMPTY_ARRAY;\n                    } else {\n                        ClassNode originType = methodNode.getParameters()[0].getOriginType();\n                        ClassNode fixedType = originType.isGenericsPlaceHolder()?ClassHelper.OBJECT_TYPE:correctToGenericsSpecRecurse(genericsSpec, originType);\n                        newParams = new Parameter[]{new Parameter(fixedType, \"val\")};\n                    }\n\n                    Expression fieldExpr = new VariableExpression(cNode.getField(fieldName));\n                    Statement body =\n                            getter ? new ReturnStatement(fieldExpr) :\n                                    new ExpressionStatement(\n                                            new BinaryExpression(\n                                                    fieldExpr,\n                                                    Token.newSymbol(Types.EQUAL, 0, 0),\n                                                    new VariableExpression(newParams[0])\n                                            )\n                                    );\n                    MethodNode impl = new MethodNode(\n                            methodNode.getName(),\n                            Opcodes.ACC_PUBLIC | isStatic,\n                            returnType,\n                            newParams,\n                            ClassNode.EMPTY_ARRAY,\n                            body\n                    );\n                    AnnotationNode an = new AnnotationNode(COMPILESTATIC_CLASSNODE);\n                    impl.addAnnotation(an);\n                    cNode.addTransform(StaticCompileTransformation.class, an);\n                    cNode.addMethod(impl);\n                }\n            }\n        }\n    }",
            " 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214 +\n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230 +\n 231  \n 232  \n 233 +\n 234 +\n 235 +\n 236 +\n 237 +\n 238 +\n 239 +\n 240 +\n 241 +\n 242 +\n 243 +\n 244 +\n 245 +\n 246 +\n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253 +\n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266 +\n 267  \n 268 +\n 269 +\n 270  \n 271  \n 272  \n 273 +\n 274  \n 275  \n 276 +\n 277 +\n 278 +\n 279 +\n 280 +\n 281 +\n 282 +\n 283 +\n 284 +\n 285 +\n 286 +\n 287 +\n 288 +\n 289 +\n 290  \n 291  \n 292  \n 293  ",
            "    private static void applyTrait(final ClassNode trait, final ClassNode cNode, final TraitHelpersTuple helpers) {\n        ClassNode helperClassNode = helpers.getHelper();\n        ClassNode fieldHelperClassNode = helpers.getFieldHelper();\n        Map<String,ClassNode> genericsSpec = GenericsUtils.createGenericsSpec(cNode);\n        genericsSpec = GenericsUtils.createGenericsSpec(trait, genericsSpec);\n\n        for (MethodNode methodNode : helperClassNode.getAllDeclaredMethods()) {\n            String name = methodNode.getName();\n            Parameter[] helperMethodParams = methodNode.getParameters();\n            boolean isAbstract = methodNode.isAbstract();\n            if (!isAbstract && helperMethodParams.length > 0 && ((methodNode.getModifiers() & Opcodes.ACC_STATIC) == Opcodes.ACC_STATIC) && (!name.contains(\"$\") || (methodNode.getModifiers() & Opcodes.ACC_SYNTHETIC) == 0)) {\n                ArgumentListExpression argList = new ArgumentListExpression();\n                argList.addExpression(new VariableExpression(\"this\"));\n                Parameter[] origParams = new Parameter[helperMethodParams.length - 1];\n                Parameter[] params = new Parameter[helperMethodParams.length - 1];\n                System.arraycopy(methodNode.getParameters(), 1, params, 0, params.length);\n                Map<String,ClassNode> methodGenericsSpec = new LinkedHashMap<String, ClassNode>(genericsSpec);\n                MethodNode originalMethod = trait.getMethod(name, params);\n                // Original method may be null for the case of private or static methods\n                if (originalMethod!=null) {\n                    methodGenericsSpec = GenericsUtils.addMethodGenerics(originalMethod, methodGenericsSpec);\n                }\n                for (int i = 1; i < helperMethodParams.length; i++) {\n                    Parameter parameter = helperMethodParams[i];\n                    ClassNode originType = parameter.getOriginType();\n                    ClassNode fixedType = correctToGenericsSpecRecurse(methodGenericsSpec, originType);\n                    Parameter newParam = new Parameter(fixedType, \"arg\" + i);\n                    List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n                    List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n                    GeneralUtils.copyAnnotatedNodeAnnotations(parameter, copied, notCopied);\n                    newParam.addAnnotations(copied);\n                    params[i - 1] = newParam;\n                    origParams[i-1] = parameter;\n                    argList.addExpression(new VariableExpression(params[i - 1]));\n                }\n                createForwarderMethod(trait, cNode, methodNode, originalMethod, helperClassNode, methodGenericsSpec, helperMethodParams, origParams, params, argList);\n            }\n        }\n        cNode.addObjectInitializerStatements(new ExpressionStatement(\n                new MethodCallExpression(\n                        new ClassExpression(helperClassNode),\n                        Traits.INIT_METHOD,\n                        new ArgumentListExpression(new VariableExpression(\"this\")))\n        ));\n        MethodCallExpression staticInitCall = new MethodCallExpression(\n                new ClassExpression(helperClassNode),\n                Traits.STATIC_INIT_METHOD,\n                new ArgumentListExpression(new ClassExpression(cNode)));\n        MethodNode staticInitMethod = new MethodNode(\n                Traits.STATIC_INIT_METHOD, Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC, ClassHelper.VOID_TYPE,\n                new Parameter[] {new Parameter(ClassHelper.CLASS_Type,\"clazz\")}, ClassNode.EMPTY_ARRAY, EmptyStatement.INSTANCE);\n        staticInitMethod.setDeclaringClass(helperClassNode);\n        staticInitCall.setMethodTarget(staticInitMethod);\n        cNode.addStaticInitializerStatements(Collections.<Statement>singletonList(new ExpressionStatement(\n                staticInitCall\n        )), false);\n        if (fieldHelperClassNode != null && !cNode.declaresInterface(fieldHelperClassNode)) {\n            // we should implement the field helper interface too\n            cNode.addInterface(fieldHelperClassNode);\n            // implementation of methods\n            List<MethodNode> declaredMethods = new LinkedList<MethodNode>();\n            for (MethodNode declaredMethod : fieldHelperClassNode.getAllDeclaredMethods()) {\n                if (declaredMethod.getName().endsWith(Traits.DIRECT_GETTER_SUFFIX)) {\n                    declaredMethods.add(0, declaredMethod);\n                } else {\n                    declaredMethods.add(declaredMethod);\n                }\n            }\n            for (MethodNode methodNode : declaredMethods) {\n                String fieldName = methodNode.getName();\n                if (fieldName.endsWith(Traits.DIRECT_GETTER_SUFFIX) || fieldName.endsWith(Traits.DIRECT_SETTER_SUFFIX)) {\n                    int suffixIdx = fieldName.lastIndexOf(\"$\");\n                    fieldName = fieldName.substring(0, suffixIdx);\n                    String operation = methodNode.getName().substring(suffixIdx + 1);\n                    boolean getter = \"get\".equals(operation);\n                    ClassNode returnType = correctToGenericsSpecRecurse(genericsSpec, methodNode.getReturnType());\n                    int fieldMods = 0;\n                    int isStatic = 0;\n                    boolean publicField = true;\n                    FieldNode helperField = fieldHelperClassNode.getField(Traits.FIELD_PREFIX + Traits.PUBLIC_FIELD_PREFIX + fieldName);\n                    if (helperField==null) {\n                        publicField = false;\n                        helperField = fieldHelperClassNode.getField(Traits.FIELD_PREFIX + Traits.PRIVATE_FIELD_PREFIX + fieldName);\n                    }\n                    if (helperField==null) {\n                        publicField = true;\n                        // try to find a static one\n                        helperField = fieldHelperClassNode.getField(Traits.STATIC_FIELD_PREFIX+Traits.PUBLIC_FIELD_PREFIX+fieldName);\n                        if (helperField==null) {\n                            publicField = false;\n                            helperField = fieldHelperClassNode.getField(Traits.STATIC_FIELD_PREFIX+Traits.PRIVATE_FIELD_PREFIX +fieldName);\n                        }\n                        fieldMods = fieldMods | Opcodes.ACC_STATIC;\n                        isStatic = Opcodes.ACC_STATIC;\n                    }\n                    if (helperField == null) {\n                        fieldMods = 0;\n                        isStatic = 0;\n                        for (Integer mod : Traits.FIELD_PREFIXES) {\n                            helperField = fieldHelperClassNode.getField(String.format(\"$0x%04x\", mod) + fieldName);\n                            if (helperField != null) {\n                                if ((mod & Opcodes.ACC_STATIC) != 0) isStatic = Opcodes.ACC_STATIC;\n                                fieldMods = fieldMods | mod;\n                                break;\n                            }\n                        }\n                    } else {\n                        fieldMods = fieldMods | (publicField?Opcodes.ACC_PUBLIC:Opcodes.ACC_PRIVATE);\n                    }\n                    if (getter) {\n                        // add field\n                        if (helperField!=null) {\n                            List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n                            List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n                            GeneralUtils.copyAnnotatedNodeAnnotations(helperField, copied, notCopied);\n                            FieldNode fieldNode = cNode.addField(fieldName, fieldMods, returnType, (fieldMods & Opcodes.ACC_FINAL) == 0 ? null : helperField.getInitialExpression());\n                            fieldNode.addAnnotations(copied);\n                        }\n                    }\n                    Parameter[] newParams;\n                    if (getter) {\n                        newParams = Parameter.EMPTY_ARRAY;\n                    } else {\n                        ClassNode originType = methodNode.getParameters()[0].getOriginType();\n                        ClassNode fixedType = originType.isGenericsPlaceHolder()?ClassHelper.OBJECT_TYPE:correctToGenericsSpecRecurse(genericsSpec, originType);\n                        newParams = new Parameter[]{new Parameter(fixedType, \"val\")};\n                    }\n\n                    Expression fieldExpr = varX(cNode.getField(fieldName));\n                    Statement body =\n                            getter ? returnS(fieldExpr) :\n                                    stmt(\n                                            new BinaryExpression(\n                                                    fieldExpr,\n                                                    Token.newSymbol(Types.EQUAL, 0, 0),\n                                                    varX(newParams[0])\n                                            )\n                                    );\n                    if (getter || (fieldMods & Opcodes.ACC_FINAL) == 0) {\n                        MethodNode impl = new MethodNode(\n                                methodNode.getName(),\n                                Opcodes.ACC_PUBLIC | isStatic,\n                                returnType,\n                                newParams,\n                                ClassNode.EMPTY_ARRAY,\n                                body\n                        );\n                        AnnotationNode an = new AnnotationNode(COMPILESTATIC_CLASSNODE);\n                        impl.addAnnotation(an);\n                        cNode.addTransform(StaticCompileTransformation.class, an);\n                        cNode.addMethod(impl);\n                    }\n                }\n            }\n        }\n    }"
        ],
        [
            "TraitASTTransformation::processField(FieldNode,MethodNode,MethodNode,ClassNode,ClassNode,Set)",
            " 388  \n 389  \n 390  \n 391 -\n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419 -\n 420 -\n 421 -\n 422 -\n 423 -\n 424 -\n 425 -\n 426 -\n 427  \n 428  \n 429  \n 430  \n 431  \n 432  \n 433  \n 434  \n 435  \n 436  \n 437  \n 438 -\n 439 -\n 440 -\n 441  \n 442  \n 443  \n 444  \n 445  \n 446 -\n 447  \n 448  \n 449  \n 450  \n 451  \n 452  \n 453  \n 454  ",
            "    private void processField(final FieldNode field, final MethodNode initializer, final MethodNode staticInitializer, final ClassNode fieldHelper, final ClassNode trait, final Set<String> knownFields) {\n        Expression initialExpression = field.getInitialExpression();\n        MethodNode selectedMethod = field.isStatic()?staticInitializer:initializer;\n        if (initialExpression != null) {\n            VariableExpression thisObject = new VariableExpression(selectedMethod.getParameters()[0]);\n            ExpressionStatement initCode = new ExpressionStatement(initialExpression);\n            processBody(thisObject, selectedMethod, initCode, trait, fieldHelper, knownFields);\n            BlockStatement code = (BlockStatement) selectedMethod.getCode();\n            MethodCallExpression mce;\n            if (field.isStatic()) {\n                mce = new MethodCallExpression(\n                        new ClassExpression(INVOKERHELPER_CLASSNODE),\n                        \"invokeStaticMethod\",\n                        new ArgumentListExpression(\n                                thisObject,\n                                new ConstantExpression(Traits.helperSetterName(field)),\n                                initCode.getExpression()\n                        )\n                );\n            } else {\n                mce = new MethodCallExpression(\n                        new CastExpression(createReceiverType(field.isStatic(), fieldHelper), thisObject),\n                        Traits.helperSetterName(field),\n                        new CastExpression(field.getOriginType(),initCode.getExpression())\n                );\n            }\n            mce.setImplicitThis(false);\n            mce.setSourcePosition(initialExpression);\n            code.addStatement(new ExpressionStatement(mce));\n        }\n        // define setter/getter helper methods\n        fieldHelper.addMethod(\n                Traits.helperSetterName(field),\n                ACC_PUBLIC | ACC_ABSTRACT,\n                field.getOriginType(),\n                new Parameter[]{new Parameter(field.getOriginType(), \"val\")},\n                ClassNode.EMPTY_ARRAY,\n                null\n        );\n        fieldHelper.addMethod(\n                Traits.helperGetterName(field),\n                ACC_PUBLIC | ACC_ABSTRACT,\n                field.getOriginType(),\n                Parameter.EMPTY_ARRAY,\n                ClassNode.EMPTY_ARRAY,\n                null\n        );\n\n        // dummy fields are only used to carry annotations if instance field\n        // and to differentiate from static fields otherwise\n        String dummyFieldName = (field.isStatic() ? Traits.STATIC_FIELD_PREFIX : Traits.FIELD_PREFIX) +\n                (field.isPublic()? Traits.PUBLIC_FIELD_PREFIX : Traits.PRIVATE_FIELD_PREFIX)+\n                Traits.remappedFieldName(field.getOwner(), field.getName());\n        FieldNode dummyField = new FieldNode(\n                dummyFieldName,\n                ACC_STATIC | ACC_PUBLIC | ACC_FINAL | ACC_SYNTHETIC,\n                field.getOriginType(),\n                fieldHelper,\n                null\n        );\n        // copy annotations from field to dummy field\n        List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n        List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n        GeneralUtils.copyAnnotatedNodeAnnotations(field, copied, notCopied);\n        dummyField.addAnnotations(copied);\n        fieldHelper.addField(dummyField);\n    }",
            " 388  \n 389  \n 390  \n 391 +\n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419 +\n 420 +\n 421 +\n 422 +\n 423 +\n 424 +\n 425 +\n 426 +\n 427 +\n 428 +\n 429  \n 430  \n 431  \n 432  \n 433  \n 434  \n 435  \n 436  \n 437  \n 438  \n 439  \n 440 +\n 441 +\n 442  \n 443  \n 444  \n 445  \n 446  \n 447 +\n 448  \n 449  \n 450  \n 451  \n 452  \n 453  \n 454  \n 455  ",
            "    private void processField(final FieldNode field, final MethodNode initializer, final MethodNode staticInitializer, final ClassNode fieldHelper, final ClassNode trait, final Set<String> knownFields) {\n        Expression initialExpression = field.getInitialExpression();\n        MethodNode selectedMethod = field.isStatic()?staticInitializer:initializer;\n        if (initialExpression != null && !field.isFinal()) {\n            VariableExpression thisObject = new VariableExpression(selectedMethod.getParameters()[0]);\n            ExpressionStatement initCode = new ExpressionStatement(initialExpression);\n            processBody(thisObject, selectedMethod, initCode, trait, fieldHelper, knownFields);\n            BlockStatement code = (BlockStatement) selectedMethod.getCode();\n            MethodCallExpression mce;\n            if (field.isStatic()) {\n                mce = new MethodCallExpression(\n                        new ClassExpression(INVOKERHELPER_CLASSNODE),\n                        \"invokeStaticMethod\",\n                        new ArgumentListExpression(\n                                thisObject,\n                                new ConstantExpression(Traits.helperSetterName(field)),\n                                initCode.getExpression()\n                        )\n                );\n            } else {\n                mce = new MethodCallExpression(\n                        new CastExpression(createReceiverType(field.isStatic(), fieldHelper), thisObject),\n                        Traits.helperSetterName(field),\n                        new CastExpression(field.getOriginType(),initCode.getExpression())\n                );\n            }\n            mce.setImplicitThis(false);\n            mce.setSourcePosition(initialExpression);\n            code.addStatement(new ExpressionStatement(mce));\n        }\n        // define setter/getter helper methods\n        if (!Modifier.isFinal(field.getModifiers())) {\n            fieldHelper.addMethod(\n                    Traits.helperSetterName(field),\n                    ACC_PUBLIC | ACC_ABSTRACT,\n                    field.getOriginType(),\n                    new Parameter[]{new Parameter(field.getOriginType(), \"val\")},\n                    ClassNode.EMPTY_ARRAY,\n                    null\n            );\n        }\n        fieldHelper.addMethod(\n                Traits.helperGetterName(field),\n                ACC_PUBLIC | ACC_ABSTRACT,\n                field.getOriginType(),\n                Parameter.EMPTY_ARRAY,\n                ClassNode.EMPTY_ARRAY,\n                null\n        );\n\n        // dummy fields are only used to carry annotations if instance field\n        // and to differentiate from static fields otherwise\n        int mods = field.getModifiers() & Traits.FIELD_PREFIX_MASK;\n        String dummyFieldName = String.format(\"$0x%04x\", mods) + Traits.remappedFieldName(field.getOwner(), field.getName());\n        FieldNode dummyField = new FieldNode(\n                dummyFieldName,\n                ACC_STATIC | ACC_PUBLIC | ACC_FINAL | ACC_SYNTHETIC,\n                field.getOriginType(),\n                fieldHelper,\n                field.isFinal() ? initialExpression : null\n        );\n        // copy annotations from field to dummy field\n        List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n        List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n        GeneralUtils.copyAnnotatedNodeAnnotations(field, copied, notCopied);\n        dummyField.addAnnotations(copied);\n        fieldHelper.addField(dummyField);\n    }"
        ]
    ],
    "83037298daa86a4fcc7613f98fcebae6102ce90d": [
        [
            "TraitASTTransformation::processField(FieldNode,MethodNode,MethodNode,ClassNode,ClassNode,ClassNode,Set)",
            " 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413 -\n 414 -\n 415 -\n 416 -\n 417 -\n 418 -\n 419 -\n 420 -\n 421 -\n 422 -\n 423 -\n 424 -\n 425 -\n 426 -\n 427 -\n 428 -\n 429 -\n 430 -\n 431 -\n 432 -\n 433 -\n 434 -\n 435 -\n 436 -\n 437 -\n 438  \n 439  \n 440 -\n 441 -\n 442 -\n 443 -\n 444 -\n 445 -\n 446 -\n 447 -\n 448 -\n 449 -\n 450 -\n 451  \n 452  \n 453  \n 454  \n 455  \n 456  \n 457  \n 458  \n 459  \n 460  \n 461  \n 462  \n 463  \n 464  \n 465  \n 466  \n 467  \n 468  \n 469  \n 470  \n 471  \n 472  \n 473  \n 474  \n 475  \n 476  \n 477  ",
            "    private void processField(final FieldNode field, final MethodNode initializer, final MethodNode staticInitializer,\n                              final ClassNode fieldHelper, final ClassNode helper, final ClassNode trait,\n                              final Set<String> knownFields) {\n        if (field.isProtected()) {\n            unit.addError(new SyntaxException(\"Cannot have protected field in a trait (\" + trait.getName() + \"#\" + field.getName() + \")\",\n                    field.getLineNumber(), field.getColumnNumber()));\n            return;\n        }\n\n        Expression initialExpression = field.getInitialExpression();\n        MethodNode selectedMethod = field.isStatic()?staticInitializer:initializer;\n        if (initialExpression != null) {\n            if (field.isFinal()) {\n                String baseName = field.isStatic() ? Traits.STATIC_INIT_METHOD : Traits.INIT_METHOD;\n                MethodNode fieldInitializer = new MethodNode(\n                        baseName + Traits.remappedFieldName(trait, field.getName()),\n                        ACC_STATIC | ACC_PUBLIC | ACC_SYNTHETIC,\n                        field.getOriginType(),\n                        Parameter.EMPTY_ARRAY,\n                        ClassNode.EMPTY_ARRAY,\n                        returnS(initialExpression)\n                );\n                helper.addMethod(fieldInitializer);\n            } else {\n                VariableExpression thisObject = new VariableExpression(selectedMethod.getParameters()[0]);\n                ExpressionStatement initCode = new ExpressionStatement(initialExpression);\n                processBody(thisObject, initCode, trait, helper, fieldHelper, knownFields);\n                BlockStatement code = (BlockStatement) selectedMethod.getCode();\n                MethodCallExpression mce;\n                if (field.isStatic()) {\n                    mce = new MethodCallExpression(\n                            new ClassExpression(INVOKERHELPER_CLASSNODE),\n                            \"invokeStaticMethod\",\n                            new ArgumentListExpression(\n                                    thisObject,\n                                    new ConstantExpression(Traits.helperSetterName(field)),\n                                    initCode.getExpression()\n                            )\n                    );\n                } else {\n                    mce = new MethodCallExpression(\n                            new CastExpression(createReceiverType(field.isStatic(), fieldHelper), thisObject),\n                            Traits.helperSetterName(field),\n                            new CastExpression(field.getOriginType(),initCode.getExpression())\n                    );\n                }\n                mce.setImplicitThis(false);\n                mce.setSourcePosition(initialExpression);\n                code.addStatement(new ExpressionStatement(mce));\n            }\n        }\n        // define setter/getter helper methods\n        if (!Modifier.isFinal(field.getModifiers())) {\n            fieldHelper.addMethod(\n                    Traits.helperSetterName(field),\n                    ACC_PUBLIC | ACC_ABSTRACT,\n                    field.getOriginType(),\n                    new Parameter[]{new Parameter(field.getOriginType(), \"val\")},\n                    ClassNode.EMPTY_ARRAY,\n                    null\n            );\n        }\n        fieldHelper.addMethod(\n                Traits.helperGetterName(field),\n                ACC_PUBLIC | ACC_ABSTRACT,\n                field.getOriginType(),\n                Parameter.EMPTY_ARRAY,\n                ClassNode.EMPTY_ARRAY,\n                null\n        );\n\n        // dummy fields are only used to carry annotations if instance field\n        // and to differentiate from static fields otherwise\n        int mods = field.getModifiers() & Traits.FIELD_PREFIX_MASK;\n        String dummyFieldName = String.format(\"$0x%04x\", mods) + Traits.remappedFieldName(field.getOwner(), field.getName());\n        FieldNode dummyField = new FieldNode(\n                dummyFieldName,\n                ACC_STATIC | ACC_PUBLIC | ACC_FINAL | ACC_SYNTHETIC,\n                field.getOriginType(),\n                fieldHelper,\n                field.isFinal() ? initialExpression : null\n        );\n        // copy annotations from field to dummy field\n        List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n        List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n        GeneralUtils.copyAnnotatedNodeAnnotations(field, copied, notCopied);\n        dummyField.addAnnotations(copied);\n        fieldHelper.addField(dummyField);\n    }",
            " 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412 +\n 413 +\n 414 +\n 415 +\n 416 +\n 417 +\n 418 +\n 419 +\n 420 +\n 421 +\n 422 +\n 423 +\n 424 +\n 425 +\n 426 +\n 427 +\n 428  \n 429 +\n 430 +\n 431 +\n 432 +\n 433 +\n 434  \n 435 +\n 436 +\n 437 +\n 438  \n 439 +\n 440 +\n 441 +\n 442 +\n 443 +\n 444 +\n 445 +\n 446 +\n 447 +\n 448  \n 449  \n 450  \n 451  \n 452  \n 453  \n 454  \n 455  \n 456  \n 457  \n 458  \n 459  \n 460  \n 461  \n 462  \n 463  \n 464  \n 465  \n 466  \n 467  \n 468  \n 469  \n 470  \n 471  \n 472  \n 473  \n 474 +\n 475 +\n 476 +\n 477 +\n 478 +\n 479 +\n 480 +\n 481 +\n 482 +\n 483 +\n 484 +\n 485 +\n 486 +\n 487 +\n 488 +\n 489 +\n 490 +\n 491 +\n 492  ",
            "    private void processField(final FieldNode field, final MethodNode initializer, final MethodNode staticInitializer,\n                              final ClassNode fieldHelper, final ClassNode helper, final ClassNode trait,\n                              final Set<String> knownFields) {\n        if (field.isProtected()) {\n            unit.addError(new SyntaxException(\"Cannot have protected field in a trait (\" + trait.getName() + \"#\" + field.getName() + \")\",\n                    field.getLineNumber(), field.getColumnNumber()));\n            return;\n        }\n\n        Expression initialExpression = field.getInitialExpression();\n        MethodNode selectedMethod = field.isStatic()?staticInitializer:initializer;\n        if (initialExpression != null) {\n            if (field.isFinal()) {\n                String baseName = field.isStatic() ? Traits.STATIC_INIT_METHOD : Traits.INIT_METHOD;\n                MethodNode fieldInitializer = new MethodNode(\n                        baseName + Traits.remappedFieldName(trait, field.getName()),\n                        ACC_STATIC | ACC_PUBLIC | ACC_SYNTHETIC,\n                        field.getOriginType(),\n                        Parameter.EMPTY_ARRAY,\n                        ClassNode.EMPTY_ARRAY,\n                        returnS(initialExpression)\n                );\n                helper.addMethod(fieldInitializer);\n            }\n            VariableExpression thisObject = new VariableExpression(selectedMethod.getParameters()[0]);\n            ExpressionStatement initCode = new ExpressionStatement(initialExpression);\n            processBody(thisObject, initCode, trait, helper, fieldHelper, knownFields);\n            BlockStatement code = (BlockStatement) selectedMethod.getCode();\n            MethodCallExpression mce;\n            if (field.isStatic()) {\n                mce = new MethodCallExpression(\n                        new ClassExpression(INVOKERHELPER_CLASSNODE),\n                        \"invokeStaticMethod\",\n                        new ArgumentListExpression(\n                                thisObject,\n                                new ConstantExpression(Traits.helperSetterName(field)),\n                                initCode.getExpression()\n                        )\n                );\n            } else {\n                mce = new MethodCallExpression(\n                        new CastExpression(createReceiverType(field.isStatic(), fieldHelper), thisObject),\n                        Traits.helperSetterName(field),\n                        new CastExpression(field.getOriginType(),initCode.getExpression())\n                );\n            }\n            mce.setImplicitThis(false);\n            mce.setSourcePosition(initialExpression);\n            code.addStatement(new ExpressionStatement(mce));\n        }\n        // define setter/getter helper methods (setter added even for final fields for legacy compatibility)\n        fieldHelper.addMethod(\n                Traits.helperSetterName(field),\n                ACC_PUBLIC | ACC_ABSTRACT,\n                field.getOriginType(),\n                new Parameter[]{new Parameter(field.getOriginType(), \"val\")},\n                ClassNode.EMPTY_ARRAY,\n                null\n        );\n        fieldHelper.addMethod(\n                Traits.helperGetterName(field),\n                ACC_PUBLIC | ACC_ABSTRACT,\n                field.getOriginType(),\n                Parameter.EMPTY_ARRAY,\n                ClassNode.EMPTY_ARRAY,\n                null\n        );\n\n        // dummy fields are only used to carry annotations if instance field\n        // and to differentiate from static fields otherwise\n        int mods = field.getModifiers() & Traits.FIELD_PREFIX_MASK;\n        String dummyFieldName = String.format(\"$0x%04x\", mods) + Traits.remappedFieldName(field.getOwner(), field.getName());\n        FieldNode dummyField = new FieldNode(\n                dummyFieldName,\n                ACC_STATIC | ACC_PUBLIC | ACC_FINAL | ACC_SYNTHETIC,\n                field.getOriginType(),\n                fieldHelper,\n                field.isFinal() ? initialExpression : null\n        );\n        // copy annotations from field to dummy field\n        List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n        List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n        GeneralUtils.copyAnnotatedNodeAnnotations(field, copied, notCopied);\n        dummyField.addAnnotations(copied);\n        fieldHelper.addField(dummyField);\n\n        // retain legacy field (will be given lower precedence than above)\n        dummyFieldName = (field.isStatic() ? Traits.STATIC_FIELD_PREFIX : Traits.FIELD_PREFIX) +\n                (field.isPublic()? Traits.PUBLIC_FIELD_PREFIX : Traits.PRIVATE_FIELD_PREFIX)+\n                Traits.remappedFieldName(field.getOwner(), field.getName());\n        dummyField = new FieldNode(\n                dummyFieldName,\n                ACC_STATIC | ACC_PUBLIC | ACC_FINAL | ACC_SYNTHETIC,\n                field.getOriginType(),\n                fieldHelper,\n                null\n        );\n        // copy annotations from field to legacy dummy field\n        copied = new LinkedList<AnnotationNode>();\n        notCopied = new LinkedList<AnnotationNode>();\n        GeneralUtils.copyAnnotatedNodeAnnotations(field, copied, notCopied);\n        dummyField.addAnnotations(copied);\n        fieldHelper.addField(dummyField);\n    }"
        ],
        [
            "TraitComposer::applyTrait(ClassNode,ClassNode,TraitHelpersTuple)",
            " 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220 -\n 221 -\n 222 -\n 223 -\n 224  \n 225 -\n 226 -\n 227 -\n 228 -\n 229  \n 230  \n 231 -\n 232  \n 233 -\n 234 -\n 235 -\n 236 -\n 237 -\n 238 -\n 239 -\n 240 -\n 241 -\n 242 -\n 243 -\n 244 -\n 245  \n 246  \n 247 -\n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284 -\n 285  \n 286  \n 287  \n 288  \n 289  \n 290 -\n 291 -\n 292 -\n 293 -\n 294 -\n 295 -\n 296 -\n 297 -\n 298 -\n 299 -\n 300 -\n 301 -\n 302 -\n 303 -\n 304 -\n 305  \n 306  \n 307  \n 308  ",
            "    private static void applyTrait(final ClassNode trait, final ClassNode cNode, final TraitHelpersTuple helpers) {\n        ClassNode helperClassNode = helpers.getHelper();\n        ClassNode fieldHelperClassNode = helpers.getFieldHelper();\n        Map<String,ClassNode> genericsSpec = GenericsUtils.createGenericsSpec(cNode);\n        genericsSpec = GenericsUtils.createGenericsSpec(trait, genericsSpec);\n\n        for (MethodNode methodNode : helperClassNode.getAllDeclaredMethods()) {\n            String name = methodNode.getName();\n            Parameter[] helperMethodParams = methodNode.getParameters();\n            boolean isAbstract = methodNode.isAbstract();\n            if (!isAbstract && helperMethodParams.length > 0 && ((methodNode.getModifiers() & Opcodes.ACC_STATIC) == Opcodes.ACC_STATIC) && (!name.contains(\"$\") || (methodNode.getModifiers() & Opcodes.ACC_SYNTHETIC) == 0)) {\n                ArgumentListExpression argList = new ArgumentListExpression();\n                argList.addExpression(new VariableExpression(\"this\"));\n                Parameter[] origParams = new Parameter[helperMethodParams.length - 1];\n                Parameter[] params = new Parameter[helperMethodParams.length - 1];\n                System.arraycopy(methodNode.getParameters(), 1, params, 0, params.length);\n                Map<String,ClassNode> methodGenericsSpec = new LinkedHashMap<String, ClassNode>(genericsSpec);\n                MethodNode originalMethod = trait.getMethod(name, params);\n                // Original method may be null for the case of private or static methods\n                if (originalMethod!=null) {\n                    methodGenericsSpec = GenericsUtils.addMethodGenerics(originalMethod, methodGenericsSpec);\n                }\n                for (int i = 1; i < helperMethodParams.length; i++) {\n                    Parameter parameter = helperMethodParams[i];\n                    ClassNode originType = parameter.getOriginType();\n                    ClassNode fixedType = correctToGenericsSpecRecurse(methodGenericsSpec, originType);\n                    Parameter newParam = new Parameter(fixedType, \"arg\" + i);\n                    List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n                    List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n                    GeneralUtils.copyAnnotatedNodeAnnotations(parameter, copied, notCopied);\n                    newParam.addAnnotations(copied);\n                    params[i - 1] = newParam;\n                    origParams[i-1] = parameter;\n                    argList.addExpression(new VariableExpression(params[i - 1]));\n                }\n                createForwarderMethod(trait, cNode, methodNode, originalMethod, helperClassNode, methodGenericsSpec, helperMethodParams, origParams, params, argList);\n            }\n        }\n        cNode.addObjectInitializerStatements(new ExpressionStatement(\n                new MethodCallExpression(\n                        new ClassExpression(helperClassNode),\n                        Traits.INIT_METHOD,\n                        new ArgumentListExpression(new VariableExpression(\"this\")))\n        ));\n        MethodCallExpression staticInitCall = new MethodCallExpression(\n                new ClassExpression(helperClassNode),\n                Traits.STATIC_INIT_METHOD,\n                new ArgumentListExpression(new ClassExpression(cNode)));\n        MethodNode staticInitMethod = new MethodNode(\n                Traits.STATIC_INIT_METHOD, Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC, ClassHelper.VOID_TYPE,\n                new Parameter[] {new Parameter(ClassHelper.CLASS_Type,\"clazz\")}, ClassNode.EMPTY_ARRAY, EmptyStatement.INSTANCE);\n        staticInitMethod.setDeclaringClass(helperClassNode);\n        staticInitCall.setMethodTarget(staticInitMethod);\n        cNode.addStaticInitializerStatements(Collections.<Statement>singletonList(new ExpressionStatement(\n                staticInitCall\n        )), false);\n        if (fieldHelperClassNode != null && !cNode.declaresInterface(fieldHelperClassNode)) {\n            // we should implement the field helper interface too\n            cNode.addInterface(fieldHelperClassNode);\n            // implementation of methods\n            List<MethodNode> declaredMethods = new LinkedList<MethodNode>();\n            for (MethodNode declaredMethod : fieldHelperClassNode.getAllDeclaredMethods()) {\n                if (declaredMethod.getName().endsWith(Traits.DIRECT_GETTER_SUFFIX)) {\n                    declaredMethods.add(0, declaredMethod);\n                } else {\n                    declaredMethods.add(declaredMethod);\n                }\n            }\n            for (MethodNode methodNode : declaredMethods) {\n                String fieldName = methodNode.getName();\n                if (fieldName.endsWith(Traits.DIRECT_GETTER_SUFFIX) || fieldName.endsWith(Traits.DIRECT_SETTER_SUFFIX)) {\n                    int suffixIdx = fieldName.lastIndexOf(\"$\");\n                    fieldName = fieldName.substring(0, suffixIdx);\n                    String operation = methodNode.getName().substring(suffixIdx + 1);\n                    boolean getter = \"get\".equals(operation);\n                    ClassNode returnType = correctToGenericsSpecRecurse(genericsSpec, methodNode.getReturnType());\n                    int fieldMods = 0;\n                    int isStatic = 0;\n                    boolean publicField = true;\n                    FieldNode helperField = fieldHelperClassNode.getField(Traits.FIELD_PREFIX + Traits.PUBLIC_FIELD_PREFIX + fieldName);\n                    if (helperField==null) {\n                        publicField = false;\n                        helperField = fieldHelperClassNode.getField(Traits.FIELD_PREFIX + Traits.PRIVATE_FIELD_PREFIX + fieldName);\n                    }\n                    if (helperField==null) {\n                        publicField = true;\n                        // try to find a static one\n                        helperField = fieldHelperClassNode.getField(Traits.STATIC_FIELD_PREFIX+Traits.PUBLIC_FIELD_PREFIX+fieldName);\n                        if (helperField==null) {\n                            publicField = false;\n                            helperField = fieldHelperClassNode.getField(Traits.STATIC_FIELD_PREFIX+Traits.PRIVATE_FIELD_PREFIX +fieldName);\n                        }\n                        fieldMods = fieldMods | Opcodes.ACC_STATIC;\n                        isStatic = Opcodes.ACC_STATIC;\n                    }\n                    if (helperField == null) {\n                        fieldMods = 0;\n                        isStatic = 0;\n                        for (Integer mod : Traits.FIELD_PREFIXES) {\n                            helperField = fieldHelperClassNode.getField(String.format(\"$0x%04x\", mod) + fieldName);\n                            if (helperField != null) {\n                                if ((mod & Opcodes.ACC_STATIC) != 0) isStatic = Opcodes.ACC_STATIC;\n                                fieldMods = fieldMods | mod;\n                                break;\n                            }\n                        }\n                    } else {\n                        fieldMods = fieldMods | (publicField?Opcodes.ACC_PUBLIC:Opcodes.ACC_PRIVATE);\n                    }\n                    if (getter) {\n                        // add field\n                        if (helperField!=null) {\n                            List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n                            List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n                            GeneralUtils.copyAnnotatedNodeAnnotations(helperField, copied, notCopied);\n                            FieldNode fieldNode = cNode.addField(fieldName, fieldMods, returnType, (fieldMods & Opcodes.ACC_FINAL) == 0 ? null : helperField.getInitialExpression());\n                            fieldNode.addAnnotations(copied);\n                            // getInitialExpression above will be null if not in same source unit\n                            // so instead set within (static) initializer\n                            if (fieldNode.isFinal() && !(helperClassNode instanceof InnerClassNode)) {\n                                String baseName = fieldNode.isStatic() ? Traits.STATIC_INIT_METHOD : Traits.INIT_METHOD;\n                                Expression mce = callX(helperClassNode, baseName + fieldNode.getName());\n                                Statement stmt = stmt(assignX(varX(fieldNode.getName(), fieldNode.getType()), mce));\n                                if (isStatic == 0) {\n                                    cNode.addObjectInitializerStatements(stmt);\n                                } else {\n                                    cNode.addStaticInitializerStatements(Collections.<Statement>singletonList(stmt), false);\n                                }\n                            }\n                        }\n                    }\n                    Parameter[] newParams;\n                    if (getter) {\n                        newParams = Parameter.EMPTY_ARRAY;\n                    } else {\n                        ClassNode originType = methodNode.getParameters()[0].getOriginType();\n                        ClassNode fixedType = originType.isGenericsPlaceHolder()?ClassHelper.OBJECT_TYPE:correctToGenericsSpecRecurse(genericsSpec, originType);\n                        newParams = new Parameter[]{new Parameter(fixedType, \"val\")};\n                    }\n\n                    Expression fieldExpr = varX(cNode.getField(fieldName));\n                    Statement body =\n                            getter ? returnS(fieldExpr) :\n                                    stmt(\n                                            new BinaryExpression(\n                                                    fieldExpr,\n                                                    Token.newSymbol(Types.EQUAL, 0, 0),\n                                                    varX(newParams[0])\n                                            )\n                                    );\n                    if (getter || (fieldMods & Opcodes.ACC_FINAL) == 0) {\n                        MethodNode impl = new MethodNode(\n                                methodNode.getName(),\n                                Opcodes.ACC_PUBLIC | isStatic,\n                                returnType,\n                                newParams,\n                                ClassNode.EMPTY_ARRAY,\n                                body\n                        );\n                        AnnotationNode an = new AnnotationNode(COMPILESTATIC_CLASSNODE);\n                        impl.addAnnotation(an);\n                        cNode.addTransform(StaticCompileTransformation.class, an);\n                        cNode.addMethod(impl);\n                    }\n                }\n            }\n        }\n    }",
            " 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220 +\n 221 +\n 222 +\n 223 +\n 224 +\n 225 +\n 226 +\n 227 +\n 228 +\n 229 +\n 230 +\n 231 +\n 232  \n 233 +\n 234 +\n 235 +\n 236 +\n 237  \n 238  \n 239 +\n 240  \n 241 +\n 242 +\n 243 +\n 244 +\n 245 +\n 246 +\n 247 +\n 248  \n 249 +\n 250 +\n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286 +\n 287  \n 288  \n 289 +\n 290  \n 291  \n 292  \n 293  \n 294  \n 295 +\n 296 +\n 297 +\n 298 +\n 299 +\n 300 +\n 301 +\n 302 +\n 303 +\n 304 +\n 305 +\n 306 +\n 307 +\n 308 +\n 309 +\n 310  \n 311  \n 312  \n 313  ",
            "    private static void applyTrait(final ClassNode trait, final ClassNode cNode, final TraitHelpersTuple helpers) {\n        ClassNode helperClassNode = helpers.getHelper();\n        ClassNode fieldHelperClassNode = helpers.getFieldHelper();\n        Map<String,ClassNode> genericsSpec = GenericsUtils.createGenericsSpec(cNode);\n        genericsSpec = GenericsUtils.createGenericsSpec(trait, genericsSpec);\n\n        for (MethodNode methodNode : helperClassNode.getAllDeclaredMethods()) {\n            String name = methodNode.getName();\n            Parameter[] helperMethodParams = methodNode.getParameters();\n            boolean isAbstract = methodNode.isAbstract();\n            if (!isAbstract && helperMethodParams.length > 0 && ((methodNode.getModifiers() & Opcodes.ACC_STATIC) == Opcodes.ACC_STATIC) && (!name.contains(\"$\") || (methodNode.getModifiers() & Opcodes.ACC_SYNTHETIC) == 0)) {\n                ArgumentListExpression argList = new ArgumentListExpression();\n                argList.addExpression(new VariableExpression(\"this\"));\n                Parameter[] origParams = new Parameter[helperMethodParams.length - 1];\n                Parameter[] params = new Parameter[helperMethodParams.length - 1];\n                System.arraycopy(methodNode.getParameters(), 1, params, 0, params.length);\n                Map<String,ClassNode> methodGenericsSpec = new LinkedHashMap<String, ClassNode>(genericsSpec);\n                MethodNode originalMethod = trait.getMethod(name, params);\n                // Original method may be null for the case of private or static methods\n                if (originalMethod!=null) {\n                    methodGenericsSpec = GenericsUtils.addMethodGenerics(originalMethod, methodGenericsSpec);\n                }\n                for (int i = 1; i < helperMethodParams.length; i++) {\n                    Parameter parameter = helperMethodParams[i];\n                    ClassNode originType = parameter.getOriginType();\n                    ClassNode fixedType = correctToGenericsSpecRecurse(methodGenericsSpec, originType);\n                    Parameter newParam = new Parameter(fixedType, \"arg\" + i);\n                    List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n                    List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n                    GeneralUtils.copyAnnotatedNodeAnnotations(parameter, copied, notCopied);\n                    newParam.addAnnotations(copied);\n                    params[i - 1] = newParam;\n                    origParams[i-1] = parameter;\n                    argList.addExpression(new VariableExpression(params[i - 1]));\n                }\n                createForwarderMethod(trait, cNode, methodNode, originalMethod, helperClassNode, methodGenericsSpec, helperMethodParams, origParams, params, argList);\n            }\n        }\n        cNode.addObjectInitializerStatements(new ExpressionStatement(\n                new MethodCallExpression(\n                        new ClassExpression(helperClassNode),\n                        Traits.INIT_METHOD,\n                        new ArgumentListExpression(new VariableExpression(\"this\")))\n        ));\n        MethodCallExpression staticInitCall = new MethodCallExpression(\n                new ClassExpression(helperClassNode),\n                Traits.STATIC_INIT_METHOD,\n                new ArgumentListExpression(new ClassExpression(cNode)));\n        MethodNode staticInitMethod = new MethodNode(\n                Traits.STATIC_INIT_METHOD, Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC, ClassHelper.VOID_TYPE,\n                new Parameter[] {new Parameter(ClassHelper.CLASS_Type,\"clazz\")}, ClassNode.EMPTY_ARRAY, EmptyStatement.INSTANCE);\n        staticInitMethod.setDeclaringClass(helperClassNode);\n        staticInitCall.setMethodTarget(staticInitMethod);\n        cNode.addStaticInitializerStatements(Collections.<Statement>singletonList(new ExpressionStatement(\n                staticInitCall\n        )), false);\n        if (fieldHelperClassNode != null && !cNode.declaresInterface(fieldHelperClassNode)) {\n            // we should implement the field helper interface too\n            cNode.addInterface(fieldHelperClassNode);\n            // implementation of methods\n            List<MethodNode> declaredMethods = new LinkedList<MethodNode>();\n            for (MethodNode declaredMethod : fieldHelperClassNode.getAllDeclaredMethods()) {\n                if (declaredMethod.getName().endsWith(Traits.DIRECT_GETTER_SUFFIX)) {\n                    declaredMethods.add(0, declaredMethod);\n                } else {\n                    declaredMethods.add(declaredMethod);\n                }\n            }\n            for (MethodNode methodNode : declaredMethods) {\n                String fieldName = methodNode.getName();\n                if (fieldName.endsWith(Traits.DIRECT_GETTER_SUFFIX) || fieldName.endsWith(Traits.DIRECT_SETTER_SUFFIX)) {\n                    int suffixIdx = fieldName.lastIndexOf(\"$\");\n                    fieldName = fieldName.substring(0, suffixIdx);\n                    String operation = methodNode.getName().substring(suffixIdx + 1);\n                    boolean getter = \"get\".equals(operation);\n                    ClassNode returnType = correctToGenericsSpecRecurse(genericsSpec, methodNode.getReturnType());\n                    int fieldMods = 0;\n                    int isStatic = 0;\n                    boolean publicField = true;\n                    FieldNode helperField = null;\n                    fieldMods = 0;\n                    isStatic = 0;\n\n                    // look first for field with encoded modifier information\n                    for (Integer mod : Traits.FIELD_PREFIXES) {\n                        helperField = fieldHelperClassNode.getField(String.format(\"$0x%04x\", mod) + fieldName);\n                        if (helperField != null) {\n                            if ((mod & Opcodes.ACC_STATIC) != 0) isStatic = Opcodes.ACC_STATIC;\n                            fieldMods = fieldMods | mod;\n                            break;\n                        }\n                    }\n\n                    if (helperField == null) {\n                        // look for possible legacy fields (trait compiled pre 2.4.8)\n                        helperField = fieldHelperClassNode.getField(Traits.FIELD_PREFIX + Traits.PUBLIC_FIELD_PREFIX + fieldName);\n                        if (helperField==null) {\n                            publicField = false;\n                            helperField = fieldHelperClassNode.getField(Traits.FIELD_PREFIX + Traits.PRIVATE_FIELD_PREFIX + fieldName);\n                        }\n                        if (helperField==null) {\n                            publicField = true;\n                            // try to find a static one\n                            helperField = fieldHelperClassNode.getField(Traits.STATIC_FIELD_PREFIX+Traits.PUBLIC_FIELD_PREFIX+fieldName);\n                            if (helperField==null) {\n                                publicField = false;\n                                helperField = fieldHelperClassNode.getField(Traits.STATIC_FIELD_PREFIX+Traits.PRIVATE_FIELD_PREFIX +fieldName);\n                            }\n                            fieldMods = fieldMods | Opcodes.ACC_STATIC;\n                            isStatic = Opcodes.ACC_STATIC;\n                        }\n                        fieldMods = fieldMods | (publicField?Opcodes.ACC_PUBLIC:Opcodes.ACC_PRIVATE);\n                    }\n                    if (getter) {\n                        // add field\n                        if (helperField!=null) {\n                            List<AnnotationNode> copied = new LinkedList<AnnotationNode>();\n                            List<AnnotationNode> notCopied = new LinkedList<AnnotationNode>();\n                            GeneralUtils.copyAnnotatedNodeAnnotations(helperField, copied, notCopied);\n                            FieldNode fieldNode = cNode.addField(fieldName, fieldMods, returnType, (fieldMods & Opcodes.ACC_FINAL) == 0 ? null : helperField.getInitialExpression());\n                            fieldNode.addAnnotations(copied);\n                            // getInitialExpression above will be null if not in same source unit\n                            // so instead set within (static) initializer\n                            if (fieldNode.isFinal() && !(helperClassNode instanceof InnerClassNode)) {\n                                String baseName = fieldNode.isStatic() ? Traits.STATIC_INIT_METHOD : Traits.INIT_METHOD;\n                                Expression mce = callX(helperClassNode, baseName + fieldNode.getName());\n                                Statement stmt = stmt(assignX(varX(fieldNode.getName(), fieldNode.getType()), mce));\n                                if (isStatic == 0) {\n                                    cNode.addObjectInitializerStatements(stmt);\n                                } else {\n                                    cNode.addStaticInitializerStatements(Collections.<Statement>singletonList(stmt), false);\n                                }\n                            }\n                        }\n                    }\n                    Parameter[] newParams;\n                    if (getter) {\n                        newParams = Parameter.EMPTY_ARRAY;\n                    } else {\n                        ClassNode originType = methodNode.getParameters()[0].getOriginType();\n                        ClassNode fixedType = originType.isGenericsPlaceHolder()?ClassHelper.OBJECT_TYPE:correctToGenericsSpecRecurse(genericsSpec, originType);\n                        newParams = new Parameter[]{new Parameter(fixedType, \"val\")};\n                    }\n\n                    Expression fieldExpr = varX(cNode.getField(fieldName));\n                    boolean finalSetter = !getter && (fieldMods & Opcodes.ACC_FINAL) != 0;\n                    Statement body =\n                            getter ? returnS(fieldExpr) :\n                                    (finalSetter ? null : stmt(\n                                            new BinaryExpression(\n                                                    fieldExpr,\n                                                    Token.newSymbol(Types.EQUAL, 0, 0),\n                                                    varX(newParams[0])\n                                            )\n                                    ));\n                    // add getter/setter even though setter not strictly needed for final fields\n                    // but add empty body for setter for legacy compatibility\n                    MethodNode impl = new MethodNode(\n                            methodNode.getName(),\n                            Opcodes.ACC_PUBLIC | isStatic,\n                            returnType,\n                            newParams,\n                            ClassNode.EMPTY_ARRAY,\n                            body\n                    );\n                    AnnotationNode an = new AnnotationNode(COMPILESTATIC_CLASSNODE);\n                    impl.addAnnotation(an);\n                    cNode.addTransform(StaticCompileTransformation.class, an);\n                    cNode.addMethod(impl);\n                }\n            }\n        }\n    }"
        ]
    ]
}