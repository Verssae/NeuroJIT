{
    "f39b83eebb6133086e01d98c1f3fb3af38f2dd09": [
        [
            "RabbitConsumer::handleDelivery(String,Envelope,AMQP,byte)",
            "  62  \n  63  \n  64 -\n  65  \n  66 -\n  67  \n  68  \n  69 -\n  70 -\n  71  \n  72  \n  73  \n  74  \n  75 -\n  76  \n  77 -\n  78 -\n  79 -\n  80 -\n  81 -\n  82 -\n  83 -\n  84 -\n  85  ",
            "    @Override\n    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n    \ttry {\n            if (!consumer.getEndpoint().isAutoAck()) {\n            \tlock.acquire();\n            }\n            //Channel might be open because while we were waiting for the lock, stop() has been succesfully called.\n            if (!channel.isOpen()) return;\n            \n            try {\n                doHandleDelivery(consumerTag, envelope, properties, body);\n            } finally {\n                if (!consumer.getEndpoint().isAutoAck()) {\n                \tlock.release();\n                }\n\t\t\t}\n    \t\t\n    \t} catch (InterruptedException e) {\n        \tlog.error(\"Thread Interrupted!\");\n    \t\t\n    \t}\n        \n\t\t\t\n    }",
            "  62  \n  63  \n  64 +\n  65  \n  66 +\n  67  \n  68  \n  69 +\n  70 +\n  71 +\n  72 +\n  73  \n  74  \n  75  \n  76  \n  77 +\n  78  \n  79 +\n  80 +\n  81 +\n  82 +\n  83 +\n  84  ",
            "    @Override\n    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n        try {\n            if (!consumer.getEndpoint().isAutoAck()) {\n                lock.acquire();\n            }\n            //Channel might be open because while we were waiting for the lock, stop() has been succesfully called.\n            if (!channel.isOpen()) {\n                return;\n            }\n\n            try {\n                doHandleDelivery(consumerTag, envelope, properties, body);\n            } finally {\n                if (!consumer.getEndpoint().isAutoAck()) {\n                    lock.release();\n                }\n            }\n\n        } catch (InterruptedException e) {\n            log.warn(\"Thread Interrupted!\");\n        }\n    }"
        ],
        [
            "RabbitConsumer::handleShutdownSignal(String,ShutdownSignalException)",
            " 245  \n 246  \n 247  \n 248  \n 249 -\n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  ",
            "    /**\n     * No-op implementation of {@link Consumer#handleShutdownSignal}.\n     */\n    public void handleShutdownSignal(String consumerTag, ShutdownSignalException sig) {\n        log.info(\"Recieved shutdown signal on the rabbitMQ channel\");\n\n        // Check if the consumer closed the connection or something else\n        if (!sig.isInitiatedByApplication()) {\n            // Something else closed the connection so reconnect\n            boolean connected = false;\n            while (!connected && !stopping) {\n                try {\n                    reconnect();\n                    connected = true;\n                } catch (IOException | TimeoutException e) {\n                    log.warn(\"Unable to obtain a RabbitMQ channel. Will try again\");\n\n                    Integer networkRecoveryInterval = consumer.getEndpoint().getNetworkRecoveryInterval();\n                    final long connectionRetryInterval = networkRecoveryInterval != null && networkRecoveryInterval > 0\n                            ? networkRecoveryInterval : 100L;\n                    try {\n                        Thread.sleep(connectionRetryInterval);\n                    } catch (InterruptedException e1) {\n                        Thread.currentThread().interrupt();\n                    }\n                }\n            }\n        }\n    }",
            " 244  \n 245  \n 246  \n 247  \n 248 +\n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  ",
            "    /**\n     * No-op implementation of {@link Consumer#handleShutdownSignal}.\n     */\n    public void handleShutdownSignal(String consumerTag, ShutdownSignalException sig) {\n        log.info(\"Received shutdown signal on the rabbitMQ channel\");\n\n        // Check if the consumer closed the connection or something else\n        if (!sig.isInitiatedByApplication()) {\n            // Something else closed the connection so reconnect\n            boolean connected = false;\n            while (!connected && !stopping) {\n                try {\n                    reconnect();\n                    connected = true;\n                } catch (IOException | TimeoutException e) {\n                    log.warn(\"Unable to obtain a RabbitMQ channel. Will try again\");\n\n                    Integer networkRecoveryInterval = consumer.getEndpoint().getNetworkRecoveryInterval();\n                    final long connectionRetryInterval = networkRecoveryInterval != null && networkRecoveryInterval > 0\n                            ? networkRecoveryInterval : 100L;\n                    try {\n                        Thread.sleep(connectionRetryInterval);\n                    } catch (InterruptedException e1) {\n                        Thread.currentThread().interrupt();\n                    }\n                }\n            }\n        }\n    }"
        ],
        [
            "RabbitConsumer::handleRecoverOk(String)",
            " 275  \n 276  \n 277  \n 278  \n 279  \n 280 -\n 281  ",
            "    /**\n     * No-op implementation of {@link Consumer#handleRecoverOk}.\n     */\n    public void handleRecoverOk(String consumerTag) {\n        // no work to do\n        log.debug(\"Recieved recover ok signal on the rabbitMQ channel\");\n    }",
            " 274  \n 275  \n 276  \n 277  \n 278  \n 279 +\n 280  ",
            "    /**\n     * No-op implementation of {@link Consumer#handleRecoverOk}.\n     */\n    public void handleRecoverOk(String consumerTag) {\n        // no work to do\n        log.debug(\"Received recover ok signal on the rabbitMQ channel\");\n    }"
        ],
        [
            "RabbitConsumer::stop()",
            " 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189 -\n 190  \n 191  \n 192  \n 193 -\n 194  \n 195  \n 196  \n 197 -\n 198  \n 199  ",
            "    /**\n     * Unbind consumer from channel\n     */\n    public void stop() throws IOException, TimeoutException {\n        stopping = true;\n        if (channel == null) {\n            return;\n        }\n        if (tag != null && isChannelOpen()) {\n            channel.basicCancel(tag);\n        }\n        try {\n\t\t\tlock.acquire();\n            if (isChannelOpen()) {\n                channel.close();\n            }\n\t\t} catch (TimeoutException e) {\n            log.error(\"Timeout occured\");\n            throw e;\n        } catch (InterruptedException e1) {\n        \tlog.error(\"Thread Interrupted!\");\n        } finally {\n            lock.release();",
            " 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188 +\n 189  \n 190  \n 191  \n 192 +\n 193  \n 194  \n 195  \n 196 +\n 197  \n 198  \n 199 +\n 200 +\n 201  ",
            "    /**\n     * Unbind consumer from channel\n     */\n    public void stop() throws IOException, TimeoutException {\n        stopping = true;\n        if (channel == null) {\n            return;\n        }\n        if (tag != null && isChannelOpen()) {\n            channel.basicCancel(tag);\n        }\n        try {\n            lock.acquire();\n            if (isChannelOpen()) {\n                channel.close();\n            }\n        } catch (TimeoutException e) {\n            log.error(\"Timeout occured\");\n            throw e;\n        } catch (InterruptedException e1) {\n            log.error(\"Thread Interrupted!\");\n        } finally {\n            lock.release();\n\n        }\n    }"
        ],
        [
            "RabbitMQConsumer::closeConnectionAndChannel()",
            " 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134 -\n 135 -\n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  ",
            "    /**\n     * If needed, close Connection and Channels\n     */\n    private void closeConnectionAndChannel() throws IOException, TimeoutException {\n        if (startConsumerCallable != null) {\n            startConsumerCallable.stop();\n        }\n        for (RabbitConsumer consumer : this.consumers) {\n            try {\n                consumer.stop();\n            } catch (TimeoutException e) {\n                log.error(\"Timeout occured\");\n                throw e;\n            }\n        }\n        this.consumers.clear();\n        if (conn != null) {\n            log.debug(\"Closing connection: {} with timeout: {} ms.\", conn, closeTimeout);\n            conn.close(closeTimeout);\n            conn = null;\n        }\n    }",
            " 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134 +\n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  ",
            "    /**\n     * If needed, close Connection and Channels\n     */\n    private void closeConnectionAndChannel() throws IOException, TimeoutException {\n        if (startConsumerCallable != null) {\n            startConsumerCallable.stop();\n        }\n        for (RabbitConsumer consumer : this.consumers) {\n            try {\n                consumer.stop();\n            } catch (TimeoutException e) {\n                log.warn(\"Timeout occurred while stopping consumer. This exception is ignored\", e);\n            }\n        }\n        this.consumers.clear();\n        if (conn != null) {\n            log.debug(\"Closing connection: {} with timeout: {} ms.\", conn, closeTimeout);\n            conn.close(closeTimeout);\n            conn = null;\n        }\n    }"
        ],
        [
            "RabbitConsumer::handleCancelOk(String)",
            " 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231 -\n 232  ",
            "    /**\n     * No-op implementation of {@link Consumer#handleCancelOk}.\n     * \n     * @param consumerTag\n     *            the defined consumer tag (client- or server-generated)\n     */\n    public void handleCancelOk(String consumerTag) {\n        // no work to do\n        log.debug(\"Recieved cancelOk signal on the rabbitMQ channel\");\n    }",
            " 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230 +\n 231  ",
            "    /**\n     * No-op implementation of {@link Consumer#handleCancelOk}.\n     *\n     * @param consumerTag\n     *            the defined consumer tag (client- or server-generated)\n     */\n    public void handleCancelOk(String consumerTag) {\n        // no work to do\n        log.debug(\"Received cancelOk signal on the rabbitMQ channel\");\n    }"
        ],
        [
            "RabbitConsumer::handleCancel(String)",
            " 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242 -\n 243  ",
            "    /**\n     * No-op implementation of {@link Consumer#handleCancel(String)}\n     * \n     * @param consumerTag\n     *            the defined consumer tag (client- or server-generated)\n     */\n    public void handleCancel(String consumerTag) throws IOException {\n        // no work to do\n        log.debug(\"Recieved cancel signal on the rabbitMQ channel\");\n    }",
            " 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241 +\n 242  ",
            "    /**\n     * No-op implementation of {@link Consumer#handleCancel(String)}\n     *\n     * @param consumerTag\n     *            the defined consumer tag (client- or server-generated)\n     */\n    public void handleCancel(String consumerTag) throws IOException {\n        // no work to do\n        log.debug(\"Received cancel signal on the rabbitMQ channel\");\n    }"
        ]
    ],
    "b5d907fb95f856585f1508fe805bec25dec7c4c4": [
        [
            "OsgiCamelContextPublisher::registerCamelContext(CamelContext)",
            "  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116 -\n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  ",
            "    public ServiceRegistration<?> registerCamelContext(CamelContext camelContext) throws InvalidSyntaxException {\n        // avoid registering the same service again\n        // we must include unique camel management name so the symbolic name becomes unique,\n        // in case the bundle has more than one CamelContext\n        String name = camelContext.getName();\n        String managementName = camelContext.getManagementName();\n        String symbolicName = bundleContext.getBundle().getSymbolicName();\n\n        if (!lookupCamelContext(bundleContext, symbolicName, name)) {\n            Version bundleVersion = getBundleVersion(bundleContext.getBundle());\n\n            Dictionary<String, Object > props = new Hashtable<String, Object>();\n            props.put(CONTEXT_SYMBOLIC_NAME_PROPERTY, symbolicName);\n            props.put(CONTEXT_VERSION_PROPERTY, bundleVersion);\n            props.put(CONTEXT_NAME_PROPERTY, name);\n            if (managementName != null) {\n                props.put(CONTEXT_MANAGEMENT_NAME_PROPERTY, managementName);\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Registering CamelContext [{}] of in OSGi registry\", camelContext.getName());\n            }\n\n            ServiceRegistration<?> reg = bundleContext.registerService(CamelContext.class.getName(), camelContext, props);\n            if (reg != null) {\n                registrations.put(camelContext, reg);\n            }\n            return reg;\n        } else {\n            return null;\n        }\n    }",
            "  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116 +\n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  ",
            "    public ServiceRegistration<?> registerCamelContext(CamelContext camelContext) throws InvalidSyntaxException {\n        // avoid registering the same service again\n        // we must include unique camel management name so the symbolic name becomes unique,\n        // in case the bundle has more than one CamelContext\n        String name = camelContext.getName();\n        String managementName = camelContext.getManagementName();\n        String symbolicName = bundleContext.getBundle().getSymbolicName();\n\n        if (!lookupCamelContext(bundleContext, symbolicName, name)) {\n            Version bundleVersion = getBundleVersion(bundleContext.getBundle());\n\n            Dictionary<String, Object > props = new Hashtable<String, Object>();\n            props.put(CONTEXT_SYMBOLIC_NAME_PROPERTY, symbolicName);\n            props.put(CONTEXT_VERSION_PROPERTY, bundleVersion);\n            props.put(CONTEXT_NAME_PROPERTY, name);\n            if (managementName != null) {\n                props.put(CONTEXT_MANAGEMENT_NAME_PROPERTY, managementName);\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Registering CamelContext [{}] of in OSGi registry\", name);\n            }\n\n            ServiceRegistration<?> reg = bundleContext.registerService(CamelContext.class.getName(), camelContext, props);\n            if (reg != null) {\n                registrations.put(camelContext, reg);\n            }\n            return reg;\n        } else {\n            return null;\n        }\n    }"
        ],
        [
            "JmsEndpoint::configureListenerContainer(AbstractMessageListenerContainer,JmsConsumer)",
            " 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232 -\n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  ",
            "    public void configureListenerContainer(AbstractMessageListenerContainer listenerContainer, JmsConsumer consumer) {\n        if (destinationName != null) {\n            listenerContainer.setDestinationName(destinationName);\n            log.debug(\"Using destinationName: {} on listenerContainer: {}\", destinationName, listenerContainer);\n        } else if (destination != null) {\n            listenerContainer.setDestination(destination);\n            log.debug(\"Using destination: {} on listenerContainer: {}\", destinationName, listenerContainer);\n        } else {\n            DestinationResolver resolver = getDestinationResolver();\n            if (resolver != null) {\n                listenerContainer.setDestinationResolver(resolver);\n            } else {\n                throw new IllegalArgumentException(\"Neither destination, destinationName or destinationResolver are specified on this endpoint!\");\n            }\n            log.debug(\"Using destinationResolver: {} on listenerContainer: {}\", resolver, listenerContainer);\n        }\n        listenerContainer.setPubSubDomain(pubSubDomain);\n\n        // include destination name as part of thread and transaction name\n        String consumerName = getThreadName();\n\n        if (configuration.getTaskExecutor() != null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Using custom TaskExecutor: {} on listener container: {}\", configuration.getTaskExecutor(), listenerContainer);\n            }\n            setContainerTaskExecutor(listenerContainer, configuration.getTaskExecutor());\n            // we are using a shared thread pool that this listener container is using.\n            // store a reference to the consumer, but we should not shutdown the thread pool when the consumer stops\n            // as the lifecycle of the shared thread pool is handled elsewhere\n            if (configuration.getTaskExecutor() instanceof ExecutorService) {\n                consumer.setListenerContainerExecutorService((ExecutorService) configuration.getTaskExecutor(), false);\n            }\n        } else if ((listenerContainer instanceof DefaultJmsMessageListenerContainer && configuration.getDefaultTaskExecutorType() == null)\n                || !(listenerContainer instanceof DefaultJmsMessageListenerContainer)) {\n            // preserve backwards compatibility if an explicit Default TaskExecutor Type was not set;\n            // otherwise, defer the creation of the TaskExecutor\n            // use a cached pool as DefaultMessageListenerContainer will throttle pool sizing\n            ExecutorService executor = getCamelContext().getExecutorServiceManager().newCachedThreadPool(consumer, consumerName);\n            setContainerTaskExecutor(listenerContainer, executor);\n            // we created a new private thread pool that this listener container is using, now store a reference on the consumer\n            // so when the consumer is stopped we can shutdown the thread pool also, to ensure all resources is shutdown\n            consumer.setListenerContainerExecutorService(executor, true);\n        } else {\n            // do nothing, as we're working with a DefaultJmsMessageListenerContainer with an explicit DefaultTaskExecutorType,\n            // so DefaultJmsMessageListenerContainer#createDefaultTaskExecutor will handle the creation\n            log.debug(\"Deferring creation of TaskExecutor for listener container: {} as per policy: {}\",\n                    listenerContainer, configuration.getDefaultTaskExecutorType());\n        }\n\n        // set a default transaction name if none provided\n        if (configuration.getTransactionName() == null) {\n            if (listenerContainer instanceof DefaultMessageListenerContainer) {\n                ((DefaultMessageListenerContainer) listenerContainer).setTransactionName(consumerName);\n            }\n        }\n    }",
            " 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232 +\n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  ",
            "    public void configureListenerContainer(AbstractMessageListenerContainer listenerContainer, JmsConsumer consumer) {\n        if (destinationName != null) {\n            listenerContainer.setDestinationName(destinationName);\n            log.debug(\"Using destinationName: {} on listenerContainer: {}\", destinationName, listenerContainer);\n        } else if (destination != null) {\n            listenerContainer.setDestination(destination);\n            log.debug(\"Using destination: {} on listenerContainer: {}\", destinationName, listenerContainer);\n        } else {\n            DestinationResolver resolver = getDestinationResolver();\n            if (resolver != null) {\n                listenerContainer.setDestinationResolver(resolver);\n            } else {\n                throw new IllegalArgumentException(\"Neither destination, destinationName or destinationResolver are specified on this endpoint!\");\n            }\n            log.debug(\"Using destinationResolver: {} on listenerContainer: {}\", resolver, listenerContainer);\n        }\n        listenerContainer.setPubSubDomain(pubSubDomain);\n\n        // include destination name as part of thread and transaction name\n        String consumerName = getThreadName();\n\n        if (configuration.getTaskExecutor() != null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Using custom TaskExecutor: {} on listener container: {}\", configuration.getTaskExecutor(), listenerContainer);\n            }\n            setContainerTaskExecutor(listenerContainer, configuration.getTaskExecutor());\n            // we are using a shared thread pool that this listener container is using.\n            // store a reference to the consumer, but we should not shutdown the thread pool when the consumer stops\n            // as the lifecycle of the shared thread pool is handled elsewhere\n            if (configuration.getTaskExecutor() instanceof ExecutorService) {\n                consumer.setListenerContainerExecutorService((ExecutorService) configuration.getTaskExecutor(), false);\n            }\n        } else if ((listenerContainer instanceof DefaultJmsMessageListenerContainer && configuration.getDefaultTaskExecutorType() == null)\n                || !(listenerContainer instanceof DefaultJmsMessageListenerContainer)) {\n            // preserve backwards compatibility if an explicit Default TaskExecutor Type was not set;\n            // otherwise, defer the creation of the TaskExecutor\n            // use a cached pool as DefaultMessageListenerContainer will throttle pool sizing\n            ExecutorService executor = getCamelContext().getExecutorServiceManager().newCachedThreadPool(consumer, consumerName);\n            setContainerTaskExecutor(listenerContainer, executor);\n            // we created a new private thread pool that this listener container is using, now store a reference on the consumer\n            // so when the consumer is stopped we can shutdown the thread pool also, to ensure all resources is shutdown\n            consumer.setListenerContainerExecutorService(executor, true);\n        } else {\n            // do nothing, as we're working with a DefaultJmsMessageListenerContainer with an explicit DefaultTaskExecutorType,\n            // so DefaultJmsMessageListenerContainer#createDefaultTaskExecutor will handle the creation\n            log.debug(\"Deferring creation of TaskExecutor for listener container: {} as per policy: {}\",\n                    listenerContainer, getDefaultTaskExecutorType());\n        }\n\n        // set a default transaction name if none provided\n        if (configuration.getTransactionName() == null) {\n            if (listenerContainer instanceof DefaultMessageListenerContainer) {\n                ((DefaultMessageListenerContainer) listenerContainer).setTransactionName(consumerName);\n            }\n        }\n    }"
        ],
        [
            "InjectorManager::afterClasses()",
            "  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81 -\n  82 -\n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  ",
            "    /** Lets close all of the injectors we have created so far */\n    public void afterClasses() throws CloseFailedException {\n        Injector injector = injectors.get(moduleType);\n        if (injector != null) {\n            classScope.close(injector);\n        } else {\n            System.out.println(\"Could not close Class scope as there is no Injector for module type \"\n                               + injector);\n        }\n\n        // NOTE that we don't have any good hooks yet to call complete()\n        // when the JVM is completed to ensure real singletons shut down\n        // correctly\n        //\n        if (isCloseSingletonsAfterClasses()) {\n            closeInjectors();\n        }\n    }",
            "  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81 +\n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  ",
            "    /** Lets close all of the injectors we have created so far */\n    public void afterClasses() throws CloseFailedException {\n        Injector injector = injectors.get(moduleType);\n        if (injector != null) {\n            classScope.close(injector);\n        } else {\n            System.out.println(\"Could not close Class scope as there is no Injector for module type\");\n        }\n\n        // NOTE that we don't have any good hooks yet to call complete()\n        // when the JVM is completed to ensure real singletons shut down\n        // correctly\n        //\n        if (isCloseSingletonsAfterClasses()) {\n            closeInjectors();\n        }\n    }"
        ],
        [
            "SnmpTrapConsumer::processPdu(CommandResponderEvent)",
            " 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131 -\n 132  \n 133  ",
            "    public void processPdu(CommandResponderEvent event) {\n        PDU pdu = event.getPDU();\n        // check PDU not null\n        if (pdu != null) {\n            // check for INFORM\n            // code take from the book \"Essential SNMP\"\n            if ((pdu.getType() != PDU.TRAP) && (pdu.getType() != PDU.V1TRAP) && (pdu.getType() != PDU.REPORT)\n                && (pdu.getType() != PDU.RESPONSE)) {\n                // first response the inform-message and then process the\n                // message\n                pdu.setErrorIndex(0);\n                pdu.setErrorStatus(0);\n                pdu.setType(PDU.RESPONSE);\n                StatusInformation statusInformation = new StatusInformation();\n                StateReference ref = event.getStateReference();\n                try {\n                    event.getMessageDispatcher().returnResponsePdu(event.getMessageProcessingModel(),\n                                                                   event.getSecurityModel(),\n                                                                   event.getSecurityName(),\n                                                                   event.getSecurityLevel(), pdu,\n                                                                   event.getMaxSizeResponsePDU(), ref,\n                                                                   statusInformation);\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"response to INFORM sent\");\n                    }\n                } catch (MessageException ex) {\n                    getExceptionHandler().handleException(ex);\n                }\n            }\n            processPDU(pdu, event);\n        } else {\n            LOG.debug(\"Received invalid trap PDU: \" + pdu);\n        }\n    }",
            " 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131 +\n 132  \n 133  ",
            "    public void processPdu(CommandResponderEvent event) {\n        PDU pdu = event.getPDU();\n        // check PDU not null\n        if (pdu != null) {\n            // check for INFORM\n            // code take from the book \"Essential SNMP\"\n            if ((pdu.getType() != PDU.TRAP) && (pdu.getType() != PDU.V1TRAP) && (pdu.getType() != PDU.REPORT)\n                && (pdu.getType() != PDU.RESPONSE)) {\n                // first response the inform-message and then process the\n                // message\n                pdu.setErrorIndex(0);\n                pdu.setErrorStatus(0);\n                pdu.setType(PDU.RESPONSE);\n                StatusInformation statusInformation = new StatusInformation();\n                StateReference ref = event.getStateReference();\n                try {\n                    event.getMessageDispatcher().returnResponsePdu(event.getMessageProcessingModel(),\n                                                                   event.getSecurityModel(),\n                                                                   event.getSecurityName(),\n                                                                   event.getSecurityLevel(), pdu,\n                                                                   event.getMaxSizeResponsePDU(), ref,\n                                                                   statusInformation);\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"response to INFORM sent\");\n                    }\n                } catch (MessageException ex) {\n                    getExceptionHandler().handleException(ex);\n                }\n            }\n            processPDU(pdu, event);\n        } else {\n            LOG.debug(\"Received invalid trap PDU\");\n        }\n    }"
        ],
        [
            "BacklogDebugger::NodeBreakpoint::beforeProcess(Exchange,Processor,ProcessorDefinition)",
            " 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564 -\n 565  \n 566  \n 567  \n 568 -\n 569  \n 570 -\n 571  \n 572  \n 573  \n 574  \n 575  \n 576  ",
            "        @Override\n        public void beforeProcess(Exchange exchange, Processor processor, ProcessorDefinition<?> definition) {\n            // store a copy of the message so we can see that from the debugger\n            Date timestamp = new Date();\n            String toNode = definition.getId();\n            String routeId = ProcessorDefinitionHelper.getRouteId(definition);\n            String exchangeId = exchange.getExchangeId();\n            String messageAsXml = MessageHelper.dumpAsXml(exchange.getIn(), true, 2, isBodyIncludeStreams(), isBodyIncludeFiles(), getBodyMaxChars());\n            long uid = debugCounter.incrementAndGet();\n\n            BacklogTracerEventMessage msg = new DefaultBacklogTracerEventMessage(uid, timestamp, routeId, toNode, exchangeId, messageAsXml);\n            suspendedBreakpointMessages.put(nodeId, msg);\n\n            // suspend at this breakpoint\n            final SuspendedExchange se = suspendedBreakpoints.get(nodeId);\n            if (se != null) {\n                // now wait until we should continue\n                logger.log(\"NodeBreakpoint at node \" + toNode + \" is waiting to continue for exchangeId: \" + exchange.getExchangeId());\n                try {\n                    boolean hit = se.getLatch().await(fallbackTimeout, TimeUnit.SECONDS);\n                    if (!hit) {\n                        logger.log(\"NodeBreakpoint at node \" + toNode + \" timed out and is continued exchangeId: \" + exchange.getExchangeId(), LoggingLevel.WARN);\n                    } else {\n                        logger.log(\"NodeBreakpoint at node \" + toNode + \" is continued exchangeId: \" + exchange.getExchangeId());\n                    }\n                } catch (InterruptedException e) {\n                    // ignore\n                }\n            }\n        }",
            " 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564 +\n 565  \n 566  \n 567  \n 568 +\n 569  \n 570 +\n 571  \n 572  \n 573  \n 574  \n 575  \n 576  ",
            "        @Override\n        public void beforeProcess(Exchange exchange, Processor processor, ProcessorDefinition<?> definition) {\n            // store a copy of the message so we can see that from the debugger\n            Date timestamp = new Date();\n            String toNode = definition.getId();\n            String routeId = ProcessorDefinitionHelper.getRouteId(definition);\n            String exchangeId = exchange.getExchangeId();\n            String messageAsXml = MessageHelper.dumpAsXml(exchange.getIn(), true, 2, isBodyIncludeStreams(), isBodyIncludeFiles(), getBodyMaxChars());\n            long uid = debugCounter.incrementAndGet();\n\n            BacklogTracerEventMessage msg = new DefaultBacklogTracerEventMessage(uid, timestamp, routeId, toNode, exchangeId, messageAsXml);\n            suspendedBreakpointMessages.put(nodeId, msg);\n\n            // suspend at this breakpoint\n            final SuspendedExchange se = suspendedBreakpoints.get(nodeId);\n            if (se != null) {\n                // now wait until we should continue\n                logger.log(\"NodeBreakpoint at node \" + toNode + \" is waiting to continue for exchangeId: \" + exchangeId);\n                try {\n                    boolean hit = se.getLatch().await(fallbackTimeout, TimeUnit.SECONDS);\n                    if (!hit) {\n                        logger.log(\"NodeBreakpoint at node \" + toNode + \" timed out and is continued exchangeId: \" + exchangeId, LoggingLevel.WARN);\n                    } else {\n                        logger.log(\"NodeBreakpoint at node \" + toNode + \" is continued exchangeId: \" + exchangeId);\n                    }\n                } catch (InterruptedException e) {\n                    // ignore\n                }\n            }\n        }"
        ],
        [
            "AggregateProcessor::doForceCompletionOnStop()",
            "1438  \n1439  \n1440  \n1441  \n1442  \n1443 -\n1444  \n1445  \n1446  \n1447  \n1448 -\n1449  \n1450  \n1451  \n1452  \n1453  \n1454  \n1455  \n1456  ",
            "    private void doForceCompletionOnStop() {\n        int expected = forceCompletionOfAllGroups();\n\n        StopWatch watch = new StopWatch();\n        while (inProgressCompleteExchanges.size() > 0) {\n            LOG.trace(\"Waiting for {} inflight exchanges to complete\", inProgressCompleteExchanges.size());\n            try {\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                // break out as we got interrupted such as the JVM terminating\n                LOG.warn(\"Interrupted while waiting for {} inflight exchanges to complete.\", inProgressCompleteExchanges.size());\n                break;\n            }\n        }\n\n        if (expected > 0) {\n            LOG.info(\"Forcing completion of all groups with {} exchanges completed in {}\", expected, TimeUtils.printDuration(watch.stop()));\n        }\n    }",
            "1438  \n1439  \n1440  \n1441  \n1442  \n1443 +\n1444  \n1445  \n1446  \n1447  \n1448 +\n1449  \n1450  \n1451  \n1452  \n1453  \n1454  \n1455  \n1456  ",
            "    private void doForceCompletionOnStop() {\n        int expected = forceCompletionOfAllGroups();\n\n        StopWatch watch = new StopWatch();\n        while (inProgressCompleteExchanges.size() > 0) {\n            LOG.trace(\"Waiting for {} inflight exchanges to complete\", getInProgressCompleteExchanges());\n            try {\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                // break out as we got interrupted such as the JVM terminating\n                LOG.warn(\"Interrupted while waiting for {} inflight exchanges to complete.\", getInProgressCompleteExchanges());\n                break;\n            }\n        }\n\n        if (expected > 0) {\n            LOG.info(\"Forcing completion of all groups with {} exchanges completed in {}\", expected, TimeUtils.printDuration(watch.stop()));\n        }\n    }"
        ],
        [
            "DisruptorReference::removeEndpoint(DisruptorEndpoint)",
            " 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371 -\n 372  ",
            "    public synchronized void removeEndpoint(final DisruptorEndpoint disruptorEndpoint) {\n        LOGGER.debug(\"Removing Endpoint: \" + disruptorEndpoint);\n        if (getEndpointCount() == 1) {\n            LOGGER.debug(\"Last Endpoint removed, shutdown disruptor\");\n            //Shutdown our disruptor\n            shutdownDisruptor(false);\n\n            //As there are no endpoints dependent on this Disruptor, we may also shutdown our executor\n            shutdownExecutor();\n        }\n        endpoints.remove(disruptorEndpoint);\n        LOGGER.debug(\"Endpoint removed: {}, new total endpoints {}\", disruptorEndpoint, endpoints.size());\n    }",
            " 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371 +\n 372  ",
            "    public synchronized void removeEndpoint(final DisruptorEndpoint disruptorEndpoint) {\n        LOGGER.debug(\"Removing Endpoint: \" + disruptorEndpoint);\n        if (getEndpointCount() == 1) {\n            LOGGER.debug(\"Last Endpoint removed, shutdown disruptor\");\n            //Shutdown our disruptor\n            shutdownDisruptor(false);\n\n            //As there are no endpoints dependent on this Disruptor, we may also shutdown our executor\n            shutdownExecutor();\n        }\n        endpoints.remove(disruptorEndpoint);\n        LOGGER.debug(\"Endpoint removed: {}, new total endpoints {}\", disruptorEndpoint, getEndpointCount());\n    }"
        ]
    ],
    "e0ff3755efc141714aa48ae4c0d1024249dfd0cf": [
        [
            "DdbStreamConsumerTest::GetRecordsAnswer::answer(InvocationOnMock)",
            " 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190 -\n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  ",
            "        @Override\n        public GetRecordsResult answer(InvocationOnMock invocation) throws Throwable {\n            final String shardIterator = ((GetRecordsRequest) invocation.getArguments()[0]).getShardIterator();\n            // note that HashMap returns null when there is no entry in the map.\n            // A null 'nextShardIterator' indicates that the shard has finished\n            // and we should move onto the next shard.\n            String nextShardIterator = shardIterators.get(shardIterator);\n            Matcher m = SHARD_ITERATOR_PATTERN.matcher(shardIterator);\n            Collection<Record> ans = answers.get(shardIterator);\n            if (nextShardIterator == null && m.matches()) { // last shard iterates forever.\n                Integer num = Integer.parseInt(m.group(1));\n                nextShardIterator = \"shard_iterator_d_\" + pad(Integer.toString(num + 1), 3);\n            }\n            if (null == ans) { // default to an empty list of records.\n                ans = createRecords();\n            }\n            return new GetRecordsResult()\n                    .withRecords(ans)\n                    .withNextShardIterator(nextShardIterator);\n        }",
            " 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190 +\n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  ",
            "        @Override\n        public GetRecordsResult answer(InvocationOnMock invocation) throws Throwable {\n            final String shardIterator = ((GetRecordsRequest) invocation.getArguments()[0]).getShardIterator();\n            // note that HashMap returns null when there is no entry in the map.\n            // A null 'nextShardIterator' indicates that the shard has finished\n            // and we should move onto the next shard.\n            String nextShardIterator = shardIterators.get(shardIterator);\n            Matcher m = shardIteratorPattern.matcher(shardIterator);\n            Collection<Record> ans = answers.get(shardIterator);\n            if (nextShardIterator == null && m.matches()) { // last shard iterates forever.\n                Integer num = Integer.parseInt(m.group(1));\n                nextShardIterator = \"shard_iterator_d_\" + pad(Integer.toString(num + 1), 3);\n            }\n            if (null == ans) { // default to an empty list of records.\n                ans = createRecords();\n            }\n            return new GetRecordsResult()\n                    .withRecords(ans)\n                    .withNextShardIterator(nextShardIterator);\n        }"
        ],
        [
            "SparkComponent::doCreateConsumer(CamelContext,Processor,String,String,String,String,String,RestConfiguration,Map,boolean)",
            " 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302 -\n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344  \n 345  \n 346  \n 347  ",
            "    Consumer doCreateConsumer(CamelContext camelContext, Processor processor, String verb, String basePath, String uriTemplate,\n                              String consumes, String produces, RestConfiguration configuration, Map<String, Object> parameters, boolean api) throws Exception {\n\n        String path = basePath;\n        if (uriTemplate != null) {\n            // make sure to avoid double slashes\n            if (uriTemplate.startsWith(\"/\")) {\n                path = path + uriTemplate;\n            } else {\n                path = path + \"/\" + uriTemplate;\n            }\n        }\n        path = FileUtil.stripLeadingSeparator(path);\n\n        RestConfiguration config = configuration;\n        if (config == null) {\n            config = camelContext.getRestConfiguration(\"spark-rest\", true);\n        }\n\n        Map<String, Object> map = new HashMap<String, Object>();\n        if (consumes != null) {\n            map.put(\"accept\", consumes);\n        }\n\n        // setup endpoint options\n        if (config.getEndpointProperties() != null && !config.getEndpointProperties().isEmpty()) {\n            map.putAll(config.getEndpointProperties());\n        }\n\n        if (ObjectHelper.isNotEmpty(path)) {\n            // spark-rest uses :name syntax instead of {name} so we need to replace those\n            Matcher matcher = pattern.matcher(path);\n            path = matcher.replaceAll(\":$1\");\n        }\n\n        // prefix path with context-path if configured in rest-dsl configuration\n        String contextPath = config.getContextPath();\n        if (ObjectHelper.isNotEmpty(contextPath)) {\n            contextPath = FileUtil.stripTrailingSeparator(contextPath);\n            contextPath = FileUtil.stripLeadingSeparator(contextPath);\n            if (ObjectHelper.isNotEmpty(contextPath)) {\n                path = contextPath + \"/\" + path;\n            }\n        }\n\n        String url;\n        if (api) {\n            url = \"spark-rest:%s:%s?matchOnUriPrefix=true\";\n        } else {\n            url = \"spark-rest:%s:%s\";\n        }\n\n        url = String.format(url, verb, path);\n\n        String query = URISupport.createQueryString(map);\n        if (!query.isEmpty()) {\n            url = url + \"?\" + query;\n        }\n\n        // get the endpoint\n        SparkEndpoint endpoint = camelContext.getEndpoint(url, SparkEndpoint.class);\n        setProperties(camelContext, endpoint, parameters);\n\n        // configure consumer properties\n        Consumer consumer = endpoint.createConsumer(processor);\n        if (config.isEnableCORS()) {\n            // if CORS is enabled then configure that on the spark consumer\n            if (config.getConsumerProperties() == null) {\n                config.setConsumerProperties(new HashMap<String, Object>());\n            }\n            config.getConsumerProperties().put(\"enableCors\", true);\n        }\n        if (config.getConsumerProperties() != null && !config.getConsumerProperties().isEmpty()) {\n            setProperties(camelContext, consumer, config.getConsumerProperties());\n        }\n        return consumer;\n    }",
            " 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302 +\n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344  \n 345  \n 346  \n 347  ",
            "    Consumer doCreateConsumer(CamelContext camelContext, Processor processor, String verb, String basePath, String uriTemplate,\n                              String consumes, String produces, RestConfiguration configuration, Map<String, Object> parameters, boolean api) throws Exception {\n\n        String path = basePath;\n        if (uriTemplate != null) {\n            // make sure to avoid double slashes\n            if (uriTemplate.startsWith(\"/\")) {\n                path = path + uriTemplate;\n            } else {\n                path = path + \"/\" + uriTemplate;\n            }\n        }\n        path = FileUtil.stripLeadingSeparator(path);\n\n        RestConfiguration config = configuration;\n        if (config == null) {\n            config = camelContext.getRestConfiguration(\"spark-rest\", true);\n        }\n\n        Map<String, Object> map = new HashMap<String, Object>();\n        if (consumes != null) {\n            map.put(\"accept\", consumes);\n        }\n\n        // setup endpoint options\n        if (config.getEndpointProperties() != null && !config.getEndpointProperties().isEmpty()) {\n            map.putAll(config.getEndpointProperties());\n        }\n\n        if (ObjectHelper.isNotEmpty(path)) {\n            // spark-rest uses :name syntax instead of {name} so we need to replace those\n            Matcher matcher = PATTERN.matcher(path);\n            path = matcher.replaceAll(\":$1\");\n        }\n\n        // prefix path with context-path if configured in rest-dsl configuration\n        String contextPath = config.getContextPath();\n        if (ObjectHelper.isNotEmpty(contextPath)) {\n            contextPath = FileUtil.stripTrailingSeparator(contextPath);\n            contextPath = FileUtil.stripLeadingSeparator(contextPath);\n            if (ObjectHelper.isNotEmpty(contextPath)) {\n                path = contextPath + \"/\" + path;\n            }\n        }\n\n        String url;\n        if (api) {\n            url = \"spark-rest:%s:%s?matchOnUriPrefix=true\";\n        } else {\n            url = \"spark-rest:%s:%s\";\n        }\n\n        url = String.format(url, verb, path);\n\n        String query = URISupport.createQueryString(map);\n        if (!query.isEmpty()) {\n            url = url + \"?\" + query;\n        }\n\n        // get the endpoint\n        SparkEndpoint endpoint = camelContext.getEndpoint(url, SparkEndpoint.class);\n        setProperties(camelContext, endpoint, parameters);\n\n        // configure consumer properties\n        Consumer consumer = endpoint.createConsumer(processor);\n        if (config.isEnableCORS()) {\n            // if CORS is enabled then configure that on the spark consumer\n            if (config.getConsumerProperties() == null) {\n                config.setConsumerProperties(new HashMap<String, Object>());\n            }\n            config.getConsumerProperties().put(\"enableCors\", true);\n        }\n        if (config.getConsumerProperties() != null && !config.getConsumerProperties().isEmpty()) {\n            setProperties(camelContext, consumer, config.getConsumerProperties());\n        }\n        return consumer;\n    }"
        ],
        [
            "JasyptPropertiesParser::parseProperty(String,String,Properties)",
            "  51  \n  52  \n  53  \n  54  \n  55  \n  56 -\n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  ",
            "    @Override\n    public String parseProperty(String key, String value, Properties properties) {\n        log.trace(format(\"Parsing property '%s=%s'\", key, value));\n        if (value != null) {\n            initEncryptor();\n            Matcher matcher = pattern.matcher(value);\n            while (matcher.find()) {\n                log.trace(format(\"Decrypting part '%s'\", matcher.group(0)));\n                String decrypted = encryptor.decrypt(matcher.group(1));\n                value = value.replace(matcher.group(0), decrypted);\n            }\n        }\n        return value;\n    }",
            "  51  \n  52  \n  53  \n  54  \n  55  \n  56 +\n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  ",
            "    @Override\n    public String parseProperty(String key, String value, Properties properties) {\n        log.trace(format(\"Parsing property '%s=%s'\", key, value));\n        if (value != null) {\n            initEncryptor();\n            Matcher matcher = PATTERN.matcher(value);\n            while (matcher.find()) {\n                log.trace(format(\"Decrypting part '%s'\", matcher.group(0)));\n                String decrypted = encryptor.decrypt(matcher.group(1));\n                value = value.replace(matcher.group(0), decrypted);\n            }\n        }\n        return value;\n    }"
        ],
        [
            "DropboxConfigurationValidator::validatePathInUnix(String)",
            " 119  \n 120 -\n 121  \n 122  \n 123  \n 124  ",
            "    private static void validatePathInUnix(String path) throws DropboxException {\n        Matcher matcher = pattern.matcher(path);\n        if (!matcher.matches()) {\n            throw new DropboxException(path + \" is not a valid path, must be in UNIX form!\");\n        }\n    }",
            " 119  \n 120 +\n 121  \n 122  \n 123  \n 124  ",
            "    private static void validatePathInUnix(String path) throws DropboxException {\n        Matcher matcher = PATTERN.matcher(path);\n        if (!matcher.matches()) {\n            throw new DropboxException(path + \" is not a valid path, must be in UNIX form!\");\n        }\n    }"
        ]
    ],
    "dd6f9ba60fb472b5a4e44f5b7d0a89b7dc895ade": [
        [
            "DefaultUndertowHttpBinding::toHttpRequest(ClientRequest,Message)",
            " 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357 -\n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374 -\n 375  \n 376  \n 377  \n 378  \n 379  \n 380  ",
            "    @Override\n    public Object toHttpRequest(ClientRequest clientRequest, Message message) {\n\n        Object body = message.getBody();\n\n        // set the content type in the response.\n        String contentType = MessageHelper.getContentType(message);\n        if (contentType != null) {\n            // set content-type\n            clientRequest.getRequestHeaders().put(Headers.CONTENT_TYPE, contentType);\n            LOG.trace(\"Content-Type: {}\", contentType);\n        }\n\n        TypeConverter tc = message.getExchange().getContext().getTypeConverter();\n\n        //copy headers from Message to Request\n        for (Map.Entry<String, Object> entry : message.getHeaders().entrySet()) {\n            String key = entry.getKey();\n            Object value = entry.getValue();\n            // use an iterator as there can be multiple values. (must not use a delimiter)\n            final Iterator<?> it = ObjectHelper.createIterator(value, null);\n            while (it.hasNext()) {\n                String headerValue = tc.convertTo(String.class, it.next());\n                if (headerValue != null && headerFilterStrategy != null\n                        && !headerFilterStrategy.applyFilterToCamelHeaders(key, headerValue, message.getExchange())) {\n                    LOG.trace(\"HTTP-Header: {}={}\", key, headerValue);\n                    clientRequest.getRequestHeaders().add(new HttpString(key), headerValue);\n                }\n            }\n        }\n\n        return body;\n    }",
            " 351  \n 352  \n 353  \n 354  \n 355  \n 356 +\n 357 +\n 358  \n 359  \n 360  \n 361  \n 362 +\n 363  \n 364  \n 365  \n 366 +\n 367 +\n 368 +\n 369 +\n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383 +\n 384  \n 385  \n 386  \n 387  \n 388  \n 389  ",
            "    @Override\n    public Object toHttpRequest(ClientRequest clientRequest, Message message) {\n\n        Object body = message.getBody();\n\n        final HeaderMap requestHeaders = clientRequest.getRequestHeaders();\n\n        // set the content type in the response.\n        String contentType = MessageHelper.getContentType(message);\n        if (contentType != null) {\n            // set content-type\n            requestHeaders.put(Headers.CONTENT_TYPE, contentType);\n            LOG.trace(\"Content-Type: {}\", contentType);\n        }\n\n        // Set the Host header\n        final String host = message.getHeader(\"Host\", String.class);\n        requestHeaders.put(Headers.HOST, Optional.ofNullable(host).orElseGet(()-> URI.create(clientRequest.getPath()).getAuthority()));\n\n        TypeConverter tc = message.getExchange().getContext().getTypeConverter();\n\n        //copy headers from Message to Request\n        for (Map.Entry<String, Object> entry : message.getHeaders().entrySet()) {\n            String key = entry.getKey();\n            Object value = entry.getValue();\n            // use an iterator as there can be multiple values. (must not use a delimiter)\n            final Iterator<?> it = ObjectHelper.createIterator(value, null);\n            while (it.hasNext()) {\n                String headerValue = tc.convertTo(String.class, it.next());\n                if (headerValue != null && headerFilterStrategy != null\n                        && !headerFilterStrategy.applyFilterToCamelHeaders(key, headerValue, message.getExchange())) {\n                    LOG.trace(\"HTTP-Header: {}={}\", key, headerValue);\n                    requestHeaders.add(new HttpString(key), headerValue);\n                }\n            }\n        }\n\n        return body;\n    }"
        ]
    ],
    "fe57a498f6a5305b2d9a06999c8ca9c3c6c12d16": [
        [
            "MessageHelper::doDumpMessageHistoryStacktrace(Exchange,ExchangeFormatter,boolean)",
            " 538  \n 539  \n 540  \n 541  \n 542  \n 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549 -\n 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564  \n 565 -\n 566  \n 567  \n 568  \n 569  \n 570  \n 571  \n 572  \n 573  \n 574  \n 575  \n 576  \n 577  \n 578  \n 579  \n 580  \n 581  \n 582  \n 583  \n 584  \n 585  \n 586  \n 587  \n 588  \n 589  \n 590  \n 591  \n 592  \n 593  \n 594  \n 595  ",
            "    @SuppressWarnings(\"unchecked\")\n    public static String doDumpMessageHistoryStacktrace(Exchange exchange, ExchangeFormatter exchangeFormatter, boolean logStackTrace) {\n        List<MessageHistory> list = exchange.getProperty(Exchange.MESSAGE_HISTORY, List.class);\n        if (list == null || list.isEmpty()) {\n            return null;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"\\n\");\n        sb.append(\"Message History\\n\");\n        sb.append(\"---------------------------------------------------------------------------------------------------------------------------------------\\n\");\n        sb.append(String.format(MESSAGE_HISTORY_HEADER, \"RouteId\", \"ProcessorId\", \"Processor\", \"Elapsed (ms)\"));\n        sb.append(\"\\n\");\n\n        // add incoming origin of message on the top\n        String routeId = exchange.getFromRouteId();\n        String id = routeId;\n        String label = \"\";\n        if (exchange.getFromEndpoint() != null) {\n            label = URISupport.sanitizeUri(exchange.getFromEndpoint().getEndpointUri());\n        }\n        long elapsed = 0;\n        Date created = exchange.getProperty(Exchange.CREATED_TIMESTAMP, Date.class);\n        if (created != null) {\n            elapsed = new StopWatch(created).stop();\n        }\n\n        sb.append(String.format(MESSAGE_HISTORY_OUTPUT, routeId, id, label, elapsed));\n        sb.append(\"\\n\");\n\n        // and then each history\n        for (MessageHistory history : list) {\n            routeId = history.getRouteId() != null ? history.getRouteId() : \"\";\n            id = history.getNode().getId();\n            // we need to avoid leak the sensible information here\n            // the sanitizeUri takes a very long time for very long string and the format cuts this to\n            // 78 characters, anyway. Cut this to 100 characters. This will give enough space for removing\n            // characters in the sanitizeUri method and will be reasonably fast\n            label =  URISupport.sanitizeUri(StringHelper.limitLength(history.getNode().getLabel(), 100));\n            elapsed = history.getElapsed();\n\n            sb.append(String.format(MESSAGE_HISTORY_OUTPUT, routeId, id, label, elapsed));\n            sb.append(\"\\n\");\n        }\n\n        if (exchangeFormatter != null) {\n            sb.append(\"\\nExchange\\n\");\n            sb.append(\"---------------------------------------------------------------------------------------------------------------------------------------\\n\");\n            sb.append(exchangeFormatter.format(exchange));\n            sb.append(\"\\n\");\n        }\n\n        if (logStackTrace) {\n            sb.append(\"\\nStacktrace\\n\");\n            sb.append(\"---------------------------------------------------------------------------------------------------------------------------------------\");\n        }\n        return sb.toString();\n    }",
            " 538  \n 539  \n 540  \n 541  \n 542  \n 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549 +\n 550 +\n 551 +\n 552 +\n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564  \n 565  \n 566  \n 567  \n 568 +\n 569 +\n 570 +\n 571 +\n 572  \n 573  \n 574  \n 575  \n 576  \n 577  \n 578  \n 579  \n 580  \n 581  \n 582  \n 583  \n 584  \n 585  \n 586  \n 587  \n 588  \n 589  \n 590  \n 591  \n 592  \n 593  \n 594  \n 595  \n 596  \n 597  \n 598  \n 599  \n 600  \n 601  ",
            "    @SuppressWarnings(\"unchecked\")\n    public static String doDumpMessageHistoryStacktrace(Exchange exchange, ExchangeFormatter exchangeFormatter, boolean logStackTrace) {\n        List<MessageHistory> list = exchange.getProperty(Exchange.MESSAGE_HISTORY, List.class);\n        if (list == null || list.isEmpty()) {\n            return null;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"\\n\");\n        sb.append(\"Message History\\n\");\n        sb.append(\"---------------------------------------------------------------------------------------------------------------------------------------\\n\");\n        String goMessageHistoryHeaeder = exchange.getContext().getGlobalOption(Exchange.MESSAGE_HISTORY_HEADER_FORMAT);\n        sb.append(String.format(\n                         goMessageHistoryHeaeder == null ? MESSAGE_HISTORY_HEADER : goMessageHistoryHeaeder,\n                         \"RouteId\", \"ProcessorId\", \"Processor\", \"Elapsed (ms)\"));\n        sb.append(\"\\n\");\n\n        // add incoming origin of message on the top\n        String routeId = exchange.getFromRouteId();\n        String id = routeId;\n        String label = \"\";\n        if (exchange.getFromEndpoint() != null) {\n            label = URISupport.sanitizeUri(exchange.getFromEndpoint().getEndpointUri());\n        }\n        long elapsed = 0;\n        Date created = exchange.getProperty(Exchange.CREATED_TIMESTAMP, Date.class);\n        if (created != null) {\n            elapsed = new StopWatch(created).stop();\n        }\n\n        String goMessageHistoryOutput = exchange.getContext().getGlobalOption(Exchange.MESSAGE_HISTORY_OUTPUT_FORMAT);\n        sb.append(String.format(\n                        goMessageHistoryOutput == null ? MESSAGE_HISTORY_OUTPUT : goMessageHistoryOutput,\n                        routeId, id, label, elapsed));\n        sb.append(\"\\n\");\n\n        // and then each history\n        for (MessageHistory history : list) {\n            routeId = history.getRouteId() != null ? history.getRouteId() : \"\";\n            id = history.getNode().getId();\n            // we need to avoid leak the sensible information here\n            // the sanitizeUri takes a very long time for very long string and the format cuts this to\n            // 78 characters, anyway. Cut this to 100 characters. This will give enough space for removing\n            // characters in the sanitizeUri method and will be reasonably fast\n            label =  URISupport.sanitizeUri(StringHelper.limitLength(history.getNode().getLabel(), 100));\n            elapsed = history.getElapsed();\n\n            sb.append(String.format(MESSAGE_HISTORY_OUTPUT, routeId, id, label, elapsed));\n            sb.append(\"\\n\");\n        }\n\n        if (exchangeFormatter != null) {\n            sb.append(\"\\nExchange\\n\");\n            sb.append(\"---------------------------------------------------------------------------------------------------------------------------------------\\n\");\n            sb.append(exchangeFormatter.format(exchange));\n            sb.append(\"\\n\");\n        }\n\n        if (logStackTrace) {\n            sb.append(\"\\nStacktrace\\n\");\n            sb.append(\"---------------------------------------------------------------------------------------------------------------------------------------\");\n        }\n        return sb.toString();\n    }"
        ]
    ],
    "572f3cee35fe7098b53d056a647abbed839f82f7": [
        [
            "XmppBinding::populateXmppMessage(Message,Exchange)",
            "  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78 -\n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  ",
            "    /**\n     * Populates the given XMPP message from the inbound exchange\n     */\n    public void populateXmppMessage(Message message, Exchange exchange) {\n        message.setBody(exchange.getIn().getBody(String.class));\n\n        Set<Map.Entry<String, Object>> entries = exchange.getIn().getHeaders().entrySet();\n        for (Map.Entry<String, Object> entry : entries) {\n            String name = entry.getKey();\n            Object value = entry.getValue();\n            if (!headerFilterStrategy.applyFilterToCamelHeaders(name, value, exchange)) {\n\n                if (\"subject\".equalsIgnoreCase(name)) {\n                    // special for subject\n                    String subject = exchange.getContext().getTypeConverter().convertTo(String.class, value);\n                    message.setSubject(subject);\n                } else if (\"language\".equalsIgnoreCase(name)) {\n                    // special for language\n                    String language = exchange.getContext().getTypeConverter().convertTo(String.class, value);\n                    message.setLanguage(language);\n                } else {\n                    try {\n                        JivePropertiesManager.addProperty(message, name, value);\n                        LOG.trace(\"Added property name: {} value: {}\", name, value.toString());\n                    } catch (IllegalArgumentException iae) {\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Cannot add property \" + name + \" to XMPP message due: \", iae);\n                        }\n                    }\n                }\n            }\n        }\n\n        String id = exchange.getExchangeId();\n        if (id != null) {\n            JivePropertiesManager.addProperty(message, \"exchangeId\", id);\n        }\n    }",
            "  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78 +\n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  ",
            "    /**\n     * Populates the given XMPP message from the inbound exchange\n     */\n    public void populateXmppMessage(Message message, Exchange exchange) {\n        message.setBody(exchange.getIn().getBody(String.class));\n\n        Set<Map.Entry<String, Object>> entries = exchange.getIn().getHeaders().entrySet();\n        for (Map.Entry<String, Object> entry : entries) {\n            String name = entry.getKey();\n            Object value = entry.getValue();\n            if (!headerFilterStrategy.applyFilterToCamelHeaders(name, value, exchange)) {\n\n                if (\"subject\".equalsIgnoreCase(name)) {\n                    // special for subject\n                    String subject = exchange.getContext().getTypeConverter().convertTo(String.class, value);\n                    message.setSubject(subject);\n                } else if (\"language\".equalsIgnoreCase(name)) {\n                    // special for language\n                    String language = exchange.getContext().getTypeConverter().convertTo(String.class, value);\n                    message.setLanguage(language);\n                } else {\n                    try {\n                        JivePropertiesManager.addProperty(message, name, value);\n                        LOG.trace(\"Added property name: {} value: {}\", name, value);\n                    } catch (IllegalArgumentException iae) {\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Cannot add property \" + name + \" to XMPP message due: \", iae);\n                        }\n                    }\n                }\n            }\n        }\n\n        String id = exchange.getExchangeId();\n        if (id != null) {\n            JivePropertiesManager.addProperty(message, \"exchangeId\", id);\n        }\n    }"
        ],
        [
            "XmppConsumer::doStop()",
            " 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179 -\n 180 -\n 181 -\n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  ",
            "    @Override\n    protected void doStop() throws Exception {\n        super.doStop();\n\n        // stop scheduler first\n        if (scheduledExecutor != null) {\n            getEndpoint().getCamelContext().getExecutorServiceManager().shutdownNow(scheduledExecutor);\n            scheduledExecutor = null;\n        }\n\n        if (muc != null) {\n            if (LOG.isInfoEnabled()) {\n                LOG.info(\"Leaving room: {}\", muc.getRoom());\n            }\n            muc.removeMessageListener(this);\n            muc.leave();\n            muc = null;\n        }\n        if (connection != null && connection.isConnected()) {\n            connection.disconnect();\n        }\n    }",
            " 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179 +\n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  ",
            "    @Override\n    protected void doStop() throws Exception {\n        super.doStop();\n\n        // stop scheduler first\n        if (scheduledExecutor != null) {\n            getEndpoint().getCamelContext().getExecutorServiceManager().shutdownNow(scheduledExecutor);\n            scheduledExecutor = null;\n        }\n\n        if (muc != null) {\n            LOG.info(\"Leaving room: {}\", muc.getRoom());\n            muc.removeMessageListener(this);\n            muc.leave();\n            muc = null;\n        }\n        if (connection != null && connection.isConnected()) {\n            connection.disconnect();\n        }\n    }"
        ],
        [
            "XmppGroupChatProducer::initializeChat()",
            " 124  \n 125  \n 126  \n 127  \n 128  \n 129 -\n 130  \n 131 -\n 132 -\n 133 -\n 134  \n 135  ",
            "    protected synchronized void initializeChat() throws InterruptedException, SmackException, XMPPException, XmppStringprepException {\n        if (chat == null) {\n            room = endpoint.resolveRoom(connection);\n            MultiUserChatManager chatManager = MultiUserChatManager.getInstanceFor(connection);\n            chat = chatManager.getMultiUserChat(JidCreate.entityBareFrom(room));\n            MucEnterConfiguration mucc = chat.getEnterConfigurationBuilder(Resourcepart.from(endpoint.getNickname())).requestNoHistory().build();\n            chat.join(mucc);\n            if (LOG.isInfoEnabled()) {\n                LOG.info(\"Joined room: {} as: {}\", room, endpoint.getNickname());\n            }\n        }\n    }",
            " 124  \n 125  \n 126  \n 127  \n 128  \n 129 +\n 130 +\n 131 +\n 132  \n 133 +\n 134  \n 135  ",
            "    protected synchronized void initializeChat() throws InterruptedException, SmackException, XMPPException, XmppStringprepException {\n        if (chat == null) {\n            room = endpoint.resolveRoom(connection);\n            MultiUserChatManager chatManager = MultiUserChatManager.getInstanceFor(connection);\n            chat = chatManager.getMultiUserChat(JidCreate.entityBareFrom(room));\n            MucEnterConfiguration mucc = chat.getEnterConfigurationBuilder(Resourcepart.from(endpoint.getNickname()))\n                    .requestNoHistory()\n                    .build();\n            chat.join(mucc);\n            LOG.info(\"Joined room: {} as: {}\", room, endpoint.getNickname());\n        }\n    }"
        ],
        [
            "XmppConsumer::doStart()",
            "  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106 -\n 107  \n 108 -\n 109 -\n 110 -\n 111  \n 112  \n 113  \n 114  \n 115  ",
            "    @Override\n    protected void doStart() throws Exception {\n        try {\n            connection = endpoint.createConnection();\n        } catch (SmackException e) {\n            if (endpoint.isTestConnectionOnStartup()) {\n                throw new RuntimeException(\"Could not connect to XMPP server.\", e);\n            } else {\n                LOG.warn(e.getMessage());\n                if (getExceptionHandler() != null) {\n                    getExceptionHandler().handleException(e.getMessage(), e);\n                }\n                scheduleDelayedStart();\n                return;\n            }\n        }\n\n        chatManager = ChatManager.getInstanceFor(connection);\n        chatManager.addIncomingListener(this);\n\n        OrFilter pubsubPacketFilter = new OrFilter();\n        if (endpoint.isPubsub()) {\n            //xep-0060: pubsub#notification_type can be 'headline' or 'normal'\n            pubsubPacketFilter.addFilter(MessageTypeFilter.HEADLINE);\n            pubsubPacketFilter.addFilter(MessageTypeFilter.NORMAL);\n            connection.addSyncStanzaListener(this, pubsubPacketFilter);\n        }\n\n        if (endpoint.getRoom() == null) {\n            privateChat = chatManager.chatWith(JidCreate.entityBareFrom(endpoint.getChatId()));\n        } else {\n            // add the presence packet listener to the connection so we only get packets that concerns us\n            // we must add the listener before creating the muc\n\n            final AndFilter packetFilter = new AndFilter(new StanzaTypeFilter(Presence.class));\n            connection.addSyncStanzaListener(this, packetFilter);\n            MultiUserChatManager mucm = MultiUserChatManager.getInstanceFor(connection);\n            muc = mucm.getMultiUserChat(JidCreate.entityBareFrom(endpoint.resolveRoom(connection)));\n            muc.addMessageListener(this);\n            MucEnterConfiguration mucc = muc.getEnterConfigurationBuilder(Resourcepart.from(endpoint.getNickname())).requestNoHistory().build();\n            muc.join(mucc);\n            if (LOG.isInfoEnabled()) {\n                LOG.info(\"Joined room: {} as: {}\", muc.getRoom(), endpoint.getNickname());\n            }\n        }\n\n        this.startRobustConnectionMonitor();\n        super.doStart();\n    }",
            "  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106 +\n 107 +\n 108 +\n 109  \n 110 +\n 111  \n 112  \n 113  \n 114  \n 115  ",
            "    @Override\n    protected void doStart() throws Exception {\n        try {\n            connection = endpoint.createConnection();\n        } catch (SmackException e) {\n            if (endpoint.isTestConnectionOnStartup()) {\n                throw new RuntimeException(\"Could not connect to XMPP server.\", e);\n            } else {\n                LOG.warn(e.getMessage());\n                if (getExceptionHandler() != null) {\n                    getExceptionHandler().handleException(e.getMessage(), e);\n                }\n                scheduleDelayedStart();\n                return;\n            }\n        }\n\n        chatManager = ChatManager.getInstanceFor(connection);\n        chatManager.addIncomingListener(this);\n\n        OrFilter pubsubPacketFilter = new OrFilter();\n        if (endpoint.isPubsub()) {\n            //xep-0060: pubsub#notification_type can be 'headline' or 'normal'\n            pubsubPacketFilter.addFilter(MessageTypeFilter.HEADLINE);\n            pubsubPacketFilter.addFilter(MessageTypeFilter.NORMAL);\n            connection.addSyncStanzaListener(this, pubsubPacketFilter);\n        }\n\n        if (endpoint.getRoom() == null) {\n            privateChat = chatManager.chatWith(JidCreate.entityBareFrom(endpoint.getChatId()));\n        } else {\n            // add the presence packet listener to the connection so we only get packets that concerns us\n            // we must add the listener before creating the muc\n\n            final AndFilter packetFilter = new AndFilter(new StanzaTypeFilter(Presence.class));\n            connection.addSyncStanzaListener(this, packetFilter);\n            MultiUserChatManager mucm = MultiUserChatManager.getInstanceFor(connection);\n            muc = mucm.getMultiUserChat(JidCreate.entityBareFrom(endpoint.resolveRoom(connection)));\n            muc.addMessageListener(this);\n            MucEnterConfiguration mucc = muc.getEnterConfigurationBuilder(Resourcepart.from(endpoint.getNickname()))\n                    .requestNoHistory()\n                    .build();\n            muc.join(mucc);\n            LOG.info(\"Joined room: {} as: {}\", muc.getRoom(), endpoint.getNickname());\n        }\n\n        this.startRobustConnectionMonitor();\n        super.doStart();\n    }"
        ],
        [
            "XmppBinding::populateXmppStanza(Stanza,Exchange)",
            "  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105 -\n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  ",
            "    /**\n     * Populates the given XMPP stanza from the inbound exchange\n     */\n    public void populateXmppStanza(Stanza stanza, Exchange exchange) {\n        Set<Map.Entry<String, Object>> entries = exchange.getIn().getHeaders().entrySet();\n        for (Map.Entry<String, Object> entry : entries) {\n            String name = entry.getKey();\n            Object value = entry.getValue();\n            if (!headerFilterStrategy.applyFilterToCamelHeaders(name, value, exchange)) {\n                try {\n                    JivePropertiesManager.addProperty(stanza, name, value);\n                    LOG.debug(\"Added property name: \" + name + \" value: \" + value.toString());\n                } catch (IllegalArgumentException iae) {\n                    LOG.debug(\"Not adding property \" + name + \" to XMPP message due to \" + iae);\n                }\n            }\n        }\n        String id = exchange.getExchangeId();\n        if (id != null) {\n            JivePropertiesManager.addProperty(stanza, \"exchangeId\", id);\n        }\n    }",
            "  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105 +\n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  ",
            "    /**\n     * Populates the given XMPP stanza from the inbound exchange\n     */\n    public void populateXmppStanza(Stanza stanza, Exchange exchange) {\n        Set<Map.Entry<String, Object>> entries = exchange.getIn().getHeaders().entrySet();\n        for (Map.Entry<String, Object> entry : entries) {\n            String name = entry.getKey();\n            Object value = entry.getValue();\n            if (!headerFilterStrategy.applyFilterToCamelHeaders(name, value, exchange)) {\n                try {\n                    JivePropertiesManager.addProperty(stanza, name, value);\n                    LOG.debug(\"Added property name: \" + name + \" value: \" + value);\n                } catch (IllegalArgumentException iae) {\n                    LOG.debug(\"Not adding property \" + name + \" to XMPP message due to \" + iae);\n                }\n            }\n        }\n        String id = exchange.getExchangeId();\n        if (id != null) {\n            JivePropertiesManager.addProperty(stanza, \"exchangeId\", id);\n        }\n    }"
        ]
    ],
    "23b84b9f0264eaf35a6ef7ebc87b223c4a7177af": [
        [
            "MethodInfo::createMethodInvocation(Object,boolean,Exchange)",
            " 247  \n 248  \n 249  \n 250 -\n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344  \n 345  \n 346  \n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  ",
            "    public MethodInvocation createMethodInvocation(final Object pojo, boolean hasParameters, final Exchange exchange) {\n        final Object[] arguments;\n        if (hasParameters) {\n             arguments = parametersExpression.evaluate(exchange, Object[].class);\n        } else {\n            arguments = null;\n        }\n\n        return new MethodInvocation() {\n            public Method getMethod() {\n                return method;\n            }\n\n            public Object[] getArguments() {\n                return arguments;\n            }\n\n            public boolean proceed(AsyncCallback callback) {\n                Object body = exchange.getIn().getBody();\n                if (body != null && body instanceof StreamCache) {\n                    // ensure the stream cache is reset before calling the method\n                    ((StreamCache) body).reset();\n                }\n                try {\n                    return doProceed(callback);\n                } catch (InvocationTargetException e) {\n                    exchange.setException(e.getTargetException());\n                    callback.done(true);\n                    return true;\n                } catch (Throwable e) {\n                    exchange.setException(e);\n                    callback.done(true);\n                    return true;\n                }\n            }\n\n            private boolean doProceed(AsyncCallback callback) throws Exception {\n                // dynamic router should be invoked beforehand\n                if (dynamicRouter != null) {\n                    if (!dynamicRouter.isStarted()) {\n                        ServiceHelper.startService(dynamicRouter);\n                    }\n                    // use a expression which invokes the method to be used by dynamic router\n                    Expression expression = new DynamicRouterExpression(pojo);\n                    return dynamicRouter.doRoutingSlip(exchange, expression, callback);\n                }\n\n                // invoke pojo\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\">>>> invoking: {} on bean: {} with arguments: {} for exchange: {}\", new Object[]{method, pojo, asString(arguments), exchange});\n                }\n                Object result = invoke(method, pojo, arguments, exchange);\n\n                // the method may be a closure or chained method returning a callable which should be called\n                if (result instanceof Callable) {\n                    LOG.trace(\"Method returned Callback which will be called: {}\", result);\n                    Object callableResult = ((Callable) result).call();\n                    if (callableResult != null) {\n                        result = callableResult;\n                    } else {\n                        // if callable returned null we should not change the body\n                        result = Void.TYPE;\n                    }\n                }\n\n                if (recipientList != null) {\n                    // ensure its started\n                    if (!recipientList.isStarted()) {\n                        ServiceHelper.startService(recipientList);\n                    }\n                    return recipientList.sendToRecipientList(exchange, result, callback);\n                }\n                if (routingSlip != null) {\n                    if (!routingSlip.isStarted()) {\n                        ServiceHelper.startService(routingSlip);\n                    }\n                    return routingSlip.doRoutingSlip(exchange, result, callback);\n                }\n\n                //If it's Java 8 async result\n                if (CompletionStage.class.isAssignableFrom(getMethod().getReturnType())) {\n                    CompletionStage<?> completionStage = (CompletionStage<?>) result;\n\n                    completionStage\n                            .whenComplete((resultObject, e) -> {\n                                if (e != null) {\n                                    exchange.setException(e);\n                                } else if (resultObject != null) {\n                                    fillResult(exchange, resultObject);\n                                }\n                                callback.done(false);\n                            });\n                    return false;\n                }\n\n                // if the method returns something then set the value returned on the Exchange\n                if (!getMethod().getReturnType().equals(Void.TYPE) && result != Void.TYPE) {\n                    fillResult(exchange, result);\n                }\n\n                // we did not use any of the eips, but just invoked the bean\n                // so notify the callback we are done synchronously\n                callback.done(true);\n                return true;\n            }\n\n            public Object getThis() {\n                return pojo;\n            }\n\n            public AccessibleObject getStaticPart() {\n                return method;\n            }\n        };\n    }",
            " 247  \n 248  \n 249  \n 250 +\n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344  \n 345  \n 346  \n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  ",
            "    public MethodInvocation createMethodInvocation(final Object pojo, boolean hasParameters, final Exchange exchange) {\n        final Object[] arguments;\n        if (hasParameters) {\n            arguments = parametersExpression.evaluate(exchange, Object[].class);\n        } else {\n            arguments = null;\n        }\n\n        return new MethodInvocation() {\n            public Method getMethod() {\n                return method;\n            }\n\n            public Object[] getArguments() {\n                return arguments;\n            }\n\n            public boolean proceed(AsyncCallback callback) {\n                Object body = exchange.getIn().getBody();\n                if (body != null && body instanceof StreamCache) {\n                    // ensure the stream cache is reset before calling the method\n                    ((StreamCache) body).reset();\n                }\n                try {\n                    return doProceed(callback);\n                } catch (InvocationTargetException e) {\n                    exchange.setException(e.getTargetException());\n                    callback.done(true);\n                    return true;\n                } catch (Throwable e) {\n                    exchange.setException(e);\n                    callback.done(true);\n                    return true;\n                }\n            }\n\n            private boolean doProceed(AsyncCallback callback) throws Exception {\n                // dynamic router should be invoked beforehand\n                if (dynamicRouter != null) {\n                    if (!dynamicRouter.isStarted()) {\n                        ServiceHelper.startService(dynamicRouter);\n                    }\n                    // use a expression which invokes the method to be used by dynamic router\n                    Expression expression = new DynamicRouterExpression(pojo);\n                    return dynamicRouter.doRoutingSlip(exchange, expression, callback);\n                }\n\n                // invoke pojo\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\">>>> invoking: {} on bean: {} with arguments: {} for exchange: {}\", new Object[]{method, pojo, asString(arguments), exchange});\n                }\n                Object result = invoke(method, pojo, arguments, exchange);\n\n                // the method may be a closure or chained method returning a callable which should be called\n                if (result instanceof Callable) {\n                    LOG.trace(\"Method returned Callback which will be called: {}\", result);\n                    Object callableResult = ((Callable) result).call();\n                    if (callableResult != null) {\n                        result = callableResult;\n                    } else {\n                        // if callable returned null we should not change the body\n                        result = Void.TYPE;\n                    }\n                }\n\n                if (recipientList != null) {\n                    // ensure its started\n                    if (!recipientList.isStarted()) {\n                        ServiceHelper.startService(recipientList);\n                    }\n                    return recipientList.sendToRecipientList(exchange, result, callback);\n                }\n                if (routingSlip != null) {\n                    if (!routingSlip.isStarted()) {\n                        ServiceHelper.startService(routingSlip);\n                    }\n                    return routingSlip.doRoutingSlip(exchange, result, callback);\n                }\n\n                //If it's Java 8 async result\n                if (CompletionStage.class.isAssignableFrom(getMethod().getReturnType())) {\n                    CompletionStage<?> completionStage = (CompletionStage<?>) result;\n\n                    completionStage\n                            .whenComplete((resultObject, e) -> {\n                                if (e != null) {\n                                    exchange.setException(e);\n                                } else if (resultObject != null) {\n                                    fillResult(exchange, resultObject);\n                                }\n                                callback.done(false);\n                            });\n                    return false;\n                }\n\n                // if the method returns something then set the value returned on the Exchange\n                if (!getMethod().getReturnType().equals(Void.TYPE) && result != Void.TYPE) {\n                    fillResult(exchange, result);\n                }\n\n                // we did not use any of the eips, but just invoked the bean\n                // so notify the callback we are done synchronously\n                callback.done(true);\n                return true;\n            }\n\n            public Object getThis() {\n                return pojo;\n            }\n\n            public AccessibleObject getStaticPart() {\n                return method;\n            }\n        };\n    }"
        ],
        [
            "IOConverterCharsetTest::testToReaderFileWithCharsetLatin1()",
            "  96  \n  97  \n  98  \n  99 -\n 100  \n 101  \n 102  \n 103  \n 104  \n 105  ",
            "    public void testToReaderFileWithCharsetLatin1() throws Exception {\n        File file = new File(\"src/test/resources/org/apache/camel/converter/german.iso-8859-1.txt\");\n        try (BufferedReader reader = IOConverter.toReader(file, \"ISO-8859-1\");\n        BufferedReader naiveReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\"))) {\n            String line = reader.readLine();\n            String naiveLine = naiveReader.readLine();\n            assertEquals(naiveLine, line);\n            assertEquals(CONTENT, line);\n        }\n    }",
            "  97  \n  98  \n  99  \n 100 +\n 101  \n 102  \n 103  \n 104  \n 105  \n 106  ",
            "    public void testToReaderFileWithCharsetLatin1() throws Exception {\n        File file = new File(\"src/test/resources/org/apache/camel/converter/german.iso-8859-1.txt\");\n        try (BufferedReader reader = IOConverter.toReader(file, \"ISO-8859-1\");\n        BufferedReader naiveReader = new BufferedReader(new InputStreamReader(Files.newInputStream(Paths.get(file.getAbsolutePath())), \"ISO-8859-1\"))) {\n            String line = reader.readLine();\n            String naiveLine = naiveReader.readLine();\n            assertEquals(naiveLine, line);\n            assertEquals(CONTENT, line);\n        }\n    }"
        ],
        [
            "IOConverterCharsetTest::testToReaderFileWithCharsetUTF8()",
            "  85  \n  86  \n  87  \n  88 -\n  89  \n  90  \n  91  \n  92  \n  93  \n  94  ",
            "    public void testToReaderFileWithCharsetUTF8() throws Exception {\n        File file = new File(\"src/test/resources/org/apache/camel/converter/german.utf-8.txt\");\n        try (BufferedReader reader = IOConverter.toReader(file, \"UTF-8\");\n        BufferedReader naiveReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8))) {\n            String line = reader.readLine();\n            String naiveLine = naiveReader.readLine();\n            assertEquals(naiveLine, line);\n            assertEquals(CONTENT, line);\n        }\n    }",
            "  86  \n  87  \n  88  \n  89 +\n  90  \n  91  \n  92  \n  93  \n  94  \n  95  ",
            "    public void testToReaderFileWithCharsetUTF8() throws Exception {\n        File file = new File(\"src/test/resources/org/apache/camel/converter/german.utf-8.txt\");\n        try (BufferedReader reader = IOConverter.toReader(file, \"UTF-8\");\n        BufferedReader naiveReader = new BufferedReader(new InputStreamReader(Files.newInputStream(Paths.get(file.getAbsolutePath())), StandardCharsets.UTF_8))) {\n            String line = reader.readLine();\n            String naiveLine = naiveReader.readLine();\n            assertEquals(naiveLine, line);\n            assertEquals(CONTENT, line);\n        }\n    }"
        ],
        [
            "IOConverterCharsetTest::testToInputStreamFileDirectByteDumpWithCharsetLatin1()",
            "  72  \n  73  \n  74  \n  75  \n  76 -\n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  ",
            "    public void testToInputStreamFileDirectByteDumpWithCharsetLatin1() throws Exception {\n        switchToDefaultCharset(StandardCharsets.UTF_8);\n        File file = new File(\"src/test/resources/org/apache/camel/converter/german.iso-8859-1.txt\");\n        try (InputStream in = IOConverter.toInputStream(file, \"ISO-8859-1\");\n        InputStream naiveIn = new FileInputStream(file)) {\n            byte[] bytes = new byte[8192];\n            in.read(bytes);\n            byte[] naiveBytes = new byte[8192];\n            naiveIn.read(naiveBytes);\n            assertFalse(\"both input streams deliver the same byte sequence\", Arrays.equals(naiveBytes, bytes));\n        }\n    }",
            "  73  \n  74  \n  75  \n  76  \n  77 +\n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  ",
            "    public void testToInputStreamFileDirectByteDumpWithCharsetLatin1() throws Exception {\n        switchToDefaultCharset(StandardCharsets.UTF_8);\n        File file = new File(\"src/test/resources/org/apache/camel/converter/german.iso-8859-1.txt\");\n        try (InputStream in = IOConverter.toInputStream(file, \"ISO-8859-1\");\n        InputStream naiveIn = Files.newInputStream(Paths.get(file.getAbsolutePath()))) {\n            byte[] bytes = new byte[8192];\n            in.read(bytes);\n            byte[] naiveBytes = new byte[8192];\n            naiveIn.read(naiveBytes);\n            assertFalse(\"both input streams deliver the same byte sequence\", Arrays.equals(naiveBytes, bytes));\n        }\n    }"
        ],
        [
            "FileProducerCharsetUTFtoUTFTest::testFileProducerCharsetUTFtoUTF()",
            "  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64 -\n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  ",
            "    public void testFileProducerCharsetUTFtoUTF() throws Exception {\n        oneExchangeDone.matchesMockWaitTime();\n\n        File file = new File(\"target/charset/output.txt\");\n        assertTrue(\"File should exist\", file.exists());\n\n        InputStream fis = IOHelper.buffered(new FileInputStream(file));\n        byte[] buffer = new byte[100];\n\n        int len = fis.read(buffer);\n        assertTrue(\"Should read data: \" + len, len != -1);\n        byte[] data = new byte[len];\n        System.arraycopy(buffer, 0, data, 0, len);\n        fis.close();\n\n        // data should be in utf, where the danish ae is -61 -90\n        assertEquals(5, data.length);\n        assertEquals(65, data[0]);\n        assertEquals(66, data[1]);\n        assertEquals(67, data[2]);\n        assertEquals(-61, data[3]);\n        assertEquals(-90, data[4]);\n    }",
            "  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64 +\n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  ",
            "    public void testFileProducerCharsetUTFtoUTF() throws Exception {\n        oneExchangeDone.matchesMockWaitTime();\n\n        File file = new File(\"target/charset/output.txt\");\n        assertTrue(\"File should exist\", file.exists());\n\n        InputStream fis = Files.newInputStream(Paths.get(file.getAbsolutePath()));\n        byte[] buffer = new byte[100];\n\n        int len = fis.read(buffer);\n        assertTrue(\"Should read data: \" + len, len != -1);\n        byte[] data = new byte[len];\n        System.arraycopy(buffer, 0, data, 0, len);\n        fis.close();\n\n        // data should be in utf, where the danish ae is -61 -90\n        assertEquals(5, data.length);\n        assertEquals(65, data[0]);\n        assertEquals(66, data[1]);\n        assertEquals(67, data[2]);\n        assertEquals(-61, data[3]);\n        assertEquals(-90, data[4]);\n    }"
        ],
        [
            "FileProducerCharsetUTFtoUTFTest::setUp()",
            "  36  \n  37  \n  38  \n  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51 -\n  52  \n  53  \n  54  \n  55  \n  56  ",
            "    @Override\n    protected void setUp() throws Exception {\n        // use utf-8 as original payload with 00e6 which is a danish ae letter\n        utf = \"ABC\\u00e6\".getBytes(\"utf-8\");\n\n        deleteDirectory(\"target/charset\");\n        createDirectory(\"target/charset/input\");\n\n        log.debug(\"utf: {}\", new String(utf, Charset.forName(\"utf-8\")));\n\n        for (byte b : utf) {\n            log.debug(\"utf byte: {}\", b);\n        }\n\n        // write the byte array to a file using plain API\n        FileOutputStream fos = new FileOutputStream(\"target/charset/input/input.txt\");\n        fos.write(utf);\n        fos.close();\n\n        super.setUp();\n    }",
            "  36  \n  37  \n  38  \n  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51 +\n  52  \n  53  \n  54  \n  55  \n  56  ",
            "    @Override\n    protected void setUp() throws Exception {\n        // use utf-8 as original payload with 00e6 which is a danish ae letter\n        utf = \"ABC\\u00e6\".getBytes(\"utf-8\");\n\n        deleteDirectory(\"target/charset\");\n        createDirectory(\"target/charset/input\");\n\n        log.debug(\"utf: {}\", new String(utf, Charset.forName(\"utf-8\")));\n\n        for (byte b : utf) {\n            log.debug(\"utf byte: {}\", b);\n        }\n\n        // write the byte array to a file using plain API\n        OutputStream fos = Files.newOutputStream(Paths.get(\"target/charset/input/input.txt\"));\n        fos.write(utf);\n        fos.close();\n\n        super.setUp();\n    }"
        ],
        [
            "FileProducerCharsetUTFOptimizedTest::testFileProducerCharsetUTFOptimized()",
            "  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64 -\n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  ",
            "    public void testFileProducerCharsetUTFOptimized() throws Exception {\n        oneExchangeDone.matchesMockWaitTime();\n\n        File file = new File(\"target/charset/output.txt\");\n        assertTrue(\"File should exist\", file.exists());\n\n        InputStream fis = IOHelper.buffered(new FileInputStream(file));\n        byte[] buffer = new byte[100];\n\n        int len = fis.read(buffer);\n        assertTrue(\"Should read data: \" + len, len != -1);\n        byte[] data = new byte[len];\n        System.arraycopy(buffer, 0, data, 0, len);\n        fis.close();\n\n        // data should be in utf, where the danish ae is -61 -90\n        assertEquals(5, data.length);\n        assertEquals(65, data[0]);\n        assertEquals(66, data[1]);\n        assertEquals(67, data[2]);\n        assertEquals(-61, data[3]);\n        assertEquals(-90, data[4]);\n    }",
            "  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67 +\n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  ",
            "    public void testFileProducerCharsetUTFOptimized() throws Exception {\n        oneExchangeDone.matchesMockWaitTime();\n\n        File file = new File(\"target/charset/output.txt\");\n        assertTrue(\"File should exist\", file.exists());\n\n        InputStream fis = Files.newInputStream(Paths.get(file.getAbsolutePath()));\n        byte[] buffer = new byte[100];\n\n        int len = fis.read(buffer);\n        assertTrue(\"Should read data: \" + len, len != -1);\n        byte[] data = new byte[len];\n        System.arraycopy(buffer, 0, data, 0, len);\n        fis.close();\n\n        // data should be in utf, where the danish ae is -61 -90\n        assertEquals(5, data.length);\n        assertEquals(65, data[0]);\n        assertEquals(66, data[1]);\n        assertEquals(67, data[2]);\n        assertEquals(-61, data[3]);\n        assertEquals(-90, data[4]);\n    }"
        ],
        [
            "XmlLineNumberParserTest::testParseCamelContext()",
            "  45  \n  46 -\n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  ",
            "    public void testParseCamelContext() throws Exception {\n        FileInputStream fis = new FileInputStream(\"src/test/resources/org/apache/camel/util/camel-context.xml\");\n        Document dom = XmlLineNumberParser.parseXml(fis, null, \"camelContext\", null);\n        assertNotNull(dom);\n\n        NodeList list = dom.getElementsByTagName(\"camelContext\");\n        assertEquals(1, list.getLength());\n        Node node = list.item(0);\n\n        String lineNumber = (String) node.getUserData(XmlLineNumberParser.LINE_NUMBER);\n        String lineNumberEnd = (String) node.getUserData(XmlLineNumberParser.LINE_NUMBER_END);\n\n        assertEquals(\"29\", lineNumber);\n        assertEquals(\"47\", lineNumberEnd);\n    }",
            "  47  \n  48 +\n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  ",
            "    public void testParseCamelContext() throws Exception {\n        InputStream fis = Files.newInputStream(Paths.get(\"src/test/resources/org/apache/camel/util/camel-context.xml\"));\n        Document dom = XmlLineNumberParser.parseXml(fis, null, \"camelContext\", null);\n        assertNotNull(dom);\n\n        NodeList list = dom.getElementsByTagName(\"camelContext\");\n        assertEquals(1, list.getLength());\n        Node node = list.item(0);\n\n        String lineNumber = (String) node.getUserData(XmlLineNumberParser.LINE_NUMBER);\n        String lineNumberEnd = (String) node.getUserData(XmlLineNumberParser.LINE_NUMBER_END);\n\n        assertEquals(\"29\", lineNumber);\n        assertEquals(\"47\", lineNumberEnd);\n    }"
        ],
        [
            "XsltBuilderTest::testXsltInputStream()",
            " 104  \n 105  \n 106  \n 107 -\n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  ",
            "    public void testXsltInputStream() throws Exception {\n        File styleSheet = new File(\"src/test/resources/org/apache/camel/builder/xml/example.xsl\");\n\n        XsltBuilder builder = XsltBuilder.xslt(new FileInputStream(styleSheet));\n\n        Exchange exchange = new DefaultExchange(context);\n        exchange.getIn().setBody(\"<hello>world!</hello>\");\n\n        builder.process(exchange);\n\n        assertEquals(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><goodbye>world!</goodbye>\", exchange.getOut().getBody());\n    }",
            " 105  \n 106  \n 107  \n 108 +\n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  ",
            "    public void testXsltInputStream() throws Exception {\n        File styleSheet = new File(\"src/test/resources/org/apache/camel/builder/xml/example.xsl\");\n\n        XsltBuilder builder = XsltBuilder.xslt(Files.newInputStream(Paths.get(styleSheet.getAbsolutePath())));\n\n        Exchange exchange = new DefaultExchange(context);\n        exchange.getIn().setBody(\"<hello>world!</hello>\");\n\n        builder.process(exchange);\n\n        assertEquals(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><goodbye>world!</goodbye>\", exchange.getOut().getBody());\n    }"
        ],
        [
            "XsltBuilderTest::testXsltTemplates()",
            " 145  \n 146  \n 147 -\n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  ",
            "    public void testXsltTemplates() throws Exception {\n        File file = new File(\"src/test/resources/org/apache/camel/builder/xml/example.xsl\");\n        Source source = new SAXSource(new InputSource(new FileInputStream(file)));\n\n        XmlConverter converter = new XmlConverter();\n        Templates styleSheet = converter.getTransformerFactory().newTemplates(source);\n\n        XsltBuilder builder = XsltBuilder.xslt(styleSheet);\n\n        Exchange exchange = new DefaultExchange(context);\n        exchange.getIn().setBody(\"<hello>world!</hello>\");\n\n        builder.process(exchange);\n\n        assertEquals(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><goodbye>world!</goodbye>\", exchange.getOut().getBody());\n    }",
            " 146  \n 147  \n 148 +\n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  ",
            "    public void testXsltTemplates() throws Exception {\n        File file = new File(\"src/test/resources/org/apache/camel/builder/xml/example.xsl\");\n        Source source = new SAXSource(new InputSource(Files.newInputStream(Paths.get(file.getAbsolutePath()))));\n\n        XmlConverter converter = new XmlConverter();\n        Templates styleSheet = converter.getTransformerFactory().newTemplates(source);\n\n        XsltBuilder builder = XsltBuilder.xslt(styleSheet);\n\n        Exchange exchange = new DefaultExchange(context);\n        exchange.getIn().setBody(\"<hello>world!</hello>\");\n\n        builder.process(exchange);\n\n        assertEquals(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><goodbye>world!</goodbye>\", exchange.getOut().getBody());\n    }"
        ],
        [
            "XmlLineNumberParserTest::testParse()",
            "  29  \n  30 -\n  31  \n  32  \n  33  \n  34  \n  35  \n  36  \n  37  \n  38  \n  39  \n  40  \n  41  \n  42  \n  43  ",
            "    public void testParse() throws Exception {\n        FileInputStream fis = new FileInputStream(\"src/test/resources/org/apache/camel/util/camel-context.xml\");\n        Document dom = XmlLineNumberParser.parseXml(fis);\n        assertNotNull(dom);\n\n        NodeList list = dom.getElementsByTagName(\"beans\");\n        assertEquals(1, list.getLength());\n        Node node = list.item(0);\n\n        String lineNumber = (String) node.getUserData(XmlLineNumberParser.LINE_NUMBER);\n        String lineNumberEnd = (String) node.getUserData(XmlLineNumberParser.LINE_NUMBER_END);\n\n        assertEquals(\"24\", lineNumber);\n        assertEquals(\"49\", lineNumberEnd);\n    }",
            "  31  \n  32 +\n  33  \n  34  \n  35  \n  36  \n  37  \n  38  \n  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  ",
            "    public void testParse() throws Exception {\n        InputStream fis = Files.newInputStream(Paths.get(\"src/test/resources/org/apache/camel/util/camel-context.xml\"));\n        Document dom = XmlLineNumberParser.parseXml(fis);\n        assertNotNull(dom);\n\n        NodeList list = dom.getElementsByTagName(\"beans\");\n        assertEquals(1, list.getLength());\n        Node node = list.item(0);\n\n        String lineNumber = (String) node.getUserData(XmlLineNumberParser.LINE_NUMBER);\n        String lineNumberEnd = (String) node.getUserData(XmlLineNumberParser.LINE_NUMBER_END);\n\n        assertEquals(\"24\", lineNumber);\n        assertEquals(\"49\", lineNumberEnd);\n    }"
        ],
        [
            "IOConverterCharsetTest::testToInputStreamFileWithCharsetUTF8()",
            "  33  \n  34  \n  35  \n  36  \n  37  \n  38 -\n  39  \n  40  \n  41  \n  42  \n  43  \n  44  ",
            "    public void testToInputStreamFileWithCharsetUTF8() throws Exception {\n        switchToDefaultCharset(StandardCharsets.UTF_8);\n        File file = new File(\"src/test/resources/org/apache/camel/converter/german.utf-8.txt\");\n        try (InputStream in = IOConverter.toInputStream(file, \"UTF-8\");\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8)); \n        BufferedReader naiveReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8))) {\n            String line = reader.readLine();\n            String naiveLine = naiveReader.readLine();\n            assertEquals(naiveLine, line);\n            assertEquals(CONTENT, line);\n        }\n    }",
            "  34  \n  35  \n  36  \n  37  \n  38  \n  39 +\n  40  \n  41  \n  42  \n  43  \n  44  \n  45  ",
            "    public void testToInputStreamFileWithCharsetUTF8() throws Exception {\n        switchToDefaultCharset(StandardCharsets.UTF_8);\n        File file = new File(\"src/test/resources/org/apache/camel/converter/german.utf-8.txt\");\n        try (InputStream in = IOConverter.toInputStream(file, \"UTF-8\");\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8)); \n        BufferedReader naiveReader = new BufferedReader(new InputStreamReader(Files.newInputStream(Paths.get(file.getAbsolutePath())), StandardCharsets.UTF_8))) {\n            String line = reader.readLine();\n            String naiveLine = naiveReader.readLine();\n            assertEquals(naiveLine, line);\n            assertEquals(CONTENT, line);\n        }\n    }"
        ],
        [
            "FileProducerCharsetUTFtoISOConvertBodyToTest::testFileProducerCharsetUTFtoISOConvertBodyTo()",
            "  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71 -\n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  ",
            "    public void testFileProducerCharsetUTFtoISOConvertBodyTo() throws Exception {\n        oneExchangeDone.matchesMockWaitTime();\n\n        File file = new File(\"target/charset/output.txt\");\n        assertTrue(\"File should exist\", file.exists());\n\n        InputStream fis = IOHelper.buffered(new FileInputStream(file));\n        byte[] buffer = new byte[100];\n\n        int len = fis.read(buffer);\n        assertTrue(\"Should read data: \" + len, len != -1);\n        byte[] data = new byte[len];\n        System.arraycopy(buffer, 0, data, 0, len);\n        fis.close();\n\n\n        for (byte b : data) {\n            log.info(\"loaded byte: {}\", b);\n        }\n\n        // data should be in iso, where the danish ae is -26\n        assertEquals(4, data.length);\n        assertEquals(65, data[0]);\n        assertEquals(66, data[1]);\n        assertEquals(67, data[2]);\n        assertEquals(-26, data[3]);\n    }",
            "  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74 +\n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  ",
            "    public void testFileProducerCharsetUTFtoISOConvertBodyTo() throws Exception {\n        oneExchangeDone.matchesMockWaitTime();\n\n        File file = new File(\"target/charset/output.txt\");\n        assertTrue(\"File should exist\", file.exists());\n\n        InputStream fis = Files.newInputStream(Paths.get(file.getAbsolutePath()));\n        byte[] buffer = new byte[100];\n\n        int len = fis.read(buffer);\n        assertTrue(\"Should read data: \" + len, len != -1);\n        byte[] data = new byte[len];\n        System.arraycopy(buffer, 0, data, 0, len);\n        fis.close();\n\n\n        for (byte b : data) {\n            log.info(\"loaded byte: {}\", b);\n        }\n\n        // data should be in iso, where the danish ae is -26\n        assertEquals(4, data.length);\n        assertEquals(65, data[0]);\n        assertEquals(66, data[1]);\n        assertEquals(67, data[2]);\n        assertEquals(-26, data[3]);\n    }"
        ],
        [
            "FileProducerCharsetUTFtoISOTest::setUp()",
            "  37  \n  38  \n  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57 -\n  58  \n  59  \n  60  \n  61  \n  62  ",
            "    @Override\n    protected void setUp() throws Exception {\n        // use utf-8 as original payload with 00e6 which is a danish ae letter\n        utf = \"ABC\\u00e6\".getBytes(\"utf-8\");\n        iso = \"ABC\\u00e6\".getBytes(\"iso-8859-1\");\n\n        deleteDirectory(\"target/charset\");\n        createDirectory(\"target/charset/input\");\n\n        log.debug(\"utf: {}\", new String(utf, Charset.forName(\"utf-8\")));\n        log.debug(\"iso: {}\", new String(iso, Charset.forName(\"iso-8859-1\")));\n\n        for (byte b : utf) {\n            log.debug(\"utf byte: {}\", b);\n        }\n        for (byte b : iso) {\n            log.debug(\"iso byte: {}\", b);\n        }\n\n        // write the byte array to a file using plain API\n        FileOutputStream fos = new FileOutputStream(\"target/charset/input/input.txt\");\n        fos.write(utf);\n        fos.close();\n\n        super.setUp();\n    }",
            "  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60 +\n  61  \n  62  \n  63  \n  64  \n  65  ",
            "    @Override\n    protected void setUp() throws Exception {\n        // use utf-8 as original payload with 00e6 which is a danish ae letter\n        utf = \"ABC\\u00e6\".getBytes(\"utf-8\");\n        iso = \"ABC\\u00e6\".getBytes(\"iso-8859-1\");\n\n        deleteDirectory(\"target/charset\");\n        createDirectory(\"target/charset/input\");\n\n        log.debug(\"utf: {}\", new String(utf, Charset.forName(\"utf-8\")));\n        log.debug(\"iso: {}\", new String(iso, Charset.forName(\"iso-8859-1\")));\n\n        for (byte b : utf) {\n            log.debug(\"utf byte: {}\", b);\n        }\n        for (byte b : iso) {\n            log.debug(\"iso byte: {}\", b);\n        }\n\n        // write the byte array to a file using plain API\n        OutputStream fos = Files.newOutputStream(Paths.get(\"target/charset/input/input.txt\"));\n        fos.write(utf);\n        fos.close();\n\n        super.setUp();\n    }"
        ],
        [
            "XmlLineNumberParserTest::testParseCamelContextForceNamespace()",
            "  61  \n  62 -\n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  ",
            "    public void testParseCamelContextForceNamespace() throws Exception {\n        FileInputStream fis = new FileInputStream(\"src/test/resources/org/apache/camel/util/camel-context.xml\");\n        Document dom = XmlLineNumberParser.parseXml(fis, null, \"camelContext\", \"http://camel.apache.org/schema/spring\");\n        assertNotNull(dom);\n\n        NodeList list = dom.getElementsByTagName(\"camelContext\");\n        assertEquals(1, list.getLength());\n        Node node = list.item(0);\n\n        String lineNumber = (String) node.getUserData(XmlLineNumberParser.LINE_NUMBER);\n        String lineNumberEnd = (String) node.getUserData(XmlLineNumberParser.LINE_NUMBER_END);\n\n        String ns = node.getNamespaceURI();\n        assertEquals(\"http://camel.apache.org/schema/spring\", ns);\n\n        assertEquals(\"29\", lineNumber);\n        assertEquals(\"47\", lineNumberEnd);\n\n        // and there are two routes\n        list = dom.getElementsByTagName(\"route\");\n        assertEquals(2, list.getLength());\n        Node node1 = list.item(0);\n        Node node2 = list.item(1);\n\n        String lineNumber1 = (String) node1.getUserData(XmlLineNumberParser.LINE_NUMBER);\n        String lineNumberEnd1 = (String) node1.getUserData(XmlLineNumberParser.LINE_NUMBER_END);\n        assertEquals(\"31\", lineNumber1);\n        assertEquals(\"37\", lineNumberEnd1);\n\n        String lineNumber2 = (String) node2.getUserData(XmlLineNumberParser.LINE_NUMBER);\n        String lineNumberEnd2 = (String) node2.getUserData(XmlLineNumberParser.LINE_NUMBER_END);\n        assertEquals(\"39\", lineNumber2);\n        assertEquals(\"45\", lineNumberEnd2);\n    }",
            "  63  \n  64 +\n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  ",
            "    public void testParseCamelContextForceNamespace() throws Exception {\n        InputStream fis = Files.newInputStream(Paths.get(\"src/test/resources/org/apache/camel/util/camel-context.xml\"));\n        Document dom = XmlLineNumberParser.parseXml(fis, null, \"camelContext\", \"http://camel.apache.org/schema/spring\");\n        assertNotNull(dom);\n\n        NodeList list = dom.getElementsByTagName(\"camelContext\");\n        assertEquals(1, list.getLength());\n        Node node = list.item(0);\n\n        String lineNumber = (String) node.getUserData(XmlLineNumberParser.LINE_NUMBER);\n        String lineNumberEnd = (String) node.getUserData(XmlLineNumberParser.LINE_NUMBER_END);\n\n        String ns = node.getNamespaceURI();\n        assertEquals(\"http://camel.apache.org/schema/spring\", ns);\n\n        assertEquals(\"29\", lineNumber);\n        assertEquals(\"47\", lineNumberEnd);\n\n        // and there are two routes\n        list = dom.getElementsByTagName(\"route\");\n        assertEquals(2, list.getLength());\n        Node node1 = list.item(0);\n        Node node2 = list.item(1);\n\n        String lineNumber1 = (String) node1.getUserData(XmlLineNumberParser.LINE_NUMBER);\n        String lineNumberEnd1 = (String) node1.getUserData(XmlLineNumberParser.LINE_NUMBER_END);\n        assertEquals(\"31\", lineNumber1);\n        assertEquals(\"37\", lineNumberEnd1);\n\n        String lineNumber2 = (String) node2.getUserData(XmlLineNumberParser.LINE_NUMBER);\n        String lineNumberEnd2 = (String) node2.getUserData(XmlLineNumberParser.LINE_NUMBER_END);\n        assertEquals(\"39\", lineNumber2);\n        assertEquals(\"45\", lineNumberEnd2);\n    }"
        ],
        [
            "XsltBuilderTest::testXsltSource()",
            " 131  \n 132  \n 133 -\n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  ",
            "    public void testXsltSource() throws Exception {\n        File file = new File(\"src/test/resources/org/apache/camel/builder/xml/example.xsl\");\n        Source styleSheet = new SAXSource(new InputSource(new FileInputStream(file)));\n\n        XsltBuilder builder = XsltBuilder.xslt(styleSheet);\n\n        Exchange exchange = new DefaultExchange(context);\n        exchange.getIn().setBody(\"<hello>world!</hello>\");\n\n        builder.process(exchange);\n\n        assertEquals(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><goodbye>world!</goodbye>\", exchange.getOut().getBody());\n    }",
            " 132  \n 133  \n 134 +\n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  ",
            "    public void testXsltSource() throws Exception {\n        File file = new File(\"src/test/resources/org/apache/camel/builder/xml/example.xsl\");\n        Source styleSheet = new SAXSource(new InputSource(Files.newInputStream(Paths.get(file.getAbsolutePath()))));\n\n        XsltBuilder builder = XsltBuilder.xslt(styleSheet);\n\n        Exchange exchange = new DefaultExchange(context);\n        exchange.getIn().setBody(\"<hello>world!</hello>\");\n\n        builder.process(exchange);\n\n        assertEquals(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><goodbye>world!</goodbye>\", exchange.getOut().getBody());\n    }"
        ],
        [
            "IOConverterCharsetTest::testToInputStreamFileWithCharsetLatin1()",
            "  59  \n  60  \n  61  \n  62  \n  63  \n  64 -\n  65  \n  66  \n  67  \n  68  \n  69  \n  70  ",
            "    public void testToInputStreamFileWithCharsetLatin1() throws Exception {\n        switchToDefaultCharset(StandardCharsets.UTF_8);\n        File file = new File(\"src/test/resources/org/apache/camel/converter/german.iso-8859-1.txt\");\n        try (InputStream in = IOConverter.toInputStream(file, \"ISO-8859-1\");\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));\n        BufferedReader naiveReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\"))) {\n            String line = reader.readLine();\n            String naiveLine = naiveReader.readLine();\n            assertEquals(naiveLine, line);\n            assertEquals(CONTENT, line);\n        }\n    }",
            "  60  \n  61  \n  62  \n  63  \n  64  \n  65 +\n  66  \n  67  \n  68  \n  69  \n  70  \n  71  ",
            "    public void testToInputStreamFileWithCharsetLatin1() throws Exception {\n        switchToDefaultCharset(StandardCharsets.UTF_8);\n        File file = new File(\"src/test/resources/org/apache/camel/converter/german.iso-8859-1.txt\");\n        try (InputStream in = IOConverter.toInputStream(file, \"ISO-8859-1\");\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));\n        BufferedReader naiveReader = new BufferedReader(new InputStreamReader(Files.newInputStream(Paths.get(file.getAbsolutePath())), \"ISO-8859-1\"))) {\n            String line = reader.readLine();\n            String naiveLine = naiveReader.readLine();\n            assertEquals(naiveLine, line);\n            assertEquals(CONTENT, line);\n        }\n    }"
        ],
        [
            "FileProducerCharsetUTFtoISOTest::testFileProducerCharsetUTFtoISO()",
            "  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70 -\n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  ",
            "    public void testFileProducerCharsetUTFtoISO() throws Exception {\n        oneExchangeDone.matchesMockWaitTime();\n\n        File file = new File(\"target/charset/output.txt\");\n        assertTrue(\"File should exist\", file.exists());\n\n        InputStream fis = IOHelper.buffered(new FileInputStream(file));\n        byte[] buffer = new byte[100];\n\n        int len = fis.read(buffer);\n        assertTrue(\"Should read data: \" + len, len != -1);\n        byte[] data = new byte[len];\n        System.arraycopy(buffer, 0, data, 0, len);\n        fis.close();\n\n        // data should be in iso, where the danish ae is -26\n        assertEquals(4, data.length);\n        assertEquals(65, data[0]);\n        assertEquals(66, data[1]);\n        assertEquals(67, data[2]);\n        assertEquals(-26, data[3]);\n    }",
            "  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73 +\n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  ",
            "    public void testFileProducerCharsetUTFtoISO() throws Exception {\n        oneExchangeDone.matchesMockWaitTime();\n\n        File file = new File(\"target/charset/output.txt\");\n        assertTrue(\"File should exist\", file.exists());\n\n        InputStream fis = Files.newInputStream(Paths.get(file.getAbsolutePath()));\n        byte[] buffer = new byte[100];\n\n        int len = fis.read(buffer);\n        assertTrue(\"Should read data: \" + len, len != -1);\n        byte[] data = new byte[len];\n        System.arraycopy(buffer, 0, data, 0, len);\n        fis.close();\n\n        // data should be in iso, where the danish ae is -26\n        assertEquals(4, data.length);\n        assertEquals(65, data[0]);\n        assertEquals(66, data[1]);\n        assertEquals(67, data[2]);\n        assertEquals(-26, data[3]);\n    }"
        ],
        [
            "ValidatorBeanCallTest::MyValidatorBean::loadFile()",
            "  74 -\n  75 -\n  76  ",
            "        public InputStream loadFile() throws FileNotFoundException {\n            return new FileInputStream(\"src/test/resources/report.xsd\");\n        }",
            "  77 +\n  78 +\n  79  ",
            "        public InputStream loadFile() throws Exception {\n            return Files.newInputStream(Paths.get(\"src/test/resources/report.xsd\"));\n        }"
        ],
        [
            "FileProducerCharsetUTFtoISOConfiguredTest::setUp()",
            "  37  \n  38  \n  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57 -\n  58  \n  59  \n  60  \n  61  \n  62  ",
            "    @Override\n    protected void setUp() throws Exception {\n        // use utf-8 as original payload with 00e6 which is a danish ae letter\n        utf = \"ABC\\u00e6\".getBytes(\"utf-8\");\n        iso = \"ABC\\u00e6\".getBytes(\"iso-8859-1\");\n\n        deleteDirectory(\"target/charset\");\n        createDirectory(\"target/charset/input\");\n\n        log.debug(\"utf: {}\", new String(utf, Charset.forName(\"utf-8\")));\n        log.debug(\"iso: {}\", new String(iso, Charset.forName(\"iso-8859-1\")));\n\n        for (byte b : utf) {\n            log.debug(\"utf byte: {}\", b);\n        }\n        for (byte b : iso) {\n            log.debug(\"iso byte: {}\", b);\n        }\n\n        // write the byte array to a file using plain API\n        FileOutputStream fos = new FileOutputStream(\"target/charset/input/input.txt\");\n        fos.write(utf);\n        fos.close();\n\n        super.setUp();\n    }",
            "  37  \n  38  \n  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57 +\n  58  \n  59  \n  60  \n  61  \n  62  ",
            "    @Override\n    protected void setUp() throws Exception {\n        // use utf-8 as original payload with 00e6 which is a danish ae letter\n        utf = \"ABC\\u00e6\".getBytes(\"utf-8\");\n        iso = \"ABC\\u00e6\".getBytes(\"iso-8859-1\");\n\n        deleteDirectory(\"target/charset\");\n        createDirectory(\"target/charset/input\");\n\n        log.debug(\"utf: {}\", new String(utf, Charset.forName(\"utf-8\")));\n        log.debug(\"iso: {}\", new String(iso, Charset.forName(\"iso-8859-1\")));\n\n        for (byte b : utf) {\n            log.debug(\"utf byte: {}\", b);\n        }\n        for (byte b : iso) {\n            log.debug(\"iso byte: {}\", b);\n        }\n\n        // write the byte array to a file using plain API\n        OutputStream fos = Files.newOutputStream(Paths.get(\"target/charset/input/input.txt\"));\n        fos.write(utf);\n        fos.close();\n\n        super.setUp();\n    }"
        ],
        [
            "IOHelperTest::assertReadAsWritten(String,String,String)",
            "  90  \n  91  \n  92  \n  93 -\n  94  \n  95  ",
            "    private void assertReadAsWritten(String testname, String text, String compareText) throws Exception {\n        File file = tempFile(testname);\n        write(file, text);\n        String loadText = IOHelper.loadText(new FileInputStream(file));\n        assertEquals(compareText, loadText);\n    }",
            "  91  \n  92  \n  93  \n  94 +\n  95  \n  96  ",
            "    private void assertReadAsWritten(String testname, String text, String compareText) throws Exception {\n        File file = tempFile(testname);\n        write(file, text);\n        String loadText = IOHelper.loadText(Files.newInputStream(Paths.get(file.getAbsolutePath())));\n        assertEquals(compareText, loadText);\n    }"
        ],
        [
            "FileProducerCharsetUTFOptimizedTest::setUp()",
            "  36  \n  37  \n  38  \n  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51 -\n  52  \n  53  \n  54  \n  55  \n  56  ",
            "    @Override\n    protected void setUp() throws Exception {\n        // use utf-8 as original payload with 00e6 which is a danish ae letter\n        utf = \"ABC\\u00e6\".getBytes(\"utf-8\");\n\n        deleteDirectory(\"target/charset\");\n        createDirectory(\"target/charset/input\");\n\n        log.debug(\"utf: {}\", new String(utf, Charset.forName(\"utf-8\")));\n\n        for (byte b : utf) {\n            log.debug(\"utf byte: {}\", b);\n        }\n\n        // write the byte array to a file using plain API\n        FileOutputStream fos = new FileOutputStream(\"target/charset/input/input.txt\");\n        fos.write(utf);\n        fos.close();\n\n        super.setUp();\n    }",
            "  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54 +\n  55  \n  56  \n  57  \n  58  \n  59  ",
            "    @Override\n    protected void setUp() throws Exception {\n        // use utf-8 as original payload with 00e6 which is a danish ae letter\n        utf = \"ABC\\u00e6\".getBytes(\"utf-8\");\n\n        deleteDirectory(\"target/charset\");\n        createDirectory(\"target/charset/input\");\n\n        log.debug(\"utf: {}\", new String(utf, Charset.forName(\"utf-8\")));\n\n        for (byte b : utf) {\n            log.debug(\"utf byte: {}\", b);\n        }\n\n        // write the byte array to a file using plain API\n        OutputStream fos = Files.newOutputStream(Paths.get(\"target/charset/input/input.txt\"));\n        fos.write(utf);\n        fos.close();\n\n        super.setUp();\n    }"
        ],
        [
            "IOConverterTest::testToBytes()",
            "  48  \n  49  \n  50 -\n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  ",
            "    public void testToBytes() throws Exception {\n        File file = new File(\"src/test/resources/org/apache/camel/converter/dummy.txt\");\n        byte[] data = IOConverter.toBytes(new FileInputStream(file));\n        assertEquals(\"get the wrong byte size\", file.length(), data.length);\n        assertEquals('#', (char) data[0]);\n\n        // should contain Hello World!\n        String s = new String(data);\n        assertTrue(\"Should contain Hello World!\", s.contains(\"Hello World\"));\n    }",
            "  50  \n  51  \n  52 +\n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  ",
            "    public void testToBytes() throws Exception {\n        File file = new File(\"src/test/resources/org/apache/camel/converter/dummy.txt\");\n        byte[] data = IOConverter.toBytes(Files.newInputStream(Paths.get(file.getAbsolutePath())));\n        assertEquals(\"get the wrong byte size\", file.length(), data.length);\n        assertEquals('#', (char) data[0]);\n\n        // should contain Hello World!\n        String s = new String(data);\n        assertTrue(\"Should contain Hello World!\", s.contains(\"Hello World\"));\n    }"
        ],
        [
            "XsltBuilderTest::testXsltTransformerInputStream()",
            " 117  \n 118  \n 119  \n 120  \n 121 -\n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  ",
            "    public void testXsltTransformerInputStream() throws Exception {\n        File styleSheet = new File(\"src/test/resources/org/apache/camel/builder/xml/example.xsl\");\n\n        XsltBuilder builder = new XsltBuilder();\n        builder.setTransformerInputStream(new FileInputStream(styleSheet));\n\n        Exchange exchange = new DefaultExchange(context);\n        exchange.getIn().setBody(\"<hello>world!</hello>\");\n\n        builder.process(exchange);\n\n        assertEquals(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><goodbye>world!</goodbye>\", exchange.getOut().getBody());\n    }",
            " 118  \n 119  \n 120  \n 121  \n 122 +\n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  ",
            "    public void testXsltTransformerInputStream() throws Exception {\n        File styleSheet = new File(\"src/test/resources/org/apache/camel/builder/xml/example.xsl\");\n\n        XsltBuilder builder = new XsltBuilder();\n        builder.setTransformerInputStream(Files.newInputStream(Paths.get(styleSheet.getAbsolutePath())));\n\n        Exchange exchange = new DefaultExchange(context);\n        exchange.getIn().setBody(\"<hello>world!</hello>\");\n\n        builder.process(exchange);\n\n        assertEquals(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><goodbye>world!</goodbye>\", exchange.getOut().getBody());\n    }"
        ],
        [
            "IOConverterCharsetTest::testToInputStreamFileWithCharsetUTF8withOtherDefaultEncoding()",
            "  46  \n  47  \n  48  \n  49  \n  50  \n  51 -\n  52  \n  53  \n  54  \n  55  \n  56  \n  57  ",
            "    public void testToInputStreamFileWithCharsetUTF8withOtherDefaultEncoding() throws Exception {\n        switchToDefaultCharset(StandardCharsets.ISO_8859_1);\n        File file = new File(\"src/test/resources/org/apache/camel/converter/german.utf-8.txt\");\n        try (InputStream in = IOConverter.toInputStream(file, \"UTF-8\");\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in, StandardCharsets.ISO_8859_1));\n        BufferedReader naiveReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8))) {\n            String line = reader.readLine();\n            String naiveLine = naiveReader.readLine();\n            assertEquals(naiveLine, line);\n            assertEquals(CONTENT, line);\n        }\n    }",
            "  47  \n  48  \n  49  \n  50  \n  51  \n  52 +\n  53  \n  54  \n  55  \n  56  \n  57  \n  58  ",
            "    public void testToInputStreamFileWithCharsetUTF8withOtherDefaultEncoding() throws Exception {\n        switchToDefaultCharset(StandardCharsets.ISO_8859_1);\n        File file = new File(\"src/test/resources/org/apache/camel/converter/german.utf-8.txt\");\n        try (InputStream in = IOConverter.toInputStream(file, \"UTF-8\");\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in, StandardCharsets.ISO_8859_1));\n        BufferedReader naiveReader = new BufferedReader(new InputStreamReader(Files.newInputStream(Paths.get(file.getAbsolutePath())), StandardCharsets.UTF_8))) {\n            String line = reader.readLine();\n            String naiveLine = naiveReader.readLine();\n            assertEquals(naiveLine, line);\n            assertEquals(CONTENT, line);\n        }\n    }"
        ],
        [
            "FileProducerCharsetUTFtoISOConvertBodyToTest::setUp()",
            "  38  \n  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58 -\n  59  \n  60  \n  61  \n  62  \n  63  ",
            "    @Override\n    protected void setUp() throws Exception {\n        // use utf-8 as original payload with 00e6 which is a danish ae letter\n        utf = \"ABC\\u00e6\".getBytes(\"utf-8\");\n        iso = \"ABC\\u00e6\".getBytes(\"iso-8859-1\");\n\n        deleteDirectory(\"target/charset\");\n        createDirectory(\"target/charset/input\");\n\n        log.debug(\"utf: {}\", new String(utf, Charset.forName(\"utf-8\")));\n        log.debug(\"iso: {}\", new String(iso, Charset.forName(\"iso-8859-1\")));\n\n        for (byte b : utf) {\n            log.debug(\"utf byte: {}\", b);\n        }\n        for (byte b : iso) {\n            log.debug(\"iso byte: {}\", b);\n        }\n\n        // write the byte array to a file using plain API\n        FileOutputStream fos = new FileOutputStream(\"target/charset/input/input.txt\");\n        fos.write(utf);\n        fos.close();\n\n        super.setUp();\n    }",
            "  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61 +\n  62  \n  63  \n  64  \n  65  \n  66  ",
            "    @Override\n    protected void setUp() throws Exception {\n        // use utf-8 as original payload with 00e6 which is a danish ae letter\n        utf = \"ABC\\u00e6\".getBytes(\"utf-8\");\n        iso = \"ABC\\u00e6\".getBytes(\"iso-8859-1\");\n\n        deleteDirectory(\"target/charset\");\n        createDirectory(\"target/charset/input\");\n\n        log.debug(\"utf: {}\", new String(utf, Charset.forName(\"utf-8\")));\n        log.debug(\"iso: {}\", new String(iso, Charset.forName(\"iso-8859-1\")));\n\n        for (byte b : utf) {\n            log.debug(\"utf byte: {}\", b);\n        }\n        for (byte b : iso) {\n            log.debug(\"iso byte: {}\", b);\n        }\n\n        // write the byte array to a file using plain API\n        OutputStream fos = Files.newOutputStream(Paths.get(\"target/charset/input/input.txt\"));\n        fos.write(utf);\n        fos.close();\n\n        super.setUp();\n    }"
        ],
        [
            "FileProducerCharsetUTFtoISOConfiguredTest::testFileProducerCharsetUTFtoISO()",
            "  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70 -\n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  ",
            "    public void testFileProducerCharsetUTFtoISO() throws Exception {\n        oneExchangeDone.matchesMockWaitTime();\n\n        File file = new File(\"target/charset/output.txt\");\n        assertTrue(\"File should exist\", file.exists());\n\n        InputStream fis = IOHelper.buffered(new FileInputStream(file));\n        byte[] buffer = new byte[100];\n\n        int len = fis.read(buffer);\n        assertTrue(\"Should read data: \" + len, len != -1);\n        byte[] data = new byte[len];\n        System.arraycopy(buffer, 0, data, 0, len);\n        fis.close();\n\n        // data should be in iso, where the danish ae is -26\n        assertEquals(4, data.length);\n        assertEquals(65, data[0]);\n        assertEquals(66, data[1]);\n        assertEquals(67, data[2]);\n        assertEquals(-26, data[3]);\n    }",
            "  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70 +\n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  ",
            "    public void testFileProducerCharsetUTFtoISO() throws Exception {\n        oneExchangeDone.matchesMockWaitTime();\n\n        File file = new File(\"target/charset/output.txt\");\n        assertTrue(\"File should exist\", file.exists());\n\n        InputStream fis = Files.newInputStream(Paths.get(file.getAbsolutePath()));\n        byte[] buffer = new byte[100];\n\n        int len = fis.read(buffer);\n        assertTrue(\"Should read data: \" + len, len != -1);\n        byte[] data = new byte[len];\n        System.arraycopy(buffer, 0, data, 0, len);\n        fis.close();\n\n        // data should be in iso, where the danish ae is -26\n        assertEquals(4, data.length);\n        assertEquals(65, data[0]);\n        assertEquals(66, data[1]);\n        assertEquals(67, data[2]);\n        assertEquals(-26, data[3]);\n    }"
        ]
    ],
    "a8407f8aa67ef04395a55c9f1aaadf4a945b416d": [
        [
            "MllpTcpServerConsumer::validateConsumer(Socket)",
            " 192  \n 193  \n 194  \n 195  \n 196  \n 197 -\n 198  \n 199  \n 200  \n 201  \n 202  \n 203  ",
            "    public void validateConsumer(Socket clientSocket) {\n        MllpSocketBuffer mllpBuffer = new MllpSocketBuffer(getEndpoint());\n        TcpServerConsumerValidationRunnable client = new TcpServerConsumerValidationRunnable(this, clientSocket, mllpBuffer);\n\n        try {\n            log.info(\"Validating consumer for Socket {}\", clientSocket);\n            validationExecutor.submit(client);\n        } catch (RejectedExecutionException rejectedExecutionEx) {\n            log.warn(\"Cannot validate consumer - max validations already active\");\n            mllpBuffer.resetSocket(clientSocket);\n        }\n    }",
            " 192  \n 193  \n 194  \n 195  \n 196  \n 197 +\n 198  \n 199  \n 200  \n 201  \n 202  \n 203  ",
            "    public void validateConsumer(Socket clientSocket) {\n        MllpSocketBuffer mllpBuffer = new MllpSocketBuffer(getEndpoint());\n        TcpServerConsumerValidationRunnable client = new TcpServerConsumerValidationRunnable(this, clientSocket, mllpBuffer);\n\n        try {\n            log.debug(\"Validating consumer for Socket {}\", clientSocket);\n            validationExecutor.submit(client);\n        } catch (RejectedExecutionException rejectedExecutionEx) {\n            log.warn(\"Cannot validate consumer - max validations already active\");\n            mllpBuffer.resetSocket(clientSocket);\n        }\n    }"
        ],
        [
            "TcpSocketConsumerRunnable::run()",
            " 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169 -\n 170  \n 171 -\n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209 -\n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  ",
            "    @Override\n    public void run() {\n        running = true;\n        String originalThreadName = Thread.currentThread().getName();\n        Thread.currentThread().setName(createThreadName(clientSocket));\n        MDC.put(MDCUnitOfWork.MDC_CAMEL_CONTEXT_ID, consumer.getEndpoint().getCamelContext().getName());\n\n        Route route = consumer.getRoute();\n        if (route != null) {\n            String routeId = route.getId();\n            if (routeId != null) {\n                MDC.put(MDCUnitOfWork.MDC_ROUTE_ID, route.getId());\n            }\n        }\n\n        log.debug(\"Starting {} for {}\", this.getClass().getSimpleName(), combinedAddress);\n        try {\n            byte[] hl7MessageBytes = null;\n            if (mllpBuffer.hasCompleteEnvelope()) {\n                // If we got a complete message on the validation read, process it\n                hl7MessageBytes = mllpBuffer.toMllpPayload();\n                mllpBuffer.reset();\n                consumer.processMessage(hl7MessageBytes, this);\n            }\n\n            while (running && null != clientSocket && clientSocket.isConnected() && !clientSocket.isClosed()) {\n                log.debug(\"Checking for data ....\");\n                try {\n                    mllpBuffer.readFrom(clientSocket);\n                    if (mllpBuffer.hasCompleteEnvelope()) {\n                        hl7MessageBytes = mllpBuffer.toMllpPayload();\n                        log.debug(\"Received {} byte message {}\", hl7MessageBytes.length, Hl7Util.convertToPrintFriendlyString(hl7MessageBytes));\n                        if (mllpBuffer.hasLeadingOutOfBandData()) {\n                            // TODO:  Move the convertion utilities to the MllpSocketBuffer to avoid a byte[] copy\n                            log.warn(\"Ignoring leading out-of-band data: {}\", Hl7Util.convertToPrintFriendlyString(mllpBuffer.getLeadingOutOfBandData()));\n                        }\n                        if (mllpBuffer.hasTrailingOutOfBandData()) {\n                            log.warn(\"Ignoring trailing out-of-band data: {}\", Hl7Util.convertToPrintFriendlyString(mllpBuffer.getTrailingOutOfBandData()));\n                        }\n                        mllpBuffer.reset();\n\n                        consumer.processMessage(hl7MessageBytes, this);\n                    } else if (!mllpBuffer.hasStartOfBlock()) {\n                        byte[] payload = mllpBuffer.toByteArray();\n                        log.warn(\"Ignoring {} byte un-enveloped payload {}\", payload.length, Hl7Util.convertToPrintFriendlyString(payload));\n                        mllpBuffer.reset();\n                    } else if (!mllpBuffer.isEmpty()) {\n                        byte[] payload = mllpBuffer.toByteArray();\n                        log.warn(\"Partial {} byte payload received {}\", payload.length, Hl7Util.convertToPrintFriendlyString(payload));\n                    }\n                } catch (SocketTimeoutException timeoutEx) {\n                    if (mllpBuffer.isEmpty()) {\n                        if (consumer.getConfiguration().hasIdleTimeout()) {\n                            long currentTicks = System.currentTimeMillis();\n                            long lastReceivedMessageTicks = consumer.getConsumerRunnables().get(this);\n                            long idleTime = currentTicks - lastReceivedMessageTicks;\n                            if (idleTime >= consumer.getConfiguration().getIdleTimeout()) {\n                                consumer.getEndpoint().doConnectionClose(clientSocket, true, log);\n                            }\n                        }\n                        log.debug(\"No data received - ignoring timeout\");\n                    } else {\n                        mllpBuffer.resetSocket(clientSocket);\n                        new MllpInvalidMessageException(\"Timeout receiving complete message payload\", mllpBuffer.toByteArrayAndReset(), timeoutEx);\n                        consumer.handleMessageTimeout(\"Timeout receiving complete message payload\", mllpBuffer.toByteArrayAndReset(), timeoutEx);\n                    }\n                } catch (MllpSocketException mllpSocketEx) {\n                    mllpBuffer.resetSocket(clientSocket);\n                    if (!mllpBuffer.isEmpty()) {\n                        consumer.handleMessageException(\"Exception encountered reading payload\", mllpBuffer.toByteArrayAndReset(), mllpSocketEx);\n                    } else {\n                        log.warn(\"Ignoring exception encountered checking for data\", mllpSocketEx);\n                    }\n                }\n            }\n        } catch (Exception unexpectedEx) {\n            log.error(\"Unexpected exception encountered receiving messages\", unexpectedEx);\n        } finally {\n            consumer.getConsumerRunnables().remove(this);\n            log.debug(\"{} for {} completed\", this.getClass().getSimpleName(), combinedAddress);\n\n            Thread.currentThread().setName(originalThreadName);\n            MDC.remove(MDCUnitOfWork.MDC_ROUTE_ID);\n            MDC.remove(MDCUnitOfWork.MDC_CAMEL_CONTEXT_ID);\n\n            mllpBuffer.resetSocket(clientSocket);\n        }\n    }",
            " 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169 +\n 170 +\n 171 +\n 172  \n 173 +\n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211 +\n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  ",
            "    @Override\n    public void run() {\n        running = true;\n        String originalThreadName = Thread.currentThread().getName();\n        Thread.currentThread().setName(createThreadName(clientSocket));\n        MDC.put(MDCUnitOfWork.MDC_CAMEL_CONTEXT_ID, consumer.getEndpoint().getCamelContext().getName());\n\n        Route route = consumer.getRoute();\n        if (route != null) {\n            String routeId = route.getId();\n            if (routeId != null) {\n                MDC.put(MDCUnitOfWork.MDC_ROUTE_ID, route.getId());\n            }\n        }\n\n        log.debug(\"Starting {} for {}\", this.getClass().getSimpleName(), combinedAddress);\n        try {\n            byte[] hl7MessageBytes = null;\n            if (mllpBuffer.hasCompleteEnvelope()) {\n                // If we got a complete message on the validation read, process it\n                hl7MessageBytes = mllpBuffer.toMllpPayload();\n                mllpBuffer.reset();\n                consumer.processMessage(hl7MessageBytes, this);\n            }\n\n            while (running && null != clientSocket && clientSocket.isConnected() && !clientSocket.isClosed()) {\n                log.debug(\"Checking for data ....\");\n                try {\n                    mllpBuffer.readFrom(clientSocket);\n                    if (mllpBuffer.hasCompleteEnvelope()) {\n                        hl7MessageBytes = mllpBuffer.toMllpPayload();\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Received {} byte message {}\", hl7MessageBytes.length, Hl7Util.convertToPrintFriendlyString(hl7MessageBytes));\n                        }\n                        if (mllpBuffer.hasLeadingOutOfBandData()) {\n                            // TODO:  Move the conversion utilities to the MllpSocketBuffer to avoid a byte[] copy\n                            log.warn(\"Ignoring leading out-of-band data: {}\", Hl7Util.convertToPrintFriendlyString(mllpBuffer.getLeadingOutOfBandData()));\n                        }\n                        if (mllpBuffer.hasTrailingOutOfBandData()) {\n                            log.warn(\"Ignoring trailing out-of-band data: {}\", Hl7Util.convertToPrintFriendlyString(mllpBuffer.getTrailingOutOfBandData()));\n                        }\n                        mllpBuffer.reset();\n\n                        consumer.processMessage(hl7MessageBytes, this);\n                    } else if (!mllpBuffer.hasStartOfBlock()) {\n                        byte[] payload = mllpBuffer.toByteArray();\n                        log.warn(\"Ignoring {} byte un-enveloped payload {}\", payload.length, Hl7Util.convertToPrintFriendlyString(payload));\n                        mllpBuffer.reset();\n                    } else if (!mllpBuffer.isEmpty()) {\n                        byte[] payload = mllpBuffer.toByteArray();\n                        log.warn(\"Partial {} byte payload received {}\", payload.length, Hl7Util.convertToPrintFriendlyString(payload));\n                    }\n                } catch (SocketTimeoutException timeoutEx) {\n                    if (mllpBuffer.isEmpty()) {\n                        if (consumer.getConfiguration().hasIdleTimeout()) {\n                            long currentTicks = System.currentTimeMillis();\n                            long lastReceivedMessageTicks = consumer.getConsumerRunnables().get(this);\n                            long idleTime = currentTicks - lastReceivedMessageTicks;\n                            if (idleTime >= consumer.getConfiguration().getIdleTimeout()) {\n                                consumer.getEndpoint().doConnectionClose(clientSocket, true, log);\n                            }\n                        }\n                        log.debug(\"No data received - ignoring timeout\");\n                    } else {\n                        mllpBuffer.resetSocket(clientSocket);\n                        new MllpInvalidMessageException(\"Timeout receiving complete message payload\", mllpBuffer.toByteArrayAndReset(), timeoutEx);\n                        consumer.handleMessageTimeout(\"Timeout receiving complete message payload\", mllpBuffer.toByteArrayAndReset(), timeoutEx);\n                    }\n                } catch (MllpSocketException mllpSocketEx) {\n                    mllpBuffer.resetSocket(clientSocket);\n                    if (!mllpBuffer.isEmpty()) {\n                        consumer.handleMessageException(\"Exception encountered reading payload\", mllpBuffer.toByteArrayAndReset(), mllpSocketEx);\n                    } else {\n                        log.debug(\"Ignoring exception encountered checking for data\", mllpSocketEx);\n                    }\n                }\n            }\n        } catch (Exception unexpectedEx) {\n            log.error(\"Unexpected exception encountered receiving messages\", unexpectedEx);\n        } finally {\n            consumer.getConsumerRunnables().remove(this);\n            log.debug(\"{} for {} completed\", this.getClass().getSimpleName(), combinedAddress);\n\n            Thread.currentThread().setName(originalThreadName);\n            MDC.remove(MDCUnitOfWork.MDC_ROUTE_ID);\n            MDC.remove(MDCUnitOfWork.MDC_CAMEL_CONTEXT_ID);\n\n            mllpBuffer.resetSocket(clientSocket);\n        }\n    }"
        ],
        [
            "MllpSocketBuffer::doSocketClose(Socket,String,boolean)",
            " 657  \n 658  \n 659  \n 660  \n 661  \n 662 -\n 663  \n 664  \n 665  \n 666  \n 667  \n 668  \n 669  \n 670  \n 671  \n 672  \n 673  \n 674  \n 675  \n 676  \n 677  \n 678  \n 679  \n 680  \n 681  \n 682  \n 683  \n 684  \n 685  \n 686  \n 687  \n 688  \n 689  \n 690  \n 691  \n 692  \n 693  \n 694  \n 695  \n 696  \n 697  \n 698  \n 699  ",
            "    void doSocketClose(Socket socket, String logMessage, boolean reset) {\n        if (socket != null && socket.isConnected() && !socket.isClosed()) {\n            if (logMessage != null && !logMessage.isEmpty()) {\n                log.info(\"{} - {} socket {}\", reset ? \"Resetting\" : \"Closing\", logMessage, socket);\n            } else {\n                log.info(\"{} socket {}\", reset ? \"Resetting\" : \"Closing\", socket);\n            }\n\n            endpoint.updateLastConnectionTerminatedTicks();\n\n            if (!socket.isInputShutdown()) {\n                try {\n                    socket.shutdownInput();\n                } catch (IOException ignoredEx) {\n                    // TODO: Maybe log this\n                }\n            }\n\n            if (!socket.isOutputShutdown()) {\n                try {\n                    socket.shutdownOutput();\n                } catch (IOException ignoredEx) {\n                    // TODO: Maybe log this\n                }\n            }\n\n            if (reset) {\n                try {\n                    final boolean on = true;\n                    final int linger = 0;\n                    socket.setSoLinger(on, linger);\n                } catch (IOException ignoredEx) {\n                    // TODO: Maybe log this\n                }\n            }\n\n            try {\n                socket.close();\n            } catch (IOException ignoredEx) {\n                // TODO: Maybe log this\n            }\n        }\n    }",
            " 655  \n 656  \n 657  \n 658  \n 659  \n 660 +\n 661  \n 662  \n 663  \n 664  \n 665  \n 666  \n 667  \n 668  \n 669  \n 670  \n 671  \n 672  \n 673  \n 674  \n 675  \n 676  \n 677  \n 678  \n 679  \n 680  \n 681  \n 682  \n 683  \n 684  \n 685  \n 686  \n 687  \n 688  \n 689  \n 690  \n 691  \n 692  \n 693  \n 694  \n 695  \n 696  \n 697  ",
            "    void doSocketClose(Socket socket, String logMessage, boolean reset) {\n        if (socket != null && socket.isConnected() && !socket.isClosed()) {\n            if (logMessage != null && !logMessage.isEmpty()) {\n                log.info(\"{} - {} socket {}\", reset ? \"Resetting\" : \"Closing\", logMessage, socket);\n            } else {\n                log.debug(\"{} socket {}\", reset ? \"Resetting\" : \"Closing\", socket);\n            }\n\n            endpoint.updateLastConnectionTerminatedTicks();\n\n            if (!socket.isInputShutdown()) {\n                try {\n                    socket.shutdownInput();\n                } catch (IOException ignoredEx) {\n                    // TODO: Maybe log this\n                }\n            }\n\n            if (!socket.isOutputShutdown()) {\n                try {\n                    socket.shutdownOutput();\n                } catch (IOException ignoredEx) {\n                    // TODO: Maybe log this\n                }\n            }\n\n            if (reset) {\n                try {\n                    final boolean on = true;\n                    final int linger = 0;\n                    socket.setSoLinger(on, linger);\n                } catch (IOException ignoredEx) {\n                    // TODO: Maybe log this\n                }\n            }\n\n            try {\n                socket.close();\n            } catch (IOException ignoredEx) {\n                // TODO: Maybe log this\n            }\n        }\n    }"
        ],
        [
            "MllpSocketBuffer::readSocketInputStream(InputStream,Socket)",
            " 605  \n 606  \n 607  \n 608  \n 609  \n 610 -\n 611 -\n 612 -\n 613  \n 614  \n 615  \n 616  \n 617  \n 618  \n 619  \n 620  \n 621  \n 622  \n 623  \n 624  \n 625  \n 626  \n 627  \n 628  \n 629 -\n 630 -\n 631 -\n 632  \n 633  \n 634 -\n 635 -\n 636  \n 637  \n 638  \n 639  ",
            "    void readSocketInputStream(InputStream socketInputStream, Socket socket) throws MllpSocketException, SocketTimeoutException {\n        log.trace(\"Entering readSocketInputStream - size = {}\", size());\n        try {\n            int readCount = socketInputStream.read(buffer, availableByteCount, buffer.length - availableByteCount);\n            if (readCount == MllpProtocolConstants.END_OF_STREAM) {\n                final String exceptionMessage = \"END_OF_STREAM returned from SocketInputStream.read(byte[], off, len)\";\n                resetSocket(socket, exceptionMessage);\n                throw new SocketException(exceptionMessage);\n            }\n            if (readCount > 0) {\n                for (int i = 0; (startOfBlockIndex == -1 || endOfBlockIndex == -1) && i < readCount; ++i) {\n                    updateIndexes(buffer[availableByteCount + i], i);\n                }\n                availableByteCount += readCount;\n\n                if (hasStartOfBlock()) {\n                    log.trace(\"Read {} bytes for a total of {} bytes\", readCount, availableByteCount);\n                } else {\n                    log.warn(\"Ignoring {} bytes received before START_OF_BLOCK\", size(), toPrintFriendlyStringAndReset());\n                }\n            }\n        } catch (SocketTimeoutException timeoutEx) {\n            throw timeoutEx;\n        } catch (SocketException socketEx) {\n            final String exceptionMessage = \"SocketException encountered in readSocketInputStream\";\n            resetSocket(socket, exceptionMessage);\n            throw new MllpSocketException(exceptionMessage, socketEx);\n        } catch (IOException ioEx) {\n            final String exceptionMessage = \"IOException thrown from SocketInputStream.read(byte[], off, len)\";\n            resetSocket(socket, exceptionMessage);\n            throw new MllpSocketException(exceptionMessage, ioEx);\n        } finally {\n            log.trace(\"Exiting readSocketInputStream - size = {}\", size());\n        }\n    }",
            " 605  \n 606  \n 607  \n 608  \n 609  \n 610 +\n 611 +\n 612  \n 613  \n 614  \n 615  \n 616  \n 617  \n 618  \n 619  \n 620  \n 621  \n 622  \n 623  \n 624  \n 625  \n 626  \n 627  \n 628 +\n 629 +\n 630  \n 631  \n 632 +\n 633 +\n 634  \n 635  \n 636  \n 637  ",
            "    void readSocketInputStream(InputStream socketInputStream, Socket socket) throws MllpSocketException, SocketTimeoutException {\n        log.trace(\"Entering readSocketInputStream - size = {}\", size());\n        try {\n            int readCount = socketInputStream.read(buffer, availableByteCount, buffer.length - availableByteCount);\n            if (readCount == MllpProtocolConstants.END_OF_STREAM) {\n                resetSocket(socket);\n                throw new SocketException(\"END_OF_STREAM returned from SocketInputStream.read(byte[], off, len)\");\n            }\n            if (readCount > 0) {\n                for (int i = 0; (startOfBlockIndex == -1 || endOfBlockIndex == -1) && i < readCount; ++i) {\n                    updateIndexes(buffer[availableByteCount + i], i);\n                }\n                availableByteCount += readCount;\n\n                if (hasStartOfBlock()) {\n                    log.trace(\"Read {} bytes for a total of {} bytes\", readCount, availableByteCount);\n                } else {\n                    log.warn(\"Ignoring {} bytes received before START_OF_BLOCK\", size(), toPrintFriendlyStringAndReset());\n                }\n            }\n        } catch (SocketTimeoutException timeoutEx) {\n            throw timeoutEx;\n        } catch (SocketException socketEx) {\n            resetSocket(socket);\n            throw new MllpSocketException(\"SocketException encountered in readSocketInputStream\", socketEx);\n        } catch (IOException ioEx) {\n            final String exceptionMessage = \"IOException thrown from SocketInputStream.read(byte[], off, len)\";\n            resetSocket(socket);\n            throw new MllpSocketException(\"IOException thrown from SocketInputStream.read(byte[], off, len)\", ioEx);\n        } finally {\n            log.trace(\"Exiting readSocketInputStream - size = {}\", size());\n        }\n    }"
        ]
    ],
    "1982d0a2851d76ffe904912299712cf7752eff41": [
        [
            "RunMojo::execute()",
            " 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364 -\n 365 -\n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  \n 423  \n 424  \n 425  \n 426  \n 427  \n 428  \n 429  \n 430  \n 431  \n 432  \n 433  \n 434  \n 435  \n 436  \n 437  \n 438  \n 439  \n 440  \n 441  \n 442  \n 443  \n 444  \n 445  \n 446  \n 447  \n 448  \n 449  \n 450  \n 451  \n 452  \n 453  \n 454  \n 455  \n 456  \n 457  \n 458  \n 459  \n 460  \n 461  \n 462  \n 463  \n 464  \n 465  \n 466  \n 467  \n 468  \n 469  \n 470  \n 471  \n 472  \n 473  \n 474  \n 475  \n 476  \n 477  \n 478  \n 479  \n 480  \n 481  \n 482  \n 483  \n 484  \n 485  \n 486  \n 487  \n 488  \n 489  \n 490  \n 491  \n 492  \n 493  \n 494  \n 495  \n 496  \n 497  \n 498  \n 499  \n 500  \n 501  \n 502  \n 503  \n 504  \n 505  \n 506  \n 507  \n 508  ",
            "    /**\n     * Execute goal.\n     *\n     * @throws MojoExecutionException execution of the main class or one of the\n     *                 threads it generated failed.\n     * @throws MojoFailureException something bad happened...\n     */\n    public void execute() throws MojoExecutionException, MojoFailureException {\n        boolean usingSpringJavaConfigureMain = false;\n        boolean useCdiMain = useCDI || detectCDIOnClassPath();\n        boolean usingBlueprintMain = useBlueprint || detectBlueprintOnClassPathOrBlueprintXMLFiles();\n        if (killAfter != -1) {\n            getLog().warn(\"Warning: killAfter is now deprecated. Do you need it ? Please comment on MEXEC-6.\");\n        }\n\n        // lets create the command line arguments to pass in...\n        List<String> args = new ArrayList<String>();\n        if (trace) {\n            args.add(\"-t\");\n        }\n\n        if (applicationContextUri != null) {\n            args.add(\"-ac\");\n            args.add(applicationContextUri);\n        } else if (fileApplicationContextUri != null) {\n            args.add(\"-fa\");\n            args.add(fileApplicationContextUri);\n        }\n        \n        if (configClasses != null) {\n            args.add(\"-cc\");\n            args.add(configClasses);\n            usingSpringJavaConfigureMain = true;\n        }        \n        if (basedPackages != null) {\n            args.add(\"-bp\");\n            args.add(basedPackages);\n            usingSpringJavaConfigureMain = true;\n        }\n \n        args.add(\"-d\");\n        args.add(duration);\n        if (arguments != null) {\n            args.addAll(Arrays.asList(arguments));\n        }\n        \n        if (usingSpringJavaConfigureMain) {\n            mainClass = \"org.apache.camel.spring.javaconfig.Main\";\n            getLog().info(\"Using org.apache.camel.spring.javaconfig.Main to initiate a CamelContext\");\n        } else if (useCdiMain) {\n            mainClass = \"org.apache.camel.cdi.Main\";\n            // must include plugin dependencies for cdi\n            extraPluginDependencyArtifactId = \"camel-cdi\";\n            getLog().info(\"Using \" + mainClass + \" to initiate a CamelContext\");\n        } else if (usingBlueprintMain) {\n            mainClass = \"org.apache.camel.test.blueprint.Main\";\n            // must include plugin dependencies for blueprint\n            extraPluginDependencyArtifactId = \"camel-test-blueprint\";\n            // set the configAdmin pid\n            if (configAdminPid != null) {\n                args.add(\"-pid\");\n                args.add(configAdminPid);\n            }\n            // set the configAdmin pFile\n            if (configAdminFileName != null) {\n                args.add(\"-pf\");\n                args.add(configAdminFileName);\n            }\n            getLog().info(\"Using org.apache.camel.test.blueprint.Main to initiate a CamelContext\");\n        } else if (mainClass != null) {\n            getLog().info(\"Using custom \" + mainClass + \" to initiate a CamelContext\");\n        } else {\n            // use spring by default\n            getLog().info(\"Using org.apache.camel.spring.Main to initiate a CamelContext\");\n            mainClass = \"org.apache.camel.spring.Main\";\n        }\n\n        arguments = new String[args.size()];\n        args.toArray(arguments);\n        \n        if (getLog().isDebugEnabled()) {\n            StringBuilder msg = new StringBuilder(\"Invoking: \");\n            msg.append(mainClass);\n            msg.append(\".main(\");\n            for (int i = 0; i < arguments.length; i++) {\n                if (i > 0) {\n                    msg.append(\", \");\n                }\n                msg.append(arguments[i]);\n            }\n            msg.append(\")\");\n            getLog().debug(msg);\n        }\n\n        IsolatedThreadGroup threadGroup = new IsolatedThreadGroup(mainClass /* name */);\n        final Thread bootstrapThread = new Thread(threadGroup, new Runnable() {\n            public void run() {\n                try {\n                    beforeBootstrapCamel();\n\n                    getLog().info(\"Starting Camel ...\");\n                    Method main = Thread.currentThread().getContextClassLoader()\n                            .loadClass(mainClass).getMethod(\"main\", String[].class);\n                    main.invoke(null, new Object[]{arguments});\n\n                    afterBootstrapCamel();\n                } catch (Exception e) { // just pass it on\n                    // let it be printed so end users can see the exception on the console\n                    getLog().error(\"*************************************\");\n                    getLog().error(\"Error occurred while running main from: \" + mainClass);\n                    getLog().error(e);\n                    getLog().error(\"*************************************\");\n                    Thread.currentThread().getThreadGroup().uncaughtException(Thread.currentThread(), e);\n                }\n            }\n        }, mainClass + \".main()\");\n\n        bootstrapThread.setContextClassLoader(getClassLoader());\n        setSystemProperties();\n\n        bootstrapThread.start();\n        joinNonDaemonThreads(threadGroup);\n        // It's plausible that spontaneously a non-daemon thread might be\n        // created as we try and shut down,\n        // but it's too late since the termination condition (only daemon\n        // threads) has been triggered.\n        if (keepAlive) {\n            getLog().warn(\"Warning: keepAlive is now deprecated and obsolete. Do you need it? Please comment on MEXEC-6.\");\n            waitFor(0);\n        }\n\n        if (cleanupDaemonThreads) {\n\n            terminateThreads(threadGroup);\n\n            try {\n                threadGroup.destroy();\n            } catch (IllegalThreadStateException e) {\n                getLog().warn(\"Couldn't destroy threadgroup \" + threadGroup, e);\n            }\n        }\n\n        if (originalSystemProperties != null) {\n            System.setProperties(originalSystemProperties);\n        }\n\n        synchronized (threadGroup) {\n            if (threadGroup.uncaughtException != null) {\n                throw new MojoExecutionException(null, threadGroup.uncaughtException);\n            }\n        }\n\n        registerSourceRoots();\n    }",
            " 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362 +\n 363 +\n 364 +\n 365 +\n 366 +\n 367 +\n 368 +\n 369 +\n 370 +\n 371 +\n 372 +\n 373 +\n 374 +\n 375 +\n 376 +\n 377 +\n 378 +\n 379 +\n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  \n 423  \n 424  \n 425  \n 426  \n 427  \n 428  \n 429  \n 430  \n 431  \n 432  \n 433  \n 434  \n 435  \n 436  \n 437  \n 438  \n 439  \n 440  \n 441  \n 442  \n 443  \n 444  \n 445  \n 446  \n 447  \n 448  \n 449  \n 450  \n 451  \n 452  \n 453  \n 454  \n 455  \n 456  \n 457  \n 458  \n 459  \n 460  \n 461  \n 462  \n 463  \n 464  \n 465  \n 466  \n 467  \n 468  \n 469  \n 470  \n 471  \n 472  \n 473  \n 474  \n 475  \n 476  \n 477  \n 478  \n 479  \n 480  \n 481  \n 482  \n 483  \n 484  \n 485  \n 486  \n 487  \n 488  \n 489  \n 490  \n 491  \n 492  \n 493  \n 494  \n 495  \n 496  \n 497  \n 498  \n 499  \n 500  \n 501  \n 502  \n 503  \n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512  \n 513  \n 514  \n 515  \n 516  \n 517  \n 518  \n 519  \n 520  \n 521  \n 522  ",
            "    /**\n     * Execute goal.\n     *\n     * @throws MojoExecutionException execution of the main class or one of the\n     *                 threads it generated failed.\n     * @throws MojoFailureException something bad happened...\n     */\n    public void execute() throws MojoExecutionException, MojoFailureException {\n        boolean usingSpringJavaConfigureMain = false;\n\n        boolean useCdiMain = false;\n        if (useCDI != null) {\n            // use configured value\n            useCdiMain = useCDI;\n        } else {\n            // auto detect if we have cdi\n            useCdiMain = detectCDIOnClassPath();\n        }\n        boolean usingBlueprintMain = false;\n        if (useBlueprint != null) {\n            // use configured value\n            usingBlueprintMain = useBlueprint;\n        } else {\n            // auto detect if we have blueprint\n            usingBlueprintMain = detectBlueprintOnClassPathOrBlueprintXMLFiles();\n        }\n\n        if (killAfter != -1) {\n            getLog().warn(\"Warning: killAfter is now deprecated. Do you need it ? Please comment on MEXEC-6.\");\n        }\n\n        // lets create the command line arguments to pass in...\n        List<String> args = new ArrayList<String>();\n        if (trace) {\n            args.add(\"-t\");\n        }\n\n        if (applicationContextUri != null) {\n            args.add(\"-ac\");\n            args.add(applicationContextUri);\n        } else if (fileApplicationContextUri != null) {\n            args.add(\"-fa\");\n            args.add(fileApplicationContextUri);\n        }\n        \n        if (configClasses != null) {\n            args.add(\"-cc\");\n            args.add(configClasses);\n            usingSpringJavaConfigureMain = true;\n        }        \n        if (basedPackages != null) {\n            args.add(\"-bp\");\n            args.add(basedPackages);\n            usingSpringJavaConfigureMain = true;\n        }\n \n        args.add(\"-d\");\n        args.add(duration);\n        if (arguments != null) {\n            args.addAll(Arrays.asList(arguments));\n        }\n        \n        if (usingSpringJavaConfigureMain) {\n            mainClass = \"org.apache.camel.spring.javaconfig.Main\";\n            getLog().info(\"Using org.apache.camel.spring.javaconfig.Main to initiate a CamelContext\");\n        } else if (useCdiMain) {\n            mainClass = \"org.apache.camel.cdi.Main\";\n            // must include plugin dependencies for cdi\n            extraPluginDependencyArtifactId = \"camel-cdi\";\n            getLog().info(\"Using \" + mainClass + \" to initiate a CamelContext\");\n        } else if (usingBlueprintMain) {\n            mainClass = \"org.apache.camel.test.blueprint.Main\";\n            // must include plugin dependencies for blueprint\n            extraPluginDependencyArtifactId = \"camel-test-blueprint\";\n            // set the configAdmin pid\n            if (configAdminPid != null) {\n                args.add(\"-pid\");\n                args.add(configAdminPid);\n            }\n            // set the configAdmin pFile\n            if (configAdminFileName != null) {\n                args.add(\"-pf\");\n                args.add(configAdminFileName);\n            }\n            getLog().info(\"Using org.apache.camel.test.blueprint.Main to initiate a CamelContext\");\n        } else if (mainClass != null) {\n            getLog().info(\"Using custom \" + mainClass + \" to initiate a CamelContext\");\n        } else {\n            // use spring by default\n            getLog().info(\"Using org.apache.camel.spring.Main to initiate a CamelContext\");\n            mainClass = \"org.apache.camel.spring.Main\";\n        }\n\n        arguments = new String[args.size()];\n        args.toArray(arguments);\n        \n        if (getLog().isDebugEnabled()) {\n            StringBuilder msg = new StringBuilder(\"Invoking: \");\n            msg.append(mainClass);\n            msg.append(\".main(\");\n            for (int i = 0; i < arguments.length; i++) {\n                if (i > 0) {\n                    msg.append(\", \");\n                }\n                msg.append(arguments[i]);\n            }\n            msg.append(\")\");\n            getLog().debug(msg);\n        }\n\n        IsolatedThreadGroup threadGroup = new IsolatedThreadGroup(mainClass /* name */);\n        final Thread bootstrapThread = new Thread(threadGroup, new Runnable() {\n            public void run() {\n                try {\n                    beforeBootstrapCamel();\n\n                    getLog().info(\"Starting Camel ...\");\n                    Method main = Thread.currentThread().getContextClassLoader()\n                            .loadClass(mainClass).getMethod(\"main\", String[].class);\n                    main.invoke(null, new Object[]{arguments});\n\n                    afterBootstrapCamel();\n                } catch (Exception e) { // just pass it on\n                    // let it be printed so end users can see the exception on the console\n                    getLog().error(\"*************************************\");\n                    getLog().error(\"Error occurred while running main from: \" + mainClass);\n                    getLog().error(e);\n                    getLog().error(\"*************************************\");\n                    Thread.currentThread().getThreadGroup().uncaughtException(Thread.currentThread(), e);\n                }\n            }\n        }, mainClass + \".main()\");\n\n        bootstrapThread.setContextClassLoader(getClassLoader());\n        setSystemProperties();\n\n        bootstrapThread.start();\n        joinNonDaemonThreads(threadGroup);\n        // It's plausible that spontaneously a non-daemon thread might be\n        // created as we try and shut down,\n        // but it's too late since the termination condition (only daemon\n        // threads) has been triggered.\n        if (keepAlive) {\n            getLog().warn(\"Warning: keepAlive is now deprecated and obsolete. Do you need it? Please comment on MEXEC-6.\");\n            waitFor(0);\n        }\n\n        if (cleanupDaemonThreads) {\n\n            terminateThreads(threadGroup);\n\n            try {\n                threadGroup.destroy();\n            } catch (IllegalThreadStateException e) {\n                getLog().warn(\"Couldn't destroy threadgroup \" + threadGroup, e);\n            }\n        }\n\n        if (originalSystemProperties != null) {\n            System.setProperties(originalSystemProperties);\n        }\n\n        synchronized (threadGroup) {\n            if (threadGroup.uncaughtException != null) {\n                throw new MojoExecutionException(null, threadGroup.uncaughtException);\n            }\n        }\n\n        registerSourceRoots();\n    }"
        ]
    ],
    "5737fe6086f60f9421c54e0096d5887f1449dc11": [
        [
            "IOConverterCharsetTest::testToInputStreamFileWithCharsetUTF8withOtherDefaultEncoding()",
            "  59  \n  60  \n  61  \n  62  \n  63  \n  64 -\n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  ",
            "    public void testToInputStreamFileWithCharsetUTF8withOtherDefaultEncoding() throws Exception {\n        switchToDefaultCharset(\"ISO-8859-1\");\n        File file = new File(\"src/test/resources/org/apache/camel/converter/german.utf-8.txt\");\n        InputStream in = IOConverter.toInputStream(file, \"UTF-8\");\n        // do read with default charset!\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n        BufferedReader naiveReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), \"UTF-8\"));\n        try {   \n            String line = reader.readLine();\n            String naiveLine = naiveReader.readLine();\n            assertEquals(naiveLine, line);\n            assertEquals(CONTENT, line);\n        } finally {\n            reader.close();\n            naiveReader.close();\n        }\n        \n    }",
            "  59  \n  60  \n  61  \n  62  \n  63  \n  64 +\n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  ",
            "    public void testToInputStreamFileWithCharsetUTF8withOtherDefaultEncoding() throws Exception {\n        switchToDefaultCharset(\"ISO-8859-1\");\n        File file = new File(\"src/test/resources/org/apache/camel/converter/german.utf-8.txt\");\n        InputStream in = IOConverter.toInputStream(file, \"UTF-8\");\n        // do read with default charset!\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in, StandardCharsets.ISO_8859_1));\n        BufferedReader naiveReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), \"UTF-8\"));\n        try {   \n            String line = reader.readLine();\n            String naiveLine = naiveReader.readLine();\n            assertEquals(naiveLine, line);\n            assertEquals(CONTENT, line);\n        } finally {\n            reader.close();\n            naiveReader.close();\n        }\n        \n    }"
        ],
        [
            "IOConverterCharsetTest::switchToDefaultCharset(String)",
            " 144 -\n 145 -\n 146 -\n 147 -\n 148 -\n 149 -\n 150 -\n 151 -\n 152  ",
            "    private void switchToDefaultCharset(String charset) {\n        try {\n            Field defaultCharset = Charset.class.getDeclaredField(\"defaultCharset\");\n            defaultCharset.setAccessible(true);\n            defaultCharset.set(null, Charset.forName(charset));\n        } catch (Exception e) {\n            // Do nothing here\n        }\n    }",
            " 144 +\n 145 +\n 146 +\n 147 +\n 148  ",
            "    private void switchToDefaultCharset(final String charset) {\n        final Charset newCharset = Charset.forName(charset);\n\n        IOConverter.defaultCharset = () -> newCharset;\n    }"
        ],
        [
            "IOConverter::toInputStream(File,String)",
            "  81  \n  82  \n  83  \n  84 -\n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  ",
            "    public static InputStream toInputStream(File file, String charset) throws IOException {\n        if (charset != null) {\n            final BufferedReader reader = toReader(file, charset);\n            final Charset defaultStreamCharset = Charset.defaultCharset();\n            return new InputStream() {\n                private ByteBuffer bufferBytes;\n                private CharBuffer bufferedChars = CharBuffer.allocate(4096);\n\n                @Override\n                public int read() throws IOException {\n                    if (bufferBytes == null || bufferBytes.remaining() <= 0) {\n                        bufferedChars.clear();\n                        int len = reader.read(bufferedChars);\n                        bufferedChars.flip();\n                        if (len == -1) {\n                            return -1;\n                        }\n                        bufferBytes = defaultStreamCharset.encode(bufferedChars);\n                    }\n                    return bufferBytes.get();\n                }\n\n                @Override\n                public void close() throws IOException {\n                    reader.close();\n                }\n\n                @Override\n                public void reset() throws IOException {\n                    reader.reset();\n                }\n            };\n        } else {\n            return IOHelper.buffered(new FileInputStream(file));\n        }\n    }",
            "  84  \n  85  \n  86  \n  87 +\n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  ",
            "    public static InputStream toInputStream(File file, String charset) throws IOException {\n        if (charset != null) {\n            final BufferedReader reader = toReader(file, charset);\n            final Charset defaultStreamCharset = defaultCharset.get();\n            return new InputStream() {\n                private ByteBuffer bufferBytes;\n                private CharBuffer bufferedChars = CharBuffer.allocate(4096);\n\n                @Override\n                public int read() throws IOException {\n                    if (bufferBytes == null || bufferBytes.remaining() <= 0) {\n                        bufferedChars.clear();\n                        int len = reader.read(bufferedChars);\n                        bufferedChars.flip();\n                        if (len == -1) {\n                            return -1;\n                        }\n                        bufferBytes = defaultStreamCharset.encode(bufferedChars);\n                    }\n                    return bufferBytes.get();\n                }\n\n                @Override\n                public void close() throws IOException {\n                    reader.close();\n                }\n\n                @Override\n                public void reset() throws IOException {\n                    reader.reset();\n                }\n            };\n        } else {\n            return IOHelper.buffered(new FileInputStream(file));\n        }\n    }"
        ]
    ],
    "e4ad40f2eebb68cfde175b171538e26b278f63f6": [
        [
            "DefaultCxfRsBinding::populateCxfRsResponseFromExchange(Exchange,org)",
            "  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85 -\n  86  ",
            "    public Object populateCxfRsResponseFromExchange(Exchange camelExchange,\n                                                    org.apache.cxf.message.Exchange cxfExchange) throws Exception {\n        // Need to check if the exchange has the exception\n        if (camelExchange.isFailed() && camelExchange.getException() != null) {\n            throw camelExchange.getException();\n        }\n\n        org.apache.camel.Message response;\n        if (camelExchange.getPattern().isOutCapable()) {\n            if (camelExchange.hasOut()) {\n                response = camelExchange.getOut();\n                LOG.trace(\"Get the response from the out message\");\n            } else {\n                response = camelExchange.getIn();\n                LOG.trace(\"Get the response from the in message as a fallback\");\n            }\n        } else {\n            response = camelExchange.getIn();\n            LOG.trace(\"Get the response from the in message\");\n        }\n\n        return response.getBody();\n    }",
            "  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88 +\n  89 +\n  90 +\n  91 +\n  92 +\n  93 +\n  94 +\n  95 +\n  96 +\n  97 +\n  98 +\n  99 +\n 100 +\n 101 +\n 102 +\n 103 +\n 104 +\n 105 +\n 106 +\n 107 +\n 108 +\n 109 +\n 110 +\n 111 +\n 112 +\n 113 +\n 114 +\n 115 +\n 116 +\n 117 +\n 118 +\n 119 +\n 120 +\n 121 +\n 122 +\n 123 +\n 124 +\n 125 +\n 126 +\n 127 +\n 128 +\n 129  ",
            "    public Object populateCxfRsResponseFromExchange(Exchange camelExchange,\n                                                    org.apache.cxf.message.Exchange cxfExchange) throws Exception {\n        // Need to check if the exchange has the exception\n        if (camelExchange.isFailed() && camelExchange.getException() != null) {\n            throw camelExchange.getException();\n        }\n\n        org.apache.camel.Message response;\n        if (camelExchange.getPattern().isOutCapable()) {\n            if (camelExchange.hasOut()) {\n                response = camelExchange.getOut();\n                LOG.trace(\"Get the response from the out message\");\n            } else {\n                response = camelExchange.getIn();\n                LOG.trace(\"Get the response from the in message as a fallback\");\n            }\n        } else {\n            response = camelExchange.getIn();\n            LOG.trace(\"Get the response from the in message\");\n        }\n\n        Object o = response.getBody();\n        if (!(o instanceof Response)) {\n            //not a JAX-RS Response object, we need to set the headers from the Camel values\n            \n            \n            if (response.getHeader(org.apache.cxf.message.Message.PROTOCOL_HEADERS) != null) {\n                Map<String, Object> headers = CastUtils.cast((Map<?, ?>)response.getHeader(org.apache.cxf.message.Message.PROTOCOL_HEADERS));\n                cxfExchange.getOutMessage().putIfAbsent(org.apache.cxf.message.Message.PROTOCOL_HEADERS, \n                                                        new TreeMap<>(String.CASE_INSENSITIVE_ORDER));\n                final Map<String, List<String>> cxfHeaders =\n                    CastUtils.cast((Map<?, ?>) cxfExchange.getOutMessage().get(org.apache.cxf.message.Message.PROTOCOL_HEADERS));\n                \n                for (Map.Entry<String, Object> ent : headers.entrySet()) {\n                    List<String> v;\n                    if (ent.getValue() instanceof List) {\n                        v = CastUtils.cast((List<?>)ent.getValue());\n                    } else {\n                        v = Arrays.asList(ent.getValue().toString());\n                    }\n                    cxfHeaders.put(ent.getKey(), v);\n                }\n            }\n            \n            \n            if (response.getHeader(Exchange.HTTP_RESPONSE_CODE) != null && !cxfExchange.containsKey(org.apache.cxf.message.Message.RESPONSE_CODE)) {\n                cxfExchange.put(org.apache.cxf.message.Message.RESPONSE_CODE, response.getHeader(Exchange.HTTP_RESPONSE_CODE, Integer.class));\n            }\n            if (response.getHeader(Exchange.CONTENT_TYPE) != null) {\n                cxfExchange.getOutMessage().putIfAbsent(org.apache.cxf.message.Message.PROTOCOL_HEADERS, \n                                                        new TreeMap<>(String.CASE_INSENSITIVE_ORDER));\n                final Map<String, List<String>> cxfHeaders =\n                    CastUtils.cast((Map<?, ?>) cxfExchange.getOutMessage().get(org.apache.cxf.message.Message.PROTOCOL_HEADERS));\n\n                if (!cxfHeaders.containsKey(Exchange.CONTENT_TYPE)) {\n                    List<String> a = Arrays.asList((String)response.getHeader(Exchange.CONTENT_TYPE));\n                    cxfHeaders.put(Exchange.CONTENT_TYPE, a);\n                    cxfExchange.getOutMessage().put(Exchange.CONTENT_TYPE, response.getHeader(Exchange.CONTENT_TYPE));\n                }\n            }\n        }\n        return o;\n    }"
        ],
        [
            "CxfRsConsumerTest::AbstractTestProcessor::processGetCustomer(Exchange)",
            " 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224 -\n 225  \n 226  \n 227 -\n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  ",
            "        public void processGetCustomer(Exchange exchange) throws Exception {\n            Message inMessage = exchange.getIn();                        \n            String httpMethod = inMessage.getHeader(Exchange.HTTP_METHOD, String.class);\n            assertEquals(\"Get a wrong http method\", \"GET\", httpMethod);\n            String path = inMessage.getHeader(Exchange.HTTP_PATH, String.class);\n            // The parameter of the invocation is stored in the body of in message\n            String id = inMessage.getBody(String.class);\n            if (\"/customerservice/customers/126\".equals(path)) {                            \n                Customer customer = new Customer();\n                customer.setId(Long.parseLong(id));\n                customer.setName(\"Willem\");\n                // We just put the response Object into the out message body\n                exchange.getOut().setBody(customer);\n            } else {\n                if (\"/customerservice/customers/400\".equals(path)) {\n                    // We return the remote client IP address this time\n                    org.apache.cxf.message.Message cxfMessage = inMessage.getHeader(CxfConstants.CAMEL_CXF_MESSAGE, org.apache.cxf.message.Message.class);\n                    ServletRequest request = (ServletRequest) cxfMessage.get(\"HTTP.REQUEST\");\n                    // Just make sure the request object is not null\n                    assertNotNull(\"The request object should not be null\", request);\n                    Response r = Response.status(200).entity(\"The remoteAddress is 127.0.0.1\").build();\n                    exchange.getOut().setBody(r);\n                    return;\n                }\n                if (\"/customerservice/customers/123\".equals(path)) {\n                    // send a customer response back\n                    Response r = Response.status(200).entity(\"customer response back!\").build();\n                    exchange.getOut().setBody(r);\n                    return;\n                }\n                if (\"/customerservice/customers/456\".equals(path)) {\n                    Response r = Response.status(404).entity(\"Can't found the customer with uri \" + path).build();\n                    throw new WebApplicationException(r);\n                } else if (\"/customerservice/customers/234\".equals(path)) {\n                    Response r = Response.status(404).entity(\"Can't found the customer with uri \" + path).build();\n                    exchange.getOut().setBody(r);\n                    exchange.getOut().setFault(true);\n                } else {\n                    throw new RuntimeCamelException(\"Can't found the customer with uri \" + path);\n                }\n            }\n        }",
            " 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234 +\n 235 +\n 236  \n 237  \n 238 +\n 239 +\n 240  \n 241  \n 242 +\n 243 +\n 244 +\n 245 +\n 246 +\n 247  \n 248  \n 249  \n 250  \n 251  ",
            "        public void processGetCustomer(Exchange exchange) throws Exception {\n            Message inMessage = exchange.getIn();                        \n            String httpMethod = inMessage.getHeader(Exchange.HTTP_METHOD, String.class);\n            assertEquals(\"Get a wrong http method\", \"GET\", httpMethod);\n            String path = inMessage.getHeader(Exchange.HTTP_PATH, String.class);\n            // The parameter of the invocation is stored in the body of in message\n            String id = inMessage.getBody(String.class);\n            if (\"/customerservice/customers/126\".equals(path)) {                            \n                Customer customer = new Customer();\n                customer.setId(Long.parseLong(id));\n                customer.setName(\"Willem\");\n                // We just put the response Object into the out message body\n                exchange.getOut().setBody(customer);\n            } else {\n                if (\"/customerservice/customers/400\".equals(path)) {\n                    // We return the remote client IP address this time\n                    org.apache.cxf.message.Message cxfMessage = inMessage.getHeader(CxfConstants.CAMEL_CXF_MESSAGE, org.apache.cxf.message.Message.class);\n                    ServletRequest request = (ServletRequest) cxfMessage.get(\"HTTP.REQUEST\");\n                    // Just make sure the request object is not null\n                    assertNotNull(\"The request object should not be null\", request);\n                    Response r = Response.status(200).entity(\"The remoteAddress is 127.0.0.1\").build();\n                    exchange.getOut().setBody(r);\n                    return;\n                }\n                if (\"/customerservice/customers/123\".equals(path)) {\n                    // send a customer response back\n                    Response r = Response.status(200).entity(\"customer response back!\").build();\n                    exchange.getOut().setBody(r);\n                    return;\n                }\n                if (\"/customerservice/customers/456\".equals(path)) {\n                    Response r = Response.status(404).entity(\"Can't found the customer with uri \" + path)\n                        .header(\"Content-Type\", \"text/plain\").build();\n                    throw new WebApplicationException(r);\n                } else if (\"/customerservice/customers/234\".equals(path)) {\n                    Response r = Response.status(404).entity(\"Can't found the customer with uri \" + path)\n                        .header(\"Content-Type\", \"text/plain\").build();\n                    exchange.getOut().setBody(r);\n                    exchange.getOut().setFault(true);\n                } else if (\"/customerservice/customers/789\".equals(path)) {\n                    exchange.getOut().setBody(\"Can't found the customer with uri \" + path);\n                    exchange.getOut().setHeader(Exchange.CONTENT_TYPE, \"text/plain\");\n                    exchange.getOut().setHeader(Exchange.HTTP_RESPONSE_CODE, \"404\");                    \n                    exchange.getOut().setFault(true);\n                } else {\n                    throw new RuntimeCamelException(\"Can't found the customer with uri \" + path);\n                }\n            }\n        }"
        ],
        [
            "CxfRsConsumerTest::testGetWrongCustomer()",
            " 146  \n 147  \n 148 -\n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  ",
            "    @Test\n    public void testGetWrongCustomer() throws Exception {\n        URL url = new URL(\"http://localhost:\" + CXT + \"/rest/customerservice/customers/456\");\n        try {\n            url.openStream();\n            fail(\"Expect to get exception here\");\n        } catch (FileNotFoundException exception) {\n            // do nothing here\n        }\n        \n        url = new URL(\"http://localhost:\" + CXT + \"/rest/customerservice/customers/234\");\n        try {\n            url.openStream();\n            fail(\"Expect to get exception here\");\n        } catch (FileNotFoundException exception) {\n            // do nothing here\n        }\n        \n        url = new URL(\"http://localhost:\" + CXT + \"/rest/customerservice/customers/256\");\n        try {\n            url.openStream();\n            fail(\"Expect to get exception here\");\n        } catch (IOException exception) {\n            // expect the Internal error exception\n        }\n        \n    }",
            " 146  \n 147  \n 148 +\n 149 +\n 150 +\n 151 +\n 152 +\n 153 +\n 154 +\n 155 +\n 156 +\n 157 +\n 158 +\n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  ",
            "    @Test\n    public void testGetWrongCustomer() throws Exception {\n        URL url;\n        \n        url = new URL(\"http://localhost:\" + CXT + \"/rest/customerservice/customers/789\");\n        try {\n            url.openStream();\n            fail(\"Expect to get exception here\");\n        } catch (IOException exception) {\n            // expect the Internal error exception\n        }\n        \n        url = new URL(\"http://localhost:\" + CXT + \"/rest/customerservice/customers/456\");\n        try {\n            url.openStream();\n            fail(\"Expect to get exception here\");\n        } catch (FileNotFoundException exception) {\n            // do nothing here\n        }\n        \n        url = new URL(\"http://localhost:\" + CXT + \"/rest/customerservice/customers/234\");\n        try {\n            url.openStream();\n            fail(\"Expect to get exception here\");\n        } catch (FileNotFoundException exception) {\n            // do nothing here\n        }\n        \n        url = new URL(\"http://localhost:\" + CXT + \"/rest/customerservice/customers/256\");\n        try {\n            url.openStream();\n            fail(\"Expect to get exception here\");\n        } catch (IOException exception) {\n            // expect the Internal error exception\n        }\n        \n    }"
        ]
    ],
    "7c3ab11142c23f2b2f3e753336b67c2b2eded7f5": [
        [
            "GoogleMailStreamConfiguration::getQuery()",
            " 147 -\n 148 -\n 149 -",
            "\tpublic String getQuery() {\n\t\treturn query;\n\t}",
            " 151 +\n 152 +\n 153 +",
            "    public String getQuery() {\n        return query;\n    }"
        ],
        [
            "GoogleMailStreamConfiguration::setMarkAsRead(boolean)",
            " 184  \n 185  \n 186  \n 187 -\n 188 -\n 189 -",
            "    /**\n     * Mark the message as read once it has been consumed\n     */\n\tpublic void setMarkAsRead(boolean markAsRead) {\n\t\tthis.markAsRead = markAsRead;\n\t}",
            " 188  \n 189  \n 190  \n 191 +\n 192 +\n 193 +",
            "    /**\n     * Mark the message as read once it has been consumed\n     */\n    public void setMarkAsRead(boolean markAsRead) {\n        this.markAsRead = markAsRead;\n    }"
        ],
        [
            "GoogleMailStreamEndpoint::GoogleMailStreamEndpoint(String,GoogleMailStreamComponent,GoogleMailStreamConfiguration)",
            "  48 -\n  49 -\n  50 -\n  51 -\n  52 -",
            "\tpublic GoogleMailStreamEndpoint(String uri, GoogleMailStreamComponent component,\n\t\t\tGoogleMailStreamConfiguration endpointConfiguration) {\n\t\tsuper(uri, component);\n\t\tthis.configuration = endpointConfiguration;\n\t}",
            "  54 +\n  55 +\n  56 +\n  57 +",
            "    public GoogleMailStreamEndpoint(String uri, GoogleMailStreamComponent component, GoogleMailStreamConfiguration endpointConfiguration) {\n        super(uri, component);\n        this.configuration = endpointConfiguration;\n    }"
        ],
        [
            "GoogleMailStreamConfiguration::setLabels(String)",
            " 173  \n 174  \n 175  \n 176 -\n 177 -\n 178 -",
            "    /**\n     * Comma separated list of labels to take into account\n     */\n\tpublic void setLabels(String labels) {\n\t\tthis.labels = labels;\n\t}",
            " 177  \n 178  \n 179  \n 180 +\n 181 +\n 182 +",
            "    /**\n     * Comma separated list of labels to take into account\n     */\n    public void setLabels(String labels) {\n        this.labels = labels;\n    }"
        ],
        [
            "GoogleMailStreamConsumer::GoogleMailStreamConsumer(Endpoint,Processor,String)",
            "  52 -\n  53 -\n  54 -\n  55 -",
            "\tpublic GoogleMailStreamConsumer(Endpoint endpoint, Processor processor, String unreadLabelId) {\n\t\tsuper(endpoint, processor);\n\t\tthis.unreadLabelId = unreadLabelId;\n\t}",
            "  53 +\n  54 +\n  55 +\n  56 +",
            "    public GoogleMailStreamConsumer(Endpoint endpoint, Processor processor, String unreadLabelId) {\n        super(endpoint, processor);\n        this.unreadLabelId = unreadLabelId;\n    }"
        ],
        [
            "GoogleMailStreamConsumerIntegrationTest::testConsumePrefixedMessages()",
            "  25  \n  26 -\n  27 -\n  28 -\n  29 -\n  30 -",
            "\t@Test\n\tpublic void testConsumePrefixedMessages() throws Exception {\n\t\tMockEndpoint mock = getMockEndpoint(\"mock:result\");\n\t\tmock.expectedMinimumMessageCount(1);\n\t\tassertMockEndpointsSatisfied();\n\t}",
            "  25  \n  26 +\n  27 +\n  28 +\n  29 +\n  30 +",
            "    @Test\n    public void testConsumePrefixedMessages() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedMinimumMessageCount(1);\n        assertMockEndpointsSatisfied();\n    }"
        ],
        [
            "GoogleMailStreamEndpoint::createExchange(ExchangePattern,com)",
            "  96 -\n  97 -\n  98 -\n  99 -\n 100 -\n 101 -\n 102 -\n 103 -\n 104 -\n 105 -\n 106 -\n 107 -\n 108 -\n 109 -\n 110 -\n 111 -\n 112 -\n 113 -",
            "\tpublic Exchange createExchange(ExchangePattern pattern, com.google.api.services.gmail.model.Message mail)\n\t\t\tthrows UnsupportedEncodingException {\n\n\t\tExchange exchange = super.createExchange();\n\t\tMessage message = exchange.getIn();\n\t\texchange.getIn().setHeader(GoogleMailStreamConstants.MAIL_ID, mail.getId());\n\t\tif (mail.getPayload().getParts() != null) {\n\t\t\t\tif (mail.getPayload().getParts().get(0).getBody().getData() != null) {\n\t\t\tbyte[] bodyBytes = Base64\n\t\t\t\t\t.decodeBase64(mail.getPayload().getParts().get(0).getBody().getData().trim().toString()); // get\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// body\n\t\t\tString body = new String(bodyBytes, \"UTF-8\");\n\t\t\tmessage.setBody(body);\n\t\t\t}\n\t\t}\n\t\tsetHeaders(message, mail.getPayload().getHeaders());\n\t\treturn exchange;\n\t}",
            " 101 +\n 102 +\n 103 +\n 104 +\n 105 +\n 106 +\n 107 +\n 108 +\n 109 +\n 110 +\n 111 +\n 112 +\n 113 +\n 114 +\n 115 +\n 116 +",
            "    public Exchange createExchange(ExchangePattern pattern, com.google.api.services.gmail.model.Message mail) throws UnsupportedEncodingException {\n\n        Exchange exchange = super.createExchange();\n        Message message = exchange.getIn();\n        exchange.getIn().setHeader(GoogleMailStreamConstants.MAIL_ID, mail.getId());\n        if (mail.getPayload().getParts() != null) {\n            if (mail.getPayload().getParts().get(0).getBody().getData() != null) {\n                byte[] bodyBytes = Base64.decodeBase64(mail.getPayload().getParts().get(0).getBody().getData().trim().toString()); // get\n                                                                                                                                   // body\n                String body = new String(bodyBytes, \"UTF-8\");\n                message.setBody(body);\n            }\n        }\n        setHeaders(message, mail.getPayload().getHeaders());\n        return exchange;\n    }"
        ],
        [
            "GoogleMailStreamComponent::createEndpoint(String,String,Map)",
            "  87  \n  88 -\n  89 -\n  90 -\n  91 -\n  92 -\n  93 -\n  94 -",
            "\t@Override\n\tprotected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n\t\tfinal GoogleMailStreamConfiguration configuration = this.configuration.copy();\n\t\tsetProperties(configuration, parameters);\n\t\tGoogleMailStreamEndpoint endpoint = new GoogleMailStreamEndpoint(uri, this, configuration);\n\t\tsetProperties(endpoint, parameters);\n\t\treturn endpoint;\n\t}",
            "  86  \n  87 +\n  88 +\n  89 +\n  90 +\n  91 +\n  92 +\n  93 +",
            "    @Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        final GoogleMailStreamConfiguration configuration = this.configuration.copy();\n        setProperties(configuration, parameters);\n        GoogleMailStreamEndpoint endpoint = new GoogleMailStreamEndpoint(uri, this, configuration);\n        setProperties(endpoint, parameters);\n        return endpoint;\n    }"
        ],
        [
            "GoogleMailStreamEndpoint::getConfiguration()",
            "  87 -\n  88 -\n  89 -",
            "\tpublic GoogleMailStreamConfiguration getConfiguration() {\n\t\treturn configuration;\n\t}",
            "  92 +\n  93 +\n  94 +",
            "    public GoogleMailStreamConfiguration getConfiguration() {\n        return configuration;\n    }"
        ],
        [
            "GoogleMailStreamEndpoint::getClientFactory()",
            "  79 -\n  80 -\n  81 -",
            "\tpublic GoogleMailClientFactory getClientFactory() {\n\t\treturn ((GoogleMailStreamComponent) getComponent()).getClientFactory();\n\t}",
            "  84 +\n  85 +\n  86 +",
            "    public GoogleMailClientFactory getClientFactory() {\n        return ((GoogleMailStreamComponent)getComponent()).getClientFactory();\n    }"
        ],
        [
            "GoogleMailStreamConsumer::processRollback(Exchange,String)",
            " 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181 -\n 182 -\n 183 -\n 184 -\n 185 -\n 186 -\n 187 -\n 188 -\n 189 -\n 190 -\n 191 -\n 192 -\n 193  \n 194 -",
            "\t/**\n\t * Strategy when processing the exchange failed.\n\t *\n\t * @param exchange\n\t *            the exchange\n\t * @throws IOException\n\t */\n\tprotected void processRollback(Exchange exchange, String unreadLabelId) {\n\t\ttry {\n\t\t\tLOG.warn(\"Exchange failed, so rolling back mail {} to un \" + exchange);\n\n\t\t\tList<String> add = new ArrayList<String>();\n\t\t\tadd.add(unreadLabelId);\n\t\t\tModifyMessageRequest mods = new ModifyMessageRequest().setAddLabelIds(add);\n\t\t\tgetClient().users().messages()\n\t\t\t\t\t.modify(\"me\", exchange.getIn().getHeader(GoogleMailStreamConstants.MAIL_ID, String.class), mods)\n\t\t\t\t\t.execute();\n\t} catch (Exception e) {\n        getExceptionHandler().handleException(\"Error occurred mark as read mail. This exception is ignored.\", exchange, e);\n    }\n\t}",
            " 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178 +\n 179 +\n 180 +\n 181 +\n 182 +\n 183 +\n 184 +\n 185 +\n 186 +\n 187 +\n 188 +\n 189 +",
            "    /**\n     * Strategy when processing the exchange failed.\n     *\n     * @param exchange the exchange\n     * @throws IOException\n     */\n    protected void processRollback(Exchange exchange, String unreadLabelId) {\n        try {\n            LOG.warn(\"Exchange failed, so rolling back mail {} to un \" + exchange);\n\n            List<String> add = new ArrayList<String>();\n            add.add(unreadLabelId);\n            ModifyMessageRequest mods = new ModifyMessageRequest().setAddLabelIds(add);\n            getClient().users().messages().modify(\"me\", exchange.getIn().getHeader(GoogleMailStreamConstants.MAIL_ID, String.class), mods).execute();\n        } catch (Exception e) {\n            getExceptionHandler().handleException(\"Error occurred mark as read mail. This exception is ignored.\", exchange, e);\n        }\n    }"
        ],
        [
            "GoogleMailStreamEndpoint::createConsumer(Processor)",
            "  59  \n  60 -\n  61 -\n  62 -\n  63 -\n  64 -\n  65 -\n  66 -\n  67 -\n  68 -\n  69 -\n  70 -\n  71 -\n  72 -\n  73 -",
            "\t@Override\n\tpublic Consumer createConsumer(Processor processor) throws Exception {\n\t\tString unreadLabelId = null;\n\t\tString readLabelId = null;\n\t\tListLabelsResponse listResponse = getClient().users().labels().list(\"me\").execute();\n\t\tfor (Label label : listResponse.getLabels()) {\n\t\t\tLabel countLabel = getClient().users().labels().get(\"me\", label.getId()).execute();\n\t\t\tif (countLabel.getName().equalsIgnoreCase(\"UNREAD\")) {\n\t\t\t\tunreadLabelId = countLabel.getId();\n\t\t\t}\n\t\t}\n\t\tfinal GoogleMailStreamConsumer consumer = new GoogleMailStreamConsumer(this, processor, unreadLabelId);\n\t\tconfigureConsumer(consumer);\n\t\treturn consumer;\n\t}",
            "  64  \n  65 +\n  66 +\n  67 +\n  68 +\n  69 +\n  70 +\n  71 +\n  72 +\n  73 +\n  74 +\n  75 +\n  76 +\n  77 +\n  78 +",
            "    @Override\n    public Consumer createConsumer(Processor processor) throws Exception {\n        String unreadLabelId = null;\n        String readLabelId = null;\n        ListLabelsResponse listResponse = getClient().users().labels().list(\"me\").execute();\n        for (Label label : listResponse.getLabels()) {\n            Label countLabel = getClient().users().labels().get(\"me\", label.getId()).execute();\n            if (countLabel.getName().equalsIgnoreCase(\"UNREAD\")) {\n                unreadLabelId = countLabel.getId();\n            }\n        }\n        final GoogleMailStreamConsumer consumer = new GoogleMailStreamConsumer(this, processor, unreadLabelId);\n        configureConsumer(consumer);\n        return consumer;\n    }"
        ],
        [
            "GoogleMailStreamEndpoint::isSingleton()",
            "  91  \n  92 -\n  93 -\n  94 -",
            "\t@Override\n\tpublic boolean isSingleton() {\n\t\treturn true;\n\t}",
            "  96  \n  97 +\n  98 +\n  99 +",
            "    @Override\n    public boolean isSingleton() {\n        return true;\n    }"
        ],
        [
            "GoogleMailStreamConfiguration::getMaxResults()",
            " 158 -\n 159 -\n 160 -",
            "\tpublic long getMaxResults() {\n\t\treturn maxResults;\n\t}",
            " 162 +\n 163 +\n 164 +",
            "    public long getMaxResults() {\n        return maxResults;\n    }"
        ],
        [
            "GoogleMailStreamConsumer::processCommit(Exchange,String)",
            " 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152 -\n 153 -\n 154 -\n 155 -\n 156 -\n 157 -\n 158 -\n 159 -\n 160 -\n 161 -\n 162 -\n 163 -\n 164 -\n 165 -\n 166 -\n 167 -\n 168 -\n 169  \n 170  \n 171  \n 172 -",
            "\t/**\n\t * Strategy to delete the message after being processed.\n\t *\n\t * @param exchange\n\t *            the exchange\n\t * @throws IOException\n\t */\n\tprotected void processCommit(Exchange exchange, String unreadLabelId) {\n\t\ttry {\n\t\tif (getConfiguration().isMarkAsRead()) {\n\t\t\tString id = exchange.getIn().getHeader(GoogleMailStreamConstants.MAIL_ID, String.class);\n\n\t\t\tLOG.trace(\"Marking email {} as read\",id);\n\n\t\t\tList<String> remove = new ArrayList<String>();\n\t\t\tremove.add(unreadLabelId);\n\t\t\tModifyMessageRequest mods = new ModifyMessageRequest().setRemoveLabelIds(remove);\n\t\t\tgetClient().users().messages()\n\t\t\t\t\t.modify(\"me\", exchange.getIn().getHeader(GoogleMailStreamConstants.MAIL_ID, String.class), mods)\n\t\t\t\t\t.execute();\n\n\t\t\tLOG.trace(\"Marked email {} as read\",id);\n\t\t}\n\t\t} catch (Exception e) {\n            getExceptionHandler().handleException(\"Error occurred mark as read mail. This exception is ignored.\", exchange, e);\n        }\n\n\t}",
            " 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152 +\n 153 +\n 154 +\n 155 +\n 156 +\n 157 +\n 158 +\n 159 +\n 160 +\n 161 +\n 162 +\n 163 +\n 164 +\n 165 +\n 166 +\n 167  \n 168  \n 169  \n 170  ",
            "    /**\n     * Strategy to delete the message after being processed.\n     *\n     * @param exchange the exchange\n     * @throws IOException\n     */\n    protected void processCommit(Exchange exchange, String unreadLabelId) {\n        try {\n            if (getConfiguration().isMarkAsRead()) {\n                String id = exchange.getIn().getHeader(GoogleMailStreamConstants.MAIL_ID, String.class);\n\n                LOG.trace(\"Marking email {} as read\", id);\n\n                List<String> remove = new ArrayList<String>();\n                remove.add(unreadLabelId);\n                ModifyMessageRequest mods = new ModifyMessageRequest().setRemoveLabelIds(remove);\n                getClient().users().messages().modify(\"me\", exchange.getIn().getHeader(GoogleMailStreamConstants.MAIL_ID, String.class), mods).execute();\n\n                LOG.trace(\"Marked email {} as read\", id);\n            }\n        } catch (Exception e) {\n            getExceptionHandler().handleException(\"Error occurred mark as read mail. This exception is ignored.\", exchange, e);\n        }\n\n    }"
        ],
        [
            "GoogleMailStreamEndpoint::createProducer()",
            "  54  \n  55 -\n  56 -\n  57 -",
            "\t@Override\n\tpublic Producer createProducer() throws Exception {\n\t\tthrow new IllegalArgumentException(\"The camel google mail stream component doesn't support producer\");\n\t}",
            "  59  \n  60 +\n  61 +\n  62 +",
            "    @Override\n    public Producer createProducer() throws Exception {\n        throw new IllegalArgumentException(\"The camel google mail stream component doesn't support producer\");\n    }"
        ],
        [
            "GoogleMailStreamComponent::getClientFactory()",
            "  62  \n  63  \n  64  \n  65 -\n  66 -\n  67 -\n  68 -\n  69 -\n  70 -",
            "\t/**\n\t * The client Factory\n\t */\n\tpublic GoogleMailClientFactory getClientFactory() {\n\t\tif (clientFactory == null) {\n\t\t\tclientFactory = new BatchGoogleMailClientFactory();\n\t\t}\n\t\treturn clientFactory;\n\t}",
            "  61  \n  62  \n  63  \n  64 +\n  65 +\n  66 +\n  67 +\n  68 +\n  69 +",
            "    /**\n     * The client Factory\n     */\n    public GoogleMailClientFactory getClientFactory() {\n        if (clientFactory == null) {\n            clientFactory = new BatchGoogleMailClientFactory();\n        }\n        return clientFactory;\n    }"
        ],
        [
            "GoogleMailStreamConsumerIntegrationTest::createRouteBuilder()",
            "  32  \n  33 -\n  34 -\n  35 -\n  36 -\n  37  \n  38 -\n  39 -\n  40  \n  41 -\n  42 -\n  43 -",
            "\t@Override\n\tprotected RouteBuilder createRouteBuilder() throws Exception {\n\t\treturn new RouteBuilder() {\n\t\t\t@Override\n\t\t\tpublic void configure() {\n\n\t\t\t\tfrom(\"google-mail-stream://test?markAsRead=true&delay=5000&maxResults=10\")\n\t\t\t\t\t\t\t\t.to(\"mock:result\");\n\n\t\t\t}\n\t\t};\n\t}",
            "  32  \n  33 +\n  34 +\n  35 +\n  36 +\n  37  \n  38 +\n  39  \n  40 +\n  41 +\n  42 +",
            "    @Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            @Override\n            public void configure() {\n\n                from(\"google-mail-stream://test?markAsRead=true&delay=5000&maxResults=10\").to(\"mock:result\");\n\n            }\n        };\n    }"
        ],
        [
            "GoogleMailStreamConfiguration::isMarkAsRead()",
            " 180 -\n 181 -\n 182 -",
            "\tpublic boolean isMarkAsRead() {\n\t\treturn markAsRead;\n\t}",
            " 184 +\n 185 +\n 186 +",
            "    public boolean isMarkAsRead() {\n        return markAsRead;\n    }"
        ],
        [
            "GoogleMailStreamComponent::setClientFactory(GoogleMailClientFactory)",
            "  83 -\n  84 -\n  85 -",
            "\tpublic void setClientFactory(GoogleMailClientFactory clientFactory) {\n\t\tthis.clientFactory = clientFactory;\n\t}",
            "  82 +\n  83 +\n  84 +",
            "    public void setClientFactory(GoogleMailClientFactory clientFactory) {\n        this.clientFactory = clientFactory;\n    }"
        ],
        [
            "GoogleMailStreamConfiguration::setMaxResults(long)",
            " 162  \n 163  \n 164  \n 165 -\n 166 -\n 167 -",
            "    /**\n     * Max results to be returned\n     */\n\tpublic void setMaxResults(long maxResults) {\n\t\tthis.maxResults = maxResults;\n\t}",
            " 166  \n 167  \n 168  \n 169 +\n 170 +\n 171 +",
            "    /**\n     * Max results to be returned\n     */\n    public void setMaxResults(long maxResults) {\n        this.maxResults = maxResults;\n    }"
        ],
        [
            "GoogleMailStreamConsumer::getConfiguration()",
            "  57 -\n  58 -\n  59 -",
            "\tprotected GoogleMailStreamConfiguration getConfiguration() {\n\t\treturn getEndpoint().getConfiguration();\n\t}",
            "  58 +\n  59 +\n  60 +",
            "    protected GoogleMailStreamConfiguration getConfiguration() {\n        return getEndpoint().getConfiguration();\n    }"
        ],
        [
            "GoogleMailStreamConfiguration::copy()",
            " 195 -\n 196  \n 197  \n 198  \n 199  \n 200  \n 201  ",
            "\tpublic GoogleMailStreamConfiguration copy() {\n        try {\n            return (GoogleMailStreamConfiguration)super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeCamelException(e);\n        }\n    }",
            " 199 +\n 200  \n 201  \n 202  \n 203  \n 204  \n 205  ",
            "    public GoogleMailStreamConfiguration copy() {\n        try {\n            return (GoogleMailStreamConfiguration)super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeCamelException(e);\n        }\n    }"
        ],
        [
            "GoogleMailStreamConsumer::poll()",
            "  70  \n  71 -\n  72 -\n  73 -\n  74 -\n  75 -\n  76 -\n  77 -\n  78 -\n  79 -\n  80 -\n  81 -\n  82 -\n  83 -\n  84 -\n  85 -\n  86 -\n  87 -\n  88 -\n  89 -\n  90 -\n  91 -\n  92 -\n  93 -\n  94 -\n  95 -\n  96 -",
            "\t@Override\n\tprotected int poll() throws Exception {\n\t\tcom.google.api.services.gmail.Gmail.Users.Messages.List request = getClient().users().messages().list(\"me\");\n\t\tif (ObjectHelper.isNotEmpty(getConfiguration().getQuery())) {\n\t\t\trequest.setQ(getConfiguration().getQuery());\n\t\t}\n\t\tif (ObjectHelper.isNotEmpty(getConfiguration().getMaxResults())) {\n\t\t\trequest.setMaxResults(getConfiguration().getMaxResults());\n\t\t}\n\t\tif (ObjectHelper.isNotEmpty(getConfiguration().getLabels())) {\n\t\t\trequest.setLabelIds(splitLabels(getConfiguration().getLabels()));\n\t\t}\n\n\t\tQueue<Exchange> answer = new LinkedList<>();\n\n\t\tListMessagesResponse c = request.execute();\n\t\tif (c.getMessages() != null) {\n\t\tfor (Iterator iterator = c.getMessages().iterator(); iterator.hasNext();) {\n\t\t\tMessage message = (Message) iterator.next();\n\t\t\tMessage mess = getClient().users().messages().get(\"me\", message.getId()).setFormat(\"FULL\").execute();\n\t\t\tExchange exchange = ((GoogleMailStreamEndpoint) getEndpoint())\n\t\t\t\t\t.createExchange(getEndpoint().getExchangePattern(), mess);\n\t\t\tanswer.add(exchange);\n\t\t}}\n\n\t\treturn processBatch(CastUtils.cast(answer));\n\t}",
            "  71  \n  72 +\n  73 +\n  74 +\n  75 +\n  76 +\n  77 +\n  78 +\n  79 +\n  80 +\n  81 +\n  82 +\n  83 +\n  84 +\n  85 +\n  86 +\n  87 +\n  88 +\n  89 +\n  90 +\n  91 +\n  92 +\n  93 +\n  94 +\n  95 +\n  96 +\n  97 +",
            "    @Override\n    protected int poll() throws Exception {\n        com.google.api.services.gmail.Gmail.Users.Messages.List request = getClient().users().messages().list(\"me\");\n        if (ObjectHelper.isNotEmpty(getConfiguration().getQuery())) {\n            request.setQ(getConfiguration().getQuery());\n        }\n        if (ObjectHelper.isNotEmpty(getConfiguration().getMaxResults())) {\n            request.setMaxResults(getConfiguration().getMaxResults());\n        }\n        if (ObjectHelper.isNotEmpty(getConfiguration().getLabels())) {\n            request.setLabelIds(splitLabels(getConfiguration().getLabels()));\n        }\n\n        Queue<Exchange> answer = new LinkedList<>();\n\n        ListMessagesResponse c = request.execute();\n        if (c.getMessages() != null) {\n            for (Iterator iterator = c.getMessages().iterator(); iterator.hasNext();) {\n                Message message = (Message)iterator.next();\n                Message mess = getClient().users().messages().get(\"me\", message.getId()).setFormat(\"FULL\").execute();\n                Exchange exchange = ((GoogleMailStreamEndpoint)getEndpoint()).createExchange(getEndpoint().getExchangePattern(), mess);\n                answer.add(exchange);\n            }\n        }\n\n        return processBatch(CastUtils.cast(answer));\n    }"
        ],
        [
            "GoogleMailStreamComponent::getConfiguration()",
            "  72 -\n  73 -\n  74 -",
            "\tpublic GoogleMailStreamConfiguration getConfiguration() {\n\t\treturn configuration;\n\t}",
            "  71 +\n  72 +\n  73 +",
            "    public GoogleMailStreamConfiguration getConfiguration() {\n        return configuration;\n    }"
        ],
        [
            "GoogleMailStreamEndpoint::getClient()",
            "  75 -\n  76 -\n  77 -",
            "\tpublic Gmail getClient() {\n\t\treturn ((GoogleMailStreamComponent) getComponent()).getClient(configuration);\n\t}",
            "  80 +\n  81 +\n  82 +",
            "    public Gmail getClient() {\n        return ((GoogleMailStreamComponent)getComponent()).getClient(configuration);\n    }"
        ],
        [
            "GoogleMailStreamConfiguration::getIndex()",
            " 136  \n 137 -",
            "    public String getIndex() {\n\t\treturn index;",
            " 140  \n 141 +\n 142 +",
            "    public String getIndex() {\n        return index;\n    }"
        ],
        [
            "GoogleMailStreamComponent::getClient(GoogleMailStreamConfiguration)",
            "  52 -\n  53 -\n  54 -\n  55 -\n  56 -\n  57 -\n  58 -\n  59 -\n  60 -",
            "\tpublic Gmail getClient(GoogleMailStreamConfiguration googleMailConfiguration) {\n\t\tif (client == null) {\n\t\t\tclient = getClientFactory().makeClient(googleMailConfiguration.getClientId(),\n\t\t\t\t\tgoogleMailConfiguration.getClientSecret(), googleMailConfiguration.getScopes(),\n\t\t\t\t\tgoogleMailConfiguration.getApplicationName(), googleMailConfiguration.getRefreshToken(),\n\t\t\t\t\tgoogleMailConfiguration.getAccessToken());\n\t\t}\n\t\treturn client;\n\t}",
            "  52 +\n  53 +\n  54 +\n  55 +\n  56 +\n  57 +\n  58 +\n  59 +",
            "    public Gmail getClient(GoogleMailStreamConfiguration googleMailConfiguration) {\n        if (client == null) {\n            client = getClientFactory().makeClient(googleMailConfiguration.getClientId(), googleMailConfiguration.getClientSecret(), googleMailConfiguration.getScopes(),\n                                                   googleMailConfiguration.getApplicationName(), googleMailConfiguration.getRefreshToken(),\n                                                   googleMailConfiguration.getAccessToken());\n        }\n        return client;\n    }"
        ],
        [
            "GoogleMailStreamConsumer::splitLabels(String)",
            " 140 -\n 141 -\n 142 -\n 143 -",
            "\tprivate List<String> splitLabels(String labels) throws AddressException {\n\t\tList<String> labelsList = Splitter.on(',').splitToList(getConfiguration().getLabels());\n\t\treturn labelsList;\n\t}",
            " 141 +\n 142 +\n 143 +\n 144 +",
            "    private List<String> splitLabels(String labels) throws AddressException {\n        List<String> labelsList = Splitter.on(',').splitToList(getConfiguration().getLabels());\n        return labelsList;\n    }"
        ],
        [
            "GoogleMailStreamConfiguration::setIndex(String)",
            " 140  \n 141  \n 142  \n 143 -\n 144 -\n 145 -",
            "    /**\n     * Specifies an index for the endpoint\n     */\n\tpublic void setIndex(String index) {\n\t\tthis.index = index;\n\t}   ",
            " 144  \n 145  \n 146  \n 147 +\n 148 +\n 149 +",
            "    /**\n     * Specifies an index for the endpoint\n     */\n    public void setIndex(String index) {\n        this.index = index;\n    }"
        ],
        [
            "GoogleMailStreamConsumer::processBatch(Queue)",
            "  98  \n  99 -\n 100 -\n 101 -\n 102 -\n 103 -\n 104 -\n 105 -\n 106 -\n 107 -\n 108 -\n 109 -\n 110 -\n 111 -\n 112 -\n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129 -\n 130 -\n 131 -\n 132 -\n 133 -\n 134 -\n 135 -\n 136 -\n 137 -\n 138 -",
            "\t@Override\n\tpublic int processBatch(Queue<Object> exchanges) throws Exception {\n\t\tint total = exchanges.size();\n\n\t\tfor (int index = 0; index < total && isBatchAllowed(); index++) {\n\t\t\t// only loop if we are started (allowed to run)\n\t\t\tfinal Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n\t\t\t// add current index and total as properties\n\t\t\texchange.setProperty(Exchange.BATCH_INDEX, index);\n\t\t\texchange.setProperty(Exchange.BATCH_SIZE, total);\n\t\t\texchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n\n\t\t\t// update pending number of exchanges\n\t\t\tpendingExchanges = total - index - 1;\n\t\t\t\n            // add on completion to handle after work when the exchange is done\n            exchange.addOnCompletion(new Synchronization() {\n                public void onComplete(Exchange exchange) {\n                    processCommit(exchange, unreadLabelId);\n                }\n\n                public void onFailure(Exchange exchange) {\n                    processRollback(exchange, unreadLabelId);\n                }\n\n                @Override\n                public String toString() {\n                    return \"GoogleMailStreamConsumerOnCompletion\";\n                }\n            });\n\n\t\t\tgetAsyncProcessor().process(exchange, new AsyncCallback() {\n\t\t\t\t@Override\n\t\t\t\tpublic void done(boolean doneSync) {\n\t\t\t\t\tLOG.trace(\"Processing exchange done\");\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn total;\n\t}",
            "  99  \n 100 +\n 101 +\n 102 +\n 103 +\n 104 +\n 105 +\n 106 +\n 107 +\n 108 +\n 109 +\n 110 +\n 111 +\n 112 +\n 113 +\n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130 +\n 131 +\n 132 +\n 133 +\n 134 +\n 135 +\n 136 +\n 137 +\n 138 +\n 139 +",
            "    @Override\n    public int processBatch(Queue<Object> exchanges) throws Exception {\n        int total = exchanges.size();\n\n        for (int index = 0; index < total && isBatchAllowed(); index++) {\n            // only loop if we are started (allowed to run)\n            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n            // add current index and total as properties\n            exchange.setProperty(Exchange.BATCH_INDEX, index);\n            exchange.setProperty(Exchange.BATCH_SIZE, total);\n            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n\n            // update pending number of exchanges\n            pendingExchanges = total - index - 1;\n\n            // add on completion to handle after work when the exchange is done\n            exchange.addOnCompletion(new Synchronization() {\n                public void onComplete(Exchange exchange) {\n                    processCommit(exchange, unreadLabelId);\n                }\n\n                public void onFailure(Exchange exchange) {\n                    processRollback(exchange, unreadLabelId);\n                }\n\n                @Override\n                public String toString() {\n                    return \"GoogleMailStreamConsumerOnCompletion\";\n                }\n            });\n\n            getAsyncProcessor().process(exchange, new AsyncCallback() {\n                @Override\n                public void done(boolean doneSync) {\n                    LOG.trace(\"Processing exchange done\");\n                }\n            });\n        }\n\n        return total;\n    }"
        ],
        [
            "GoogleMailStreamEndpoint::setHeaders(Message,List)",
            " 115 -\n 116 -\n 117 -\n 118 -\n 119 -\n 120 -\n 121 -\n 122 -\n 123 -\n 124 -\n 125 -\n 126 -\n 127 -\n 128 -\n 129 -\n 130 -\n 131 -\n 132 -\n 133 -",
            "\tprivate void setHeaders(Message message, List<MessagePartHeader> headers) {\n\t\tfor (MessagePartHeader header : headers) {\n\t\t\tif (header.getName().equalsIgnoreCase(\"SUBJECT\") || header.getName().equalsIgnoreCase(\"subject\")) {\n\t\t\t\tmessage.setHeader(GoogleMailStreamConstants.MAIL_SUBJECT, header.getValue());\n\t\t\t}\n\t\t\tif (header.getName().equalsIgnoreCase(\"TO\") || header.getName().equalsIgnoreCase(\"to\")) {\n\t\t\t\tmessage.setHeader(GoogleMailStreamConstants.MAIL_TO, header.getValue());\n\t\t\t}\n\t\t\tif (header.getName().equalsIgnoreCase(\"FROM\") || header.getName().equalsIgnoreCase(\"from\")) {\n\t\t\t\tmessage.setHeader(GoogleMailStreamConstants.MAIL_FROM, header.getValue());\n\t\t\t}\n\t\t\tif (header.getName().equalsIgnoreCase(\"CC\") || header.getName().equalsIgnoreCase(\"cc\")) {\n\t\t\t\tmessage.setHeader(GoogleMailStreamConstants.MAIL_CC, header.getValue());\n\t\t\t}\n\t\t\tif (header.getName().equalsIgnoreCase(\"BCC\") || header.getName().equalsIgnoreCase(\"bcc\")) {\n\t\t\t\tmessage.setHeader(GoogleMailStreamConstants.MAIL_BCC, header.getValue());\n\t\t\t}\n\t\t}\n\t}",
            " 118 +\n 119 +\n 120 +\n 121 +\n 122 +\n 123 +\n 124 +\n 125 +\n 126 +\n 127 +\n 128 +\n 129 +\n 130 +\n 131 +\n 132 +\n 133 +\n 134 +\n 135 +\n 136 +",
            "    private void setHeaders(Message message, List<MessagePartHeader> headers) {\n        for (MessagePartHeader header : headers) {\n            if (header.getName().equalsIgnoreCase(\"SUBJECT\") || header.getName().equalsIgnoreCase(\"subject\")) {\n                message.setHeader(GoogleMailStreamConstants.MAIL_SUBJECT, header.getValue());\n            }\n            if (header.getName().equalsIgnoreCase(\"TO\") || header.getName().equalsIgnoreCase(\"to\")) {\n                message.setHeader(GoogleMailStreamConstants.MAIL_TO, header.getValue());\n            }\n            if (header.getName().equalsIgnoreCase(\"FROM\") || header.getName().equalsIgnoreCase(\"from\")) {\n                message.setHeader(GoogleMailStreamConstants.MAIL_FROM, header.getValue());\n            }\n            if (header.getName().equalsIgnoreCase(\"CC\") || header.getName().equalsIgnoreCase(\"cc\")) {\n                message.setHeader(GoogleMailStreamConstants.MAIL_CC, header.getValue());\n            }\n            if (header.getName().equalsIgnoreCase(\"BCC\") || header.getName().equalsIgnoreCase(\"bcc\")) {\n                message.setHeader(GoogleMailStreamConstants.MAIL_BCC, header.getValue());\n            }\n        }\n    }"
        ],
        [
            "GoogleMailStreamConsumer::getEndpoint()",
            "  65  \n  66 -\n  67 -\n  68 -",
            "\t@Override\n\tpublic GoogleMailStreamEndpoint getEndpoint() {\n\t\treturn (GoogleMailStreamEndpoint) super.getEndpoint();\n\t}",
            "  66  \n  67 +\n  68 +\n  69 +",
            "    @Override\n    public GoogleMailStreamEndpoint getEndpoint() {\n        return (GoogleMailStreamEndpoint)super.getEndpoint();\n    }"
        ],
        [
            "GoogleMailStreamConsumer::getClient()",
            "  61 -\n  62 -\n  63 -",
            "\tprotected Gmail getClient() {\n\t\treturn getEndpoint().getClient();\n\t}",
            "  62 +\n  63 +\n  64 +",
            "    protected Gmail getClient() {\n        return getEndpoint().getClient();\n    }"
        ],
        [
            "GoogleMailStreamConfiguration::setQuery(String)",
            " 151  \n 152  \n 153  \n 154 -\n 155 -\n 156 -",
            "    /**\n     * The query to execute on gmail box\n     */\n\tpublic void setQuery(String query) {\n\t\tthis.query = query;\n\t}",
            " 155  \n 156  \n 157  \n 158 +\n 159 +\n 160 +",
            "    /**\n     * The query to execute on gmail box\n     */\n    public void setQuery(String query) {\n        this.query = query;\n    }"
        ],
        [
            "GoogleMailStreamComponent::setConfiguration(GoogleMailStreamConfiguration)",
            "  76  \n  77  \n  78  \n  79 -\n  80 -\n  81 -",
            "\t/**\n\t * The configuration\n\t */\n\tpublic void setConfiguration(GoogleMailStreamConfiguration configuration) {\n\t\tthis.configuration = configuration;\n\t}",
            "  75  \n  76  \n  77  \n  78 +\n  79 +\n  80 +",
            "    /**\n     * The configuration\n     */\n    public void setConfiguration(GoogleMailStreamConfiguration configuration) {\n        this.configuration = configuration;\n    }"
        ],
        [
            "GoogleMailStreamEndpoint::setClientFactory(GoogleMailClientFactory)",
            "  83 -\n  84 -\n  85 -",
            "\tpublic void setClientFactory(GoogleMailClientFactory clientFactory) {\n\t\t((GoogleMailStreamComponent) getComponent()).setClientFactory(clientFactory);\n\t}",
            "  88 +\n  89 +\n  90 +",
            "    public void setClientFactory(GoogleMailClientFactory clientFactory) {\n        ((GoogleMailStreamComponent)getComponent()).setClientFactory(clientFactory);\n    }"
        ],
        [
            "GoogleMailStreamConfiguration::getLabels()",
            " 169 -\n 170 -\n 171 -",
            "\tpublic String getLabels() {\n\t\treturn labels;\n\t}",
            " 173 +\n 174 +\n 175 +",
            "    public String getLabels() {\n        return labels;\n    }"
        ]
    ],
    "45596f3aeae6a3b9cb46f01217caa436a3502737": [
        [
            "ContainerAwareTestSupportIT::createContainer()",
            "  35  \n  36  \n  37 -\n  38  \n  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  ",
            "    @Override\n    protected GenericContainer<?> createContainer() {\n        return new GenericContainer(\"consul:1.0.0\")\n            .withNetworkAliases(\"myconsul\")\n            .withExposedPorts(8500)\n            .waitingFor(Wait.forLogMessageContaining(\"Synced node info\", 1))\n            .withCommand(\n                \"agent\",\n                \"-dev\",\n                \"-server\",\n                \"-bootstrap\",\n                \"-client\",\n                \"0.0.0.0\",\n                \"-log-level\",\n                \"trace\"",
            "  35  \n  36  \n  37 +\n  38  \n  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  ",
            "    @Override\n    protected GenericContainer<?> createContainer() {\n        return new GenericContainer(\"consul:1.0.7\")\n            .withNetworkAliases(\"myconsul\")\n            .withExposedPorts(8500)\n            .waitingFor(Wait.forLogMessageContaining(\"Synced node info\", 1))\n            .withCommand(\n                \"agent\",\n                \"-dev\",\n                \"-server\",\n                \"-bootstrap\",\n                \"-client\",\n                \"0.0.0.0\",\n                \"-log-level\",\n                \"trace\""
        ],
        [
            "ConsulServiceDiscovery::newService(String,CatalogService,List)",
            "  79  \n  80  \n  81 -\n  82 -\n  83 -\n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  ",
            "    private ServiceDefinition newService(String serviceName, CatalogService service, List<ServiceHealth> serviceHealthList) {\n        Map<String, String> meta = new HashMap<>();\n        ObjectHelper.ifNotEmpty(service.getServiceId(), val -> meta.put(\"service_id\", val));\n        ObjectHelper.ifNotEmpty(service.getNode(), val -> meta.put(\"node\", val));\n        ObjectHelper.ifNotEmpty(service.getServiceName(), val -> meta.put(\"service_name\", val));\n\n        List<String> tags = service.getServiceTags();\n        if (tags != null) {\n            for (String tag : service.getServiceTags()) {\n                String[] items = tag.split(\"=\");\n                if (items.length == 1) {\n                    meta.put(items[0], items[0]);\n                } else if (items.length == 2) {\n                    meta.put(items[0], items[1]);\n                }\n            }\n        }\n\n        return new DefaultServiceDefinition(\n            serviceName,\n            service.getServiceAddress(),\n            service.getServicePort(),\n            meta,\n            new DefaultServiceHealth(\n                serviceHealthList.stream()\n                    .filter(h -> ObjectHelper.equal(h.getService().getId(), service.getServiceId()))\n                    .allMatch(this::isHealthy)",
            "  79  \n  80  \n  81 +\n  82 +\n  83 +\n  84  \n  85 +\n  86 +\n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99 +\n 100 +\n 101 +\n 102 +\n 103 +\n 104 +\n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  ",
            "    private ServiceDefinition newService(String serviceName, CatalogService service, List<ServiceHealth> serviceHealthList) {\n        Map<String, String> meta = new HashMap<>();\n        ObjectHelper.ifNotEmpty(service.getServiceId(), val -> meta.put(ServiceDefinition.SERVICE_META_ID, val));\n        ObjectHelper.ifNotEmpty(service.getServiceName(), val -> meta.put(ServiceDefinition.SERVICE_META_NAME, val));\n        ObjectHelper.ifNotEmpty(service.getNode(), val -> meta.put(\"service.node\", val));\n\n        // Consul < 1.0.7 does not have a concept of meta-data so meta is\n        // retrieved using tags\n        List<String> tags = service.getServiceTags();\n        if (tags != null) {\n            for (String tag : service.getServiceTags()) {\n                String[] items = tag.split(\"=\");\n                if (items.length == 1) {\n                    meta.put(items[0], items[0]);\n                } else if (items.length == 2) {\n                    meta.put(items[0], items[1]);\n                }\n            }\n        }\n\n        // From Consul => 1.0.7, a new meta data attribute has been introduced\n        // and it is now taken ito account\n        service.getServiceMeta().ifPresent(\n            serviceMeta -> serviceMeta.forEach(meta::put)\n        );\n\n        return new DefaultServiceDefinition(\n            serviceName,\n            service.getServiceAddress(),\n            service.getServicePort(),\n            meta,\n            new DefaultServiceHealth(\n                serviceHealthList.stream()\n                    .filter(h -> ObjectHelper.equal(h.getService().getId(), service.getServiceId()))\n                    .allMatch(this::isHealthy)"
        ],
        [
            "ContainerAwareSpringTestSupportIT::createContainer()",
            "  43  \n  44  \n  45 -\n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  ",
            "    @Override\n    protected GenericContainer<?> createContainer() {\n        return new GenericContainer(\"consul:1.0.0\")\n            .withNetworkAliases(\"myconsul\")\n            .withExposedPorts(8500)\n            .waitingFor(Wait.forLogMessageContaining(\"Synced node info\", 1))\n            .withCommand(\n                \"agent\",\n                \"-dev\",\n                \"-server\",\n                \"-bootstrap\",\n                \"-client\",\n                \"0.0.0.0\",\n                \"-log-level\",\n                \"trace\"",
            "  43  \n  44  \n  45 +\n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  ",
            "    @Override\n    protected GenericContainer<?> createContainer() {\n        return new GenericContainer(\"consul:1.0.7\")\n            .withNetworkAliases(\"myconsul\")\n            .withExposedPorts(8500)\n            .waitingFor(Wait.forLogMessageContaining(\"Synced node info\", 1))\n            .withCommand(\n                \"agent\",\n                \"-dev\",\n                \"-server\",\n                \"-bootstrap\",\n                \"-client\",\n                \"0.0.0.0\",\n                \"-log-level\",\n                \"trace\""
        ],
        [
            "ConsulServiceDiscoveryTest::testServiceDiscovery()",
            "  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99 -\n 100 -\n 101 -\n 102 -\n 103 -\n 104 -\n 105 -\n 106  \n 107  ",
            "    @Test\n    public void testServiceDiscovery() throws Exception {\n        ConsulConfiguration configuration = new ConsulConfiguration();\n        configuration.setUrl(consulUrl());\n\n        ServiceDiscovery discovery = new ConsulServiceDiscovery(configuration);\n\n        List<ServiceDefinition> services = discovery.getServices(\"my-service\");\n        assertNotNull(services);\n        assertEquals(6, services.size());\n\n        for (ServiceDefinition service : services) {\n            assertFalse(service.getMetadata().isEmpty());\n            assertTrue(service.getMetadata().containsKey(\"service_name\"));\n            assertTrue(service.getMetadata().containsKey(\"service_id\"));\n            assertTrue(service.getMetadata().containsKey(\"a-tag\"));\n            assertTrue(service.getMetadata().containsKey(\"key1\"));\n            assertTrue(service.getMetadata().containsKey(\"key2\"));\n            assertEquals(\"\" + service.getHealth().isHealthy(), service.getMetadata().get(\"healthy\"));\n        }\n    }",
            "  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101 +\n 102 +\n 103 +\n 104 +\n 105 +\n 106 +\n 107 +\n 108 +\n 109  \n 110  ",
            "    @Test\n    public void testServiceDiscovery() throws Exception {\n        ConsulConfiguration configuration = new ConsulConfiguration();\n        configuration.setUrl(consulUrl());\n\n        ServiceDiscovery discovery = new ConsulServiceDiscovery(configuration);\n\n        List<ServiceDefinition> services = discovery.getServices(\"my-service\");\n        assertNotNull(services);\n        assertEquals(6, services.size());\n\n        for (ServiceDefinition service : services) {\n            Assertions.assertThat(service.getMetadata()).isNotEmpty();\n            Assertions.assertThat(service.getMetadata()).containsEntry(ServiceDefinition.SERVICE_META_NAME, \"my-service\");\n            Assertions.assertThat(service.getMetadata()).containsKey(ServiceDefinition.SERVICE_META_ID);\n            Assertions.assertThat(service.getMetadata()).containsKey(\"a-tag\");\n            Assertions.assertThat(service.getMetadata()).containsEntry(\"key1\", \"value1\");\n            Assertions.assertThat(service.getMetadata()).containsEntry(\"key2\", \"value2\");\n            Assertions.assertThat(service.getMetadata()).containsEntry(\"meta-key\", \"meta-val\");\n            Assertions.assertThat(\"\" + service.getHealth().isHealthy()).isEqualTo(service.getMetadata().get(\"healthy\"));\n        }\n    }"
        ],
        [
            "ConsulServiceDiscoveryTest::doPreSetup()",
            "  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  ",
            "    @Override\n    protected void doPreSetup() throws Exception {\n        super.doPreSetup();\n\n        client = getConsul().agentClient();\n        registrations = new ArrayList<>(3);\n\n        for (int i = 0; i < 6; i++) {\n            final boolean healty = ThreadLocalRandom.current().nextBoolean();\n            final int port = SocketUtils.findAvailableTcpPort();\n\n            Registration.RegCheck c = ImmutableRegCheck.builder()\n                .ttl(\"1m\")\n                .status(healty ? \"passing\" : \"critical\")\n                .build();\n\n            Registration r = ImmutableRegistration.builder()\n                .id(\"service-\" + i)\n                .name(\"my-service\")\n                .address(\"127.0.0.1\")\n                .addTags(\"a-tag\")\n                .addTags(\"key1=value1\")\n                .addTags(\"key2=value2\")\n                .addTags(\"healthy=\" + healty)\n                .port(port)\n                .check(c)\n                .build();\n\n            client.register(r);\n            registrations.add(r);\n        }\n    }",
            "  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68 +\n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  ",
            "    @Override\n    protected void doPreSetup() throws Exception {\n        super.doPreSetup();\n\n        client = getConsul().agentClient();\n        registrations = new ArrayList<>(3);\n\n        for (int i = 0; i < 6; i++) {\n            final boolean healty = ThreadLocalRandom.current().nextBoolean();\n            final int port = SocketUtils.findAvailableTcpPort();\n\n            Registration.RegCheck c = ImmutableRegCheck.builder()\n                .ttl(\"1m\")\n                .status(healty ? \"passing\" : \"critical\")\n                .build();\n\n            Registration r = ImmutableRegistration.builder()\n                .id(\"service-\" + i)\n                .name(\"my-service\")\n                .address(\"127.0.0.1\")\n                .addTags(\"a-tag\")\n                .addTags(\"key1=value1\")\n                .addTags(\"key2=value2\")\n                .addTags(\"healthy=\" + healty)\n                .putMeta(\"meta-key\", \"meta-val\")\n                .port(port)\n                .check(c)\n                .build();\n\n            client.register(r);\n            registrations.add(r);\n        }\n    }"
        ]
    ],
    "7bd4a0f66eac727fc187a62ccfdc318481455f16": [
        [
            "DefaultRestletBinding::populateRestletRequestFromExchange(Request,Exchange)",
            " 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290 -\n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  ",
            "    public void populateRestletRequestFromExchange(Request request, Exchange exchange) {\n        request.setReferrerRef(\"camel-restlet\");\n\n        final Method method = request.getMethod();\n\n        MediaType mediaType = exchange.getIn().getHeader(Exchange.CONTENT_TYPE, MediaType.class);\n        if (mediaType == null) {\n            mediaType = MediaType.APPLICATION_WWW_FORM;\n        }\n\n        Form form = null;\n        // Use forms only for PUT, POST and x-www-form-urlencoded\n        if ((Method.PUT == method || Method.POST == method) && MediaType.APPLICATION_WWW_FORM.equals(mediaType, true)) {\n            form = new Form();\n            \n            if (exchange.getIn().getBody() instanceof Map) {\n                //Body is key value pairs\n                try {\n                    Map pairs = exchange.getIn().getBody(Map.class);\n                    for (Object key: pairs.keySet()) {\n                        Object value = pairs.get(key);\n                        form.add(key.toString(), value != null ? value.toString() : null);\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeCamelException(\"body for \" + MediaType.APPLICATION_WWW_FORM + \" request must be Map<String,String> or string format like name=bob&password=secRet\", e);\n                }\n            } else {\n                // use string based for forms\n                String body = exchange.getIn().getBody(String.class);\n                if (body != null) {\n                    List<NameValuePair> pairs = URLEncodedUtils.parse(body, Charset.forName(IOHelper.getCharsetName(exchange, true)));\n                    for (NameValuePair p : pairs) {\n                        form.add(p.getName(), p.getValue());\n                    }\n                }\n            }\n        }\n\n        // get outgoing custom http headers from the exchange if they exists\n        Series<Header> restletHeaders = exchange.getIn().getHeader(HeaderConstants.ATTRIBUTE_HEADERS, Series.class);\n        if (restletHeaders == null) {\n            restletHeaders = new Series<>(Header.class);\n            request.getAttributes().put(HeaderConstants.ATTRIBUTE_HEADERS, restletHeaders);\n        } else {\n            // if the restlet headers already exists on the exchange, we need to filter them\n            for (String name : restletHeaders.getNames()) {\n                if (headerFilterStrategy.applyFilterToCamelHeaders(name, restletHeaders.getValues(name), exchange)) {\n                    restletHeaders.removeAll(name);\n                }\n            }\n            request.getAttributes().put(HeaderConstants.ATTRIBUTE_HEADERS, restletHeaders);\n\n            // since the restlet headers already exists remove them from the exchange so they don't get added again below\n            // we will get a new set of restlet headers on the response\n            exchange.getIn().removeHeader(HeaderConstants.ATTRIBUTE_HEADERS);\n        }\n\n        // login and password are filtered by header filter strategy\n        String login = exchange.getIn().getHeader(RestletConstants.RESTLET_LOGIN, String.class);\n        String password = exchange.getIn().getHeader(RestletConstants.RESTLET_PASSWORD, String.class);\n\n        if (login != null && password != null) {\n            ChallengeResponse authentication = new ChallengeResponse(ChallengeScheme.HTTP_BASIC, login, password);\n            request.setChallengeResponse(authentication);\n            LOG.debug(\"Basic HTTP Authentication has been applied\");\n        }\n\n        for (Map.Entry<String, Object> entry : exchange.getIn().getHeaders().entrySet()) {\n            String key = entry.getKey();\n            Object value = entry.getValue();\n            if (!headerFilterStrategy.applyFilterToCamelHeaders(key, value, exchange)) {\n                // Use forms only for PUT, POST and x-www-form-urlencoded\n                if (form != null) {\n                    if (key.startsWith(\"org.restlet.\")) {\n                        // put the org.restlet headers in attributes\n                        request.getAttributes().put(key, value);\n                    } else {\n                        // put the user stuff in the form\n                        if (value instanceof Collection) {\n                            for (Object v : (Collection<?>) value) {\n                                form.add(key, v.toString());\n                                if (!headerFilterStrategy.applyFilterToCamelHeaders(key, value, exchange)) {\n                                    restletHeaders.set(key, value.toString());\n                                }\n                            }\n                        } else {\n                            //Add headers to headers and to body\n                            form.add(key, value.toString());\n                            if (!headerFilterStrategy.applyFilterToCamelHeaders(key, value, exchange)) {\n                                restletHeaders.set(key, value.toString());\n                            }\n                        }\n                    }\n                } else {\n                    // For non-form post put all the headers in custom headers\n                    if (!headerFilterStrategy.applyFilterToCamelHeaders(key, value, exchange)) {\n                        restletHeaders.set(key, value.toString());\n                    }\n                }\n                LOG.debug(\"Populate Restlet request from exchange header: {} value: {}\", key, value);\n            }\n        }\n\n        if (form != null) {\n            request.setEntity(form.getWebRepresentation());\n            LOG.debug(\"Populate Restlet {} request from exchange body as form using media type {}\", method, mediaType);\n        } else {\n            // include body if PUT or POST\n            if (request.getMethod() == Method.PUT || request.getMethod() == Method.POST) {\n                Representation body = createRepresentationFromBody(exchange, mediaType);\n                request.setEntity(body);\n                LOG.debug(\"Populate Restlet {} request from exchange body: {} using media type {}\", method, body, mediaType);\n            } else {\n                // no body\n                LOG.debug(\"Populate Restlet {} request from exchange using media type {}\", method, mediaType);\n                request.setEntity(new EmptyRepresentation());\n            }\n        }\n\n        // filter out standard restlet headers which must be configured differently\n        org.restlet.Message extensionHeaders = new Request();\n        HeaderUtils.copyExtensionHeaders(restletHeaders, extensionHeaders);\n\n        // setup standard headers\n        Series<Header> standardHeaders = new Series<>(Header.class);\n        standardHeaders.addAll(restletHeaders);\n        standardHeaders.removeAll(extensionHeaders.getHeaders());\n\n        // setup extension headers\n        restletHeaders.removeAll(standardHeaders);\n\n        // now add standard headers but via the special restlet api\n        LOG.debug(\"Detected {} request extension headers\", extensionHeaders.getHeaders().size());\n        LOG.debug(\"Detected {} request standard headers\", standardHeaders.size());\n\n        configureRestletRequestStandardHeaders(exchange, request, standardHeaders);\n\n        // deprecated accept\n        final MediaType[] acceptedMediaTypes = exchange.getIn().getHeader(Exchange.ACCEPT_CONTENT_TYPE, MediaType[].class);\n        if (acceptedMediaTypes != null) {\n            ClientInfo clientInfo = request.getClientInfo();\n            List<Preference<MediaType>> acceptedMediaTypesList = clientInfo.getAcceptedMediaTypes();\n            for (MediaType acceptedMediaType : acceptedMediaTypes) {\n                acceptedMediaTypesList.add(new Preference<>(acceptedMediaType));\n            }\n        }\n    }",
            " 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290 +\n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  ",
            "    public void populateRestletRequestFromExchange(Request request, Exchange exchange) {\n        request.setReferrerRef(\"camel-restlet\");\n\n        final Method method = request.getMethod();\n\n        MediaType mediaType = exchange.getIn().getHeader(Exchange.CONTENT_TYPE, MediaType.class);\n        if (mediaType == null) {\n            mediaType = MediaType.APPLICATION_WWW_FORM;\n        }\n\n        Form form = null;\n        // Use forms only for PUT, POST and x-www-form-urlencoded\n        if ((Method.PUT == method || Method.POST == method) && MediaType.APPLICATION_WWW_FORM.equals(mediaType, true)) {\n            form = new Form();\n            \n            if (exchange.getIn().getBody() instanceof Map) {\n                //Body is key value pairs\n                try {\n                    Map pairs = exchange.getIn().getBody(Map.class);\n                    for (Object key: pairs.keySet()) {\n                        Object value = pairs.get(key);\n                        form.add(key.toString(), value != null ? value.toString() : null);\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeCamelException(\"body for \" + MediaType.APPLICATION_WWW_FORM + \" request must be Map<String,String> or string format like name=bob&password=secRet\", e);\n                }\n            } else {\n                // use string based for forms\n                String body = exchange.getIn().getBody(String.class);\n                if (body != null) {\n                    List<NameValuePair> pairs = URLEncodedUtils.parse(body, Charset.forName(IOHelper.getCharsetName(exchange, true)));\n                    for (NameValuePair p : pairs) {\n                        form.add(p.getName(), p.getValue());\n                    }\n                }\n            }\n        }\n\n        // get outgoing custom http headers from the exchange if they exists\n        Series<Header> restletHeaders = exchange.getIn().getHeader(HeaderConstants.ATTRIBUTE_HEADERS, Series.class);\n        if (restletHeaders == null) {\n            restletHeaders = new Series<>(Header.class);\n            request.getAttributes().put(HeaderConstants.ATTRIBUTE_HEADERS, restletHeaders);\n        } else {\n            // if the restlet headers already exists on the exchange, we need to filter them\n            for (String name : restletHeaders.getNames()) {\n                if (headerFilterStrategy.applyFilterToCamelHeaders(name, restletHeaders.getValues(name), exchange)) {\n                    restletHeaders.removeAll(name);\n                }\n            }\n            request.getAttributes().put(HeaderConstants.ATTRIBUTE_HEADERS, restletHeaders);\n\n            // since the restlet headers already exists remove them from the exchange so they don't get added again below\n            // we will get a new set of restlet headers on the response\n            exchange.getIn().removeHeader(HeaderConstants.ATTRIBUTE_HEADERS);\n        }\n\n        // login and password are filtered by header filter strategy\n        String login = exchange.getIn().getHeader(RestletConstants.RESTLET_LOGIN, String.class);\n        String password = exchange.getIn().getHeader(RestletConstants.RESTLET_PASSWORD, String.class);\n\n        if (login != null && password != null) {\n            ChallengeResponse authentication = new ChallengeResponse(ChallengeScheme.HTTP_BASIC, login, password);\n            request.setChallengeResponse(authentication);\n            LOG.debug(\"Basic HTTP Authentication has been applied\");\n        }\n\n        for (Map.Entry<String, Object> entry : exchange.getIn().getHeaders().entrySet()) {\n            String key = entry.getKey();\n            Object value = entry.getValue();\n            if (!headerFilterStrategy.applyFilterToCamelHeaders(key, value, exchange)) {\n                // Use forms only for PUT, POST and x-www-form-urlencoded\n                if (form != null) {\n                    if (key.startsWith(\"org.restlet.\")) {\n                        // put the org.restlet headers in attributes\n                        request.getAttributes().put(key, value);\n                    } else {\n                        // put the user stuff in the form\n                        if (value instanceof Collection) {\n                            for (Object v : (Collection<?>) value) {\n                                form.add(key, v.toString());\n                                if (!headerFilterStrategy.applyFilterToCamelHeaders(key, value, exchange)) {\n                                    restletHeaders.set(key, value.toString());\n                                }\n                            }\n                        } else {\n                            //Add headers to headers and to body\n                            form.add(key, value.toString());\n                            if (!headerFilterStrategy.applyFilterToCamelHeaders(key, value, exchange)) {\n                                restletHeaders.set(key, value.toString());\n                            }\n                        }\n                    }\n                } else {\n                    // For non-form post put all the headers in custom headers\n                    if (!headerFilterStrategy.applyFilterToCamelHeaders(key, value, exchange)) {\n                        restletHeaders.set(key, value.toString());\n                    }\n                }\n                LOG.debug(\"Populate Restlet request from exchange header: {} value: {}\", key, value);\n            }\n        }\n\n        if (form != null) {\n            request.setEntity(form.getWebRepresentation());\n            LOG.debug(\"Populate Restlet {} request from exchange body as form using media type {}\", method, mediaType);\n        } else {\n            // include body if PUT or POST\n            if (request.getMethod().equals(Method.PUT) || request.getMethod().equals(Method.POST)) {\n                Representation body = createRepresentationFromBody(exchange, mediaType);\n                request.setEntity(body);\n                LOG.debug(\"Populate Restlet {} request from exchange body: {} using media type {}\", method, body, mediaType);\n            } else {\n                // no body\n                LOG.debug(\"Populate Restlet {} request from exchange using media type {}\", method, mediaType);\n                request.setEntity(new EmptyRepresentation());\n            }\n        }\n\n        // filter out standard restlet headers which must be configured differently\n        org.restlet.Message extensionHeaders = new Request();\n        HeaderUtils.copyExtensionHeaders(restletHeaders, extensionHeaders);\n\n        // setup standard headers\n        Series<Header> standardHeaders = new Series<>(Header.class);\n        standardHeaders.addAll(restletHeaders);\n        standardHeaders.removeAll(extensionHeaders.getHeaders());\n\n        // setup extension headers\n        restletHeaders.removeAll(standardHeaders);\n\n        // now add standard headers but via the special restlet api\n        LOG.debug(\"Detected {} request extension headers\", extensionHeaders.getHeaders().size());\n        LOG.debug(\"Detected {} request standard headers\", standardHeaders.size());\n\n        configureRestletRequestStandardHeaders(exchange, request, standardHeaders);\n\n        // deprecated accept\n        final MediaType[] acceptedMediaTypes = exchange.getIn().getHeader(Exchange.ACCEPT_CONTENT_TYPE, MediaType[].class);\n        if (acceptedMediaTypes != null) {\n            ClientInfo clientInfo = request.getClientInfo();\n            List<Preference<MediaType>> acceptedMediaTypesList = clientInfo.getAcceptedMediaTypes();\n            for (MediaType acceptedMediaType : acceptedMediaTypes) {\n                acceptedMediaTypesList.add(new Preference<>(acceptedMediaType));\n            }\n        }\n    }"
        ]
    ],
    "bdc882a2031df73fdf48d5c22ff8c0014ceec82d": [
        [
            "TarAggregationStrategy::addFileToTar(File,File,String)",
            " 195  \n 196 -\n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  ",
            "    private void addFileToTar(File source, File file, String fileName) throws IOException, ArchiveException {\n        File tmpTar = File.createTempFile(source.getName(), null, parentDir);\n        tmpTar.delete();\n        if (!source.renameTo(tmpTar)) {\n            throw new IOException(\"Could not make temp file (\" + source.getName() + \")\");\n        }\n\n        FileInputStream fis = new FileInputStream(tmpTar);\n        TarArchiveInputStream tin = (TarArchiveInputStream) new ArchiveStreamFactory().createArchiveInputStream(ArchiveStreamFactory.TAR, fis);\n        TarArchiveOutputStream tos = new TarArchiveOutputStream(new FileOutputStream(source));\n        tos.setLongFileMode(TarArchiveOutputStream.LONGFILE_POSIX);\n        tos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_POSIX);\n\n        InputStream in = new FileInputStream(file);\n\n        // copy the existing entries    \n        ArchiveEntry nextEntry;\n        while ((nextEntry = tin.getNextEntry()) != null) {\n            tos.putArchiveEntry(nextEntry);\n            IOUtils.copy(tin, tos);\n            tos.closeArchiveEntry();\n        }\n\n        // Add the new entry\n        TarArchiveEntry entry = new TarArchiveEntry(fileName == null ? file.getName() : fileName);\n        entry.setSize(file.length());\n        tos.putArchiveEntry(entry);\n        IOUtils.copy(in, tos);\n        tos.closeArchiveEntry();\n\n        IOHelper.close(fis, in, tin, tos);\n        LOG.trace(\"Deleting temporary file: {}\", tmpTar);\n        FileUtil.deleteFile(tmpTar);\n    }",
            " 196  \n 197 +\n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  ",
            "    private void addFileToTar(File source, File file, String fileName) throws IOException, ArchiveException {\n        File tmpTar = Files.createTempFile(parentDir.toPath(), source.getName(), null).toFile();\n        tmpTar.delete();\n        if (!source.renameTo(tmpTar)) {\n            throw new IOException(\"Could not make temp file (\" + source.getName() + \")\");\n        }\n\n        FileInputStream fis = new FileInputStream(tmpTar);\n        TarArchiveInputStream tin = (TarArchiveInputStream) new ArchiveStreamFactory().createArchiveInputStream(ArchiveStreamFactory.TAR, fis);\n        TarArchiveOutputStream tos = new TarArchiveOutputStream(new FileOutputStream(source));\n        tos.setLongFileMode(TarArchiveOutputStream.LONGFILE_POSIX);\n        tos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_POSIX);\n\n        InputStream in = new FileInputStream(file);\n\n        // copy the existing entries    \n        ArchiveEntry nextEntry;\n        while ((nextEntry = tin.getNextEntry()) != null) {\n            tos.putArchiveEntry(nextEntry);\n            IOUtils.copy(tin, tos);\n            tos.closeArchiveEntry();\n        }\n\n        // Add the new entry\n        TarArchiveEntry entry = new TarArchiveEntry(fileName == null ? file.getName() : fileName);\n        entry.setSize(file.length());\n        tos.putArchiveEntry(entry);\n        IOUtils.copy(in, tos);\n        tos.closeArchiveEntry();\n\n        IOHelper.close(fis, in, tin, tos);\n        LOG.trace(\"Deleting temporary file: {}\", tmpTar);\n        FileUtil.deleteFile(tmpTar);\n    }"
        ],
        [
            "ZipAggregationStrategy::addEntryToZip(File,String,byte,int)",
            " 227  \n 228 -\n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  ",
            "    private static void addEntryToZip(File source, String entryName, byte[] buffer, int length) throws IOException {\n        File tmpZip = File.createTempFile(source.getName(), null);\n        tmpZip.delete();\n        if (!source.renameTo(tmpZip)) {\n            throw new IOException(\"Cannot create temp file: \" + source.getName());\n        }\n\n        FileInputStream fis = new FileInputStream(tmpZip);\n        ZipInputStream zin = new ZipInputStream(fis);\n        ZipOutputStream out = new ZipOutputStream(new FileOutputStream(source));\n        try {\n            out.putNextEntry(new ZipEntry(entryName));\n            out.write(buffer, 0, length);\n            out.closeEntry();\n\n            for (ZipEntry ze = zin.getNextEntry(); ze != null; ze = zin.getNextEntry()) {\n                out.putNextEntry(ze);\n                for (int read = zin.read(buffer); read > -1; read = zin.read(buffer)) {\n                    out.write(buffer, 0, read);\n                }\n                out.closeEntry();\n            }\n        } finally {\n            IOHelper.close(fis, zin, out);\n        }\n        tmpZip.delete();\n    }",
            " 228  \n 229 +\n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  ",
            "    private static void addEntryToZip(File source, String entryName, byte[] buffer, int length) throws IOException {\n        File tmpZip = Files.createTempFile(source.getName(), null).toFile();\n        tmpZip.delete();\n        if (!source.renameTo(tmpZip)) {\n            throw new IOException(\"Cannot create temp file: \" + source.getName());\n        }\n\n        FileInputStream fis = new FileInputStream(tmpZip);\n        ZipInputStream zin = new ZipInputStream(fis);\n        ZipOutputStream out = new ZipOutputStream(new FileOutputStream(source));\n        try {\n            out.putNextEntry(new ZipEntry(entryName));\n            out.write(buffer, 0, length);\n            out.closeEntry();\n\n            for (ZipEntry ze = zin.getNextEntry(); ze != null; ze = zin.getNextEntry()) {\n                out.putNextEntry(ze);\n                for (int read = zin.read(buffer); read > -1; read = zin.read(buffer)) {\n                    out.write(buffer, 0, read);\n                }\n                out.closeEntry();\n            }\n        } finally {\n            IOHelper.close(fis, zin, out);\n        }\n        tmpZip.delete();\n    }"
        ],
        [
            "ZipAggregationStrategy::addFileToZip(File,File,String)",
            " 193  \n 194 -\n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  ",
            "    private static void addFileToZip(File source, File file, String fileName) throws IOException {\n        File tmpZip = File.createTempFile(source.getName(), null);\n        tmpZip.delete();\n        if (!source.renameTo(tmpZip)) {\n            throw new IOException(\"Could not make temp file (\" + source.getName() + \")\");\n        }\n        byte[] buffer = new byte[8192];\n\n        FileInputStream fis = new FileInputStream(tmpZip);\n        ZipInputStream zin = new ZipInputStream(fis);\n        ZipOutputStream out = new ZipOutputStream(new FileOutputStream(source));\n\n        try {\n            InputStream in = new FileInputStream(file);\n            out.putNextEntry(new ZipEntry(fileName == null ? file.getName() : fileName));\n            for (int read = in.read(buffer); read > -1; read = in.read(buffer)) {\n                out.write(buffer, 0, read);\n            }\n            out.closeEntry();\n            IOHelper.close(in);\n\n            for (ZipEntry ze = zin.getNextEntry(); ze != null; ze = zin.getNextEntry()) {\n                out.putNextEntry(ze);\n                for (int read = zin.read(buffer); read > -1; read = zin.read(buffer)) {\n                    out.write(buffer, 0, read);\n                }\n                out.closeEntry();\n            }\n        } finally {\n            IOHelper.close(fis, zin, out);\n        }\n        tmpZip.delete();\n    }",
            " 194  \n 195 +\n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  ",
            "    private static void addFileToZip(File source, File file, String fileName) throws IOException {\n        File tmpZip = Files.createTempFile(source.getName(), null).toFile();\n        tmpZip.delete();\n        if (!source.renameTo(tmpZip)) {\n            throw new IOException(\"Could not make temp file (\" + source.getName() + \")\");\n        }\n        byte[] buffer = new byte[8192];\n\n        FileInputStream fis = new FileInputStream(tmpZip);\n        ZipInputStream zin = new ZipInputStream(fis);\n        ZipOutputStream out = new ZipOutputStream(new FileOutputStream(source));\n\n        try {\n            InputStream in = new FileInputStream(file);\n            out.putNextEntry(new ZipEntry(fileName == null ? file.getName() : fileName));\n            for (int read = in.read(buffer); read > -1; read = in.read(buffer)) {\n                out.write(buffer, 0, read);\n            }\n            out.closeEntry();\n            IOHelper.close(in);\n\n            for (ZipEntry ze = zin.getNextEntry(); ze != null; ze = zin.getNextEntry()) {\n                out.putNextEntry(ze);\n                for (int read = zin.read(buffer); read > -1; read = zin.read(buffer)) {\n                    out.write(buffer, 0, read);\n                }\n                out.closeEntry();\n            }\n        } finally {\n            IOHelper.close(fis, zin, out);\n        }\n        tmpZip.delete();\n    }"
        ],
        [
            "CamelBlueprintTestSupport::prepareInitialConfigFile(Properties)",
            " 526  \n 527  \n 528  \n 529  \n 530  \n 531  \n 532  \n 533  \n 534 -\n 535  \n 536  \n 537  \n 538  \n 539  \n 540  \n 541  \n 542  ",
            "    /**\n     * Create a temporary File with persisted configuration for ConfigAdmin\n     * @param initialConfiguration\n     * @return\n     */\n    private String prepareInitialConfigFile(Properties initialConfiguration) throws IOException {\n        File dir = new File(\"target/etc\");\n        dir.mkdirs();\n        File cfg = File.createTempFile(\"properties-\", \".cfg\", dir);\n        FileWriter writer = new FileWriter(cfg);\n        try {\n            initialConfiguration.store(writer, null);\n        } finally {\n            writer.close();\n        }\n        return cfg.getAbsolutePath();\n    }",
            " 527  \n 528  \n 529  \n 530  \n 531  \n 532  \n 533  \n 534  \n 535 +\n 536  \n 537  \n 538  \n 539  \n 540  \n 541  \n 542  \n 543  ",
            "    /**\n     * Create a temporary File with persisted configuration for ConfigAdmin\n     * @param initialConfiguration\n     * @return\n     */\n    private String prepareInitialConfigFile(Properties initialConfiguration) throws IOException {\n        File dir = new File(\"target/etc\");\n        dir.mkdirs();\n        File cfg = Files.createTempFile(dir.toPath(), \"properties-\", \".cfg\").toFile();\n        FileWriter writer = new FileWriter(cfg);\n        try {\n            initialConfiguration.store(writer, null);\n        } finally {\n            writer.close();\n        }\n        return cfg.getAbsolutePath();\n    }"
        ],
        [
            "TarAggregationStrategy::addEntryToTar(File,String,byte,int)",
            " 230  \n 231 -\n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  ",
            "    private void addEntryToTar(File source, String entryName, byte[] buffer, int length) throws IOException, ArchiveException {\n        File tmpTar = File.createTempFile(source.getName(), null, parentDir);\n        tmpTar.delete();\n        if (!source.renameTo(tmpTar)) {\n            throw new IOException(\"Cannot create temp file: \" + source.getName());\n        }\n\n        FileInputStream fis = new FileInputStream(tmpTar);\n        TarArchiveInputStream tin = (TarArchiveInputStream) new ArchiveStreamFactory().createArchiveInputStream(ArchiveStreamFactory.TAR, fis);\n        TarArchiveOutputStream tos = new TarArchiveOutputStream(new FileOutputStream(source));\n        tos.setLongFileMode(TarArchiveOutputStream.LONGFILE_POSIX);\n        tos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_POSIX);\n\n        // copy the existing entries    \n        ArchiveEntry nextEntry;\n        while ((nextEntry = tin.getNextEntry()) != null) {\n            tos.putArchiveEntry(nextEntry);\n            IOUtils.copy(tin, tos);\n            tos.closeArchiveEntry();\n        }\n\n        // Create new entry\n        TarArchiveEntry entry = new TarArchiveEntry(entryName);\n        entry.setSize(length);\n        tos.putArchiveEntry(entry);\n        tos.write(buffer, 0, length);\n        tos.closeArchiveEntry();\n\n        IOHelper.close(fis, tin, tos);\n        LOG.trace(\"Deleting temporary file: {}\", tmpTar);\n        FileUtil.deleteFile(tmpTar);\n    }",
            " 231  \n 232 +\n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  ",
            "    private void addEntryToTar(File source, String entryName, byte[] buffer, int length) throws IOException, ArchiveException {\n        File tmpTar = Files.createTempFile(parentDir.toPath(), source.getName(), null).toFile();\n        tmpTar.delete();\n        if (!source.renameTo(tmpTar)) {\n            throw new IOException(\"Cannot create temp file: \" + source.getName());\n        }\n\n        FileInputStream fis = new FileInputStream(tmpTar);\n        TarArchiveInputStream tin = (TarArchiveInputStream) new ArchiveStreamFactory().createArchiveInputStream(ArchiveStreamFactory.TAR, fis);\n        TarArchiveOutputStream tos = new TarArchiveOutputStream(new FileOutputStream(source));\n        tos.setLongFileMode(TarArchiveOutputStream.LONGFILE_POSIX);\n        tos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_POSIX);\n\n        // copy the existing entries    \n        ArchiveEntry nextEntry;\n        while ((nextEntry = tin.getNextEntry()) != null) {\n            tos.putArchiveEntry(nextEntry);\n            IOUtils.copy(tin, tos);\n            tos.closeArchiveEntry();\n        }\n\n        // Create new entry\n        TarArchiveEntry entry = new TarArchiveEntry(entryName);\n        entry.setSize(length);\n        tos.putArchiveEntry(entry);\n        tos.write(buffer, 0, length);\n        tos.closeArchiveEntry();\n\n        IOHelper.close(fis, tin, tos);\n        LOG.trace(\"Deleting temporary file: {}\", tmpTar);\n        FileUtil.deleteFile(tmpTar);\n    }"
        ],
        [
            "FileUtil::createTempFile(String,String,File)",
            "  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101 -\n 102  ",
            "    public static File createTempFile(String prefix, String suffix, File parentDir) throws IOException {\n        Objects.requireNonNull(parentDir);\n\n        if (suffix == null) {\n            suffix = \".tmp\";\n        }\n        if (prefix == null) {\n            prefix = \"camel\";\n        } else if (prefix.length() < 3) {\n            prefix = prefix + \"camel\";\n        }\n\n        // create parent folder\n        parentDir.mkdirs();\n\n        return File.createTempFile(prefix, suffix, parentDir);\n    }",
            "  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101 +\n 102  ",
            "    public static File createTempFile(String prefix, String suffix, File parentDir) throws IOException {\n        Objects.requireNonNull(parentDir);\n\n        if (suffix == null) {\n            suffix = \".tmp\";\n        }\n        if (prefix == null) {\n            prefix = \"camel\";\n        } else if (prefix.length() < 3) {\n            prefix = prefix + \"camel\";\n        }\n\n        // create parent folder\n        parentDir.mkdirs();\n\n        return Files.createTempFile(parentDir.toPath(), prefix, suffix).toFile();\n    }"
        ],
        [
            "BonitaAPIUtil::uploadFile(ProcessDefinitionResponse,FileInput)",
            "  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70 -\n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  ",
            "    public UploadFileResponse uploadFile(ProcessDefinitionResponse processDefinition,\n            FileInput file) throws Exception {\n        WebTarget resource = webTarget\n            .path(\"portal/resource/process/{processName}/{processVersion}/API/formFileUpload\")\n            .resolveTemplate(\"processName\", processDefinition.getName())\n            .resolveTemplate(\"processVersion\", processDefinition.getVersion());\n\n        File tempFile = File.createTempFile(\"tempFile\", \".tmp\");\n        FileOutputStream fos = new FileOutputStream(tempFile);\n        fos.write(file.getContent());\n        fos.close();\n\n        String dispositionValue = String.format(\"form-data;filename=%s;name=file\", tempFile.getName());\n        Attachment attachment = new AttachmentBuilder()\n                .object(new ByteArrayInputStream(file.getContent()))\n                .contentDisposition(new ContentDisposition(dispositionValue))\n                .build();\n\n        return resource.request().accept(MediaType.APPLICATION_JSON).post(\n                entity(attachment, MediaType.MULTIPART_FORM_DATA), UploadFileResponse.class);\n    }",
            "  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71 +\n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  ",
            "    public UploadFileResponse uploadFile(ProcessDefinitionResponse processDefinition,\n            FileInput file) throws Exception {\n        WebTarget resource = webTarget\n            .path(\"portal/resource/process/{processName}/{processVersion}/API/formFileUpload\")\n            .resolveTemplate(\"processName\", processDefinition.getName())\n            .resolveTemplate(\"processVersion\", processDefinition.getVersion());\n\n        File tempFile = Files.createTempFile(\"tempFile\", \".tmp\").toFile();\n        FileOutputStream fos = new FileOutputStream(tempFile);\n        fos.write(file.getContent());\n        fos.close();\n\n        String dispositionValue = String.format(\"form-data;filename=%s;name=file\", tempFile.getName());\n        Attachment attachment = new AttachmentBuilder()\n                .object(new ByteArrayInputStream(file.getContent()))\n                .contentDisposition(new ContentDisposition(dispositionValue))\n                .build();\n\n        return resource.request().accept(MediaType.APPLICATION_JSON).post(\n                entity(attachment, MediaType.MULTIPART_FORM_DATA), UploadFileResponse.class);\n    }"
        ],
        [
            "CamelFilterWrapper::init(FilterConfig)",
            "  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60 -\n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  ",
            "    public void init(FilterConfig config) throws ServletException {\n        Object o = config.getServletContext().getAttribute(\"javax.servlet.context.tempdir\");\n        if (o == null) {\n            //when run in embedded mode, Jetty 8 will forget to set this property,\n            //but the MultiPartFilter requires it (will NPE if not set) so we'll \n            //go ahead and set it to the default tmp dir on the system.\n            try {\n                File file = File.createTempFile(\"camel\", \"\");\n                file.delete();\n                config.getServletContext().setAttribute(\"javax.servlet.context.tempdir\",\n                                                        file.getParentFile());\n            } catch (IOException e) {\n                //ignore\n            }\n        }\n        wrapped.init(config);\n    }",
            "  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61 +\n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  ",
            "    public void init(FilterConfig config) throws ServletException {\n        Object o = config.getServletContext().getAttribute(\"javax.servlet.context.tempdir\");\n        if (o == null) {\n            //when run in embedded mode, Jetty 8 will forget to set this property,\n            //but the MultiPartFilter requires it (will NPE if not set) so we'll \n            //go ahead and set it to the default tmp dir on the system.\n            try {\n                File file = Files.createTempFile(\"camel\", \"\").toFile();\n                file.delete();\n                config.getServletContext().setAttribute(\"javax.servlet.context.tempdir\",\n                                                        file.getParentFile());\n            } catch (IOException e) {\n                //ignore\n            }\n        }\n        wrapped.init(config);\n    }"
        ],
        [
            "getHfdsFileToTmpFile(String,HdfsConfiguration)",
            " 138  \n 139  \n 140  \n 141  \n 142 -\n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  ",
            "        private File getHfdsFileToTmpFile(String hdfsPath, HdfsConfiguration configuration) {\n            try {\n                String fname = hdfsPath.substring(hdfsPath.lastIndexOf('/'));\n\n                File outputDest = File.createTempFile(fname, \".hdfs\");\n                if (outputDest.exists()) {\n                    outputDest.delete();\n                }\n\n                HdfsInfo hdfsInfo = HdfsInfoFactory.newHdfsInfo(hdfsPath);\n                FileSystem fileSystem = hdfsInfo.getFileSystem();\n                FileUtil.copy(fileSystem, new Path(hdfsPath), outputDest, false, fileSystem.getConf());\n                try {\n                    FileUtil.copyMerge(\n                            fileSystem, // src\n                            new Path(hdfsPath),\n                            FileSystem.getLocal(new Configuration()), // dest\n                            new Path(outputDest.toURI()),\n                            false, fileSystem.getConf(), null);\n                } catch (IOException e) {\n                    return outputDest;\n                }\n\n                return new File(outputDest, fname);\n            } catch (IOException ex) {\n                throw new RuntimeCamelException(ex);\n            }\n        }",
            " 139  \n 140  \n 141  \n 142  \n 143 +\n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  ",
            "        private File getHfdsFileToTmpFile(String hdfsPath, HdfsConfiguration configuration) {\n            try {\n                String fname = hdfsPath.substring(hdfsPath.lastIndexOf('/'));\n\n                File outputDest = Files.createTempFile(fname, \".hdfs\").toFile();\n                if (outputDest.exists()) {\n                    outputDest.delete();\n                }\n\n                HdfsInfo hdfsInfo = HdfsInfoFactory.newHdfsInfo(hdfsPath);\n                FileSystem fileSystem = hdfsInfo.getFileSystem();\n                FileUtil.copy(fileSystem, new Path(hdfsPath), outputDest, false, fileSystem.getConf());\n                try {\n                    FileUtil.copyMerge(\n                            fileSystem, // src\n                            new Path(hdfsPath),\n                            FileSystem.getLocal(new Configuration()), // dest\n                            new Path(outputDest.toURI()),\n                            false, fileSystem.getConf(), null);\n                } catch (IOException e) {\n                    return outputDest;\n                }\n\n                return new File(outputDest, fname);\n            } catch (IOException ex) {\n                throw new RuntimeCamelException(ex);\n            }\n        }"
        ]
    ],
    "ae3e0e48de9cd0f85c76b589b57d7ff2bbf59c98": [
        [
            "ElasticsearchActionRequestConverter::toBulkRequest(Object,Exchange)",
            " 220  \n 221  \n 222  \n 223 -\n 224  \n 225  \n 226  \n 227 -\n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  ",
            "    @Converter\n    public static BulkRequest toBulkRequest(Object documents, Exchange exchange) {\n        if (documents instanceof BulkRequest) {\n            return (BulkRequest) documents;\n        }\n        if (documents instanceof List) {\n            BulkRequest request = new BulkRequest();\n            for (Object document : (List<Object>) documents) {\n                request.add(createIndexRequest(document, exchange));\n            }\n            return request;\n        } else {\n            throw new IllegalArgumentException(\"Wrong body type. Only BulkRequest or List is allowed as a type\");\n        }\n    }",
            " 200  \n 201  \n 202  \n 203 +\n 204  \n 205  \n 206  \n 207 +\n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  ",
            "    @Converter\n    public static BulkRequest toBulkRequest(Object documents, Exchange exchange) {\n        if (documents instanceof BulkRequest) {\n            return (BulkRequest)documents;\n        }\n        if (documents instanceof List) {\n            BulkRequest request = new BulkRequest();\n            for (Object document : (List<Object>)documents) {\n                request.add(createIndexRequest(document, exchange));\n            }\n            return request;\n        } else {\n            throw new IllegalArgumentException(\"Wrong body type. Only BulkRequest or List is allowed as a type\");\n        }\n    }"
        ],
        [
            "ElasticsearchActionRequestConverter::createUpdateRequest(Object,Exchange)",
            "  56  \n  57  \n  58 -\n  59  \n  60  \n  61  \n  62 -\n  63  \n  64 -\n  65  \n  66 -\n  67  \n  68 -\n  69  \n  70  \n  71  \n  72  \n  73 -\n  74 -\n  75 -\n  76 -\n  77 -\n  78 -\n  79 -\n  80 -\n  81 -\n  82  ",
            "    private static UpdateRequest createUpdateRequest(Object document, Exchange exchange) {\n        if (document instanceof UpdateRequest) {\n            return (UpdateRequest) document;\n        }\n        UpdateRequest updateRequest = new UpdateRequest();\n        if (document instanceof byte[]) {\n            updateRequest.doc((byte[]) document);\n        } else if (document instanceof Map) {\n            updateRequest.doc((Map<String, Object>) document);\n        } else if (document instanceof String) {\n            updateRequest.doc((String) document, XContentFactory.xContentType((String) document));\n        } else if (document instanceof XContentBuilder) {\n            updateRequest.doc((XContentBuilder) document);\n        } else {\n            return null;\n        }\n\n        return updateRequest\n            .waitForActiveShards(exchange.getIn().getHeader(\n                ElasticsearchConstants.PARAM_WAIT_FOR_ACTIVE_SHARDS, Integer.class))\n            .index(exchange.getIn().getHeader(\n                ElasticsearchConstants.PARAM_INDEX_NAME, String.class))\n            .type(exchange.getIn().getHeader(\n                ElasticsearchConstants.PARAM_INDEX_TYPE, String.class))\n            .id(exchange.getIn().getHeader(\n                ElasticsearchConstants.PARAM_INDEX_ID, String.class));\n    }",
            "  55  \n  56  \n  57 +\n  58  \n  59  \n  60  \n  61 +\n  62  \n  63 +\n  64  \n  65 +\n  66  \n  67 +\n  68  \n  69  \n  70  \n  71  \n  72 +\n  73 +\n  74 +\n  75 +\n  76  ",
            "    private static UpdateRequest createUpdateRequest(Object document, Exchange exchange) {\n        if (document instanceof UpdateRequest) {\n            return (UpdateRequest)document;\n        }\n        UpdateRequest updateRequest = new UpdateRequest();\n        if (document instanceof byte[]) {\n            updateRequest.doc((byte[])document);\n        } else if (document instanceof Map) {\n            updateRequest.doc((Map<String, Object>)document);\n        } else if (document instanceof String) {\n            updateRequest.doc((String)document, XContentFactory.xContentType((String)document));\n        } else if (document instanceof XContentBuilder) {\n            updateRequest.doc((XContentBuilder)document);\n        } else {\n            return null;\n        }\n\n        return updateRequest.waitForActiveShards(exchange.getIn().getHeader(ElasticsearchConstants.PARAM_WAIT_FOR_ACTIVE_SHARDS, Integer.class))\n            .index(exchange.getIn().getHeader(ElasticsearchConstants.PARAM_INDEX_NAME, String.class))\n            .type(exchange.getIn().getHeader(ElasticsearchConstants.PARAM_INDEX_TYPE, String.class))\n            .id(exchange.getIn().getHeader(ElasticsearchConstants.PARAM_INDEX_ID, String.class));\n    }"
        ],
        [
            "ElasticsearchActionRequestConverter::toUpdateRequest(Object,Exchange)",
            " 117  \n 118  \n 119 -\n 120 -\n 121  ",
            "    @Converter\n    public static UpdateRequest toUpdateRequest(Object document, Exchange exchange) {\n        return createUpdateRequest(document, exchange)\n            .id(exchange.getIn().getHeader(ElasticsearchConstants.PARAM_INDEX_ID, String.class));\n    }",
            " 106  \n 107  \n 108 +\n 109  ",
            "    @Converter\n    public static UpdateRequest toUpdateRequest(Object document, Exchange exchange) {\n        return createUpdateRequest(document, exchange).id(exchange.getIn().getHeader(ElasticsearchConstants.PARAM_INDEX_ID, String.class));\n    }"
        ],
        [
            "ElasticsearchActionRequestConverter::toDeleteRequest(Object,Exchange)",
            " 135  \n 136  \n 137  \n 138 -\n 139  \n 140  \n 141 -\n 142 -\n 143 -\n 144 -\n 145 -\n 146 -\n 147 -\n 148  \n 149  \n 150  \n 151  ",
            "    @Converter\n    public static DeleteRequest toDeleteRequest(Object document, Exchange exchange) {\n        if (document instanceof DeleteRequest) {\n            return (DeleteRequest) document;\n        }\n        if (document instanceof String) {\n            return new DeleteRequest()\n                .index(exchange.getIn().getHeader(\n                    ElasticsearchConstants.PARAM_INDEX_NAME,\n                    String.class))\n                .type(exchange.getIn().getHeader(\n                    ElasticsearchConstants.PARAM_INDEX_TYPE,\n                    String.class)).id((String) document);\n        } else {\n            throw new IllegalArgumentException(\"Wrong body type. Only DeleteRequest or String is allowed as a type\");\n        }\n    }",
            " 120  \n 121  \n 122  \n 123 +\n 124  \n 125  \n 126 +\n 127 +\n 128  \n 129  \n 130  \n 131  ",
            "    @Converter\n    public static DeleteRequest toDeleteRequest(Object document, Exchange exchange) {\n        if (document instanceof DeleteRequest) {\n            return (DeleteRequest)document;\n        }\n        if (document instanceof String) {\n            return new DeleteRequest().index(exchange.getIn().getHeader(ElasticsearchConstants.PARAM_INDEX_NAME, String.class))\n                .type(exchange.getIn().getHeader(ElasticsearchConstants.PARAM_INDEX_TYPE, String.class)).id((String)document);\n        } else {\n            throw new IllegalArgumentException(\"Wrong body type. Only DeleteRequest or String is allowed as a type\");\n        }\n    }"
        ],
        [
            "ElasticsearchActionRequestConverter::toIndexRequest(Object,Exchange)",
            " 111  \n 112  \n 113 -\n 114 -\n 115  ",
            "    @Converter\n    public static IndexRequest toIndexRequest(Object document, Exchange exchange) {\n        return createIndexRequest(document, exchange)\n            .id(exchange.getIn().getHeader(ElasticsearchConstants.PARAM_INDEX_ID, String.class));\n    }",
            " 101  \n 102  \n 103 +\n 104  ",
            "    @Converter\n    public static IndexRequest toIndexRequest(Object document, Exchange exchange) {\n        return createIndexRequest(document, exchange).id(exchange.getIn().getHeader(ElasticsearchConstants.PARAM_INDEX_ID, String.class));\n    }"
        ],
        [
            "ElasticsearchActionRequestConverter::toDeleteIndexRequest(Object,Exchange)",
            " 153  \n 154  \n 155  \n 156 -\n 157  \n 158  \n 159 -\n 160 -\n 161 -\n 162  \n 163  \n 164  \n 165  \n 166  ",
            "    @Converter\n    public static DeleteIndexRequest toDeleteIndexRequest(Object document, Exchange exchange) {\n        if (document instanceof DeleteIndexRequest) {\n            return (DeleteIndexRequest) document;\n        }\n        if (document instanceof String) {\n        \tString index = exchange.getIn().getHeader(\n                    ElasticsearchConstants.PARAM_INDEX_NAME,\n                    String.class);\n            return new DeleteIndexRequest(index);\n        } else {\n            throw new IllegalArgumentException(\"Wrong body type. Only DeleteIndexRequest or String is allowed as a type\");\n        }\n    }",
            " 133  \n 134  \n 135  \n 136 +\n 137  \n 138  \n 139 +\n 140  \n 141  \n 142  \n 143  \n 144  ",
            "    @Converter\n    public static DeleteIndexRequest toDeleteIndexRequest(Object document, Exchange exchange) {\n        if (document instanceof DeleteIndexRequest) {\n            return (DeleteIndexRequest)document;\n        }\n        if (document instanceof String) {\n            String index = exchange.getIn().getHeader(ElasticsearchConstants.PARAM_INDEX_NAME, String.class);\n            return new DeleteIndexRequest(index);\n        } else {\n            throw new IllegalArgumentException(\"Wrong body type. Only DeleteIndexRequest or String is allowed as a type\");\n        }\n    }"
        ],
        [
            "ElasticsearchActionRequestConverter::createIndexRequest(Object,Exchange)",
            "  85  \n  86  \n  87 -\n  88  \n  89  \n  90  \n  91 -\n  92  \n  93 -\n  94  \n  95 -\n  96  \n  97 -\n  98  \n  99  \n 100  \n 101  \n 102 -\n 103 -\n 104 -\n 105 -\n 106 -\n 107 -\n 108 -\n 109  ",
            "    private static IndexRequest createIndexRequest(Object document, Exchange exchange) {\n        if (document instanceof IndexRequest) {\n            return (IndexRequest) document;\n        }\n        IndexRequest indexRequest = new IndexRequest();\n        if (document instanceof byte[]) {\n            indexRequest.source((byte[]) document, XContentFactory.xContentType((byte[]) document));\n        } else if (document instanceof Map) {\n            indexRequest.source((Map<String, Object>) document);\n        } else if (document instanceof String) {\n            indexRequest.source((String) document, XContentFactory.xContentType((String) document));\n        } else if (document instanceof XContentBuilder) {\n            indexRequest.source((XContentBuilder) document);\n        } else {\n            return null;\n        }\n\n        return indexRequest\n            .waitForActiveShards(exchange.getIn().getHeader(\n                ElasticsearchConstants.PARAM_WAIT_FOR_ACTIVE_SHARDS, Integer.class))\n            .index(exchange.getIn().getHeader(\n                ElasticsearchConstants.PARAM_INDEX_NAME, String.class))\n            .type(exchange.getIn().getHeader(\n                ElasticsearchConstants.PARAM_INDEX_TYPE, String.class));\n    }",
            "  79  \n  80  \n  81 +\n  82  \n  83  \n  84  \n  85 +\n  86  \n  87 +\n  88  \n  89 +\n  90  \n  91 +\n  92  \n  93  \n  94  \n  95  \n  96 +\n  97 +\n  98 +\n  99  ",
            "    private static IndexRequest createIndexRequest(Object document, Exchange exchange) {\n        if (document instanceof IndexRequest) {\n            return (IndexRequest)document;\n        }\n        IndexRequest indexRequest = new IndexRequest();\n        if (document instanceof byte[]) {\n            indexRequest.source((byte[])document, XContentFactory.xContentType((byte[])document));\n        } else if (document instanceof Map) {\n            indexRequest.source((Map<String, Object>)document);\n        } else if (document instanceof String) {\n            indexRequest.source((String)document, XContentFactory.xContentType((String)document));\n        } else if (document instanceof XContentBuilder) {\n            indexRequest.source((XContentBuilder)document);\n        } else {\n            return null;\n        }\n\n        return indexRequest.waitForActiveShards(exchange.getIn().getHeader(ElasticsearchConstants.PARAM_WAIT_FOR_ACTIVE_SHARDS, Integer.class))\n            .index(exchange.getIn().getHeader(ElasticsearchConstants.PARAM_INDEX_NAME, String.class))\n            .type(exchange.getIn().getHeader(ElasticsearchConstants.PARAM_INDEX_TYPE, String.class));\n    }"
        ],
        [
            "ElasticsearchActionRequestConverter::toGetRequest(Object,Exchange)",
            " 123  \n 124  \n 125  \n 126 -\n 127  \n 128 -\n 129 -\n 130 -\n 131 -\n 132 -\n 133  ",
            "    @Converter\n    public static GetRequest toGetRequest(Object document, Exchange exchange) {\n        if (document instanceof GetRequest) {\n            return (GetRequest) document;\n        }\n        return new GetRequest(exchange.getIn().getHeader(\n            ElasticsearchConstants.PARAM_INDEX_NAME, String.class))\n            .type(exchange.getIn().getHeader(\n                ElasticsearchConstants.PARAM_INDEX_TYPE,\n                String.class)).id((String) document);\n    }",
            " 111  \n 112  \n 113  \n 114 +\n 115  \n 116 +\n 117 +\n 118  ",
            "    @Converter\n    public static GetRequest toGetRequest(Object document, Exchange exchange) {\n        if (document instanceof GetRequest) {\n            return (GetRequest)document;\n        }\n        return new GetRequest(exchange.getIn().getHeader(ElasticsearchConstants.PARAM_INDEX_NAME, String.class))\n            .type(exchange.getIn().getHeader(ElasticsearchConstants.PARAM_INDEX_TYPE, String.class)).id((String)document);\n    }"
        ],
        [
            "ElasticsearchActionRequestConverter::toSearchRequest(Object,Exchange)",
            " 168  \n 169  \n 170  \n 171 -\n 172  \n 173  \n 174  \n 175 -\n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189 -\n 190 -\n 191  \n 192 -\n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201 -\n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  ",
            "    @Converter\n    public static SearchRequest toSearchRequest(Object queryObject, Exchange exchange) throws IOException {\n        if (queryObject instanceof SearchRequest) {\n            return (SearchRequest) queryObject;\n        }\n        SearchRequest searchRequest = new SearchRequest();\n\n        // Only setup the indexName and indexType if the message header has the setting\n        String indexName = exchange.getIn().getHeader(ElasticsearchConstants.PARAM_INDEX_NAME, String.class);\n        String indexType = exchange.getIn().getHeader(ElasticsearchConstants.PARAM_INDEX_TYPE, String.class);\n        if (ObjectHelper.isNotEmpty(indexName)) {\n            searchRequest.indices(indexName);\n        }\n        if (ObjectHelper.isNotEmpty(indexType)) {\n            searchRequest.types(indexType);\n        }\n\n        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();\n        String queryText = null;\n\n        if (queryObject instanceof Map<?, ?>) {\n            Map<String, Object> mapQuery = (Map<String, Object>) queryObject;\n            // Remove 'query' prefix from the query object for backward compatibility\n            if (mapQuery.containsKey(ES_QUERY_DSL_PREFIX)) {\n                mapQuery = (Map<String, Object>) mapQuery.get(ES_QUERY_DSL_PREFIX);\n            }\n            try {\n                XContentBuilder contentBuilder = XContentFactory.contentBuilder(XContentType.JSON);\n                queryText = Strings.toString(contentBuilder.map(mapQuery));\n            } catch (IOException e) {\n                LOG.error(\"Cannot build the QueryText from the map.\", e);\n            }\n        } else if (queryObject instanceof String) {\n            queryText = (String) queryObject;\n            ObjectMapper mapper = new ObjectMapper();\n            JsonNode jsonTextObject = mapper.readValue(queryText, JsonNode.class);\n            JsonNode parentJsonNode = jsonTextObject.get(ES_QUERY_DSL_PREFIX);\n            if (parentJsonNode != null) {\n                queryText = parentJsonNode.toString();\n            }\n        } else {\n            // Cannot convert the queryObject into SearchRequest\n            LOG.info(\"Cannot convert queryObject into SearchRequest object\");\n            return null;\n        }\n\n        searchSourceBuilder.query(QueryBuilders.wrapperQuery(queryText));\n        searchRequest.source(searchSourceBuilder);\n\n        return searchRequest;\n    }",
            " 146  \n 147  \n 148  \n 149 +\n 150  \n 151  \n 152  \n 153 +\n 154 +\n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168 +\n 169 +\n 170 +\n 171  \n 172 +\n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181 +\n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  ",
            "    @Converter\n    public static SearchRequest toSearchRequest(Object queryObject, Exchange exchange) throws IOException {\n        if (queryObject instanceof SearchRequest) {\n            return (SearchRequest)queryObject;\n        }\n        SearchRequest searchRequest = new SearchRequest();\n\n        // Only setup the indexName and indexType if the message header has the\n        // setting\n        String indexName = exchange.getIn().getHeader(ElasticsearchConstants.PARAM_INDEX_NAME, String.class);\n        String indexType = exchange.getIn().getHeader(ElasticsearchConstants.PARAM_INDEX_TYPE, String.class);\n        if (ObjectHelper.isNotEmpty(indexName)) {\n            searchRequest.indices(indexName);\n        }\n        if (ObjectHelper.isNotEmpty(indexType)) {\n            searchRequest.types(indexType);\n        }\n\n        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();\n        String queryText = null;\n\n        if (queryObject instanceof Map<?, ?>) {\n            Map<String, Object> mapQuery = (Map<String, Object>)queryObject;\n            // Remove 'query' prefix from the query object for backward\n            // compatibility\n            if (mapQuery.containsKey(ES_QUERY_DSL_PREFIX)) {\n                mapQuery = (Map<String, Object>)mapQuery.get(ES_QUERY_DSL_PREFIX);\n            }\n            try {\n                XContentBuilder contentBuilder = XContentFactory.contentBuilder(XContentType.JSON);\n                queryText = Strings.toString(contentBuilder.map(mapQuery));\n            } catch (IOException e) {\n                LOG.error(\"Cannot build the QueryText from the map.\", e);\n            }\n        } else if (queryObject instanceof String) {\n            queryText = (String)queryObject;\n            ObjectMapper mapper = new ObjectMapper();\n            JsonNode jsonTextObject = mapper.readValue(queryText, JsonNode.class);\n            JsonNode parentJsonNode = jsonTextObject.get(ES_QUERY_DSL_PREFIX);\n            if (parentJsonNode != null) {\n                queryText = parentJsonNode.toString();\n            }\n        } else {\n            // Cannot convert the queryObject into SearchRequest\n            LOG.info(\"Cannot convert queryObject into SearchRequest object\");\n            return null;\n        }\n\n        searchSourceBuilder.query(QueryBuilders.wrapperQuery(queryText));\n        searchRequest.source(searchSourceBuilder);\n\n        return searchRequest;\n    }"
        ]
    ],
    "a2fd6ad6ef25cff793e4f69a0fcc5e0d7bf79f06": [
        [
            "ClassComponent::createEndpoint(String,String,Map)",
            "  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49 -\n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  ",
            "    @Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        ClassEndpoint endpoint = new ClassEndpoint(uri, this);\n        endpoint.setBeanName(remaining);\n\n        // bean name is the FQN\n        String name = endpoint.getBeanName();\n        Class<?> clazz = getCamelContext().getClassResolver().resolveMandatoryClass(name);\n\n        // the bean.xxx options is for the bean\n        Map<String, Object> options = IntrospectionSupport.extractProperties(parameters, \"bean.\");\n        endpoint.setParameters(options);\n\n        BeanHolder holder;\n\n        // if there is options then we need to create a bean instance\n        if (!options.isEmpty()) {\n            // create bean\n            Object bean = getCamelContext().getInjector().newInstance(clazz);\n\n            // now set additional properties on it\n            setProperties(bean, options);\n\n            holder = new ConstantBeanHolder(bean, getCamelContext());\n        } else {\n            // otherwise refer to the type\n            holder = new ConstantTypeBeanHolder(clazz, getCamelContext());\n        }\n\n        validateParameters(uri, options, null);\n\n        // and register the bean as a holder on the endpoint\n        endpoint.setBeanHolder(holder);\n\n        return endpoint;\n    }",
            "  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49 +\n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  ",
            "    @Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        ClassEndpoint endpoint = new ClassEndpoint(uri, this);\n        endpoint.setBeanName(remaining);\n\n        // bean name is the FQN\n        String name = endpoint.getBeanName();\n        Class<?> clazz = getCamelContext().getClassResolver().resolveMandatoryClass(name);\n\n        // the bean.xxx options is for the bean\n        Map<String, Object> options = PropertiesHelper.extractProperties(parameters, \"bean.\");\n        endpoint.setParameters(options);\n\n        BeanHolder holder;\n\n        // if there is options then we need to create a bean instance\n        if (!options.isEmpty()) {\n            // create bean\n            Object bean = getCamelContext().getInjector().newInstance(clazz);\n\n            // now set additional properties on it\n            setProperties(bean, options);\n\n            holder = new ConstantBeanHolder(bean, getCamelContext());\n        } else {\n            // otherwise refer to the type\n            holder = new ConstantTypeBeanHolder(clazz, getCamelContext());\n        }\n\n        validateParameters(uri, options, null);\n\n        // and register the bean as a holder on the endpoint\n        endpoint.setBeanHolder(holder);\n\n        return endpoint;\n    }"
        ],
        [
            "SWFComponent::createEndpoint(String,String,Map)",
            "  55  \n  56  \n  57 -\n  58 -\n  59 -\n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  ",
            "    @Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        Map<String, Object> clientConfigurationParameters = IntrospectionSupport.extractProperties(parameters, \"clientConfiguration.\");\n        Map<String, Object> sWClientParameters = IntrospectionSupport.extractProperties(parameters, \"sWClient.\");\n        Map<String, Object> startWorkflowOptionsParameters = IntrospectionSupport.extractProperties(parameters, \"startWorkflowOptions.\");\n\n        SWFConfiguration configuration = this.configuration.copy();\n        configuration.setType(remaining);\n        setProperties(configuration, parameters);\n        configuration.setClientConfigurationParameters(clientConfigurationParameters);\n        configuration.setSWClientParameters(sWClientParameters);\n        configuration.setStartWorkflowOptionsParameters(startWorkflowOptionsParameters);\n        \n        if (ObjectHelper.isEmpty(configuration.getAccessKey())) {\n            setAccessKey(accessKey);\n        }\n        if (ObjectHelper.isEmpty(configuration.getSecretKey())) {\n            setSecretKey(secretKey);\n        }\n        if (ObjectHelper.isEmpty(configuration.getRegion())) {\n            setRegion(region);\n        }\n        checkAndSetRegistryClient(configuration);\n        if (configuration.getAmazonSWClient() == null && (configuration.getAccessKey() == null || configuration.getSecretKey() == null)) {\n            throw new IllegalArgumentException(\"AmazonSWClient or accessKey and secretKey must be specified.\");\n        }\n        return new SWFEndpoint(uri, this, configuration);\n    }",
            "  55  \n  56  \n  57 +\n  58 +\n  59 +\n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  ",
            "    @Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        Map<String, Object> clientConfigurationParameters = PropertiesHelper.extractProperties(parameters, \"clientConfiguration.\");\n        Map<String, Object> sWClientParameters = PropertiesHelper.extractProperties(parameters, \"sWClient.\");\n        Map<String, Object> startWorkflowOptionsParameters = PropertiesHelper.extractProperties(parameters, \"startWorkflowOptions.\");\n\n        SWFConfiguration configuration = this.configuration.copy();\n        configuration.setType(remaining);\n        setProperties(configuration, parameters);\n        configuration.setClientConfigurationParameters(clientConfigurationParameters);\n        configuration.setSWClientParameters(sWClientParameters);\n        configuration.setStartWorkflowOptionsParameters(startWorkflowOptionsParameters);\n        \n        if (ObjectHelper.isEmpty(configuration.getAccessKey())) {\n            setAccessKey(accessKey);\n        }\n        if (ObjectHelper.isEmpty(configuration.getSecretKey())) {\n            setSecretKey(secretKey);\n        }\n        if (ObjectHelper.isEmpty(configuration.getRegion())) {\n            setRegion(region);\n        }\n        checkAndSetRegistryClient(configuration);\n        if (configuration.getAmazonSWClient() == null && (configuration.getAccessKey() == null || configuration.getSecretKey() == null)) {\n            throw new IllegalArgumentException(\"AmazonSWClient or accessKey and secretKey must be specified.\");\n        }\n        return new SWFEndpoint(uri, this, configuration);\n    }"
        ],
        [
            "CxfComponent::createEndpoint(String,String,Map)",
            "  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123 -\n 124 -\n 125 -\n 126 -\n 127  \n 128  \n 129 -\n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  ",
            "    /**\n     * Create a {@link CxfEndpoint} which, can be a Spring bean endpoint having\n     * URI format cxf:bean:<i>beanId</i> or transport address endpoint having URI format\n     * cxf://<i>transportAddress</i>.\n     */\n    @Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n\n        CxfEndpoint result;\n\n        Object value = parameters.remove(\"setDefaultBus\");\n        if (value != null) {\n            log.warn(\"The option setDefaultBus is @deprecated, use name defaultBus instead\");\n            if (!parameters.containsKey(\"defaultBus\")) {\n                parameters.put(\"defaultBus\", value);\n            }\n        }\n\n        if (allowStreaming != null && !parameters.containsKey(\"allowStreaming\")) {\n            parameters.put(\"allowStreaming\", Boolean.toString(allowStreaming));\n        }\n\n        if (remaining.startsWith(CxfConstants.SPRING_CONTEXT_ENDPOINT)) {\n            // Get the bean from the Spring context\n            String beanId = remaining.substring(CxfConstants.SPRING_CONTEXT_ENDPOINT.length());\n            if (beanId.startsWith(\"//\")) {\n                beanId = beanId.substring(2);\n            }\n\n            result = createCxfSpringEndpoint(beanId);\n            // need to check the CamelContext value\n            if (getCamelContext().equals(result.getCamelContext())) {\n                result.setCamelContext(getCamelContext());\n            }\n            result.setBeanId(beanId);\n\n        } else {\n            // endpoint URI does not specify a bean\n            result = createCxfEndpoint(remaining);\n        }\n\n        if (result.getCamelContext() == null) {\n            result.setCamelContext(getCamelContext());\n        }\n        setEndpointHeaderFilterStrategy(result);\n        setProperties(result, parameters);\n\n        // extract the properties.xxx and set them as properties\n        Map<String, Object> properties = IntrospectionSupport.extractProperties(parameters, \"properties.\");\n        if (properties != null) {\n            result.setProperties(properties);\n        }\n        if (result.getProperties() != null) {\n            // set the properties of MTOM\n            result.setMtomEnabled(Boolean.valueOf((String) result.getProperties().get(Message.MTOM_ENABLED)));\n        }\n\n        // use global ssl config if set\n        if (result.getSslContextParameters() == null) {\n            result.setSslContextParameters(retrieveGlobalSslContextParameters());\n        }\n\n        return result;\n    }",
            "  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123 +\n 124 +\n 125 +\n 126  \n 127  \n 128 +\n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  ",
            "    /**\n     * Create a {@link CxfEndpoint} which, can be a Spring bean endpoint having\n     * URI format cxf:bean:<i>beanId</i> or transport address endpoint having URI format\n     * cxf://<i>transportAddress</i>.\n     */\n    @Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n\n        CxfEndpoint result;\n\n        Object value = parameters.remove(\"setDefaultBus\");\n        if (value != null) {\n            log.warn(\"The option setDefaultBus is @deprecated, use name defaultBus instead\");\n            if (!parameters.containsKey(\"defaultBus\")) {\n                parameters.put(\"defaultBus\", value);\n            }\n        }\n\n        if (allowStreaming != null && !parameters.containsKey(\"allowStreaming\")) {\n            parameters.put(\"allowStreaming\", Boolean.toString(allowStreaming));\n        }\n\n        if (remaining.startsWith(CxfConstants.SPRING_CONTEXT_ENDPOINT)) {\n            // Get the bean from the Spring context\n            String beanId = remaining.substring(CxfConstants.SPRING_CONTEXT_ENDPOINT.length());\n            if (beanId.startsWith(\"//\")) {\n                beanId = beanId.substring(2);\n            }\n\n            result = createCxfSpringEndpoint(beanId);\n            // need to check the CamelContext value\n            if (getCamelContext().equals(result.getCamelContext())) {\n                result.setCamelContext(getCamelContext());\n            }\n            result.setBeanId(beanId);\n\n        } else {\n            // endpoint URI does not specify a bean\n            result = createCxfEndpoint(remaining);\n        }\n\n        if (result.getCamelContext() == null) {\n            result.setCamelContext(getCamelContext());\n        }\n        setEndpointHeaderFilterStrategy(result);\n        setProperties(result, parameters);\n\n        // extract the properties.xxx and set them as properties\n        Map<String, Object> properties = PropertiesHelper.extractProperties(parameters, \"properties.\");\n        result.setProperties(properties);\n\n        if (result.getProperties() != null) {\n            // set the properties of MTOM\n            result.setMtomEnabled(Boolean.parseBoolean((String) result.getProperties().get(Message.MTOM_ENABLED)));\n        }\n\n        // use global ssl config if set\n        if (result.getSslContextParameters() == null) {\n            result.setSslContextParameters(retrieveGlobalSslContextParameters());\n        }\n\n        return result;\n    }"
        ],
        [
            "ElsqlComponent::createEndpoint(String,String,Map)",
            "  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66 -\n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  ",
            "    @Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        DataSource target = null;\n\n        // endpoint options overrule component configured datasource\n        DataSource ds = resolveAndRemoveReferenceParameter(parameters, \"dataSource\", DataSource.class);\n        if (ds != null) {\n            target = ds;\n        }\n        String dataSourceRef = getAndRemoveParameter(parameters, \"dataSourceRef\", String.class);\n        if (target == null && dataSourceRef != null) {\n            target = CamelContextHelper.mandatoryLookup(getCamelContext(), dataSourceRef, DataSource.class);\n        }\n        if (target == null) {\n            // fallback and use component\n            target = getDataSource();\n        }\n        if (target == null) {\n            throw new IllegalArgumentException(\"DataSource must be configured\");\n        }\n\n        NamedParameterJdbcTemplate jdbcTemplate = new NamedParameterJdbcTemplate(target);\n        Map<String, Object> params = IntrospectionSupport.extractProperties(parameters, \"template.\");\n        PropertyBindingSupport.bindProperties(getCamelContext(), jdbcTemplate, params);\n\n        String elsqlName = remaining;\n        String resUri = resourceUri;\n        String[] part = remaining.split(\":\");\n        if (part.length == 2) {\n            elsqlName = part[0];\n            resUri = part[1];\n        } else if (part.length > 2) {\n            throw new IllegalArgumentException(\"Invalid uri. Must by elsql:elsqlName:resourceUri, was: \" + uri);\n        }\n\n        String onConsume = getAndRemoveParameter(parameters, \"consumer.onConsume\", String.class);\n        if (onConsume == null) {\n            onConsume = getAndRemoveParameter(parameters, \"onConsume\", String.class);\n        }\n        String onConsumeFailed = getAndRemoveParameter(parameters, \"consumer.onConsumeFailed\", String.class);\n        if (onConsumeFailed == null) {\n            onConsumeFailed = getAndRemoveParameter(parameters, \"onConsumeFailed\", String.class);\n        }\n        String onConsumeBatchComplete = getAndRemoveParameter(parameters, \"consumer.onConsumeBatchComplete\", String.class);\n        if (onConsumeBatchComplete == null) {\n            onConsumeBatchComplete = getAndRemoveParameter(parameters, \"onConsumeBatchComplete\", String.class);\n        }\n\n        ElsqlEndpoint endpoint = new ElsqlEndpoint(uri, this, jdbcTemplate, target, elsqlName, resUri);\n        endpoint.setElSqlConfig(elSqlConfig);\n        endpoint.setDatabaseVendor(databaseVendor);\n        endpoint.setDataSource(target);\n        endpoint.setDataSourceRef(dataSourceRef);\n        endpoint.setOnConsume(onConsume);\n        endpoint.setOnConsumeFailed(onConsumeFailed);\n        endpoint.setOnConsumeBatchComplete(onConsumeBatchComplete);\n        return endpoint;\n    }",
            "  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66 +\n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  ",
            "    @Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        DataSource target = null;\n\n        // endpoint options overrule component configured datasource\n        DataSource ds = resolveAndRemoveReferenceParameter(parameters, \"dataSource\", DataSource.class);\n        if (ds != null) {\n            target = ds;\n        }\n        String dataSourceRef = getAndRemoveParameter(parameters, \"dataSourceRef\", String.class);\n        if (target == null && dataSourceRef != null) {\n            target = CamelContextHelper.mandatoryLookup(getCamelContext(), dataSourceRef, DataSource.class);\n        }\n        if (target == null) {\n            // fallback and use component\n            target = getDataSource();\n        }\n        if (target == null) {\n            throw new IllegalArgumentException(\"DataSource must be configured\");\n        }\n\n        NamedParameterJdbcTemplate jdbcTemplate = new NamedParameterJdbcTemplate(target);\n        Map<String, Object> params = PropertiesHelper.extractProperties(parameters, \"template.\");\n        PropertyBindingSupport.bindProperties(getCamelContext(), jdbcTemplate, params);\n\n        String elsqlName = remaining;\n        String resUri = resourceUri;\n        String[] part = remaining.split(\":\");\n        if (part.length == 2) {\n            elsqlName = part[0];\n            resUri = part[1];\n        } else if (part.length > 2) {\n            throw new IllegalArgumentException(\"Invalid uri. Must by elsql:elsqlName:resourceUri, was: \" + uri);\n        }\n\n        String onConsume = getAndRemoveParameter(parameters, \"consumer.onConsume\", String.class);\n        if (onConsume == null) {\n            onConsume = getAndRemoveParameter(parameters, \"onConsume\", String.class);\n        }\n        String onConsumeFailed = getAndRemoveParameter(parameters, \"consumer.onConsumeFailed\", String.class);\n        if (onConsumeFailed == null) {\n            onConsumeFailed = getAndRemoveParameter(parameters, \"onConsumeFailed\", String.class);\n        }\n        String onConsumeBatchComplete = getAndRemoveParameter(parameters, \"consumer.onConsumeBatchComplete\", String.class);\n        if (onConsumeBatchComplete == null) {\n            onConsumeBatchComplete = getAndRemoveParameter(parameters, \"onConsumeBatchComplete\", String.class);\n        }\n\n        ElsqlEndpoint endpoint = new ElsqlEndpoint(uri, this, jdbcTemplate, target, elsqlName, resUri);\n        endpoint.setElSqlConfig(elSqlConfig);\n        endpoint.setDatabaseVendor(databaseVendor);\n        endpoint.setDataSource(target);\n        endpoint.setDataSourceRef(dataSourceRef);\n        endpoint.setOnConsume(onConsume);\n        endpoint.setOnConsumeFailed(onConsumeFailed);\n        endpoint.setOnConsumeBatchComplete(onConsumeBatchComplete);\n        return endpoint;\n    }"
        ],
        [
            "BeanComponent::createEndpoint(String,String,Map)",
            "  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56 -\n  57  \n  58  \n  59  ",
            "    @Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        BeanEndpoint endpoint = new BeanEndpoint(uri, this);\n        endpoint.setBeanName(remaining);\n        endpoint.setCache(cache);\n        setProperties(endpoint, parameters);\n\n        // the bean.xxx options is for the bean\n        Map<String, Object> options = IntrospectionSupport.extractProperties(parameters, \"bean.\");\n        endpoint.setParameters(options);\n        return endpoint;\n    }",
            "  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56 +\n  57  \n  58  \n  59  ",
            "    @Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        BeanEndpoint endpoint = new BeanEndpoint(uri, this);\n        endpoint.setBeanName(remaining);\n        endpoint.setCache(cache);\n        setProperties(endpoint, parameters);\n\n        // the bean.xxx options is for the bean\n        Map<String, Object> options = PropertiesHelper.extractProperties(parameters, \"bean.\");\n        endpoint.setParameters(options);\n        return endpoint;\n    }"
        ],
        [
            "FopProducer::setUserAgentRendererOptions(FOUserAgent,Map)",
            " 113  \n 114 -\n 115  \n 116  \n 117  \n 118  ",
            "    private void setUserAgentRendererOptions(FOUserAgent userAgent, Map<String, Object> headers) {\n        Map<String, Object> parameters = IntrospectionSupport.extractProperties(headers, FopConstants.CAMEL_FOP_RENDERER_OPTIONS);\n        if (!parameters.isEmpty()) {\n            userAgent.getRendererOptions().putAll(parameters);\n        }\n    }",
            " 112  \n 113 +\n 114  \n 115  \n 116  \n 117  ",
            "    private void setUserAgentRendererOptions(FOUserAgent userAgent, Map<String, Object> headers) {\n        Map<String, Object> parameters = PropertiesHelper.extractProperties(headers, FopConstants.CAMEL_FOP_RENDERER_OPTIONS);\n        if (!parameters.isEmpty()) {\n            userAgent.getRendererOptions().putAll(parameters);\n        }\n    }"
        ],
        [
            "FopProducer::setEncryptionParameters(FOUserAgent,Map)",
            " 101  \n 102 -\n 103 -\n 104 -\n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  ",
            "    @SuppressWarnings(\"unchecked\")\n    private void setEncryptionParameters(FOUserAgent userAgent, Map<String, Object> headers)\n        throws Exception {\n        Map<String, Object> encryptionParameters = IntrospectionSupport\n            .extractProperties(headers, FopConstants.CAMEL_FOP_ENCRYPT);\n        if (!encryptionParameters.isEmpty()) {\n            PDFEncryptionParams encryptionParams = new PDFEncryptionParams();\n            PropertyBindingSupport.bindProperties(getEndpoint().getCamelContext(), encryptionParams, encryptionParameters);\n            userAgent.getRendererOptions().put(\"encryption-params\", encryptionParams);\n        }\n    }",
            " 101  \n 102 +\n 103 +\n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  ",
            "    @SuppressWarnings(\"unchecked\")\n    private void setEncryptionParameters(FOUserAgent userAgent, Map<String, Object> headers) {\n        Map<String, Object> encryptionParameters = PropertiesHelper\n            .extractProperties(headers, FopConstants.CAMEL_FOP_ENCRYPT);\n        if (!encryptionParameters.isEmpty()) {\n            PDFEncryptionParams encryptionParams = new PDFEncryptionParams();\n            PropertyBindingSupport.bindProperties(getEndpoint().getCamelContext(), encryptionParams, encryptionParameters);\n            userAgent.getRendererOptions().put(\"encryption-params\", encryptionParams);\n        }\n    }"
        ],
        [
            "ActiveMQComponent::convertPathToActualDestination(String,Map)",
            " 167  \n 168  \n 169  \n 170  \n 171  \n 172 -\n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  ",
            "    @Override\n    @SuppressWarnings(\"unchecked\")\n    protected String convertPathToActualDestination(String path, Map<String, Object> parameters) {\n        // support ActiveMQ destination options using the destination. prefix\n        // http://activemq.apache.org/destination-options.html\n        Map options = IntrospectionSupport.extractProperties(parameters, \"destination.\");\n\n        String query;\n        try {\n            query = URISupport.createQueryString(options);\n        } catch (URISyntaxException e) {\n            throw RuntimeCamelException.wrapRuntimeCamelException(e);\n        }\n\n        // if we have destination options then append them to the destination\n        // name\n        if (ObjectHelper.isNotEmpty(query)) {\n            return path + \"?\" + query;\n        } else {\n            return path;\n        }\n    }",
            " 167  \n 168  \n 169  \n 170  \n 171  \n 172 +\n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  ",
            "    @Override\n    @SuppressWarnings(\"unchecked\")\n    protected String convertPathToActualDestination(String path, Map<String, Object> parameters) {\n        // support ActiveMQ destination options using the destination. prefix\n        // http://activemq.apache.org/destination-options.html\n        Map options = PropertiesHelper.extractProperties(parameters, \"destination.\");\n\n        String query;\n        try {\n            query = URISupport.createQueryString(options);\n        } catch (URISyntaxException e) {\n            throw RuntimeCamelException.wrapRuntimeCamelException(e);\n        }\n\n        // if we have destination options then append them to the destination\n        // name\n        if (ObjectHelper.isNotEmpty(query)) {\n            return path + \"?\" + query;\n        } else {\n            return path;\n        }\n    }"
        ],
        [
            "AbstractAtomixClientComponent::setConfigurationProperties(C,Map)",
            "  84  \n  85  \n  86 -\n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99 -\n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  ",
            "    protected C setConfigurationProperties(C configuration, Map<String, Object> parameters) throws Exception {\n        // Resolve config for named maps\n        Map<String, Object> configs = IntrospectionSupport.extractProperties(parameters, \"resource.config.\");\n        for (Map.Entry<String, Object> entry : configs.entrySet()) {\n            String ref = (String)entry.getValue();\n            if (!EndpointHelper.isReferenceParameter(ref)) {\n                throw new IllegalArgumentException(\"The option resource.config.\" + ref + \" should be a reference\");\n            }\n\n            configuration.addResourceConfig(\n                entry.getKey(),\n                EndpointHelper.resolveReferenceParameter(getCamelContext(), ref, Properties.class));\n        }\n\n        // Resolve options for named maps\n        Map<String, Object> options = IntrospectionSupport.extractProperties(parameters, \"resource.options.\");\n        for (Map.Entry<String, Object> entry : options.entrySet()) {\n            String ref = (String)entry.getValue();\n            if (!EndpointHelper.isReferenceParameter(ref)) {\n                throw new IllegalArgumentException(\"The option resource.options.\" + ref + \" should be a reference\");\n            }\n\n            configuration.addResourceOption(\n                entry.getKey(),\n                EndpointHelper.resolveReferenceParameter(getCamelContext(), ref, Properties.class));\n        }\n\n        setProperties(configuration, parameters);\n\n        return configuration;\n    }",
            "  84  \n  85  \n  86 +\n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99 +\n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  ",
            "    protected C setConfigurationProperties(C configuration, Map<String, Object> parameters) throws Exception {\n        // Resolve config for named maps\n        Map<String, Object> configs = PropertiesHelper.extractProperties(parameters, \"resource.config.\");\n        for (Map.Entry<String, Object> entry : configs.entrySet()) {\n            String ref = (String)entry.getValue();\n            if (!EndpointHelper.isReferenceParameter(ref)) {\n                throw new IllegalArgumentException(\"The option resource.config.\" + ref + \" should be a reference\");\n            }\n\n            configuration.addResourceConfig(\n                entry.getKey(),\n                EndpointHelper.resolveReferenceParameter(getCamelContext(), ref, Properties.class));\n        }\n\n        // Resolve options for named maps\n        Map<String, Object> options = PropertiesHelper.extractProperties(parameters, \"resource.options.\");\n        for (Map.Entry<String, Object> entry : options.entrySet()) {\n            String ref = (String)entry.getValue();\n            if (!EndpointHelper.isReferenceParameter(ref)) {\n                throw new IllegalArgumentException(\"The option resource.options.\" + ref + \" should be a reference\");\n            }\n\n            configuration.addResourceOption(\n                entry.getKey(),\n                EndpointHelper.resolveReferenceParameter(getCamelContext(), ref, Properties.class));\n        }\n\n        setProperties(configuration, parameters);\n\n        return configuration;\n    }"
        ],
        [
            "AhcComponent::createEndpoint(String,String,Map)",
            "  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86 -\n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106 -\n 107  \n 108  \n 109 -\n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130 -\n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  ",
            "    @Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        String addressUri = createAddressUri(uri, remaining);\n\n        SSLContextParameters ssl = getSslContextParameters();\n        if (ssl == null) {\n            ssl = retrieveGlobalSslContextParameters();\n        }\n\n        // Do not set the HTTP URI because we still have all of the Camel internal\n        // parameters in the URI at this point.\n        AhcEndpoint endpoint = createAhcEndpoint(uri, this, null);\n        setEndpointHeaderFilterStrategy(endpoint);\n        endpoint.setClient(getClient());\n        endpoint.setClientConfig(getClientConfig());\n        endpoint.setBinding(getBinding());\n        endpoint.setSslContextParameters(ssl);\n        \n        setProperties(endpoint, parameters);\n\n        if (IntrospectionSupport.hasProperties(parameters, CLIENT_CONFIG_PREFIX)) {\n            DefaultAsyncHttpClientConfig.Builder builder = endpoint.getClientConfig() == null\n                    ? new DefaultAsyncHttpClientConfig.Builder() : AhcComponent.cloneConfig(endpoint.getClientConfig());\n            \n            if (endpoint.getClient() != null) {\n                log.warn(\"The user explicitly set an AsyncHttpClient instance on the component or \"\n                         + \"endpoint, but this endpoint URI contains client configuration parameters.  \"\n                         + \"Are you sure that this is what was intended?  The AsyncHttpClient will be used\"\n                         + \" and the URI parameters will be ignored.\");\n            } else if (endpoint.getClientConfig() != null) {\n                log.warn(\"The user explicitly set an AsyncHttpClientConfig instance on the component or \"\n                         + \"endpoint, but this endpoint URI contains client configuration parameters.  \"\n                         + \"Are you sure that this is what was intended?  The URI parameters will be applied\"\n                         + \" to a clone of the supplied AsyncHttpClientConfig in order to prevent unintended modification\"\n                         + \" of the explicitly configured AsyncHttpClientConfig.  That is, the URI parameters override the\"\n                         + \" settings on the explicitly configured AsyncHttpClientConfig for this endpoint.\");\n            }\n\n            // special for realm builder\n            Builder realmBuilder = null;\n            if (IntrospectionSupport.hasProperties(parameters, CLIENT_REALM_CONFIG_PREFIX)) {\n\n                // set and validate additional parameters on client config\n                Map<String, Object> realmParams = IntrospectionSupport.extractProperties(parameters, CLIENT_REALM_CONFIG_PREFIX);\n\n                // copy the parameters for the endpoint to have\n                endpoint.setClientConfigRealmOptions(new LinkedHashMap<>(realmParams));\n\n                Object principal = realmParams.remove(\"principal\");\n                Object password = realmParams.remove(\"password\");\n\n                if (ObjectHelper.isEmpty(principal)) {\n                    throw new IllegalArgumentException(CLIENT_REALM_CONFIG_PREFIX + \".principal must be configured\");\n                }\n                if (password == null) {\n                    password = \"\";\n                }\n\n                realmBuilder = new Realm.Builder(principal.toString(), password.toString());\n                setProperties(realmBuilder, realmParams);\n                validateParameters(uri, realmParams, null);\n            }\n            \n            // set and validate additional parameters on client config\n            Map<String, Object> clientParams = IntrospectionSupport.extractProperties(parameters, CLIENT_CONFIG_PREFIX);\n\n            // copy the parameters for the endpoint to have\n            endpoint.setClientConfigOptions(new LinkedHashMap<>(clientParams));\n\n            setProperties(builder, clientParams);\n            validateParameters(uri, clientParams, null);\n\n            if (realmBuilder != null) {\n                builder.setRealm(realmBuilder.build());\n            }\n            endpoint.setClientConfig(builder.build());\n        }\n\n        // restructure uri to be based on the parameters left as we dont want to include the Camel internal options\n        addressUri = UnsafeUriCharactersEncoder.encodeHttpURI(addressUri);\n        URI httpUri = URISupport.createRemainingURI(new URI(addressUri), parameters);\n        endpoint.setHttpUri(httpUri);\n        \n        return endpoint;\n    }",
            "  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86 +\n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106 +\n 107  \n 108  \n 109 +\n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130 +\n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  ",
            "    @Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        String addressUri = createAddressUri(uri, remaining);\n\n        SSLContextParameters ssl = getSslContextParameters();\n        if (ssl == null) {\n            ssl = retrieveGlobalSslContextParameters();\n        }\n\n        // Do not set the HTTP URI because we still have all of the Camel internal\n        // parameters in the URI at this point.\n        AhcEndpoint endpoint = createAhcEndpoint(uri, this, null);\n        setEndpointHeaderFilterStrategy(endpoint);\n        endpoint.setClient(getClient());\n        endpoint.setClientConfig(getClientConfig());\n        endpoint.setBinding(getBinding());\n        endpoint.setSslContextParameters(ssl);\n        \n        setProperties(endpoint, parameters);\n\n        if (PropertiesHelper.hasProperties(parameters, CLIENT_CONFIG_PREFIX)) {\n            DefaultAsyncHttpClientConfig.Builder builder = endpoint.getClientConfig() == null\n                    ? new DefaultAsyncHttpClientConfig.Builder() : AhcComponent.cloneConfig(endpoint.getClientConfig());\n            \n            if (endpoint.getClient() != null) {\n                log.warn(\"The user explicitly set an AsyncHttpClient instance on the component or \"\n                         + \"endpoint, but this endpoint URI contains client configuration parameters.  \"\n                         + \"Are you sure that this is what was intended?  The AsyncHttpClient will be used\"\n                         + \" and the URI parameters will be ignored.\");\n            } else if (endpoint.getClientConfig() != null) {\n                log.warn(\"The user explicitly set an AsyncHttpClientConfig instance on the component or \"\n                         + \"endpoint, but this endpoint URI contains client configuration parameters.  \"\n                         + \"Are you sure that this is what was intended?  The URI parameters will be applied\"\n                         + \" to a clone of the supplied AsyncHttpClientConfig in order to prevent unintended modification\"\n                         + \" of the explicitly configured AsyncHttpClientConfig.  That is, the URI parameters override the\"\n                         + \" settings on the explicitly configured AsyncHttpClientConfig for this endpoint.\");\n            }\n\n            // special for realm builder\n            Builder realmBuilder = null;\n            if (PropertiesHelper.hasProperties(parameters, CLIENT_REALM_CONFIG_PREFIX)) {\n\n                // set and validate additional parameters on client config\n                Map<String, Object> realmParams = PropertiesHelper.extractProperties(parameters, CLIENT_REALM_CONFIG_PREFIX);\n\n                // copy the parameters for the endpoint to have\n                endpoint.setClientConfigRealmOptions(new LinkedHashMap<>(realmParams));\n\n                Object principal = realmParams.remove(\"principal\");\n                Object password = realmParams.remove(\"password\");\n\n                if (ObjectHelper.isEmpty(principal)) {\n                    throw new IllegalArgumentException(CLIENT_REALM_CONFIG_PREFIX + \".principal must be configured\");\n                }\n                if (password == null) {\n                    password = \"\";\n                }\n\n                realmBuilder = new Realm.Builder(principal.toString(), password.toString());\n                setProperties(realmBuilder, realmParams);\n                validateParameters(uri, realmParams, null);\n            }\n            \n            // set and validate additional parameters on client config\n            Map<String, Object> clientParams = PropertiesHelper.extractProperties(parameters, CLIENT_CONFIG_PREFIX);\n\n            // copy the parameters for the endpoint to have\n            endpoint.setClientConfigOptions(new LinkedHashMap<>(clientParams));\n\n            setProperties(builder, clientParams);\n            validateParameters(uri, clientParams, null);\n\n            if (realmBuilder != null) {\n                builder.setRealm(realmBuilder.build());\n            }\n            endpoint.setClientConfig(builder.build());\n        }\n\n        // restructure uri to be based on the parameters left as we dont want to include the Camel internal options\n        addressUri = UnsafeUriCharactersEncoder.encodeHttpURI(addressUri);\n        URI httpUri = URISupport.createRemainingURI(new URI(addressUri), parameters);\n        endpoint.setHttpUri(httpUri);\n        \n        return endpoint;\n    }"
        ],
        [
            "FopProducer::setRenderParameters(FOUserAgent,Map)",
            " 120 -\n 121 -\n 122  \n 123  \n 124  \n 125  ",
            "    private void setRenderParameters(FOUserAgent userAgent, Map<String, Object> headers) throws Exception {\n        Map<String, Object> parameters = IntrospectionSupport.extractProperties(headers, FopConstants.CAMEL_FOP_RENDER);\n        if (!parameters.isEmpty()) {\n            PropertyBindingSupport.bindProperties(getEndpoint().getCamelContext(), userAgent, parameters);\n        }\n    }",
            " 119 +\n 120 +\n 121  \n 122  \n 123  \n 124  ",
            "    private void setRenderParameters(FOUserAgent userAgent, Map<String, Object> headers) {\n        Map<String, Object> parameters = PropertiesHelper.extractProperties(headers, FopConstants.CAMEL_FOP_RENDER);\n        if (!parameters.isEmpty()) {\n            PropertyBindingSupport.bindProperties(getEndpoint().getCamelContext(), userAgent, parameters);\n        }\n    }"
        ]
    ]
}