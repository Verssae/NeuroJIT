{
    "f2653e69362cef9de49e6b0a5a248c7ad0602b6b": [
        [
            "AmqpProtocolConverter::ConsumerContext::settle(Delivery,int)",
            " 989  \n 990  \n 991  \n 992  \n 993  \n 994  \n 995  \n 996 -\n 997  \n 998  \n 999  \n1000  \n1001  \n1002  \n1003  \n1004  \n1005  \n1006  \n1007  \n1008  \n1009  \n1010  \n1011  \n1012  \n1013  \n1014  \n1015  \n1016 -\n1017  \n1018  \n1019  \n1020  \n1021  \n1022  \n1023  \n1024  \n1025  \n1026  \n1027  \n1028  \n1029  \n1030  \n1031  \n1032  \n1033  \n1034  \n1035  \n1036  \n1037  \n1038  \n1039  ",
            "        private void settle(final Delivery delivery, final int ackType) throws Exception {\n            byte[] tag = delivery.getTag();\n            if (tag != null && tag.length > 0 && delivery.remotelySettled()) {\n                checkinTag(tag);\n            }\n\n            if (ackType == -1) {\n                // we are going to settle, but redeliver.. we we won't yet ack to ActiveMQ\n                delivery.settle();\n                onMessageDispatch((MessageDispatch) delivery.getContext());\n            } else {\n                MessageDispatch md = (MessageDispatch) delivery.getContext();\n                MessageAck ack = new MessageAck();\n                ack.setConsumerId(consumerId);\n                ack.setFirstMessageId(md.getMessage().getMessageId());\n                ack.setLastMessageId(md.getMessage().getMessageId());\n                ack.setMessageCount(1);\n                ack.setAckType((byte) ackType);\n                ack.setDestination(md.getDestination());\n\n                DeliveryState remoteState = delivery.getRemoteState();\n                if (remoteState != null && remoteState instanceof TransactionalState) {\n                    TransactionalState s = (TransactionalState) remoteState;\n                    long txid = toLong(s.getTxnId());\n                    LocalTransactionId localTxId = new LocalTransactionId(connectionId, txid);\n                    ack.setTransactionId(localTxId);\n\n                    // Store the message sent in this TX we might need to re-send on rollback\n                    md.getMessage().setTransactionId(localTxId);\n                    dispatchedInTx.addFirst(md);\n                }\n\n                LOG.trace(\"Sending Ack to ActiveMQ: {}\", ack);\n\n                sendToActiveMQ(ack, new ResponseHandler() {\n                    @Override\n                    public void onResponse(IAmqpProtocolConverter converter, Response response) throws IOException {\n                        if (response.isException()) {\n                            if (response.isException()) {\n                                Throwable exception = ((ExceptionResponse) response).getException();\n                                exception.printStackTrace();\n                                sender.close();\n                            }\n                        } else {\n                            delivery.settle();\n                        }\n                        pumpProtonToSocket();\n                    }\n                });\n            }\n        }",
            "1001  \n1002  \n1003  \n1004  \n1005  \n1006  \n1007  \n1008 +\n1009 +\n1010  \n1011  \n1012  \n1013  \n1014  \n1015  \n1016  \n1017  \n1018  \n1019  \n1020  \n1021  \n1022  \n1023  \n1024  \n1025  \n1026  \n1027  \n1028  \n1029 +\n1030 +\n1031  \n1032  \n1033  \n1034  \n1035  \n1036  \n1037  \n1038  \n1039  \n1040  \n1041  \n1042  \n1043  \n1044  \n1045  \n1046  \n1047  \n1048  \n1049  \n1050  \n1051  \n1052  \n1053  ",
            "        private void settle(final Delivery delivery, final int ackType) throws Exception {\n            byte[] tag = delivery.getTag();\n            if (tag != null && tag.length > 0 && delivery.remotelySettled()) {\n                checkinTag(tag);\n            }\n\n            if (ackType == -1) {\n                // we are going to settle, but redeliver.. we we won't yet ack\n                // to ActiveMQ\n                delivery.settle();\n                onMessageDispatch((MessageDispatch) delivery.getContext());\n            } else {\n                MessageDispatch md = (MessageDispatch) delivery.getContext();\n                MessageAck ack = new MessageAck();\n                ack.setConsumerId(consumerId);\n                ack.setFirstMessageId(md.getMessage().getMessageId());\n                ack.setLastMessageId(md.getMessage().getMessageId());\n                ack.setMessageCount(1);\n                ack.setAckType((byte) ackType);\n                ack.setDestination(md.getDestination());\n\n                DeliveryState remoteState = delivery.getRemoteState();\n                if (remoteState != null && remoteState instanceof TransactionalState) {\n                    TransactionalState s = (TransactionalState) remoteState;\n                    long txid = toLong(s.getTxnId());\n                    LocalTransactionId localTxId = new LocalTransactionId(connectionId, txid);\n                    ack.setTransactionId(localTxId);\n\n                    // Store the message sent in this TX we might need to\n                    // re-send on rollback\n                    md.getMessage().setTransactionId(localTxId);\n                    dispatchedInTx.addFirst(md);\n                }\n\n                LOG.trace(\"Sending Ack to ActiveMQ: {}\", ack);\n\n                sendToActiveMQ(ack, new ResponseHandler() {\n                    @Override\n                    public void onResponse(IAmqpProtocolConverter converter, Response response) throws IOException {\n                        if (response.isException()) {\n                            if (response.isException()) {\n                                Throwable exception = ((ExceptionResponse) response).getException();\n                                exception.printStackTrace();\n                                sender.close();\n                            }\n                        } else {\n                            delivery.settle();\n                        }\n                        pumpProtonToSocket();\n                    }\n                });\n            }\n        }"
        ],
        [
            "AmqpProtocolConverter::ConsumerContext::onDelivery(Delivery)",
            "1053  \n1054  \n1055  \n1056  \n1057  \n1058  \n1059  \n1060  \n1061 -\n1062  \n1063 -\n1064  \n1065 -\n1066  \n1067  \n1068  \n1069  \n1070  \n1071  \n1072  \n1073  \n1074  \n1075  \n1076 -\n1077  \n1078  \n1079  \n1080  \n1081  \n1082  \n1083  \n1084  \n1085  \n1086  \n1087  \n1088  \n1089  \n1090  \n1091  \n1092  \n1093  \n1094  \n1095  \n1096  \n1097  \n1098  \n1099  \n1100  \n1101  \n1102  \n1103  \n1104  \n1105  \n1106  \n1107  \n1108  ",
            "        @Override\n        public void onDelivery(Delivery delivery) throws Exception {\n            MessageDispatch md = (MessageDispatch) delivery.getContext();\n            DeliveryState state = delivery.getRemoteState();\n\n            if (state instanceof TransactionalState) {\n                TransactionalState txState = (TransactionalState) state;\n                if (txState.getOutcome() instanceof DeliveryState) {\n\n                    LOG.trace(\"onDelivery: TX delivery state = {}\", state);\n\n                    state = (DeliveryState) txState.getOutcome();\n\n                    if (state instanceof Accepted) {\n                        if (!delivery.remotelySettled()) {\n                            delivery.disposition(new Accepted());\n                        }\n                        settle(delivery, MessageAck.DELIVERED_ACK_TYPE);\n                    }\n                }\n            } else {\n                if (state instanceof Accepted) {\n                    LOG.trace(\"onDelivery: accepted state = {}\", state);\n\n                    if (!delivery.remotelySettled()) {\n                        delivery.disposition(new Accepted());\n                    }\n                    settle(delivery, MessageAck.INDIVIDUAL_ACK_TYPE);\n                } else if (state instanceof Rejected) {\n                    // re-deliver /w incremented delivery counter.\n                    md.setRedeliveryCounter(md.getRedeliveryCounter() + 1);\n                    LOG.trace(\"onDelivery: Rejected state = {}, delivery count now {}\", state, md.getRedeliveryCounter());\n                    settle(delivery, -1);\n                } else if (state instanceof Released) {\n                    LOG.trace(\"onDelivery: Released state = {}\", state);\n                    // re-deliver && don't increment the counter.\n                    settle(delivery, -1);\n                } else if (state instanceof Modified) {\n                    Modified modified = (Modified) state;\n                    if (modified.getDeliveryFailed()) {\n                        // increment delivery counter..\n                        md.setRedeliveryCounter(md.getRedeliveryCounter() + 1);\n                    }\n                    LOG.trace(\"onDelivery: Modified state = {}, delivery count now {}\", state, md.getRedeliveryCounter());\n                    byte ackType = -1;\n                    Boolean undeliverableHere = modified.getUndeliverableHere();\n                    if (undeliverableHere != null && undeliverableHere) {\n                        // receiver does not want the message..\n                        // perhaps we should DLQ it?\n                        ackType = MessageAck.POSION_ACK_TYPE;\n                    }\n                    settle(delivery, ackType);\n                }\n            }\n            pumpOutbound();\n        }",
            "1067  \n1068  \n1069  \n1070  \n1071  \n1072  \n1073  \n1074  \n1075  \n1076  \n1077  \n1078  \n1079  \n1080  \n1081  \n1082  \n1083  \n1084  \n1085  \n1086  \n1087  \n1088  \n1089  \n1090  \n1091  \n1092  \n1093  \n1094  \n1095  \n1096  \n1097  \n1098  \n1099  \n1100  \n1101  \n1102  \n1103  \n1104  \n1105  \n1106  \n1107  \n1108  \n1109  \n1110  \n1111  \n1112  \n1113  \n1114  \n1115  \n1116  \n1117  \n1118  ",
            "        @Override\n        public void onDelivery(Delivery delivery) throws Exception {\n            MessageDispatch md = (MessageDispatch) delivery.getContext();\n            DeliveryState state = delivery.getRemoteState();\n\n            if (state instanceof TransactionalState) {\n                TransactionalState txState = (TransactionalState) state;\n                if (txState.getOutcome() instanceof DeliveryState) {\n                    LOG.trace(\"onDelivery: TX delivery state = {}\", state);\n                    state = (DeliveryState) txState.getOutcome();\n                    if (state instanceof Accepted) {\n                        if (!delivery.remotelySettled()) {\n                            delivery.disposition(new Accepted());\n                        }\n                        settle(delivery, MessageAck.DELIVERED_ACK_TYPE);\n                    }\n                }\n            } else {\n                if (state instanceof Accepted) {\n                    LOG.trace(\"onDelivery: accepted state = {}\", state);\n                    if (!delivery.remotelySettled()) {\n                        delivery.disposition(new Accepted());\n                    }\n                    settle(delivery, MessageAck.INDIVIDUAL_ACK_TYPE);\n                } else if (state instanceof Rejected) {\n                    // re-deliver /w incremented delivery counter.\n                    md.setRedeliveryCounter(md.getRedeliveryCounter() + 1);\n                    LOG.trace(\"onDelivery: Rejected state = {}, delivery count now {}\", state, md.getRedeliveryCounter());\n                    settle(delivery, -1);\n                } else if (state instanceof Released) {\n                    LOG.trace(\"onDelivery: Released state = {}\", state);\n                    // re-deliver && don't increment the counter.\n                    settle(delivery, -1);\n                } else if (state instanceof Modified) {\n                    Modified modified = (Modified) state;\n                    if (modified.getDeliveryFailed()) {\n                        // increment delivery counter..\n                        md.setRedeliveryCounter(md.getRedeliveryCounter() + 1);\n                    }\n                    LOG.trace(\"onDelivery: Modified state = {}, delivery count now {}\", state, md.getRedeliveryCounter());\n                    byte ackType = -1;\n                    Boolean undeliverableHere = modified.getUndeliverableHere();\n                    if (undeliverableHere != null && undeliverableHere) {\n                        // receiver does not want the message..\n                        // perhaps we should DLQ it?\n                        ackType = MessageAck.POSION_ACK_TYPE;\n                    }\n                    settle(delivery, ackType);\n                }\n            }\n            pumpOutbound();\n        }"
        ],
        [
            "AmqpHeader::setProtocolId(int)",
            "  45  \n  46 -\n  47  ",
            "    public void setProtocolId(int value) {\n        buffer.data[buffer.offset+4] = (byte) value;\n    }",
            "  41  \n  42 +\n  43  ",
            "    public void setProtocolId(int value) {\n        buffer.data[buffer.offset + 4] = (byte) value;\n    }"
        ],
        [
            "AmqpProtocolConverter::ProducerContext::onMessage(Receiver,Delivery,Buffer)",
            " 566  \n 567  \n 568  \n 569  \n 570  \n 571  \n 572  \n 573  \n 574  \n 575  \n 576  \n 577  \n 578 -\n 579  \n 580  \n 581  \n 582  \n 583  \n 584  \n 585  \n 586  \n 587  \n 588  \n 589  \n 590  \n 591  \n 592  \n 593  \n 594  \n 595  \n 596  \n 597  \n 598  \n 599  \n 600  \n 601  \n 602 -\n 603 -\n 604  \n 605  \n 606  \n 607  \n 608  \n 609  \n 610  \n 611  \n 612  \n 613  \n 614  \n 615  \n 616  \n 617  \n 618  \n 619  \n 620  \n 621  \n 622  \n 623  \n 624  \n 625  \n 626  \n 627 -\n 628 -\n 629  \n 630  \n 631  \n 632  \n 633  \n 634  \n 635  \n 636  \n 637  \n 638  \n 639  \n 640  \n 641 -\n 642 -\n 643  \n 644  \n 645  \n 646  \n 647  \n 648  \n 649  ",
            "        @Override\n        protected void onMessage(final Receiver receiver, final Delivery delivery, Buffer buffer) throws Exception {\n            if (!closed) {\n                EncodedMessage em = new EncodedMessage(delivery.getMessageFormat(), buffer.data, buffer.offset, buffer.length);\n                final ActiveMQMessage message = (ActiveMQMessage) getInboundTransformer().transform(em);\n                current = null;\n\n                if (destination != null) {\n                    message.setJMSDestination(destination);\n                }\n                message.setProducerId(producerId);\n\n                // Always override the AMQP client's MessageId with our own.  Preserve the\n                // original in the TextView property for later Ack.\n                MessageId messageId = new MessageId(producerId, messageIdGenerator.getNextSequenceId());\n\n                MessageId amqpMessageId = message.getMessageId();\n                if (amqpMessageId != null) {\n                    if (amqpMessageId.getTextView() != null) {\n                        messageId.setTextView(amqpMessageId.getTextView());\n                    } else {\n                        messageId.setTextView(amqpMessageId.toString());\n                    }\n                }\n\n                message.setMessageId(messageId);\n\n                LOG.trace(\"Inbound Message:{} from Producer:{}\", message.getMessageId(), producerId + \":\" + messageId.getProducerSequenceId());\n\n                DeliveryState remoteState = delivery.getRemoteState();\n                if (remoteState != null && remoteState instanceof TransactionalState) {\n                    TransactionalState s = (TransactionalState) remoteState;\n                    long txid = toLong(s.getTxnId());\n                    message.setTransactionId(new LocalTransactionId(connectionId, txid));\n                }\n\n                // Lets handle the case where the expiration was set, but the timestamp\n                // was not set by the client. Lets assign the timestamp now, and adjust the\n                // expiration.\n                if (message.getExpiration() != 0) {\n                    if (message.getTimestamp() == 0) {\n                        message.setTimestamp(System.currentTimeMillis());\n                        message.setExpiration(message.getTimestamp() + message.getExpiration());\n                    }\n                }\n\n                message.onSend();\n                if (!delivery.remotelySettled()) {\n                    sendToActiveMQ(message, new ResponseHandler() {\n                        @Override\n                        public void onResponse(IAmqpProtocolConverter converter, Response response) throws IOException {\n                            if (response.isException()) {\n                                ExceptionResponse er = (ExceptionResponse) response;\n                                Rejected rejected = new Rejected();\n                                ErrorCondition condition = new ErrorCondition();\n                                condition.setCondition(Symbol.valueOf(\"failed\"));\n                                condition.setDescription(er.getException().getMessage());\n                                rejected.setError(condition);\n                                delivery.disposition(rejected);\n                            } else {\n                                if (receiver.getCredit() <= (prefetch * .2)) {\n                                    LOG.trace(\"Sending more credit ({}) to producer: {}\",\n                                              prefetch - receiver.getCredit(), producerId);\n                                    receiver.flow(prefetch - receiver.getCredit());\n                                }\n\n                                delivery.disposition(Accepted.getInstance());\n                                delivery.settle();\n                            }\n\n                            pumpProtonToSocket();\n                        }\n                    });\n                } else {\n                    if (receiver.getCredit() <= (prefetch * .2)) {\n                        LOG.trace(\"Sending more credit ({}) to producer: {}\",\n                                  prefetch - receiver.getCredit(), producerId);\n                        receiver.flow(prefetch - receiver.getCredit());\n                        pumpProtonToSocket();\n                    }\n                    sendToActiveMQ(message, null);\n                }\n            }\n        }",
            " 575  \n 576  \n 577  \n 578  \n 579  \n 580  \n 581  \n 582  \n 583  \n 584  \n 585  \n 586  \n 587 +\n 588 +\n 589  \n 590  \n 591  \n 592  \n 593  \n 594  \n 595  \n 596  \n 597  \n 598  \n 599  \n 600  \n 601  \n 602  \n 603  \n 604  \n 605  \n 606  \n 607  \n 608  \n 609  \n 610  \n 611  \n 612 +\n 613 +\n 614 +\n 615 +\n 616  \n 617  \n 618  \n 619  \n 620  \n 621  \n 622  \n 623  \n 624  \n 625  \n 626  \n 627  \n 628  \n 629  \n 630  \n 631  \n 632  \n 633  \n 634  \n 635  \n 636  \n 637  \n 638  \n 639 +\n 640  \n 641  \n 642  \n 643  \n 644  \n 645  \n 646  \n 647  \n 648  \n 649  \n 650  \n 651  \n 652 +\n 653  \n 654  \n 655  \n 656  \n 657  \n 658  \n 659  ",
            "        @Override\n        protected void onMessage(final Receiver receiver, final Delivery delivery, Buffer buffer) throws Exception {\n            if (!closed) {\n                EncodedMessage em = new EncodedMessage(delivery.getMessageFormat(), buffer.data, buffer.offset, buffer.length);\n                final ActiveMQMessage message = (ActiveMQMessage) getInboundTransformer().transform(em);\n                current = null;\n\n                if (destination != null) {\n                    message.setJMSDestination(destination);\n                }\n                message.setProducerId(producerId);\n\n                // Always override the AMQP client's MessageId with our own.\n                // Preserve the\n                // original in the TextView property for later Ack.\n                MessageId messageId = new MessageId(producerId, messageIdGenerator.getNextSequenceId());\n\n                MessageId amqpMessageId = message.getMessageId();\n                if (amqpMessageId != null) {\n                    if (amqpMessageId.getTextView() != null) {\n                        messageId.setTextView(amqpMessageId.getTextView());\n                    } else {\n                        messageId.setTextView(amqpMessageId.toString());\n                    }\n                }\n\n                message.setMessageId(messageId);\n\n                LOG.trace(\"Inbound Message:{} from Producer:{}\", message.getMessageId(), producerId + \":\" + messageId.getProducerSequenceId());\n\n                DeliveryState remoteState = delivery.getRemoteState();\n                if (remoteState != null && remoteState instanceof TransactionalState) {\n                    TransactionalState s = (TransactionalState) remoteState;\n                    long txid = toLong(s.getTxnId());\n                    message.setTransactionId(new LocalTransactionId(connectionId, txid));\n                }\n\n                // Lets handle the case where the expiration was set, but the\n                // timestamp\n                // was not set by the client. Lets assign the timestamp now, and\n                // adjust the\n                // expiration.\n                if (message.getExpiration() != 0) {\n                    if (message.getTimestamp() == 0) {\n                        message.setTimestamp(System.currentTimeMillis());\n                        message.setExpiration(message.getTimestamp() + message.getExpiration());\n                    }\n                }\n\n                message.onSend();\n                if (!delivery.remotelySettled()) {\n                    sendToActiveMQ(message, new ResponseHandler() {\n                        @Override\n                        public void onResponse(IAmqpProtocolConverter converter, Response response) throws IOException {\n                            if (response.isException()) {\n                                ExceptionResponse er = (ExceptionResponse) response;\n                                Rejected rejected = new Rejected();\n                                ErrorCondition condition = new ErrorCondition();\n                                condition.setCondition(Symbol.valueOf(\"failed\"));\n                                condition.setDescription(er.getException().getMessage());\n                                rejected.setError(condition);\n                                delivery.disposition(rejected);\n                            } else {\n                                if (receiver.getCredit() <= (prefetch * .2)) {\n                                    LOG.trace(\"Sending more credit ({}) to producer: {}\", prefetch - receiver.getCredit(), producerId);\n                                    receiver.flow(prefetch - receiver.getCredit());\n                                }\n\n                                delivery.disposition(Accepted.getInstance());\n                                delivery.settle();\n                            }\n\n                            pumpProtonToSocket();\n                        }\n                    });\n                } else {\n                    if (receiver.getCredit() <= (prefetch * .2)) {\n                        LOG.trace(\"Sending more credit ({}) to producer: {}\", prefetch - receiver.getCredit(), producerId);\n                        receiver.flow(prefetch - receiver.getCredit());\n                        pumpProtonToSocket();\n                    }\n                    sendToActiveMQ(message, null);\n                }\n            }\n        }"
        ],
        [
            "AmqpTransportFactory::serverConfigure(Transport,WireFormat,HashMap)",
            "  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59 -\n  60 -\n  61  \n  62 -\n  63 -\n  64 -\n  65 -\n  66  \n  67  ",
            "    @SuppressWarnings(\"rawtypes\")\n    @Override\n    public Transport serverConfigure(Transport transport, WireFormat format, HashMap options) throws Exception {\n        transport = super.serverConfigure(transport, format, options);\n\n        // strip off the mutex transport.\n        if( transport instanceof MutexTransport ) {\n            transport = ((MutexTransport)transport).getNext();\n        }\n//        MutexTransport mutex = transport.narrow(MutexTransport.class);\n//        if (mutex != null) {\n//            mutex.setSyncOnCommand(true);\n//        }\n        return transport;\n    }",
            "  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62 +\n  63 +\n  64  \n  65 +\n  66  \n  67  ",
            "    @SuppressWarnings(\"rawtypes\")\n    @Override\n    public Transport serverConfigure(Transport transport, WireFormat format, HashMap options) throws Exception {\n        transport = super.serverConfigure(transport, format, options);\n\n        // strip off the mutex transport.\n        if (transport instanceof MutexTransport) {\n            transport = ((MutexTransport) transport).getNext();\n        }\n\n        return transport;\n    }"
        ],
        [
            "AmqpNioTransport::initializeStreams()",
            "  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  ",
            "    @Override\n    protected void initializeStreams() throws IOException {\n        channel = socket.getChannel();\n        channel.configureBlocking(false);\n        // listen for events telling us when the socket is readable.\n        selection = SelectorManager.getInstance().register(channel, new SelectorManager.Listener() {\n            @Override\n            public void onSelect(SelectorSelection selection) {\n                if (!isStopped()) {\n                    serviceRead();\n                }\n            }\n\n            @Override\n            public void onError(SelectorSelection selection, Throwable error) {\n                if (error instanceof IOException) {\n                    onException((IOException) error);\n                } else {\n                    onException(IOExceptionSupport.create(error));\n                }\n            }\n        });\n\n        inputBuffer = ByteBuffer.allocate(8 * 1024);\n        NIOOutputStream outPutStream = new NIOOutputStream(channel, 8 * 1024);\n        this.dataOut = new DataOutputStream(outPutStream);\n        this.buffOut = outPutStream;\n    }",
            "  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77 +\n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  ",
            "    @Override\n    protected void initializeStreams() throws IOException {\n        channel = socket.getChannel();\n        channel.configureBlocking(false);\n        // listen for events telling us when the socket is readable.\n        selection = SelectorManager.getInstance().register(channel, new SelectorManager.Listener() {\n            @Override\n            public void onSelect(SelectorSelection selection) {\n                if (!isStopped()) {\n                    serviceRead();\n                }\n            }\n\n            @Override\n            public void onError(SelectorSelection selection, Throwable error) {\n                LOG.trace(\"Error detected: {}\", error.getMessage());\n                if (error instanceof IOException) {\n                    onException((IOException) error);\n                } else {\n                    onException(IOExceptionSupport.create(error));\n                }\n            }\n        });\n\n        inputBuffer = ByteBuffer.allocate(8 * 1024);\n        NIOOutputStream outPutStream = new NIOOutputStream(channel, 8 * 1024);\n        this.dataOut = new DataOutputStream(outPutStream);\n        this.buffOut = outPutStream;\n    }"
        ],
        [
            "AMQPProtocolDiscriminator::matches(AmqpHeader)",
            "  46  \n  47  \n  48 -\n  49  \n  50  \n  51 -\n  52  \n  53  \n  54  \n  55  ",
            "            @Override\n            public boolean matches(AmqpHeader header) {\n                switch( header.getProtocolId() ) {\n                    case 0:\n                    case 3:\n                        if( header.getMajor() == 1 && header.getMinor()==0 && header.getRevision()==0 )\n                            return true;\n                }\n                return false;\n            }",
            "  47  \n  48  \n  49 +\n  50  \n  51  \n  52 +\n  53  \n  54 +\n  55  \n  56  \n  57  ",
            "            @Override\n            public boolean matches(AmqpHeader header) {\n                switch (header.getProtocolId()) {\n                    case 0:\n                    case 3:\n                        if (header.getMajor() == 1 && header.getMinor() == 0 && header.getRevision() == 0) {\n                            return true;\n                        }\n                }\n                return false;\n            }"
        ],
        [
            "AmqpHeader::AmqpHeader(Buffer)",
            "  38 -\n  39  \n  40  ",
            "    public AmqpHeader(Buffer buffer){\n        setBuffer(buffer);\n    }",
            "  33 +\n  34  \n  35  ",
            "    public AmqpHeader(Buffer buffer) {\n        setBuffer(buffer);\n    }"
        ],
        [
            "AmqpProtocolConverter::AmqpProtocolConverter(AmqpTransport)",
            " 133  \n 134  \n 135  \n 136  \n 137  \n 138 -\n 139 -\n 140 -\n 141 -\n 142 -\n 143  \n 144  \n 145  \n 146  \n 147  \n 148  ",
            "    public AmqpProtocolConverter(AmqpTransport transport) {\n        this.amqpTransport = transport;\n\n        int maxFrameSize = AmqpWireFormat.DEFAULT_MAX_FRAME_SIZE;\n\n        // AMQ-4914 - Setting the max frame size to large stalls out the QPid client on sends or\n        //            consume due to no session credit.  Once fixed we should set this value using\n        //            the configured maxFrameSize on the URI.\n        //int maxFrameSize = transport.getWireFormat().getMaxFrameSize() > Integer.MAX_VALUE ?\n        //    Integer.MAX_VALUE : (int) transport.getWireFormat().getMaxFrameSize();\n\n        this.protonTransport.setMaxFrameSize(maxFrameSize);\n        this.protonTransport.bind(this.protonConnection);\n        this.protonConnection.collect(eventCollector);\n        updateTracer();\n    }",
            " 131  \n 132  \n 133  \n 134  \n 135  \n 136 +\n 137 +\n 138 +\n 139 +\n 140 +\n 141 +\n 142 +\n 143 +\n 144 +\n 145  \n 146  \n 147  \n 148  \n 149  \n 150  ",
            "    public AmqpProtocolConverter(AmqpTransport transport) {\n        this.amqpTransport = transport;\n\n        int maxFrameSize = AmqpWireFormat.DEFAULT_MAX_FRAME_SIZE;\n\n        // AMQ-4914 - Setting the max frame size to large stalls out the QPid\n        // client on sends or\n        // consume due to no session credit. Once fixed we should set this value\n        // using\n        // the configured maxFrameSize on the URI.\n        // int maxFrameSize = transport.getWireFormat().getMaxFrameSize() >\n        // Integer.MAX_VALUE ?\n        // Integer.MAX_VALUE : (int)\n        // transport.getWireFormat().getMaxFrameSize();\n\n        this.protonTransport.setMaxFrameSize(maxFrameSize);\n        this.protonTransport.bind(this.protonConnection);\n        this.protonConnection.collect(eventCollector);\n        updateTracer();\n    }"
        ],
        [
            "AmqpHeader::AmqpHeader()",
            "  32 -\n  33 -\n  34 -\n  35 -\n  36  ",
            "    public AmqpHeader(){\n        this(new Buffer(new byte[]{\n          'A', 'M', 'Q', 'P', 0, 1, 0, 0\n        }));\n    }",
            "  29 +\n  30 +\n  31  ",
            "    public AmqpHeader() {\n        this(new Buffer(new byte[] { 'A', 'M', 'Q', 'P', 0, 1, 0, 0 }));\n    }"
        ],
        [
            "ActiveMQJMSVendor::toAddress(Destination)",
            " 125  \n 126  \n 127 -\n 128  ",
            "    @Override\n    public String toAddress(Destination dest) {\n        return ((ActiveMQDestination)dest).getQualifiedName();\n    }",
            " 125  \n 126  \n 127 +\n 128  ",
            "    @Override\n    public String toAddress(Destination dest) {\n        return ((ActiveMQDestination) dest).getQualifiedName();\n    }"
        ],
        [
            "AMQPProtocolDiscriminator::onAMQPData(Object)",
            "  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73 -\n  74  \n  75  \n  76  \n  77  \n  78 -\n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  ",
            "    @Override\n    public void onAMQPData(Object command) throws Exception {\n        if (command.getClass() == AmqpHeader.class) {\n            AmqpHeader header = (AmqpHeader) command;\n\n            Discriminator match = null;\n            for (Discriminator discriminator : DISCRIMINATORS) {\n                if( discriminator.matches(header) ) {\n                    match = discriminator;\n                }\n            }\n            // Lets use first in the list if none are a good match.\n            if( match == null ) {\n                match = DISCRIMINATORS.get(0);\n            }\n            IAmqpProtocolConverter next = match.create(transport);\n            transport.setProtocolConverter(next);\n            for (Command send : pendingCommands) {\n                next.onActiveMQCommand(send);\n            }\n            pendingCommands.clear();\n            next.onAMQPData(command);\n        } else {\n            throw new IllegalStateException();\n        }\n    }",
            "  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75 +\n  76  \n  77  \n  78  \n  79  \n  80 +\n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  ",
            "    @Override\n    public void onAMQPData(Object command) throws Exception {\n        if (command.getClass() == AmqpHeader.class) {\n            AmqpHeader header = (AmqpHeader) command;\n\n            Discriminator match = null;\n            for (Discriminator discriminator : DISCRIMINATORS) {\n                if (discriminator.matches(header)) {\n                    match = discriminator;\n                }\n            }\n            // Lets use first in the list if none are a good match.\n            if (match == null) {\n                match = DISCRIMINATORS.get(0);\n            }\n            IAmqpProtocolConverter next = match.create(transport);\n            transport.setProtocolConverter(next);\n            for (Command send : pendingCommands) {\n                next.onActiveMQCommand(send);\n            }\n            pendingCommands.clear();\n            next.onAMQPData(command);\n        } else {\n            throw new IllegalStateException();\n        }\n    }"
        ],
        [
            "ActiveMQJMSVendor::setJMSXDeliveryCount(Message,long)",
            " 120  \n 121  \n 122 -\n 123  ",
            "    @Override\n    public void setJMSXDeliveryCount(Message msg, long value) {\n        ((ActiveMQMessage)msg).setRedeliveryCounter((int) value);\n    }",
            " 120  \n 121  \n 122 +\n 123  ",
            "    @Override\n    public void setJMSXDeliveryCount(Message msg, long value) {\n        ((ActiveMQMessage) msg).setRedeliveryCounter((int) value);\n    }"
        ],
        [
            "AmqpProtocolConverter::onFrame(Buffer)",
            " 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248 -\n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  ",
            "    public void onFrame(Buffer frame) throws Exception {\n        while (frame.length > 0) {\n            try {\n                int count = protonTransport.input(frame.data, frame.offset, frame.length);\n                frame.moveHead(count);\n            } catch (Throwable e) {\n                handleException(new AmqpProtocolException(\"Could not decode AMQP frame: \" + frame, true, e));\n                return;\n            }\n\n            try {\n                if (sasl != null) {\n                    // Lets try to complete the sasl handshake.\n                    if (sasl.getRemoteMechanisms().length > 0) {\n                        if (\"PLAIN\".equals(sasl.getRemoteMechanisms()[0])) {\n                            byte[] data = new byte[sasl.pending()];\n                            sasl.recv(data, 0, data.length);\n                            Buffer[] parts = new Buffer(data).split((byte) 0);\n                            if (parts.length > 0) {\n                                connectionInfo.setUserName(parts[0].utf8().toString());\n                            }\n                            if (parts.length > 1) {\n                                connectionInfo.setPassword(parts[1].utf8().toString());\n                            }\n                            // We can't really auth at this point since we don't know the client id yet.. :(\n                            sasl.done(Sasl.SaslOutcome.PN_SASL_OK);\n                            amqpTransport.getWireFormat().magicRead = false;\n                            sasl = null;\n                            LOG.debug(\"SASL [PLAIN] Handshake complete.\");\n                        } else if (\"ANONYMOUS\".equals(sasl.getRemoteMechanisms()[0])) {\n                            sasl.done(Sasl.SaslOutcome.PN_SASL_OK);\n                            amqpTransport.getWireFormat().magicRead = false;\n                            sasl = null;\n                            LOG.debug(\"SASL [ANONYMOUS] Handshake complete.\");\n                        }\n                    }\n                }\n\n                Event event = null;\n                while ((event = eventCollector.peek()) != null) {\n                    switch (event.getType()) {\n                        case CONNECTION_REMOTE_STATE:\n                            processConnectionEvent(event.getConnection());\n                            break;\n                        case SESSION_REMOTE_STATE:\n                            processSessionEvent(event.getSession());\n                            break;\n                        case LINK_REMOTE_STATE:\n                            processLinkEvent(event.getLink());\n                            break;\n                        case LINK_FLOW:\n                            Link link = event.getLink();\n                            ((AmqpDeliveryListener) link.getContext()).drainCheck();\n                            break;\n                        case DELIVERY:\n                            processDelivery(event.getDelivery());\n                            break;\n                        default:\n                            break;\n                    }\n\n                    eventCollector.pop();\n                }\n\n            } catch (Throwable e) {\n                handleException(new AmqpProtocolException(\"Could not process AMQP commands\", true, e));\n            }\n\n            pumpProtonToSocket();\n        }\n    }",
            " 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250 +\n 251 +\n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  ",
            "    public void onFrame(Buffer frame) throws Exception {\n        while (frame.length > 0) {\n            try {\n                int count = protonTransport.input(frame.data, frame.offset, frame.length);\n                frame.moveHead(count);\n            } catch (Throwable e) {\n                handleException(new AmqpProtocolException(\"Could not decode AMQP frame: \" + frame, true, e));\n                return;\n            }\n\n            try {\n                if (sasl != null) {\n                    // Lets try to complete the sasl handshake.\n                    if (sasl.getRemoteMechanisms().length > 0) {\n                        if (\"PLAIN\".equals(sasl.getRemoteMechanisms()[0])) {\n                            byte[] data = new byte[sasl.pending()];\n                            sasl.recv(data, 0, data.length);\n                            Buffer[] parts = new Buffer(data).split((byte) 0);\n                            if (parts.length > 0) {\n                                connectionInfo.setUserName(parts[0].utf8().toString());\n                            }\n                            if (parts.length > 1) {\n                                connectionInfo.setPassword(parts[1].utf8().toString());\n                            }\n                            // We can't really auth at this point since we don't\n                            // know the client id yet.. :(\n                            sasl.done(Sasl.SaslOutcome.PN_SASL_OK);\n                            amqpTransport.getWireFormat().magicRead = false;\n                            sasl = null;\n                            LOG.debug(\"SASL [PLAIN] Handshake complete.\");\n                        } else if (\"ANONYMOUS\".equals(sasl.getRemoteMechanisms()[0])) {\n                            sasl.done(Sasl.SaslOutcome.PN_SASL_OK);\n                            amqpTransport.getWireFormat().magicRead = false;\n                            sasl = null;\n                            LOG.debug(\"SASL [ANONYMOUS] Handshake complete.\");\n                        }\n                    }\n                }\n\n                Event event = null;\n                while ((event = eventCollector.peek()) != null) {\n                    switch (event.getType()) {\n                        case CONNECTION_REMOTE_STATE:\n                            processConnectionEvent(event.getConnection());\n                            break;\n                        case SESSION_REMOTE_STATE:\n                            processSessionEvent(event.getSession());\n                            break;\n                        case LINK_REMOTE_STATE:\n                            processLinkEvent(event.getLink());\n                            break;\n                        case LINK_FLOW:\n                            Link link = event.getLink();\n                            ((AmqpDeliveryListener) link.getContext()).drainCheck();\n                            break;\n                        case DELIVERY:\n                            processDelivery(event.getDelivery());\n                            break;\n                        default:\n                            break;\n                    }\n\n                    eventCollector.pop();\n                }\n\n            } catch (Throwable e) {\n                handleException(new AmqpProtocolException(\"Could not process AMQP commands\", true, e));\n            }\n\n            pumpProtonToSocket();\n        }\n    }"
        ],
        [
            "AmqpNioTransportHelper::validateFrameSize(int)",
            " 138  \n 139  \n 140 -\n 141 -\n 142  \n 143  ",
            "    private void validateFrameSize(int frameSize) throws IOException {\n        if (nextFrameSize > AmqpWireFormat.DEFAULT_MAX_FRAME_SIZE) {\n            throw new IOException(\"Frame size of \" + nextFrameSize +\n                    \"larger than max allowed \" + AmqpWireFormat.DEFAULT_MAX_FRAME_SIZE);\n        }\n    }",
            " 144  \n 145  \n 146 +\n 147  \n 148  ",
            "    private void validateFrameSize(int frameSize) throws IOException {\n        if (nextFrameSize > AmqpWireFormat.DEFAULT_MAX_FRAME_SIZE) {\n            throw new IOException(\"Frame size of \" + nextFrameSize + \"larger than max allowed \" + AmqpWireFormat.DEFAULT_MAX_FRAME_SIZE);\n        }\n    }"
        ],
        [
            "AmqpNioTransportFactory::createTcpTransportServer(URI,ServerSocketFactory)",
            "  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  ",
            "    protected TcpTransportServer createTcpTransportServer(URI location, ServerSocketFactory serverSocketFactory) throws IOException, URISyntaxException {\n        return new TcpTransportServer(this, location, serverSocketFactory) {\n            protected Transport createTransport(Socket socket, WireFormat format) throws IOException {\n                return new AmqpNioTransport(format, socket);\n            }\n        };\n    }",
            "  53  \n  54  \n  55  \n  56 +\n  57  \n  58  \n  59  \n  60  \n  61  ",
            "    @Override\n    protected TcpTransportServer createTcpTransportServer(URI location, ServerSocketFactory serverSocketFactory) throws IOException, URISyntaxException {\n        return new TcpTransportServer(this, location, serverSocketFactory) {\n            @Override\n            protected Transport createTransport(Socket socket, WireFormat format) throws IOException {\n                return new AmqpNioTransport(format, socket);\n            }\n        };\n    }"
        ],
        [
            "ActiveMQJMSVendor::createDestination(String,Class)",
            "  88  \n  89  \n  90 -\n  91  \n  92  \n  93 -\n  94  \n  95  \n  96 -\n  97  \n  98  \n  99 -\n 100  \n 101  \n 102  \n 103  ",
            "    @Override\n    public <T extends Destination> T createDestination(String name, Class<T> kind) {\n        if( kind == Queue.class ) {\n            return kind.cast(new ActiveMQQueue(name));\n        }\n        if( kind == Topic.class ) {\n            return kind.cast(new ActiveMQTopic(name));\n        }\n        if( kind == TemporaryQueue.class ) {\n            return kind.cast(new ActiveMQTempQueue(name));\n        }\n        if( kind == TemporaryTopic.class ) {\n            return kind.cast(new ActiveMQTempTopic(name));\n        }\n        return kind.cast(ActiveMQDestination.createDestination(name, ActiveMQDestination.QUEUE_TYPE));\n    }",
            "  88  \n  89  \n  90 +\n  91  \n  92  \n  93 +\n  94  \n  95  \n  96 +\n  97  \n  98  \n  99 +\n 100  \n 101  \n 102  \n 103  ",
            "    @Override\n    public <T extends Destination> T createDestination(String name, Class<T> kind) {\n        if (kind == Queue.class) {\n            return kind.cast(new ActiveMQQueue(name));\n        }\n        if (kind == Topic.class) {\n            return kind.cast(new ActiveMQTopic(name));\n        }\n        if (kind == TemporaryQueue.class) {\n            return kind.cast(new ActiveMQTempQueue(name));\n        }\n        if (kind == TemporaryTopic.class) {\n            return kind.cast(new ActiveMQTempTopic(name));\n        }\n        return kind.cast(ActiveMQDestination.createDestination(name, ActiveMQDestination.QUEUE_TYPE));\n    }"
        ],
        [
            "AmqpNioTransportHelper::processCommand(ByteBuffer)",
            "  43  \n  44 -\n  45  \n  46 -\n  47 -\n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66 -\n  67 -\n  68  \n  69 -\n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82 -\n  83 -\n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94 -\n  95 -\n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109 -\n 110 -\n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  ",
            "    protected void processCommand(ByteBuffer plain) throws Exception {\n        // Are we waiting for the next Command or building on the current one?  The frame size is in the first 4 bytes.\n        if (nextFrameSize == -1) {\n            // We can get small packets that don't give us enough for the frame size\n            // so allocate enough for the initial size value and\n            if (plain.remaining() < 4) {\n                if (currentBuffer == null) {\n                    currentBuffer = ByteBuffer.allocate(4);\n                }\n\n                // Go until we fill the integer sized current buffer.\n                while (currentBuffer.hasRemaining() && plain.hasRemaining()) {\n                    currentBuffer.put(plain.get());\n                }\n\n                // Didn't we get enough yet to figure out next frame size.\n                if (currentBuffer.hasRemaining()) {\n                    return;\n                } else {\n                    currentBuffer.flip();\n                    nextFrameSize = currentBuffer.getInt();\n                }\n            } else {\n                // Either we are completing a previous read of the next frame size or its\n                // fully contained in plain already.\n                if (currentBuffer != null) {\n                    // Finish the frame size integer read and get from the current buffer.\n                    while (currentBuffer.hasRemaining()) {\n                        currentBuffer.put(plain.get());\n                    }\n\n                    currentBuffer.flip();\n                    nextFrameSize = currentBuffer.getInt();\n                } else {\n                    nextFrameSize = plain.getInt();\n                }\n            }\n        }\n\n        // There are three possibilities when we get here.  We could have a partial frame,\n        // a full frame, or more than 1 frame\n        while (true) {\n            // handle headers, which start with 'A','M','Q','P' rather than size\n            if (nextFrameSize == AMQP_HEADER_VALUE) {\n                nextFrameSize = handleAmqpHeader(plain);\n                if (nextFrameSize == -1) {\n                    return;\n                }\n            }\n            validateFrameSize(nextFrameSize);\n\n            // now we have the data, let's reallocate and try to fill it,  (currentBuffer.putInt() is called      TODO update\n            // because we need to put back the 4 bytes we read to determine the size)\n            if (currentBuffer == null || (currentBuffer.limit() == 4)) {\n                currentBuffer = ByteBuffer.allocate(nextFrameSize);\n                currentBuffer.putInt(nextFrameSize);\n            }\n\n            if (currentBuffer.remaining() >= plain.remaining()) {\n                currentBuffer.put(plain);\n            } else {\n                byte[] fill = new byte[currentBuffer.remaining()];\n                plain.get(fill);\n                currentBuffer.put(fill);\n            }\n\n            // Either we have enough data for a new command or we have to wait for some more.  If hasRemaining is true,\n            // we have not filled the buffer yet, i.e. we haven't received the full frame.\n            if (currentBuffer.hasRemaining()) {\n                return;\n            } else {\n                currentBuffer.flip();\n                LOG.debug(\"Calling doConsume with position {} limit {}\", currentBuffer.position(), currentBuffer.limit());\n                transportSupport.doConsume(AmqpSupport.toBuffer(currentBuffer));\n                currentBuffer = null;\n                nextFrameSize = -1;\n\n                // Determine if there are more frames to process\n                if (plain.hasRemaining()) {\n                    if (plain.remaining() < 4) {\n                        currentBuffer = ByteBuffer.allocate(4);\n                        while (currentBuffer.hasRemaining() && plain.hasRemaining()) {\n                            currentBuffer.put(plain.get());\n                        }\n                        return;\n                    } else {\n                        nextFrameSize = plain.getInt();\n                    }\n                } else {\n                    return;\n                }\n            }\n        }\n    }",
            "  44  \n  45 +\n  46 +\n  47  \n  48 +\n  49 +\n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68 +\n  69 +\n  70  \n  71 +\n  72 +\n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85 +\n  86 +\n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97 +\n  98 +\n  99 +\n 100 +\n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114 +\n 115 +\n 116 +\n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  ",
            "    protected void processCommand(ByteBuffer plain) throws Exception {\n        // Are we waiting for the next Command or building on the current one?\n        // The frame size is in the first 4 bytes.\n        if (nextFrameSize == -1) {\n            // We can get small packets that don't give us enough for the frame\n            // size so allocate enough for the initial size value and\n            if (plain.remaining() < 4) {\n                if (currentBuffer == null) {\n                    currentBuffer = ByteBuffer.allocate(4);\n                }\n\n                // Go until we fill the integer sized current buffer.\n                while (currentBuffer.hasRemaining() && plain.hasRemaining()) {\n                    currentBuffer.put(plain.get());\n                }\n\n                // Didn't we get enough yet to figure out next frame size.\n                if (currentBuffer.hasRemaining()) {\n                    return;\n                } else {\n                    currentBuffer.flip();\n                    nextFrameSize = currentBuffer.getInt();\n                }\n            } else {\n                // Either we are completing a previous read of the next frame\n                // size or its fully contained in plain already.\n                if (currentBuffer != null) {\n                    // Finish the frame size integer read and get from the\n                    // current buffer.\n                    while (currentBuffer.hasRemaining()) {\n                        currentBuffer.put(plain.get());\n                    }\n\n                    currentBuffer.flip();\n                    nextFrameSize = currentBuffer.getInt();\n                } else {\n                    nextFrameSize = plain.getInt();\n                }\n            }\n        }\n\n        // There are three possibilities when we get here. We could have a\n        // partial frame, a full frame, or more than 1 frame\n        while (true) {\n            // handle headers, which start with 'A','M','Q','P' rather than size\n            if (nextFrameSize == AMQP_HEADER_VALUE) {\n                nextFrameSize = handleAmqpHeader(plain);\n                if (nextFrameSize == -1) {\n                    return;\n                }\n            }\n            validateFrameSize(nextFrameSize);\n\n            // now we have the data, let's reallocate and try to fill it,\n            // (currentBuffer.putInt() is called TODO update\n            // because we need to put back the 4 bytes we read to determine the\n            // size)\n            if (currentBuffer == null || (currentBuffer.limit() == 4)) {\n                currentBuffer = ByteBuffer.allocate(nextFrameSize);\n                currentBuffer.putInt(nextFrameSize);\n            }\n\n            if (currentBuffer.remaining() >= plain.remaining()) {\n                currentBuffer.put(plain);\n            } else {\n                byte[] fill = new byte[currentBuffer.remaining()];\n                plain.get(fill);\n                currentBuffer.put(fill);\n            }\n\n            // Either we have enough data for a new command or we have to wait for some more.\n            // If hasRemaining is true, we have not filled the buffer yet, i.e. we haven't\n            // received the full frame.\n            if (currentBuffer.hasRemaining()) {\n                return;\n            } else {\n                currentBuffer.flip();\n                LOG.debug(\"Calling doConsume with position {} limit {}\", currentBuffer.position(), currentBuffer.limit());\n                transportSupport.doConsume(AmqpSupport.toBuffer(currentBuffer));\n                currentBuffer = null;\n                nextFrameSize = -1;\n\n                // Determine if there are more frames to process\n                if (plain.hasRemaining()) {\n                    if (plain.remaining() < 4) {\n                        currentBuffer = ByteBuffer.allocate(4);\n                        while (currentBuffer.hasRemaining() && plain.hasRemaining()) {\n                            currentBuffer.put(plain.get());\n                        }\n                        return;\n                    } else {\n                        nextFrameSize = plain.getInt();\n                    }\n                } else {\n                    return;\n                }\n            }\n        }\n    }"
        ],
        [
            "AmqpSupport::toBuffer(ByteBuffer)",
            "  28  \n  29 -\n  30  \n  31  \n  32  \n  33 -\n  34  \n  35  \n  36  \n  37  \n  38 -\n  39  \n  40  \n  41  ",
            "    static public Buffer toBuffer(ByteBuffer data) {\n        if( data == null ) {\n            return null;\n        }\n        Buffer rc;\n        if( data.isDirect() ) {\n            rc = new Buffer(data.remaining());\n            data.get(rc.data);\n        } else {\n            rc = new Buffer(data);\n            data.position(data.position()+data.remaining());\n        }\n        return rc;\n    }",
            "  27  \n  28 +\n  29  \n  30  \n  31  \n  32 +\n  33  \n  34  \n  35  \n  36  \n  37 +\n  38  \n  39  \n  40  ",
            "    static public Buffer toBuffer(ByteBuffer data) {\n        if (data == null) {\n            return null;\n        }\n        Buffer rc;\n        if (data.isDirect()) {\n            rc = new Buffer(data.remaining());\n            data.get(rc.data);\n        } else {\n            rc = new Buffer(data);\n            data.position(data.position() + data.remaining());\n        }\n        return rc;\n    }"
        ],
        [
            "ActiveMQJMSVendor::setJMSXUserID(Message,String)",
            " 105  \n 106  \n 107 -\n 108  ",
            "    @Override\n    public void setJMSXUserID(Message msg, String value) {\n        ((ActiveMQMessage)msg).setUserID(value);\n    }",
            " 105  \n 106  \n 107 +\n 108  ",
            "    @Override\n    public void setJMSXUserID(Message msg, String value) {\n        ((ActiveMQMessage) msg).setUserID(value);\n    }"
        ],
        [
            "AmqpNioSslTransportFactory::createTcpTransportServer(URI,ServerSocketFactory)",
            "  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  ",
            "    @Override\n    protected TcpTransportServer createTcpTransportServer(URI location, ServerSocketFactory serverSocketFactory) throws IOException, URISyntaxException {\n        return new TcpTransportServer(this, location, serverSocketFactory) {\n            protected Transport createTransport(Socket socket, WireFormat format) throws IOException {\n                AmqpNioSslTransport transport = new AmqpNioSslTransport(format, socket);\n                if (context != null) {\n                    transport.setSslContext(context);\n                }\n                return transport;\n            }\n\n            @Override\n            public boolean isSslServer() {\n                return true;\n            }\n        };\n    }",
            "  40  \n  41  \n  42  \n  43 +\n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  ",
            "    @Override\n    protected TcpTransportServer createTcpTransportServer(URI location, ServerSocketFactory serverSocketFactory) throws IOException, URISyntaxException {\n        return new TcpTransportServer(this, location, serverSocketFactory) {\n            @Override\n            protected Transport createTransport(Socket socket, WireFormat format) throws IOException {\n                AmqpNioSslTransport transport = new AmqpNioSslTransport(format, socket);\n                if (context != null) {\n                    transport.setSslContext(context);\n                }\n                return transport;\n            }\n\n            @Override\n            public boolean isSslServer() {\n                return true;\n            }\n        };\n    }"
        ],
        [
            "AmqpProtocolConverter::ConsumerContext::pumpOutbound()",
            " 914  \n 915  \n 916  \n 917  \n 918  \n 919  \n 920  \n 921  \n 922  \n 923  \n 924  \n 925  \n 926  \n 927  \n 928  \n 929  \n 930  \n 931  \n 932  \n 933  \n 934  \n 935  \n 936  \n 937  \n 938  \n 939  \n 940  \n 941  \n 942  \n 943  \n 944  \n 945 -\n 946 -\n 947  \n 948  \n 949  \n 950  \n 951  \n 952  \n 953  \n 954  \n 955  \n 956  \n 957  \n 958  \n 959  \n 960  \n 961  \n 962  \n 963  \n 964  \n 965  \n 966  \n 967  \n 968  \n 969  \n 970  \n 971  \n 972  \n 973  \n 974  \n 975  \n 976  \n 977  \n 978  \n 979  \n 980  \n 981  \n 982  \n 983  \n 984  \n 985  \n 986  \n 987  ",
            "        public void pumpOutbound() throws Exception {\n            while (!closed) {\n\n                while (currentBuffer != null) {\n                    int sent = sender.send(currentBuffer.data, currentBuffer.offset, currentBuffer.length);\n                    if (sent > 0) {\n                        currentBuffer.moveHead(sent);\n                        if (currentBuffer.length == 0) {\n                            if (presettle) {\n                                settle(currentDelivery, MessageAck.INDIVIDUAL_ACK_TYPE);\n                            } else {\n                                sender.advance();\n                            }\n                            currentBuffer = null;\n                            currentDelivery = null;\n                        }\n                    } else {\n                        return;\n                    }\n                }\n\n                if (outbound.isEmpty()) {\n                    return;\n                }\n\n                final MessageDispatch md = outbound.removeFirst();\n                try {\n\n                    ActiveMQMessage temp = null;\n                    if (md.getMessage() != null) {\n\n                        // Topics can dispatch the same Message to more than one consumer\n                        // so we must copy to prevent concurrent read / write to the same\n                        // message object.\n                        if (md.getDestination().isTopic()) {\n                            synchronized (md.getMessage()) {\n                                temp = (ActiveMQMessage) md.getMessage().copy();\n                            }\n                        } else {\n                            temp = (ActiveMQMessage) md.getMessage();\n                        }\n\n                        if (!temp.getProperties().containsKey(MESSAGE_FORMAT_KEY)) {\n                            temp.setProperty(MESSAGE_FORMAT_KEY, 0);\n                        }\n                    }\n\n                    final ActiveMQMessage jms = temp;\n                    if (jms == null) {\n                        // It's the end of browse signal.\n                        endOfBrowse = true;\n                        drainCheck();\n                    } else {\n                        jms.setRedeliveryCounter(md.getRedeliveryCounter());\n                        jms.setReadOnlyBody(true);\n                        final EncodedMessage amqp = outboundTransformer.transform(jms);\n                        if (amqp != null && amqp.getLength() > 0) {\n                            currentBuffer = new Buffer(amqp.getArray(), amqp.getArrayOffset(), amqp.getLength());\n                            if (presettle) {\n                                currentDelivery = sender.delivery(EMPTY_BYTE_ARRAY, 0, 0);\n                            } else {\n                                final byte[] tag = nextTag();\n                                currentDelivery = sender.delivery(tag, 0, tag.length);\n                            }\n                            currentDelivery.setContext(md);\n                        } else {\n                            // TODO: message could not be generated what now?\n                        }\n                    }\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }",
            " 924  \n 925  \n 926  \n 927  \n 928  \n 929  \n 930  \n 931  \n 932  \n 933  \n 934  \n 935  \n 936  \n 937  \n 938  \n 939  \n 940  \n 941  \n 942  \n 943  \n 944  \n 945  \n 946  \n 947  \n 948  \n 949  \n 950  \n 951  \n 952  \n 953  \n 954  \n 955 +\n 956 +\n 957 +\n 958 +\n 959  \n 960  \n 961  \n 962  \n 963  \n 964  \n 965  \n 966  \n 967  \n 968  \n 969  \n 970  \n 971  \n 972  \n 973  \n 974  \n 975  \n 976  \n 977  \n 978  \n 979  \n 980  \n 981  \n 982  \n 983  \n 984  \n 985  \n 986  \n 987  \n 988  \n 989  \n 990  \n 991  \n 992  \n 993  \n 994  \n 995  \n 996  \n 997  \n 998  \n 999  ",
            "        public void pumpOutbound() throws Exception {\n            while (!closed) {\n\n                while (currentBuffer != null) {\n                    int sent = sender.send(currentBuffer.data, currentBuffer.offset, currentBuffer.length);\n                    if (sent > 0) {\n                        currentBuffer.moveHead(sent);\n                        if (currentBuffer.length == 0) {\n                            if (presettle) {\n                                settle(currentDelivery, MessageAck.INDIVIDUAL_ACK_TYPE);\n                            } else {\n                                sender.advance();\n                            }\n                            currentBuffer = null;\n                            currentDelivery = null;\n                        }\n                    } else {\n                        return;\n                    }\n                }\n\n                if (outbound.isEmpty()) {\n                    return;\n                }\n\n                final MessageDispatch md = outbound.removeFirst();\n                try {\n\n                    ActiveMQMessage temp = null;\n                    if (md.getMessage() != null) {\n\n                        // Topics can dispatch the same Message to more than one\n                        // consumer\n                        // so we must copy to prevent concurrent read / write to\n                        // the same\n                        // message object.\n                        if (md.getDestination().isTopic()) {\n                            synchronized (md.getMessage()) {\n                                temp = (ActiveMQMessage) md.getMessage().copy();\n                            }\n                        } else {\n                            temp = (ActiveMQMessage) md.getMessage();\n                        }\n\n                        if (!temp.getProperties().containsKey(MESSAGE_FORMAT_KEY)) {\n                            temp.setProperty(MESSAGE_FORMAT_KEY, 0);\n                        }\n                    }\n\n                    final ActiveMQMessage jms = temp;\n                    if (jms == null) {\n                        // It's the end of browse signal.\n                        endOfBrowse = true;\n                        drainCheck();\n                    } else {\n                        jms.setRedeliveryCounter(md.getRedeliveryCounter());\n                        jms.setReadOnlyBody(true);\n                        final EncodedMessage amqp = outboundTransformer.transform(jms);\n                        if (amqp != null && amqp.getLength() > 0) {\n                            currentBuffer = new Buffer(amqp.getArray(), amqp.getArrayOffset(), amqp.getLength());\n                            if (presettle) {\n                                currentDelivery = sender.delivery(EMPTY_BYTE_ARRAY, 0, 0);\n                            } else {\n                                final byte[] tag = nextTag();\n                                currentDelivery = sender.delivery(tag, 0, tag.length);\n                            }\n                            currentDelivery.setContext(md);\n                        } else {\n                            // TODO: message could not be generated what now?\n                        }\n                    }\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }"
        ],
        [
            "AmqpProtocolConverter::ConsumerContext::drainCheck()",
            "1041  \n1042  \n1043  \n1044  \n1045 -\n1046  \n1047  \n1048  \n1049  \n1050  \n1051  ",
            "        @Override\n        public void drainCheck() {\n            // If we are a browser.. lets not say we are drained until\n            // we hit the end of browse message.\n            if( info.isBrowser() && !endOfBrowse)\n                return;\n\n            if (outbound.isEmpty()) {\n                sender.drained();\n            }\n        }",
            "1055  \n1056  \n1057  \n1058  \n1059 +\n1060  \n1061  \n1062  \n1063  \n1064  \n1065  ",
            "        @Override\n        public void drainCheck() {\n            // If we are a browser.. lets not say we are drained until\n            // we hit the end of browse message.\n            if (info.isBrowser() && !endOfBrowse)\n                return;\n\n            if (outbound.isEmpty()) {\n                sender.drained();\n            }\n        }"
        ],
        [
            "ActiveMQJMSVendor::setJMSXGroupID(Message,String)",
            " 110  \n 111  \n 112 -\n 113  ",
            "    @Override\n    public void setJMSXGroupID(Message msg, String value) {\n        ((ActiveMQMessage)msg).setGroupID(value);\n    }",
            " 110  \n 111  \n 112 +\n 113  ",
            "    @Override\n    public void setJMSXGroupID(Message msg, String value) {\n        ((ActiveMQMessage) msg).setGroupID(value);\n    }"
        ],
        [
            "AMQPSslTransportFactory::serverConfigure(Transport,WireFormat,HashMap)",
            "  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61 -\n  62 -\n  63 -\n  64 -\n  65 -\n  66  \n  67  ",
            "    @SuppressWarnings(\"rawtypes\")\n    @Override\n    public Transport serverConfigure(Transport transport, WireFormat format, HashMap options) throws Exception {\n        transport = super.serverConfigure(transport, format, options);\n\n        // strip off the mutex transport.\n        if (transport instanceof MutexTransport) {\n            transport = ((MutexTransport) transport).getNext();\n        }\n\n        // MutexTransport mutex = transport.narrow(MutexTransport.class);\n        // if (mutex != null) {\n        // mutex.setSyncOnCommand(true);\n        // }\n\n        return transport;\n    }",
            "  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  ",
            "    @SuppressWarnings(\"rawtypes\")\n    @Override\n    public Transport serverConfigure(Transport transport, WireFormat format, HashMap options) throws Exception {\n        transport = super.serverConfigure(transport, format, options);\n\n        // strip off the mutex transport.\n        if (transport instanceof MutexTransport) {\n            transport = ((MutexTransport) transport).getNext();\n        }\n\n        return transport;\n    }"
        ],
        [
            "AmqpHeader::setBuffer(Buffer)",
            "  73  \n  74 -\n  75  \n  76  \n  77  \n  78  ",
            "    public void setBuffer(Buffer value) {\n        if( !value.startsWith(PREFIX) || value.length()!=8 ) {\n            throw new IllegalArgumentException(\"Not an AMQP header buffer\");\n        }\n        buffer = value.buffer();\n    }",
            "  73  \n  74 +\n  75  \n  76  \n  77  \n  78  ",
            "    public void setBuffer(Buffer value) {\n        if (!value.startsWith(PREFIX) || value.length() != 8) {\n            throw new IllegalArgumentException(\"Not an AMQP header buffer\");\n        }\n        buffer = value.buffer();\n    }"
        ],
        [
            "AmqpNioTransportHelper::handleAmqpHeader(ByteBuffer)",
            " 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155 -\n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  ",
            "    private int handleAmqpHeader(ByteBuffer plain) {\n        int nextFrameSize;\n\n        LOG.debug(\"Consuming AMQP_HEADER\");\n        currentBuffer = ByteBuffer.allocate(8);\n        currentBuffer.putInt(AMQP_HEADER_VALUE);\n        while (currentBuffer.hasRemaining()) {\n            currentBuffer.put(plain.get());\n        }\n        currentBuffer.flip();\n        if (!magicConsumed) {   // The first case we see is special and has to be handled differently\n            transportSupport.doConsume(new AmqpHeader(new Buffer(currentBuffer)));\n            magicConsumed = true;\n        } else {\n            transportSupport.doConsume(AmqpSupport.toBuffer(currentBuffer));\n        }\n        currentBuffer = null;\n\n        if (plain.hasRemaining()) {\n            if (plain.remaining() < 4) {\n                nextFrameSize = 4;\n            } else {\n                nextFrameSize = plain.getInt();\n            }\n        } else {\n            nextFrameSize = -1;\n        }\n\n        return nextFrameSize;\n    }",
            " 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160 +\n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  ",
            "    private int handleAmqpHeader(ByteBuffer plain) {\n        int nextFrameSize;\n\n        LOG.debug(\"Consuming AMQP_HEADER\");\n        currentBuffer = ByteBuffer.allocate(8);\n        currentBuffer.putInt(AMQP_HEADER_VALUE);\n        while (currentBuffer.hasRemaining()) {\n            currentBuffer.put(plain.get());\n        }\n        currentBuffer.flip();\n        if (!magicConsumed) { // The first case we see is special and has to be handled differently\n            transportSupport.doConsume(new AmqpHeader(new Buffer(currentBuffer)));\n            magicConsumed = true;\n        } else {\n            transportSupport.doConsume(AmqpSupport.toBuffer(currentBuffer));\n        }\n        currentBuffer = null;\n\n        if (plain.hasRemaining()) {\n            if (plain.remaining() < 4) {\n                nextFrameSize = 4;\n            } else {\n                nextFrameSize = plain.getInt();\n            }\n        } else {\n            nextFrameSize = -1;\n        }\n\n        return nextFrameSize;\n    }"
        ],
        [
            "AmqpNioTransportFactory::serverConfigure(Transport,WireFormat,HashMap)",
            "  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73 -\n  74 -\n  75 -\n  76 -\n  77 -\n  78  \n  79  ",
            "    @SuppressWarnings(\"rawtypes\")\n    @Override\n    public Transport serverConfigure(Transport transport, WireFormat format, HashMap options) throws Exception {\n        transport = super.serverConfigure(transport, format, options);\n\n        // strip off the mutex transport.\n        if( transport instanceof MutexTransport ) {\n            transport = ((MutexTransport)transport).getNext();\n        }\n\n//        MutexTransport mutex = transport.narrow(MutexTransport.class);\n//        if (mutex != null) {\n//            mutex.setSyncOnCommand(true);\n//        }\n\n        return transport;\n    }",
            "  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  ",
            "    @SuppressWarnings(\"rawtypes\")\n    @Override\n    public Transport serverConfigure(Transport transport, WireFormat format, HashMap options) throws Exception {\n        transport = super.serverConfigure(transport, format, options);\n\n        // strip off the mutex transport.\n        if( transport instanceof MutexTransport ) {\n            transport = ((MutexTransport)transport).getNext();\n        }\n\n        return transport;\n    }"
        ],
        [
            "AmqpHeader::setRevision(int)",
            "  66  \n  67 -\n  68  ",
            "    public void setRevision(int value) {\n        buffer.data[buffer.offset+7] = (byte) value;\n    }",
            "  65  \n  66 +\n  67  ",
            "    public void setRevision(int value) {\n        buffer.data[buffer.offset + 7] = (byte) value;\n    }"
        ],
        [
            "AmqpHeader::setMinor(int)",
            "  59  \n  60 -\n  61  ",
            "    public void setMinor(int value) {\n        buffer.data[buffer.offset+6] = (byte) value;\n    }",
            "  57  \n  58 +\n  59  ",
            "    public void setMinor(int value) {\n        buffer.data[buffer.offset + 6] = (byte) value;\n    }"
        ],
        [
            "AmqpHeader::setMajor(int)",
            "  52  \n  53 -\n  54  ",
            "    public void setMajor(int value) {\n        buffer.data[buffer.offset+5] = (byte) value;\n    }",
            "  49  \n  50 +\n  51  ",
            "    public void setMajor(int value) {\n        buffer.data[buffer.offset + 5] = (byte) value;\n    }"
        ],
        [
            "AmqpProtocolConverter::onActiveMQCommand(Command)",
            " 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374 -\n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396 -\n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  ",
            "    @Override\n    public void onActiveMQCommand(Command command) throws Exception {\n        if (command.isResponse()) {\n            Response response = (Response) command;\n            ResponseHandler rh = resposeHandlers.remove(Integer.valueOf(response.getCorrelationId()));\n            if (rh != null) {\n                rh.onResponse(this, response);\n            } else {\n                // Pass down any unexpected errors. Should this close the connection?\n                if (response.isException()) {\n                    Throwable exception = ((ExceptionResponse) response).getException();\n                    handleException(exception);\n                }\n            }\n        } else if (command.isMessageDispatch()) {\n            MessageDispatch md = (MessageDispatch) command;\n            ConsumerContext consumerContext = subscriptionsByConsumerId.get(md.getConsumerId());\n            if (consumerContext != null) {\n                // End of Queue Browse will have no Message object.\n                if (md.getMessage() != null) {\n                    LOG.trace(\"Dispatching MessageId: {} to consumer\", md.getMessage().getMessageId());\n                } else {\n                    LOG.trace(\"Dispatching End of Browse Command to consumer {}\", md.getConsumerId());\n                }\n                consumerContext.onMessageDispatch(md);\n                if (md.getMessage() != null) {\n                    LOG.trace(\"Finished Dispatch of MessageId: {} to consumer\", md.getMessage().getMessageId());\n                }\n            }\n        } else if (command.getDataStructureType() == ConnectionError.DATA_STRUCTURE_TYPE) {\n            // Pass down any unexpected async errors. Should this close the connection?\n            Throwable exception = ((ConnectionError) command).getException();\n            handleException(exception);\n        } else if (command.isBrokerInfo()) {\n            // ignore\n        } else {\n            LOG.debug(\"Do not know how to process ActiveMQ Command {}\", command);\n        }\n    }",
            " 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377 +\n 378 +\n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400 +\n 401 +\n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  ",
            "    @Override\n    public void onActiveMQCommand(Command command) throws Exception {\n        if (command.isResponse()) {\n            Response response = (Response) command;\n            ResponseHandler rh = resposeHandlers.remove(Integer.valueOf(response.getCorrelationId()));\n            if (rh != null) {\n                rh.onResponse(this, response);\n            } else {\n                // Pass down any unexpected errors. Should this close the\n                // connection?\n                if (response.isException()) {\n                    Throwable exception = ((ExceptionResponse) response).getException();\n                    handleException(exception);\n                }\n            }\n        } else if (command.isMessageDispatch()) {\n            MessageDispatch md = (MessageDispatch) command;\n            ConsumerContext consumerContext = subscriptionsByConsumerId.get(md.getConsumerId());\n            if (consumerContext != null) {\n                // End of Queue Browse will have no Message object.\n                if (md.getMessage() != null) {\n                    LOG.trace(\"Dispatching MessageId: {} to consumer\", md.getMessage().getMessageId());\n                } else {\n                    LOG.trace(\"Dispatching End of Browse Command to consumer {}\", md.getConsumerId());\n                }\n                consumerContext.onMessageDispatch(md);\n                if (md.getMessage() != null) {\n                    LOG.trace(\"Finished Dispatch of MessageId: {} to consumer\", md.getMessage().getMessageId());\n                }\n            }\n        } else if (command.getDataStructureType() == ConnectionError.DATA_STRUCTURE_TYPE) {\n            // Pass down any unexpected async errors. Should this close the\n            // connection?\n            Throwable exception = ((ConnectionError) command).getException();\n            handleException(exception);\n        } else if (command.isBrokerInfo()) {\n            // ignore\n        } else {\n            LOG.debug(\"Do not know how to process ActiveMQ Command {}\", command);\n        }\n    }"
        ],
        [
            "ActiveMQJMSVendor::setJMSXGroupSequence(Message,int)",
            " 115  \n 116  \n 117 -\n 118  ",
            "    @Override\n    public void setJMSXGroupSequence(Message msg, int value) {\n        ((ActiveMQMessage)msg).setGroupSequence(value);\n    }",
            " 115  \n 116  \n 117 +\n 118  ",
            "    @Override\n    public void setJMSXGroupSequence(Message msg, int value) {\n        ((ActiveMQMessage) msg).setGroupSequence(value);\n    }"
        ]
    ],
    "7ebc6ceef8f97e2d0002df6a4befe04d528d8275": [
        [
            "MQTTProtocolConverter::onMQTTPubAck(PUBACK)",
            " 442  \n 443  \n 444  \n 445  \n 446  \n 447  \n 448  \n 449  \n 450  \n 451  \n 452  ",
            "    void onMQTTPubAck(PUBACK command) {\n        short messageId = command.messageId();\n        packetIdGenerator.ackPacketId(getClientId(), messageId);\n        MessageAck ack;\n        synchronized (consumerAcks) {\n            ack = consumerAcks.remove(messageId);\n        }\n        if (ack != null) {\n            getMQTTTransport().sendToActiveMQ(ack);\n        }\n    }",
            " 448  \n 449  \n 450 +\n 451 +\n 452  \n 453  \n 454  \n 455  \n 456  \n 457  \n 458  \n 459  \n 460  ",
            "    void onMQTTPubAck(PUBACK command) {\n        short messageId = command.messageId();\n        LOG.trace(\"MQTT Rcv PUBACK message:{} client:{} connection:{}\",\n                  messageId, clientId, connectionInfo.getConnectionId());\n        packetIdGenerator.ackPacketId(getClientId(), messageId);\n        MessageAck ack;\n        synchronized (consumerAcks) {\n            ack = consumerAcks.remove(messageId);\n        }\n        if (ack != null) {\n            getMQTTTransport().sendToActiveMQ(ack);\n        }\n    }"
        ],
        [
            "MQTTProtocolConverter::onActiveMQCommand(Command)",
            " 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  \n 423  \n 424  \n 425  \n 426  \n 427  \n 428  \n 429  \n 430  \n 431  \n 432  ",
            "    /**\n     * Dispatch an ActiveMQ command\n     */\n    public void onActiveMQCommand(Command command) throws Exception {\n        if (command.isResponse()) {\n            Response response = (Response) command;\n            ResponseHandler rh = resposeHandlers.remove(Integer.valueOf(response.getCorrelationId()));\n            if (rh != null) {\n                rh.onResponse(this, response);\n            } else {\n                // Pass down any unexpected errors. Should this close the connection?\n                if (response.isException()) {\n                    Throwable exception = ((ExceptionResponse) response).getException();\n                    handleException(exception, null);\n                }\n            }\n        } else if (command.isMessageDispatch()) {\n            MessageDispatch md = (MessageDispatch) command;\n            MQTTSubscription sub = findSubscriptionStrategy().getSubscription(md.getConsumerId());\n            if (sub != null) {\n                MessageAck ack = sub.createMessageAck(md);\n                PUBLISH publish = sub.createPublish((ActiveMQMessage) md.getMessage());\n                switch (publish.qos()) {\n                    case AT_LEAST_ONCE:\n                    case EXACTLY_ONCE:\n                        publish.dup(publish.dup() ? true : md.getMessage().isRedelivered());\n                    case AT_MOST_ONCE:\n                }\n                if (ack != null && sub.expectAck(publish)) {\n                    synchronized (consumerAcks) {\n                        consumerAcks.put(publish.messageId(), ack);\n                    }\n                }\n                getMQTTTransport().sendToMQTT(publish.encode());\n                if (ack != null && !sub.expectAck(publish)) {\n                    getMQTTTransport().sendToActiveMQ(ack);\n                }\n            }\n        } else if (command.getDataStructureType() == ConnectionError.DATA_STRUCTURE_TYPE) {\n            // Pass down any unexpected async errors. Should this close the connection?\n            Throwable exception = ((ConnectionError) command).getException();\n            handleException(exception, null);\n        } else if (command.isBrokerInfo()) {\n            //ignore\n        } else {\n            LOG.debug(\"Do not know how to process ActiveMQ Command {}\", command);\n        }\n    }",
            " 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420 +\n 421 +\n 422  \n 423  \n 424  \n 425  \n 426  \n 427  \n 428  \n 429  \n 430  \n 431  \n 432  \n 433  \n 434  \n 435  \n 436  ",
            "    /**\n     * Dispatch an ActiveMQ command\n     */\n    public void onActiveMQCommand(Command command) throws Exception {\n        if (command.isResponse()) {\n            Response response = (Response) command;\n            ResponseHandler rh = resposeHandlers.remove(Integer.valueOf(response.getCorrelationId()));\n            if (rh != null) {\n                rh.onResponse(this, response);\n            } else {\n                // Pass down any unexpected errors. Should this close the connection?\n                if (response.isException()) {\n                    Throwable exception = ((ExceptionResponse) response).getException();\n                    handleException(exception, null);\n                }\n            }\n        } else if (command.isMessageDispatch()) {\n            MessageDispatch md = (MessageDispatch) command;\n            MQTTSubscription sub = findSubscriptionStrategy().getSubscription(md.getConsumerId());\n            if (sub != null) {\n                MessageAck ack = sub.createMessageAck(md);\n                PUBLISH publish = sub.createPublish((ActiveMQMessage) md.getMessage());\n                switch (publish.qos()) {\n                    case AT_LEAST_ONCE:\n                    case EXACTLY_ONCE:\n                        publish.dup(publish.dup() ? true : md.getMessage().isRedelivered());\n                    case AT_MOST_ONCE:\n                }\n                if (ack != null && sub.expectAck(publish)) {\n                    synchronized (consumerAcks) {\n                        consumerAcks.put(publish.messageId(), ack);\n                    }\n                }\n                LOG.trace(\"MQTT Snd PUBLISH message:{} client:{} connection:{}\",\n                          publish.messageId(), clientId, connectionInfo.getConnectionId());\n                getMQTTTransport().sendToMQTT(publish.encode());\n                if (ack != null && !sub.expectAck(publish)) {\n                    getMQTTTransport().sendToActiveMQ(ack);\n                }\n            }\n        } else if (command.getDataStructureType() == ConnectionError.DATA_STRUCTURE_TYPE) {\n            // Pass down any unexpected async errors. Should this close the connection?\n            Throwable exception = ((ConnectionError) command).getException();\n            handleException(exception, null);\n        } else if (command.isBrokerInfo()) {\n            //ignore\n        } else {\n            LOG.debug(\"Do not know how to process ActiveMQ Command {}\", command);\n        }\n    }"
        ],
        [
            "MQTTProtocolConverter::createResponseHandler(PUBLISH)",
            " 682  \n 683  \n 684  \n 685  \n 686  \n 687  \n 688  \n 689  \n 690  \n 691  \n 692  \n 693  \n 694  \n 695  \n 696  \n 697  \n 698  \n 699  \n 700  \n 701  \n 702  \n 703  \n 704  \n 705  \n 706  \n 707  \n 708  \n 709  \n 710  \n 711  \n 712  \n 713  \n 714  \n 715  \n 716  \n 717  \n 718  \n 719  ",
            "    ResponseHandler createResponseHandler(final PUBLISH command) {\n        if (command != null) {\n            switch (command.qos()) {\n                case AT_LEAST_ONCE:\n                    return new ResponseHandler() {\n                        @Override\n                        public void onResponse(MQTTProtocolConverter converter, Response response) throws IOException {\n                            if (response.isException()) {\n                                LOG.warn(\"Failed to send MQTT Publish: \", command, ((ExceptionResponse) response).getException());\n                            } else {\n                                PUBACK ack = new PUBACK();\n                                ack.messageId(command.messageId());\n                                converter.getMQTTTransport().sendToMQTT(ack.encode());\n                            }\n                        }\n                    };\n                case EXACTLY_ONCE:\n                    return new ResponseHandler() {\n                        @Override\n                        public void onResponse(MQTTProtocolConverter converter, Response response) throws IOException {\n                            if (response.isException()) {\n                                LOG.warn(\"Failed to send MQTT Publish: \", command, ((ExceptionResponse) response).getException());\n                            } else {\n                                PUBREC ack = new PUBREC();\n                                ack.messageId(command.messageId());\n                                synchronized (publisherRecs) {\n                                    publisherRecs.put(command.messageId(), ack);\n                                }\n                                converter.getMQTTTransport().sendToMQTT(ack.encode());\n                            }\n                        }\n                    };\n                case AT_MOST_ONCE:\n                    break;\n            }\n        }\n        return null;\n    }",
            " 694  \n 695  \n 696  \n 697  \n 698  \n 699  \n 700  \n 701  \n 702  \n 703  \n 704  \n 705  \n 706 +\n 707 +\n 708  \n 709  \n 710  \n 711  \n 712  \n 713  \n 714  \n 715  \n 716  \n 717  \n 718  \n 719  \n 720  \n 721  \n 722  \n 723  \n 724 +\n 725 +\n 726  \n 727  \n 728  \n 729  \n 730  \n 731  \n 732  \n 733  \n 734  \n 735  ",
            "    ResponseHandler createResponseHandler(final PUBLISH command) {\n        if (command != null) {\n            switch (command.qos()) {\n                case AT_LEAST_ONCE:\n                    return new ResponseHandler() {\n                        @Override\n                        public void onResponse(MQTTProtocolConverter converter, Response response) throws IOException {\n                            if (response.isException()) {\n                                LOG.warn(\"Failed to send MQTT Publish: \", command, ((ExceptionResponse) response).getException());\n                            } else {\n                                PUBACK ack = new PUBACK();\n                                ack.messageId(command.messageId());\n                                LOG.trace(\"MQTT Snd PUBACK message:{} client:{} connection:{}\",\n                                          command.messageId(), clientId, connectionInfo.getConnectionId());\n                                converter.getMQTTTransport().sendToMQTT(ack.encode());\n                            }\n                        }\n                    };\n                case EXACTLY_ONCE:\n                    return new ResponseHandler() {\n                        @Override\n                        public void onResponse(MQTTProtocolConverter converter, Response response) throws IOException {\n                            if (response.isException()) {\n                                LOG.warn(\"Failed to send MQTT Publish: \", command, ((ExceptionResponse) response).getException());\n                            } else {\n                                PUBREC ack = new PUBREC();\n                                ack.messageId(command.messageId());\n                                synchronized (publisherRecs) {\n                                    publisherRecs.put(command.messageId(), ack);\n                                }\n                                LOG.trace(\"MQTT Snd PUBACK message:{} client:{} connection:{}\",\n                                          command.messageId(), clientId, connectionInfo.getConnectionId());\n                                converter.getMQTTTransport().sendToMQTT(ack.encode());\n                            }\n                        }\n                    };\n                case AT_MOST_ONCE:\n                    break;\n            }\n        }\n        return null;\n    }"
        ],
        [
            "MQTTProtocolConverter::convertMessage(ActiveMQMessage)",
            " 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528  \n 529  \n 530  \n 531  \n 532  \n 533  \n 534  \n 535  \n 536  \n 537  \n 538  \n 539  \n 540  \n 541  \n 542  \n 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564  \n 565  \n 566  \n 567  \n 568  \n 569  \n 570  \n 571  \n 572  \n 573  \n 574  \n 575  \n 576  \n 577  \n 578  \n 579  \n 580  \n 581  \n 582  \n 583  \n 584  \n 585  \n 586  ",
            "    public PUBLISH convertMessage(ActiveMQMessage message) throws IOException, JMSException, DataFormatException {\n        PUBLISH result = new PUBLISH();\n        // packet id is set in MQTTSubscription\n        QoS qoS;\n        if (message.propertyExists(QOS_PROPERTY_NAME)) {\n            int ordinal = message.getIntProperty(QOS_PROPERTY_NAME);\n            qoS = QoS.values()[ordinal];\n\n        } else {\n            qoS = message.isPersistent() ? QoS.AT_MOST_ONCE : QoS.AT_LEAST_ONCE;\n        }\n        result.qos(qoS);\n        if (message.getBooleanProperty(RetainedMessageSubscriptionRecoveryPolicy.RETAINED_PROPERTY)) {\n            result.retain(true);\n        }\n\n        String topicName;\n        synchronized (mqttTopicMap) {\n            topicName = mqttTopicMap.get(message.getJMSDestination());\n            if (topicName == null) {\n                String amqTopicName = findSubscriptionStrategy().onSend(message.getDestination());\n                topicName = MQTTProtocolSupport.convertActiveMQToMQTT(amqTopicName);\n                mqttTopicMap.put(message.getJMSDestination(), topicName);\n            }\n        }\n        result.topicName(new UTF8Buffer(topicName));\n\n        if (message.getDataStructureType() == ActiveMQTextMessage.DATA_STRUCTURE_TYPE) {\n            ActiveMQTextMessage msg = (ActiveMQTextMessage) message.copy();\n            msg.setReadOnlyBody(true);\n            String messageText = msg.getText();\n            if (messageText != null) {\n                result.payload(new Buffer(messageText.getBytes(\"UTF-8\")));\n            }\n        } else if (message.getDataStructureType() == ActiveMQBytesMessage.DATA_STRUCTURE_TYPE) {\n            ActiveMQBytesMessage msg = (ActiveMQBytesMessage) message.copy();\n            msg.setReadOnlyBody(true);\n            byte[] data = new byte[(int) msg.getBodyLength()];\n            msg.readBytes(data);\n            result.payload(new Buffer(data));\n        } else if (message.getDataStructureType() == ActiveMQMapMessage.DATA_STRUCTURE_TYPE) {\n            ActiveMQMapMessage msg = (ActiveMQMapMessage) message.copy();\n            msg.setReadOnlyBody(true);\n            Map<String, Object> map = msg.getContentMap();\n            if (map != null) {\n                result.payload(new Buffer(map.toString().getBytes(\"UTF-8\")));\n            }\n        } else {\n            ByteSequence byteSequence = message.getContent();\n            if (byteSequence != null && byteSequence.getLength() > 0) {\n                if (message.isCompressed()) {\n                    Inflater inflater = new Inflater();\n                    inflater.setInput(byteSequence.data, byteSequence.offset, byteSequence.length);\n                    byte[] data = new byte[4096];\n                    int read;\n                    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();\n                    while ((read = inflater.inflate(data)) != 0) {\n                        bytesOut.write(data, 0, read);\n                    }\n                    byteSequence = bytesOut.toByteSequence();\n                    bytesOut.close();\n                }\n                result.payload(new Buffer(byteSequence.data, byteSequence.offset, byteSequence.length));\n            }\n        }\n        return result;\n    }",
            " 530  \n 531  \n 532  \n 533  \n 534  \n 535  \n 536  \n 537  \n 538  \n 539  \n 540  \n 541  \n 542  \n 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564  \n 565  \n 566  \n 567  \n 568  \n 569  \n 570  \n 571  \n 572  \n 573  \n 574  \n 575  \n 576  \n 577  \n 578  \n 579  \n 580  \n 581  \n 582  \n 583  \n 584  \n 585  \n 586  \n 587  \n 588  \n 589  \n 590  \n 591  \n 592  \n 593  \n 594  \n 595 +\n 596 +\n 597  \n 598  ",
            "    public PUBLISH convertMessage(ActiveMQMessage message) throws IOException, JMSException, DataFormatException {\n        PUBLISH result = new PUBLISH();\n        // packet id is set in MQTTSubscription\n        QoS qoS;\n        if (message.propertyExists(QOS_PROPERTY_NAME)) {\n            int ordinal = message.getIntProperty(QOS_PROPERTY_NAME);\n            qoS = QoS.values()[ordinal];\n\n        } else {\n            qoS = message.isPersistent() ? QoS.AT_MOST_ONCE : QoS.AT_LEAST_ONCE;\n        }\n        result.qos(qoS);\n        if (message.getBooleanProperty(RetainedMessageSubscriptionRecoveryPolicy.RETAINED_PROPERTY)) {\n            result.retain(true);\n        }\n\n        String topicName;\n        synchronized (mqttTopicMap) {\n            topicName = mqttTopicMap.get(message.getJMSDestination());\n            if (topicName == null) {\n                String amqTopicName = findSubscriptionStrategy().onSend(message.getDestination());\n                topicName = MQTTProtocolSupport.convertActiveMQToMQTT(amqTopicName);\n                mqttTopicMap.put(message.getJMSDestination(), topicName);\n            }\n        }\n        result.topicName(new UTF8Buffer(topicName));\n\n        if (message.getDataStructureType() == ActiveMQTextMessage.DATA_STRUCTURE_TYPE) {\n            ActiveMQTextMessage msg = (ActiveMQTextMessage) message.copy();\n            msg.setReadOnlyBody(true);\n            String messageText = msg.getText();\n            if (messageText != null) {\n                result.payload(new Buffer(messageText.getBytes(\"UTF-8\")));\n            }\n        } else if (message.getDataStructureType() == ActiveMQBytesMessage.DATA_STRUCTURE_TYPE) {\n            ActiveMQBytesMessage msg = (ActiveMQBytesMessage) message.copy();\n            msg.setReadOnlyBody(true);\n            byte[] data = new byte[(int) msg.getBodyLength()];\n            msg.readBytes(data);\n            result.payload(new Buffer(data));\n        } else if (message.getDataStructureType() == ActiveMQMapMessage.DATA_STRUCTURE_TYPE) {\n            ActiveMQMapMessage msg = (ActiveMQMapMessage) message.copy();\n            msg.setReadOnlyBody(true);\n            Map<String, Object> map = msg.getContentMap();\n            if (map != null) {\n                result.payload(new Buffer(map.toString().getBytes(\"UTF-8\")));\n            }\n        } else {\n            ByteSequence byteSequence = message.getContent();\n            if (byteSequence != null && byteSequence.getLength() > 0) {\n                if (message.isCompressed()) {\n                    Inflater inflater = new Inflater();\n                    inflater.setInput(byteSequence.data, byteSequence.offset, byteSequence.length);\n                    byte[] data = new byte[4096];\n                    int read;\n                    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();\n                    while ((read = inflater.inflate(data)) != 0) {\n                        bytesOut.write(data, 0, read);\n                    }\n                    byteSequence = bytesOut.toByteSequence();\n                    bytesOut.close();\n                }\n                result.payload(new Buffer(byteSequence.data, byteSequence.offset, byteSequence.length));\n            }\n        }\n        LOG.trace(\"ActiveMQ-->MQTT:MQTT_MSGID:{} client:{} connection:{} ActiveMQ_MSGID:{}\",\n                result.messageId(), clientId, connectionInfo.getConnectionId(), message.getMessageId());\n        return result;\n    }"
        ],
        [
            "MQTTProtocolConverter::onSubscribe(SUBSCRIBE)",
            " 343  \n 344  \n 345  \n 346  \n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  ",
            "    void onSubscribe(SUBSCRIBE command) throws MQTTProtocolException {\n        checkConnected();\n        Topic[] topics = command.topics();\n        if (topics != null) {\n            byte[] qos = new byte[topics.length];\n            for (int i = 0; i < topics.length; i++) {\n                try {\n                    qos[i] = findSubscriptionStrategy().onSubscribe(topics[i]);\n                } catch (IOException e) {\n                    throw new MQTTProtocolException(\"Failed to process subscription request\", true, e);\n                }\n            }\n            SUBACK ack = new SUBACK();\n            ack.messageId(command.messageId());\n            ack.grantedQos(qos);\n            try {\n                getMQTTTransport().sendToMQTT(ack.encode());\n            } catch (IOException e) {\n                LOG.warn(\"Couldn't send SUBACK for \" + command, e);\n            }\n        } else {\n            LOG.warn(\"No topics defined for Subscription \" + command);\n        }\n    }",
            " 343  \n 344  \n 345 +\n 346 +\n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  ",
            "    void onSubscribe(SUBSCRIBE command) throws MQTTProtocolException {\n        checkConnected();\n        LOG.trace(\"MQTT SUBSCRIBE message:{} client:{} connection:{}\",\n                  command.messageId(), clientId, connectionInfo.getConnectionId());\n        Topic[] topics = command.topics();\n        if (topics != null) {\n            byte[] qos = new byte[topics.length];\n            for (int i = 0; i < topics.length; i++) {\n                try {\n                    qos[i] = findSubscriptionStrategy().onSubscribe(topics[i]);\n                } catch (IOException e) {\n                    throw new MQTTProtocolException(\"Failed to process subscription request\", true, e);\n                }\n            }\n            SUBACK ack = new SUBACK();\n            ack.messageId(command.messageId());\n            ack.grantedQos(qos);\n            try {\n                getMQTTTransport().sendToMQTT(ack.encode());\n            } catch (IOException e) {\n                LOG.warn(\"Couldn't send SUBACK for \" + command, e);\n            }\n        } else {\n            LOG.warn(\"No topics defined for Subscription \" + command);\n        }\n    }"
        ],
        [
            "MQTTProtocolConverter::onMQTTPublish(PUBLISH)",
            " 434  \n 435  \n 436  \n 437  \n 438  \n 439  \n 440  ",
            "    void onMQTTPublish(PUBLISH command) throws IOException, JMSException {\n        checkConnected();\n        ActiveMQMessage message = convertMessage(command);\n        message.setProducerId(producerId);\n        message.onSend();\n        sendToActiveMQ(message, createResponseHandler(command));\n    }",
            " 438  \n 439  \n 440 +\n 441 +\n 442  \n 443  \n 444  \n 445  \n 446  ",
            "    void onMQTTPublish(PUBLISH command) throws IOException, JMSException {\n        checkConnected();\n        LOG.trace(\"MQTT Rcv PUBLISH message:{} client:{} connection:{}\",\n                  command.messageId(), clientId, connectionInfo.getConnectionId());\n        ActiveMQMessage message = convertMessage(command);\n        message.setProducerId(producerId);\n        message.onSend();\n        sendToActiveMQ(message, createResponseHandler(command));\n    }"
        ],
        [
            "MQTTProtocolConverter::convertMessage(PUBLISH)",
            " 486  \n 487  \n 488  \n 489  \n 490  \n 491  \n 492  \n 493  \n 494  \n 495  \n 496  \n 497  \n 498  \n 499  \n 500  \n 501  \n 502  \n 503  \n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512  \n 513  \n 514  \n 515  \n 516  \n 517  \n 518  ",
            "    ActiveMQMessage convertMessage(PUBLISH command) throws JMSException {\n        ActiveMQBytesMessage msg = new ActiveMQBytesMessage();\n\n        msg.setProducerId(producerId);\n        MessageId id = new MessageId(producerId, publisherIdGenerator.getNextSequenceId());\n        msg.setMessageId(id);\n        msg.setTimestamp(System.currentTimeMillis());\n        msg.setPriority((byte) Message.DEFAULT_PRIORITY);\n        msg.setPersistent(command.qos() != QoS.AT_MOST_ONCE && !command.retain());\n        msg.setIntProperty(QOS_PROPERTY_NAME, command.qos().ordinal());\n        if (command.retain()) {\n            msg.setBooleanProperty(RetainedMessageSubscriptionRecoveryPolicy.RETAIN_PROPERTY, true);\n        }\n\n        ActiveMQDestination destination;\n        synchronized (activeMQDestinationMap) {\n            destination = activeMQDestinationMap.get(command.topicName());\n            if (destination == null) {\n                String topicName = MQTTProtocolSupport.convertMQTTToActiveMQ(command.topicName().toString());\n                try {\n                    destination = findSubscriptionStrategy().onSend(topicName);\n                } catch (IOException e) {\n                    throw JMSExceptionSupport.create(e);\n                }\n\n                activeMQDestinationMap.put(command.topicName().toString(), destination);\n            }\n        }\n\n        msg.setJMSDestination(destination);\n        msg.writeBytes(command.payload().data, command.payload().offset, command.payload().length);\n        return msg;\n    }",
            " 494  \n 495  \n 496  \n 497  \n 498  \n 499  \n 500 +\n 501 +\n 502  \n 503  \n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512  \n 513  \n 514  \n 515  \n 516  \n 517  \n 518  \n 519  \n 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528  ",
            "    ActiveMQMessage convertMessage(PUBLISH command) throws JMSException {\n        ActiveMQBytesMessage msg = new ActiveMQBytesMessage();\n\n        msg.setProducerId(producerId);\n        MessageId id = new MessageId(producerId, publisherIdGenerator.getNextSequenceId());\n        msg.setMessageId(id);\n        LOG.trace(\"MQTT-->ActiveMQ: MQTT_MSGID:{} client:{} connection:{} ActiveMQ_MSGID:{}\",\n                command.messageId(), clientId, connectionInfo.getConnectionId(), msg.getMessageId());\n        msg.setTimestamp(System.currentTimeMillis());\n        msg.setPriority((byte) Message.DEFAULT_PRIORITY);\n        msg.setPersistent(command.qos() != QoS.AT_MOST_ONCE && !command.retain());\n        msg.setIntProperty(QOS_PROPERTY_NAME, command.qos().ordinal());\n        if (command.retain()) {\n            msg.setBooleanProperty(RetainedMessageSubscriptionRecoveryPolicy.RETAIN_PROPERTY, true);\n        }\n\n        ActiveMQDestination destination;\n        synchronized (activeMQDestinationMap) {\n            destination = activeMQDestinationMap.get(command.topicName());\n            if (destination == null) {\n                String topicName = MQTTProtocolSupport.convertMQTTToActiveMQ(command.topicName().toString());\n                try {\n                    destination = findSubscriptionStrategy().onSend(topicName);\n                } catch (IOException e) {\n                    throw JMSExceptionSupport.create(e);\n                }\n\n                activeMQDestinationMap.put(command.topicName().toString(), destination);\n            }\n        }\n\n        msg.setJMSDestination(destination);\n        msg.writeBytes(command.payload().data, command.payload().offset, command.payload().length);\n        return msg;\n    }"
        ]
    ],
    "d2bd152960a74de6a61c2ddbea81ddcdcb70c177": [
        [
            "AutoNIOTransport::readFromBuffer()",
            "  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  ",
            "    /**\n     * Read from the initial buffer if it is set\n     */\n    @Override\n    protected int readFromBuffer() throws IOException {\n        int readSize = 0;\n        if (!doneInitBuffer) {\n            if (initBuffer == null || initBuffer.readSize < 8) {\n                throw new IOException(\"Protocol type could not be determined.\");\n            }\n            if (nextFrameSize == -1) {\n                readSize = 4;\n                this.initBuffer.buffer.flip();\n                for (int i = 0; i < 4; i++) {\n                    currentBuffer.put(initBuffer.buffer.get());\n                }\n            } else {\n                for (int i = 0; i < 4; i++) {\n                    currentBuffer.put(initBuffer.buffer.get());\n                }\n                readSize = 4;\n                doneInitBuffer = true;\n            }\n\n        } else {\n            readSize += channel.read(currentBuffer);\n        }\n        return readSize;\n    }",
            "  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67 +\n  68 +\n  69 +\n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  ",
            "    /**\n     * Read from the initial buffer if it is set\n     */\n    @Override\n    protected int readFromBuffer() throws IOException {\n        int readSize = 0;\n        if (!doneInitBuffer) {\n            if (initBuffer == null || initBuffer.readSize < 8) {\n                throw new IOException(\"Protocol type could not be determined.\");\n            }\n            if (nextFrameSize == -1) {\n                readSize = 4;\n                this.initBuffer.buffer.flip();\n                if (this.initBuffer.buffer.remaining() < 8) {\n                    throw new IOException(\"Protocol type could not be determined.\");\n                }\n                for (int i = 0; i < 4; i++) {\n                    currentBuffer.put(initBuffer.buffer.get());\n                }\n            } else {\n                for (int i = 0; i < 4; i++) {\n                    currentBuffer.put(initBuffer.buffer.get());\n                }\n                readSize = 4;\n                doneInitBuffer = true;\n            }\n\n        } else {\n            readSize += channel.read(currentBuffer);\n        }\n        return readSize;\n    }"
        ],
        [
            "AutoTransportMaxConnectionsTest::testMaxConnectionControl()",
            "  98  \n  99  \n 100  \n 101  \n 102  \n 103 -\n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  ",
            "    @Test\n    public void testMaxConnectionControl() throws Exception {\n        final ConnectionFactory cf = createConnectionFactory();\n        final CountDownLatch startupLatch = new CountDownLatch(1);\n\n        for(int i = 0; i < maxConnections + 20; i++) {\n            executor.submit(new Runnable() {\n                @Override\n                public void run() {\n                    Connection conn = null;\n                    try {\n                        startupLatch.await();\n                        conn = cf.createConnection();\n                        conn.start();\n                    } catch (Exception e) {\n                        //JmsUtils.closeConnection(conn);\n                    }\n                }\n            });\n        }\n\n        TcpTransportServer transportServer = (TcpTransportServer)connector.getServer();\n        // ensure the max connections is in effect\n        assertEquals(maxConnections, transportServer.getMaximumConnections());\n        // No connections at first\n        assertEquals(0, connector.getConnections().size());\n        // Release the latch to set up connections in parallel\n        startupLatch.countDown();\n\n        final TransportConnector connector = this.connector;\n\n        // Expect the max connections is created\n        assertTrue(\"Expected: \" + maxConnections + \" found: \" + connector.getConnections().size(),\n            Wait.waitFor(new Wait.Condition() {\n                @Override\n                public boolean isSatisified() throws Exception {\n                    return connector.getConnections().size() == maxConnections;\n                }\n            })",
            "  97  \n  98  \n  99  \n 100  \n 101  \n 102 +\n 103 +\n 104 +\n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111 +\n 112 +\n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  ",
            "    @Test(timeout=60000)\n    public void testMaxConnectionControl() throws Exception {\n        final ConnectionFactory cf = createConnectionFactory();\n        final CountDownLatch startupLatch = new CountDownLatch(1);\n\n        //create an extra 10 connections above max\n        for(int i = 0; i < maxConnections + 10; i++) {\n            final int count = i;\n            executor.submit(new Runnable() {\n                @Override\n                public void run() {\n                    Connection conn = null;\n                    try {\n                        startupLatch.await();\n                        //sleep for a short period of time\n                        Thread.sleep(count * 3);\n                        conn = cf.createConnection();\n                        conn.start();\n                    } catch (Exception e) {\n                        //JmsUtils.closeConnection(conn);\n                    }\n                }\n            });\n        }\n\n        TcpTransportServer transportServer = (TcpTransportServer)connector.getServer();\n        // ensure the max connections is in effect\n        assertEquals(maxConnections, transportServer.getMaximumConnections());\n        // No connections at first\n        assertEquals(0, connector.getConnections().size());\n        // Release the latch to set up connections in parallel\n        startupLatch.countDown();\n\n        final TransportConnector connector = this.connector;\n\n        // Expect the max connections is created\n        assertTrue(\"Expected: \" + maxConnections + \" found: \" + connector.getConnections().size(),\n            Wait.waitFor(new Wait.Condition() {\n                @Override\n                public boolean isSatisified() throws Exception {\n                    return connector.getConnections().size() == maxConnections;\n                }\n            })"
        ]
    ],
    "5e05df1cb76af9a4d2e7d59cb3711747c5814b75": [
        [
            "SimpleJmsQueueConnector::initializeLocalConnection()",
            " 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228 -\n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  ",
            "    @Override\n    protected void initializeLocalConnection() throws NamingException, JMSException {\n\n        final QueueConnection newConnection;\n\n        if (localConnection.get() == null) {\n            // get the connection factories\n            if (localQueueConnectionFactory == null) {\n                if (embeddedConnectionFactory == null) {\n                    // look it up from JNDI\n                    if (localConnectionFactoryName != null) {\n                        localQueueConnectionFactory = (QueueConnectionFactory)jndiLocalTemplate\n                            .lookup(localConnectionFactoryName, QueueConnectionFactory.class);\n                        if (localUsername != null) {\n                            newConnection = localQueueConnectionFactory\n                                .createQueueConnection(localUsername, localPassword);\n                        } else {\n                            newConnection = localQueueConnectionFactory.createQueueConnection();\n                        }\n                    } else {\n                        throw new JMSException(\"Cannot create localConnection - no information\");\n                    }\n                } else {\n                    newConnection = embeddedConnectionFactory.createQueueConnection();\n                }\n            } else {\n                if (localUsername != null) {\n                    newConnection = localQueueConnectionFactory.\n                            createQueueConnection(localUsername, localPassword);\n                } else {\n                    newConnection = localQueueConnectionFactory.createQueueConnection();\n                }\n            }\n\n        } else {\n            // Clear if for now in case something goes wrong during the init.\n            newConnection = (QueueConnection) localConnection.getAndSet(null);\n        }\n\n        if (localClientId != null && localClientId.length() > 0) {\n            newConnection.setClientID(getLocalClientId());\n        }\n        newConnection.start();\n\n        inboundMessageConvertor.setConnection(newConnection);\n\n        // Configure the bridges with the new Local connection.\n        initializeInboundDestinationBridgesLocalSide(newConnection);\n        initializeOutboundDestinationBridgesLocalSide(newConnection);\n\n        // Register for any async error notifications now so we can reset in the\n        // case where there's not a lot of activity and a connection drops.\n        newConnection.setExceptionListener(new ExceptionListener() {\n            @Override\n            public void onException(JMSException exception) {\n                handleConnectionFailure(newConnection);\n            }\n        });\n\n        // At this point all looks good, so this our current connection now.\n        localConnection.set(newConnection);\n    }",
            " 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227 +\n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  ",
            "    @Override\n    protected void initializeLocalConnection() throws NamingException, JMSException {\n\n        final QueueConnection newConnection;\n\n        if (localConnection.get() == null) {\n            // get the connection factories\n            if (localQueueConnectionFactory == null) {\n                if (embeddedConnectionFactory == null) {\n                    // look it up from JNDI\n                    if (localConnectionFactoryName != null) {\n                        localQueueConnectionFactory = jndiLocalTemplate\n                            .lookup(localConnectionFactoryName, QueueConnectionFactory.class);\n                        if (localUsername != null) {\n                            newConnection = localQueueConnectionFactory\n                                .createQueueConnection(localUsername, localPassword);\n                        } else {\n                            newConnection = localQueueConnectionFactory.createQueueConnection();\n                        }\n                    } else {\n                        throw new JMSException(\"Cannot create localConnection - no information\");\n                    }\n                } else {\n                    newConnection = embeddedConnectionFactory.createQueueConnection();\n                }\n            } else {\n                if (localUsername != null) {\n                    newConnection = localQueueConnectionFactory.\n                            createQueueConnection(localUsername, localPassword);\n                } else {\n                    newConnection = localQueueConnectionFactory.createQueueConnection();\n                }\n            }\n\n        } else {\n            // Clear if for now in case something goes wrong during the init.\n            newConnection = (QueueConnection) localConnection.getAndSet(null);\n        }\n\n        if (localClientId != null && localClientId.length() > 0) {\n            newConnection.setClientID(getLocalClientId());\n        }\n        newConnection.start();\n\n        inboundMessageConvertor.setConnection(newConnection);\n\n        // Configure the bridges with the new Local connection.\n        initializeInboundDestinationBridgesLocalSide(newConnection);\n        initializeOutboundDestinationBridgesLocalSide(newConnection);\n\n        // Register for any async error notifications now so we can reset in the\n        // case where there's not a lot of activity and a connection drops.\n        newConnection.setExceptionListener(new ExceptionListener() {\n            @Override\n            public void onException(JMSException exception) {\n                handleConnectionFailure(newConnection);\n            }\n        });\n\n        // At this point all looks good, so this our current connection now.\n        localConnection.set(newConnection);\n    }"
        ],
        [
            "TransportLoggerFactory::createTransportLoggerControl(int)",
            " 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204 -\n 205  \n 206  \n 207  \n 208  \n 209  \n 210  ",
            "    /**\n     * Starts the management context.\n     * Creates and registers a TransportLoggerControl MBean which enables the user\n     * to enable/disable logging for all transport loggers at once.\n     */\n     private void createTransportLoggerControl(int port) {\n         try {\n             this.managementContext = new ManagementContext();\n             this.managementContext.setConnectorPort(port);\n             this.managementContext.start();\n         } catch (Exception e) {\n             LOG.error(\"Management context could not be started, reason: \" + e, e);\n         }\n\n         try {\n             this.objectName = new ObjectName(this.managementContext.getJmxDomainName()+\":\"+ \"Type=TransportLoggerControl\");\n             AnnotatedMBean.registerMBean(this.managementContext, new TransportLoggerControl(this.managementContext),this.objectName);\n             \n             this.transportLoggerControlCreated = true;\n\n         } catch (Exception e) {\n             LOG.error(\"TransportLoggerControlMBean could not be registered, reason: \" + e, e);\n         }\n     }",
            " 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206 +\n 207  \n 208  \n 209  \n 210  \n 211  \n 212  ",
            "    /**\n     * Starts the management context.\n     * Creates and registers a TransportLoggerControl MBean which enables the user\n     * to enable/disable logging for all transport loggers at once.\n     */\n     private void createTransportLoggerControl(int port) {\n         try {\n             this.managementContext = new ManagementContext();\n             this.managementContext.setConnectorPort(port);\n             this.managementContext.start();\n         } catch (Exception e) {\n             LOG.error(\"Management context could not be started, reason: \" + e, e);\n         }\n\n         try {\n             this.objectName = new ObjectName(this.managementContext.getJmxDomainName()+\":\"+ \"Type=TransportLoggerControl\");\n             AnnotatedMBean.registerMBean(this.managementContext, new TransportLoggerControl(this.managementContext),this.objectName);\n\n             this.transportLoggerControlCreated = true;\n\n         } catch (Exception e) {\n             LOG.error(\"TransportLoggerControlMBean could not be registered, reason: \" + e, e);\n         }\n     }"
        ],
        [
            "SimpleJmsTopicConnector::initializeLocalConnection()",
            " 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226 -\n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  ",
            "    @Override\n    protected void initializeLocalConnection() throws NamingException, JMSException {\n\n        final TopicConnection newConnection;\n\n        if (localConnection.get() == null) {\n            // get the connection factories\n            if (localTopicConnectionFactory == null) {\n                if (embeddedConnectionFactory == null) {\n                    // look it up from JNDI\n                    if (localConnectionFactoryName != null) {\n                        localTopicConnectionFactory = (TopicConnectionFactory)jndiLocalTemplate\n                            .lookup(localConnectionFactoryName, TopicConnectionFactory.class);\n                        if (localUsername != null) {\n                            newConnection = localTopicConnectionFactory\n                                .createTopicConnection(localUsername, localPassword);\n                        } else {\n                            newConnection = localTopicConnectionFactory.createTopicConnection();\n                        }\n                    } else {\n                        throw new JMSException(\"Cannot create localConnection - no information\");\n                    }\n                } else {\n                    newConnection = embeddedConnectionFactory.createTopicConnection();\n                }\n            } else {\n                if (localUsername != null) {\n                    newConnection = localTopicConnectionFactory.\n                            createTopicConnection(localUsername, localPassword);\n                } else {\n                    newConnection = localTopicConnectionFactory.createTopicConnection();\n                }\n            }\n\n        } else {\n            // Clear if for now in case something goes wrong during the init.\n            newConnection = (TopicConnection) localConnection.getAndSet(null);\n        }\n\n        if (localClientId != null && localClientId.length() > 0) {\n            newConnection.setClientID(getLocalClientId());\n        }\n        newConnection.start();\n\n        inboundMessageConvertor.setConnection(newConnection);\n\n        // Configure the bridges with the new Local connection.\n        initializeInboundDestinationBridgesLocalSide(newConnection);\n        initializeOutboundDestinationBridgesLocalSide(newConnection);\n\n        // Register for any async error notifications now so we can reset in the\n        // case where there's not a lot of activity and a connection drops.\n        newConnection.setExceptionListener(new ExceptionListener() {\n            @Override\n            public void onException(JMSException exception) {\n                handleConnectionFailure(newConnection);\n            }\n        });\n\n        // At this point all looks good, so this our current connection now.\n        localConnection.set(newConnection);\n    }",
            " 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226 +\n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  ",
            "    @Override\n    protected void initializeLocalConnection() throws NamingException, JMSException {\n\n        final TopicConnection newConnection;\n\n        if (localConnection.get() == null) {\n            // get the connection factories\n            if (localTopicConnectionFactory == null) {\n                if (embeddedConnectionFactory == null) {\n                    // look it up from JNDI\n                    if (localConnectionFactoryName != null) {\n                        localTopicConnectionFactory = jndiLocalTemplate\n                            .lookup(localConnectionFactoryName, TopicConnectionFactory.class);\n                        if (localUsername != null) {\n                            newConnection = localTopicConnectionFactory\n                                .createTopicConnection(localUsername, localPassword);\n                        } else {\n                            newConnection = localTopicConnectionFactory.createTopicConnection();\n                        }\n                    } else {\n                        throw new JMSException(\"Cannot create localConnection - no information\");\n                    }\n                } else {\n                    newConnection = embeddedConnectionFactory.createTopicConnection();\n                }\n            } else {\n                if (localUsername != null) {\n                    newConnection = localTopicConnectionFactory.\n                            createTopicConnection(localUsername, localPassword);\n                } else {\n                    newConnection = localTopicConnectionFactory.createTopicConnection();\n                }\n            }\n\n        } else {\n            // Clear if for now in case something goes wrong during the init.\n            newConnection = (TopicConnection) localConnection.getAndSet(null);\n        }\n\n        if (localClientId != null && localClientId.length() > 0) {\n            newConnection.setClientID(getLocalClientId());\n        }\n        newConnection.start();\n\n        inboundMessageConvertor.setConnection(newConnection);\n\n        // Configure the bridges with the new Local connection.\n        initializeInboundDestinationBridgesLocalSide(newConnection);\n        initializeOutboundDestinationBridgesLocalSide(newConnection);\n\n        // Register for any async error notifications now so we can reset in the\n        // case where there's not a lot of activity and a connection drops.\n        newConnection.setExceptionListener(new ExceptionListener() {\n            @Override\n            public void onException(JMSException exception) {\n                handleConnectionFailure(newConnection);\n            }\n        });\n\n        // At this point all looks good, so this our current connection now.\n        localConnection.set(newConnection);\n    }"
        ],
        [
            "SimpleJmsQueueConnector::createReplyToBridge(Destination,Connection,Connection)",
            " 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  ",
            "    protected Destination createReplyToBridge(Destination destination, Connection replyToProducerConnection,\n                                              Connection replyToConsumerConnection) {\n        Queue replyToProducerQueue = (Queue)destination;\n        boolean isInbound = replyToProducerConnection.equals(localConnection.get());\n\n        if (isInbound) {\n            InboundQueueBridge bridge = (InboundQueueBridge)replyToBridges.get(replyToProducerQueue);\n            if (bridge == null) {\n                bridge = new InboundQueueBridge() {\n                    protected Destination processReplyToDestination(Destination destination) {\n                        return null;\n                    }\n                };\n                try {\n                    QueueSession replyToConsumerSession = ((QueueConnection)replyToConsumerConnection)\n                        .createQueueSession(false, Session.AUTO_ACKNOWLEDGE);\n                    Queue replyToConsumerQueue = replyToConsumerSession.createTemporaryQueue();\n                    replyToConsumerSession.close();\n                    bridge.setConsumerQueue(replyToConsumerQueue);\n                    bridge.setProducerQueue(replyToProducerQueue);\n                    bridge.setProducerConnection((QueueConnection)replyToProducerConnection);\n                    bridge.setConsumerConnection((QueueConnection)replyToConsumerConnection);\n                    bridge.setDoHandleReplyTo(false);\n                    if (bridge.getJmsMessageConvertor() == null) {\n                        bridge.setJmsMessageConvertor(getInboundMessageConvertor());\n                    }\n                    bridge.setJmsConnector(this);\n                    bridge.start();\n                    LOG.info(\"Created replyTo bridge for {}\", replyToProducerQueue);\n                } catch (Exception e) {\n                    LOG.error(\"Failed to create replyTo bridge for queue: {}\", replyToProducerQueue, e);\n                    return null;\n                }\n                replyToBridges.put(replyToProducerQueue, bridge);\n            }\n            return bridge.getConsumerQueue();\n        } else {\n            OutboundQueueBridge bridge = (OutboundQueueBridge)replyToBridges.get(replyToProducerQueue);\n            if (bridge == null) {\n                bridge = new OutboundQueueBridge() {\n                    protected Destination processReplyToDestination(Destination destination) {\n                        return null;\n                    }\n                };\n                try {\n                    QueueSession replyToConsumerSession = ((QueueConnection)replyToConsumerConnection)\n                        .createQueueSession(false, Session.AUTO_ACKNOWLEDGE);\n                    Queue replyToConsumerQueue = replyToConsumerSession.createTemporaryQueue();\n                    replyToConsumerSession.close();\n                    bridge.setConsumerQueue(replyToConsumerQueue);\n                    bridge.setProducerQueue(replyToProducerQueue);\n                    bridge.setProducerConnection((QueueConnection)replyToProducerConnection);\n                    bridge.setConsumerConnection((QueueConnection)replyToConsumerConnection);\n                    bridge.setDoHandleReplyTo(false);\n                    if (bridge.getJmsMessageConvertor() == null) {\n                        bridge.setJmsMessageConvertor(getOutboundMessageConvertor());\n                    }\n                    bridge.setJmsConnector(this);\n                    bridge.start();\n                    LOG.info(\"Created replyTo bridge for {}\", replyToProducerQueue);\n                } catch (Exception e) {\n                    LOG.error(\"Failed to create replyTo bridge for queue: {}\", replyToProducerQueue, e);\n                    return null;\n                }\n                replyToBridges.put(replyToProducerQueue, bridge);\n            }\n            return bridge.getConsumerQueue();\n        }\n    }",
            " 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362 +\n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393  \n 394 +\n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  \n 423  ",
            "    @Override\n    protected Destination createReplyToBridge(Destination destination, Connection replyToProducerConnection,\n                                              Connection replyToConsumerConnection) {\n        Queue replyToProducerQueue = (Queue)destination;\n        boolean isInbound = replyToProducerConnection.equals(localConnection.get());\n\n        if (isInbound) {\n            InboundQueueBridge bridge = (InboundQueueBridge)replyToBridges.get(replyToProducerQueue);\n            if (bridge == null) {\n                bridge = new InboundQueueBridge() {\n                    @Override\n                    protected Destination processReplyToDestination(Destination destination) {\n                        return null;\n                    }\n                };\n                try {\n                    QueueSession replyToConsumerSession = ((QueueConnection)replyToConsumerConnection)\n                        .createQueueSession(false, Session.AUTO_ACKNOWLEDGE);\n                    Queue replyToConsumerQueue = replyToConsumerSession.createTemporaryQueue();\n                    replyToConsumerSession.close();\n                    bridge.setConsumerQueue(replyToConsumerQueue);\n                    bridge.setProducerQueue(replyToProducerQueue);\n                    bridge.setProducerConnection((QueueConnection)replyToProducerConnection);\n                    bridge.setConsumerConnection((QueueConnection)replyToConsumerConnection);\n                    bridge.setDoHandleReplyTo(false);\n                    if (bridge.getJmsMessageConvertor() == null) {\n                        bridge.setJmsMessageConvertor(getInboundMessageConvertor());\n                    }\n                    bridge.setJmsConnector(this);\n                    bridge.start();\n                    LOG.info(\"Created replyTo bridge for {}\", replyToProducerQueue);\n                } catch (Exception e) {\n                    LOG.error(\"Failed to create replyTo bridge for queue: {}\", replyToProducerQueue, e);\n                    return null;\n                }\n                replyToBridges.put(replyToProducerQueue, bridge);\n            }\n            return bridge.getConsumerQueue();\n        } else {\n            OutboundQueueBridge bridge = (OutboundQueueBridge)replyToBridges.get(replyToProducerQueue);\n            if (bridge == null) {\n                bridge = new OutboundQueueBridge() {\n                    @Override\n                    protected Destination processReplyToDestination(Destination destination) {\n                        return null;\n                    }\n                };\n                try {\n                    QueueSession replyToConsumerSession = ((QueueConnection)replyToConsumerConnection)\n                        .createQueueSession(false, Session.AUTO_ACKNOWLEDGE);\n                    Queue replyToConsumerQueue = replyToConsumerSession.createTemporaryQueue();\n                    replyToConsumerSession.close();\n                    bridge.setConsumerQueue(replyToConsumerQueue);\n                    bridge.setProducerQueue(replyToProducerQueue);\n                    bridge.setProducerConnection((QueueConnection)replyToProducerConnection);\n                    bridge.setConsumerConnection((QueueConnection)replyToConsumerConnection);\n                    bridge.setDoHandleReplyTo(false);\n                    if (bridge.getJmsMessageConvertor() == null) {\n                        bridge.setJmsMessageConvertor(getOutboundMessageConvertor());\n                    }\n                    bridge.setJmsConnector(this);\n                    bridge.start();\n                    LOG.info(\"Created replyTo bridge for {}\", replyToProducerQueue);\n                } catch (Exception e) {\n                    LOG.error(\"Failed to create replyTo bridge for queue: {}\", replyToProducerQueue, e);\n                    return null;\n                }\n                replyToBridges.put(replyToProducerQueue, bridge);\n            }\n            return bridge.getConsumerQueue();\n        }\n    }"
        ],
        [
            "SimpleJmsTopicConnector::setLocalTopicConnectionFactory(TopicConnectionFactory)",
            "  80  \n  81  \n  82  \n  83 -\n  84 -\n  85  ",
            "    /**\n     * @param localTopicConnectionFactory The localTopicConnectionFactory to set.\n     */\n    public void setLocalTopicConnectionFactory(TopicConnectionFactory localConnectionFactory) {\n        this.localTopicConnectionFactory = localConnectionFactory;\n    }",
            "  80  \n  81  \n  82  \n  83 +\n  84 +\n  85  ",
            "    /**\n     * @param localTopicConnectionFactory The localTopicConnectionFactory to set.\n     */\n    public void setLocalTopicConnectionFactory(TopicConnectionFactory localTopicConnectionFactory) {\n        this.localTopicConnectionFactory = localTopicConnectionFactory;\n    }"
        ],
        [
            "ForcePersistencyModeBrokerPlugin::installPlugin(Broker)",
            "  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50 -\n  51 -\n  52 -\n  53 -\n  54 -\n  55 -",
            " * @param broker\n * @return the Broker\n * @throws Exception\n * @see org.apache.activemq.broker.BrokerPlugin#installPlugin(org.apache.activemq.broker.Broker)\n */\n\n  public Broker installPlugin(Broker broker) throws Exception{\n    ForcePersistencyModeBroker pB = new ForcePersistencyModeBroker(broker);\n    pB.setPersistenceFlag(isPersistenceForced());\n    LOG.info(\"Installing ForcePersistencyModeBroker plugin: persistency enforced={}\", pB.isPersistent());\n    return pB;\n  }",
            "  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52 +\n  53 +\n  54 +\n  55 +\n  56 +\n  57 +",
            "    /**\n     * @param broker\n     *\n     * @return the Broker\n     *\n     * @throws Exception\n     *\n     * @see org.apache.activemq.broker.BrokerPlugin#installPlugin(org.apache.activemq.broker.Broker)\n     */\n    @Override\n    public Broker installPlugin(Broker broker) throws Exception {\n        ForcePersistencyModeBroker pB = new ForcePersistencyModeBroker(broker);\n        pB.setPersistenceFlag(isPersistenceForced());\n        LOG.info(\"Installing ForcePersistencyModeBroker plugin: persistency enforced={}\", pB.isPersistent());\n        return pB;\n    }"
        ],
        [
            "SimpleJmsQueueConnector::initializeForeignConnection()",
            " 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169 -\n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  ",
            "    @Override\n    protected void initializeForeignConnection() throws NamingException, JMSException {\n\n        final QueueConnection newConnection;\n\n        if (foreignConnection.get() == null) {\n            // get the connection factories\n            if (outboundQueueConnectionFactory == null) {\n                // look it up from JNDI\n                if (outboundQueueConnectionFactoryName != null) {\n                    outboundQueueConnectionFactory = (QueueConnectionFactory)jndiOutboundTemplate\n                        .lookup(outboundQueueConnectionFactoryName, QueueConnectionFactory.class);\n                    if (outboundUsername != null) {\n                        newConnection = outboundQueueConnectionFactory\n                            .createQueueConnection(outboundUsername, outboundPassword);\n                    } else {\n                        newConnection = outboundQueueConnectionFactory.createQueueConnection();\n                    }\n                } else {\n                    throw new JMSException(\"Cannot create foreignConnection - no information\");\n                }\n            } else {\n                if (outboundUsername != null) {\n                    newConnection = outboundQueueConnectionFactory\n                        .createQueueConnection(outboundUsername, outboundPassword);\n                } else {\n                    newConnection = outboundQueueConnectionFactory.createQueueConnection();\n                }\n            }\n        } else {\n            // Clear if for now in case something goes wrong during the init.\n            newConnection = (QueueConnection) foreignConnection.getAndSet(null);\n        }\n\n        if (outboundClientId != null && outboundClientId.length() > 0) {\n            newConnection.setClientID(getOutboundClientId());\n        }\n        newConnection.start();\n\n        outboundMessageConvertor.setConnection(newConnection);\n\n        // Configure the bridges with the new Outbound connection.\n        initializeInboundDestinationBridgesOutboundSide(newConnection);\n        initializeOutboundDestinationBridgesOutboundSide(newConnection);\n\n        // Register for any async error notifications now so we can reset in the\n        // case where there's not a lot of activity and a connection drops.\n        newConnection.setExceptionListener(new ExceptionListener() {\n            @Override\n            public void onException(JMSException exception) {\n                handleConnectionFailure(newConnection);\n            }\n        });\n\n        // At this point all looks good, so this our current connection now.\n        foreignConnection.set(newConnection);\n    }",
            " 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168 +\n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  ",
            "    @Override\n    protected void initializeForeignConnection() throws NamingException, JMSException {\n\n        final QueueConnection newConnection;\n\n        if (foreignConnection.get() == null) {\n            // get the connection factories\n            if (outboundQueueConnectionFactory == null) {\n                // look it up from JNDI\n                if (outboundQueueConnectionFactoryName != null) {\n                    outboundQueueConnectionFactory = jndiOutboundTemplate\n                        .lookup(outboundQueueConnectionFactoryName, QueueConnectionFactory.class);\n                    if (outboundUsername != null) {\n                        newConnection = outboundQueueConnectionFactory\n                            .createQueueConnection(outboundUsername, outboundPassword);\n                    } else {\n                        newConnection = outboundQueueConnectionFactory.createQueueConnection();\n                    }\n                } else {\n                    throw new JMSException(\"Cannot create foreignConnection - no information\");\n                }\n            } else {\n                if (outboundUsername != null) {\n                    newConnection = outboundQueueConnectionFactory\n                        .createQueueConnection(outboundUsername, outboundPassword);\n                } else {\n                    newConnection = outboundQueueConnectionFactory.createQueueConnection();\n                }\n            }\n        } else {\n            // Clear if for now in case something goes wrong during the init.\n            newConnection = (QueueConnection) foreignConnection.getAndSet(null);\n        }\n\n        if (outboundClientId != null && outboundClientId.length() > 0) {\n            newConnection.setClientID(getOutboundClientId());\n        }\n        newConnection.start();\n\n        outboundMessageConvertor.setConnection(newConnection);\n\n        // Configure the bridges with the new Outbound connection.\n        initializeInboundDestinationBridgesOutboundSide(newConnection);\n        initializeOutboundDestinationBridgesOutboundSide(newConnection);\n\n        // Register for any async error notifications now so we can reset in the\n        // case where there's not a lot of activity and a connection drops.\n        newConnection.setExceptionListener(new ExceptionListener() {\n            @Override\n            public void onException(JMSException exception) {\n                handleConnectionFailure(newConnection);\n            }\n        });\n\n        // At this point all looks good, so this our current connection now.\n        foreignConnection.set(newConnection);\n    }"
        ],
        [
            "ForcePersistencyModeBrokerPlugin::setPersistenceFlag(boolean)",
            "  57  \n  58  \n  59  \n  60  \n  61 -\n  62 -\n  63 -",
            "  /** Sets the persistency mode.\n   *  \n   * @param persistenceFlag\n   */\n  public void setPersistenceFlag(final boolean persistenceFlag) {\n    this.persistenceFlag = persistenceFlag;\n  }",
            "  59  \n  60  \n  61  \n  62  \n  63  \n  64 +\n  65 +\n  66 +",
            "    /**\n     * Sets the persistence mode.\n     *\n     * @param persistenceFlag\n     */\n    public void setPersistenceFlag(final boolean persistenceFlag) {\n        this.persistenceFlag = persistenceFlag;\n    }"
        ],
        [
            "HexSupport::toHexFromInt(int,boolean)",
            "  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86 -\n  87 -\n  88 -\n  89 -\n  90 -\n  91  \n  92  \n  93  ",
            "    /**\n     * \n     * @param value \n     * @param trim if the leading 0's should be trimmed off.\n     * @return\n     */\n    public static String toHexFromInt(int value, boolean trim) {\n        StringBuffer rc = new StringBuffer(INT_OFFSETS.length*2);\n        for (int i = 0; i < INT_OFFSETS.length; i++) {\n        \tint b = 0xFF & (value>>INT_OFFSETS[i]);\n        \tif( !(trim && b == 0) ) { \n        \t\trc.append(HEX_TABLE[b]);\n        \t\ttrim=false;\n        \t}\n        }\n        return rc.toString();\n    }",
            "  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86 +\n  87 +\n  88 +\n  89 +\n  90 +\n  91  \n  92 +\n  93  \n  94  ",
            "    /**\n     *\n     * @param value\n     * @param trim if the leading 0's should be trimmed off.\n     * @return string hex value\n     */\n    public static String toHexFromInt(int value, boolean trim) {\n        StringBuffer rc = new StringBuffer(INT_OFFSETS.length*2);\n        for (int i = 0; i < INT_OFFSETS.length; i++) {\n            int b = 0xFF & (value>>INT_OFFSETS[i]);\n            if( !(trim && b == 0) ) {\n                rc.append(HEX_TABLE[b]);\n                trim=false;\n            }\n        }\n\n        return rc.toString();\n    }"
        ],
        [
            "QueueDispatchSelector::canSelect(Subscription,MessageReference)",
            "  54  \n  55  \n  56 -\n  57  \n  58  \n  59  \n  60  \n  61  \n  62  ",
            "    public boolean canSelect(Subscription subscription,\n            MessageReference m) throws Exception {\n       \n        boolean result = !paused && super.canDispatch(subscription, m);\n        if (result && !subscription.isBrowser()) {\n            result = exclusiveConsumer == null || exclusiveConsumer == subscription;\n        }\n        return result;\n    }",
            "  53  \n  54  \n  55 +\n  56  \n  57  \n  58  \n  59  \n  60  \n  61  ",
            "    public boolean canSelect(Subscription subscription,\n            MessageReference m) throws Exception {\n\n        boolean result = !paused && super.canDispatch(subscription, m);\n        if (result && !subscription.isBrowser()) {\n            result = exclusiveConsumer == null || exclusiveConsumer == subscription;\n        }\n        return result;\n    }"
        ],
        [
            "SimpleJmsTopicConnector::initializeForeignConnection()",
            " 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167 -\n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  ",
            "    @Override\n    protected void initializeForeignConnection() throws NamingException, JMSException {\n\n        final TopicConnection newConnection;\n\n        if (foreignConnection.get() == null) {\n            // get the connection factories\n            if (outboundTopicConnectionFactory == null) {\n                // look it up from JNDI\n                if (outboundTopicConnectionFactoryName != null) {\n                    outboundTopicConnectionFactory = (TopicConnectionFactory)jndiOutboundTemplate\n                        .lookup(outboundTopicConnectionFactoryName, TopicConnectionFactory.class);\n                    if (outboundUsername != null) {\n                        newConnection = outboundTopicConnectionFactory\n                            .createTopicConnection(outboundUsername, outboundPassword);\n                    } else {\n                        newConnection = outboundTopicConnectionFactory.createTopicConnection();\n                    }\n                } else {\n                    throw new JMSException(\"Cannot create foreignConnection - no information\");\n                }\n            } else {\n                if (outboundUsername != null) {\n                    newConnection = outboundTopicConnectionFactory\n                        .createTopicConnection(outboundUsername, outboundPassword);\n                } else {\n                    newConnection = outboundTopicConnectionFactory.createTopicConnection();\n                }\n            }\n        } else {\n            // Clear if for now in case something goes wrong during the init.\n            newConnection = (TopicConnection) foreignConnection.getAndSet(null);\n        }\n\n        if (outboundClientId != null && outboundClientId.length() > 0) {\n            newConnection.setClientID(getOutboundClientId());\n        }\n        newConnection.start();\n\n        outboundMessageConvertor.setConnection(newConnection);\n\n        // Configure the bridges with the new Outbound connection.\n        initializeInboundDestinationBridgesOutboundSide(newConnection);\n        initializeOutboundDestinationBridgesOutboundSide(newConnection);\n\n        // Register for any async error notifications now so we can reset in the\n        // case where there's not a lot of activity and a connection drops.\n        newConnection.setExceptionListener(new ExceptionListener() {\n            @Override\n            public void onException(JMSException exception) {\n                handleConnectionFailure(newConnection);\n            }\n        });\n\n        // At this point all looks good, so this our current connection now.\n        foreignConnection.set(newConnection);\n    }",
            " 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167 +\n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  ",
            "    @Override\n    protected void initializeForeignConnection() throws NamingException, JMSException {\n\n        final TopicConnection newConnection;\n\n        if (foreignConnection.get() == null) {\n            // get the connection factories\n            if (outboundTopicConnectionFactory == null) {\n                // look it up from JNDI\n                if (outboundTopicConnectionFactoryName != null) {\n                    outboundTopicConnectionFactory = jndiOutboundTemplate\n                        .lookup(outboundTopicConnectionFactoryName, TopicConnectionFactory.class);\n                    if (outboundUsername != null) {\n                        newConnection = outboundTopicConnectionFactory\n                            .createTopicConnection(outboundUsername, outboundPassword);\n                    } else {\n                        newConnection = outboundTopicConnectionFactory.createTopicConnection();\n                    }\n                } else {\n                    throw new JMSException(\"Cannot create foreignConnection - no information\");\n                }\n            } else {\n                if (outboundUsername != null) {\n                    newConnection = outboundTopicConnectionFactory\n                        .createTopicConnection(outboundUsername, outboundPassword);\n                } else {\n                    newConnection = outboundTopicConnectionFactory.createTopicConnection();\n                }\n            }\n        } else {\n            // Clear if for now in case something goes wrong during the init.\n            newConnection = (TopicConnection) foreignConnection.getAndSet(null);\n        }\n\n        if (outboundClientId != null && outboundClientId.length() > 0) {\n            newConnection.setClientID(getOutboundClientId());\n        }\n        newConnection.start();\n\n        outboundMessageConvertor.setConnection(newConnection);\n\n        // Configure the bridges with the new Outbound connection.\n        initializeInboundDestinationBridgesOutboundSide(newConnection);\n        initializeOutboundDestinationBridgesOutboundSide(newConnection);\n\n        // Register for any async error notifications now so we can reset in the\n        // case where there's not a lot of activity and a connection drops.\n        newConnection.setExceptionListener(new ExceptionListener() {\n            @Override\n            public void onException(JMSException exception) {\n                handleConnectionFailure(newConnection);\n            }\n        });\n\n        // At this point all looks good, so this our current connection now.\n        foreignConnection.set(newConnection);\n    }"
        ],
        [
            "ForcePersistencyModeBrokerPlugin::isPersistenceForced()",
            "  65  \n  66  \n  67  \n  68 -\n  69 -\n  70 -",
            "  /**\n   * @return the mode the (activated) plugin will set the message delivery mode \n   */\n  public final boolean isPersistenceForced() {\n    return persistenceFlag;\n  }",
            "  68  \n  69  \n  70  \n  71  \n  72 +\n  73 +\n  74 +",
            "    /**\n     * @return the mode the (activated) plugin will set the message delivery\n     *         mode\n     */\n    public final boolean isPersistenceForced() {\n        return persistenceFlag;\n    }"
        ],
        [
            "SimpleJmsQueueConnector::createForeignQueue(QueueSession,String)",
            " 427  \n 428  \n 429  \n 430  \n 431  \n 432  \n 433 -\n 434  \n 435  \n 436  \n 437  \n 438  \n 439  \n 440  \n 441  \n 442  \n 443  \n 444  \n 445  \n 446  \n 447  \n 448  \n 449  \n 450  \n 451 -\n 452  \n 453  \n 454  \n 455  \n 456  \n 457  \n 458  \n 459  \n 460  \n 461  \n 462  \n 463  ",
            "    protected Queue createForeignQueue(QueueSession session, String queueName) throws JMSException {\n        Queue result = null;\n\n        if (preferJndiDestinationLookup) {\n            try {\n                // look-up the Queue\n                result = (Queue)jndiOutboundTemplate.lookup(queueName, Queue.class);\n            } catch (NamingException e) {\n                try {\n                    result = session.createQueue(queueName);\n                } catch (JMSException e1) {\n                    String errStr = \"Failed to look-up or create Queue for name: \" + queueName;\n                    LOG.error(errStr, e);\n                    JMSException jmsEx = new JMSException(errStr);\n                    jmsEx.setLinkedException(e1);\n                    throw jmsEx;\n                }\n            }\n        } else {\n            try {\n                result = session.createQueue(queueName);\n            } catch (JMSException e) {\n                // look-up the Queue\n                try {\n                    result = (Queue)jndiOutboundTemplate.lookup(queueName, Queue.class);\n                } catch (NamingException e1) {\n                    String errStr = \"Failed to look-up Queue for name: \" + queueName;\n                    LOG.error(errStr, e);\n                    JMSException jmsEx = new JMSException(errStr);\n                    jmsEx.setLinkedException(e1);\n                    throw jmsEx;\n                }\n            }\n        }\n\n        return result;\n    }",
            " 429  \n 430  \n 431  \n 432  \n 433  \n 434  \n 435 +\n 436  \n 437  \n 438  \n 439  \n 440  \n 441  \n 442  \n 443  \n 444  \n 445  \n 446  \n 447  \n 448  \n 449  \n 450  \n 451  \n 452  \n 453 +\n 454  \n 455  \n 456  \n 457  \n 458  \n 459  \n 460  \n 461  \n 462  \n 463  \n 464  \n 465  ",
            "    protected Queue createForeignQueue(QueueSession session, String queueName) throws JMSException {\n        Queue result = null;\n\n        if (preferJndiDestinationLookup) {\n            try {\n                // look-up the Queue\n                result = jndiOutboundTemplate.lookup(queueName, Queue.class);\n            } catch (NamingException e) {\n                try {\n                    result = session.createQueue(queueName);\n                } catch (JMSException e1) {\n                    String errStr = \"Failed to look-up or create Queue for name: \" + queueName;\n                    LOG.error(errStr, e);\n                    JMSException jmsEx = new JMSException(errStr);\n                    jmsEx.setLinkedException(e1);\n                    throw jmsEx;\n                }\n            }\n        } else {\n            try {\n                result = session.createQueue(queueName);\n            } catch (JMSException e) {\n                // look-up the Queue\n                try {\n                    result = jndiOutboundTemplate.lookup(queueName, Queue.class);\n                } catch (NamingException e1) {\n                    String errStr = \"Failed to look-up Queue for name: \" + queueName;\n                    LOG.error(errStr, e);\n                    JMSException jmsEx = new JMSException(errStr);\n                    jmsEx.setLinkedException(e1);\n                    throw jmsEx;\n                }\n            }\n        }\n\n        return result;\n    }"
        ],
        [
            "AnnotatedMBean::getMBeanMethod(Class,String,String)",
            " 219 -\n 220 -\n 221 -\n 222 -\n 223 -\n 224 -\n 225 -\n 226 -\n 227  ",
            "    private Method getMBeanMethod(Class clazz, String methodName, String[] signature) throws ReflectiveOperationException\n    {\n       Class[] parameterTypes = new Class[signature.length];\n       for (int i = 0; i < signature.length; i++)\n       {\n          parameterTypes[i] = Class.forName(signature[i]);\n       }\n       return clazz.getMethod(methodName, parameterTypes);\n    }",
            " 221 +\n 222 +\n 223 +\n 224 +\n 225 +\n 226 +\n 227  ",
            "    private Method getMBeanMethod(Class clazz, String methodName, String[] signature) throws ReflectiveOperationException {\n        Class[] parameterTypes = new Class[signature.length];\n        for (int i = 0; i < signature.length; i++) {\n            parameterTypes[i] = Class.forName(signature[i]);\n        }\n        return clazz.getMethod(methodName, parameterTypes);\n    }"
        ],
        [
            "SimpleJmsTopicConnector::createReplyToBridge(Destination,Connection,Connection)",
            " 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  ",
            "    protected Destination createReplyToBridge(Destination destination, Connection replyToProducerConnection,\n                                              Connection replyToConsumerConnection) {\n        Topic replyToProducerTopic = (Topic)destination;\n        boolean isInbound = replyToProducerConnection.equals(localConnection.get());\n\n        if (isInbound) {\n            InboundTopicBridge bridge = (InboundTopicBridge)replyToBridges.get(replyToProducerTopic);\n            if (bridge == null) {\n                bridge = new InboundTopicBridge() {\n                    protected Destination processReplyToDestination(Destination destination) {\n                        return null;\n                    }\n                };\n                try {\n                    TopicSession replyToConsumerSession = ((TopicConnection)replyToConsumerConnection)\n                        .createTopicSession(false, Session.AUTO_ACKNOWLEDGE);\n                    Topic replyToConsumerTopic = replyToConsumerSession.createTemporaryTopic();\n                    replyToConsumerSession.close();\n                    bridge.setConsumerTopic(replyToConsumerTopic);\n                    bridge.setProducerTopic(replyToProducerTopic);\n                    bridge.setProducerConnection((TopicConnection)replyToProducerConnection);\n                    bridge.setConsumerConnection((TopicConnection)replyToConsumerConnection);\n                    bridge.setDoHandleReplyTo(false);\n                    if (bridge.getJmsMessageConvertor() == null) {\n                        bridge.setJmsMessageConvertor(getInboundMessageConvertor());\n                    }\n                    bridge.setJmsConnector(this);\n                    bridge.start();\n                    LOG.info(\"Created replyTo bridge for {}\", replyToProducerTopic);\n                } catch (Exception e) {\n                    LOG.error(\"Failed to create replyTo bridge for topic: {}\", replyToProducerTopic, e);\n                    return null;\n                }\n                replyToBridges.put(replyToProducerTopic, bridge);\n            }\n            return bridge.getConsumerTopic();\n        } else {\n            OutboundTopicBridge bridge = (OutboundTopicBridge)replyToBridges.get(replyToProducerTopic);\n            if (bridge == null) {\n                bridge = new OutboundTopicBridge() {\n                    protected Destination processReplyToDestination(Destination destination) {\n                        return null;\n                    }\n                };\n                try {\n                    TopicSession replyToConsumerSession = ((TopicConnection)replyToConsumerConnection)\n                        .createTopicSession(false, Session.AUTO_ACKNOWLEDGE);\n                    Topic replyToConsumerTopic = replyToConsumerSession.createTemporaryTopic();\n                    replyToConsumerSession.close();\n                    bridge.setConsumerTopic(replyToConsumerTopic);\n                    bridge.setProducerTopic(replyToProducerTopic);\n                    bridge.setProducerConnection((TopicConnection)replyToProducerConnection);\n                    bridge.setConsumerConnection((TopicConnection)replyToConsumerConnection);\n                    bridge.setDoHandleReplyTo(false);\n                    if (bridge.getJmsMessageConvertor() == null) {\n                        bridge.setJmsMessageConvertor(getOutboundMessageConvertor());\n                    }\n                    bridge.setJmsConnector(this);\n                    bridge.start();\n                    LOG.info(\"Created replyTo bridge for {}\", replyToProducerTopic);\n                } catch (Exception e) {\n                    LOG.error(\"Failed to create replyTo bridge for topic: {}\", replyToProducerTopic, e);\n                    return null;\n                }\n                replyToBridges.put(replyToProducerTopic, bridge);\n            }\n            return bridge.getConsumerTopic();\n        }\n    }",
            " 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361 +\n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393 +\n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  ",
            "    @Override\n    protected Destination createReplyToBridge(Destination destination, Connection replyToProducerConnection,\n                                              Connection replyToConsumerConnection) {\n        Topic replyToProducerTopic = (Topic)destination;\n        boolean isInbound = replyToProducerConnection.equals(localConnection.get());\n\n        if (isInbound) {\n            InboundTopicBridge bridge = (InboundTopicBridge)replyToBridges.get(replyToProducerTopic);\n            if (bridge == null) {\n                bridge = new InboundTopicBridge() {\n                    @Override\n                    protected Destination processReplyToDestination(Destination destination) {\n                        return null;\n                    }\n                };\n                try {\n                    TopicSession replyToConsumerSession = ((TopicConnection)replyToConsumerConnection)\n                        .createTopicSession(false, Session.AUTO_ACKNOWLEDGE);\n                    Topic replyToConsumerTopic = replyToConsumerSession.createTemporaryTopic();\n                    replyToConsumerSession.close();\n                    bridge.setConsumerTopic(replyToConsumerTopic);\n                    bridge.setProducerTopic(replyToProducerTopic);\n                    bridge.setProducerConnection((TopicConnection)replyToProducerConnection);\n                    bridge.setConsumerConnection((TopicConnection)replyToConsumerConnection);\n                    bridge.setDoHandleReplyTo(false);\n                    if (bridge.getJmsMessageConvertor() == null) {\n                        bridge.setJmsMessageConvertor(getInboundMessageConvertor());\n                    }\n                    bridge.setJmsConnector(this);\n                    bridge.start();\n                    LOG.info(\"Created replyTo bridge for {}\", replyToProducerTopic);\n                } catch (Exception e) {\n                    LOG.error(\"Failed to create replyTo bridge for topic: {}\", replyToProducerTopic, e);\n                    return null;\n                }\n                replyToBridges.put(replyToProducerTopic, bridge);\n            }\n            return bridge.getConsumerTopic();\n        } else {\n            OutboundTopicBridge bridge = (OutboundTopicBridge)replyToBridges.get(replyToProducerTopic);\n            if (bridge == null) {\n                bridge = new OutboundTopicBridge() {\n                    @Override\n                    protected Destination processReplyToDestination(Destination destination) {\n                        return null;\n                    }\n                };\n                try {\n                    TopicSession replyToConsumerSession = ((TopicConnection)replyToConsumerConnection)\n                        .createTopicSession(false, Session.AUTO_ACKNOWLEDGE);\n                    Topic replyToConsumerTopic = replyToConsumerSession.createTemporaryTopic();\n                    replyToConsumerSession.close();\n                    bridge.setConsumerTopic(replyToConsumerTopic);\n                    bridge.setProducerTopic(replyToProducerTopic);\n                    bridge.setProducerConnection((TopicConnection)replyToProducerConnection);\n                    bridge.setConsumerConnection((TopicConnection)replyToConsumerConnection);\n                    bridge.setDoHandleReplyTo(false);\n                    if (bridge.getJmsMessageConvertor() == null) {\n                        bridge.setJmsMessageConvertor(getOutboundMessageConvertor());\n                    }\n                    bridge.setJmsConnector(this);\n                    bridge.start();\n                    LOG.info(\"Created replyTo bridge for {}\", replyToProducerTopic);\n                } catch (Exception e) {\n                    LOG.error(\"Failed to create replyTo bridge for topic: {}\", replyToProducerTopic, e);\n                    return null;\n                }\n                replyToBridges.put(replyToProducerTopic, bridge);\n            }\n            return bridge.getConsumerTopic();\n        }\n    }"
        ],
        [
            "SimpleJmsTopicConnector::createForeignTopic(TopicSession,String)",
            " 425  \n 426  \n 427  \n 428  \n 429  \n 430  \n 431 -\n 432  \n 433  \n 434  \n 435  \n 436  \n 437  \n 438  \n 439  \n 440  \n 441  \n 442  \n 443  \n 444  \n 445  \n 446  \n 447  \n 448  \n 449 -\n 450  \n 451  \n 452  \n 453  \n 454  \n 455  \n 456  \n 457  \n 458  \n 459  \n 460  ",
            "    protected Topic createForeignTopic(TopicSession session, String topicName) throws JMSException {\n        Topic result = null;\n\n        if (preferJndiDestinationLookup) {\n            try {\n                // look-up the Queue\n                result = (Topic)jndiOutboundTemplate.lookup(topicName, Topic.class);\n            } catch (NamingException e) {\n                try {\n                    result = session.createTopic(topicName);\n                } catch (JMSException e1) {\n                    String errStr = \"Failed to look-up or create Topic for name: \" + topicName;\n                    LOG.error(errStr, e);\n                    JMSException jmsEx = new JMSException(errStr);\n                    jmsEx.setLinkedException(e1);\n                    throw jmsEx;\n                }\n            }\n        } else {\n            try {\n                result = session.createTopic(topicName);\n            } catch (JMSException e) {\n                // look-up the Topic\n                try {\n                    result = (Topic)jndiOutboundTemplate.lookup(topicName, Topic.class);\n                } catch (NamingException e1) {\n                    String errStr = \"Failed to look-up Topic for name: \" + topicName;\n                    LOG.error(errStr, e);\n                    JMSException jmsEx = new JMSException(errStr);\n                    jmsEx.setLinkedException(e1);\n                    throw jmsEx;\n                }\n            }\n        }\n        return result;\n    }",
            " 428  \n 429  \n 430  \n 431  \n 432  \n 433  \n 434 +\n 435  \n 436  \n 437  \n 438  \n 439  \n 440  \n 441  \n 442  \n 443  \n 444  \n 445  \n 446  \n 447  \n 448  \n 449  \n 450  \n 451  \n 452 +\n 453  \n 454  \n 455  \n 456  \n 457  \n 458  \n 459  \n 460  \n 461  \n 462 +\n 463  \n 464  ",
            "    protected Topic createForeignTopic(TopicSession session, String topicName) throws JMSException {\n        Topic result = null;\n\n        if (preferJndiDestinationLookup) {\n            try {\n                // look-up the Queue\n                result = jndiOutboundTemplate.lookup(topicName, Topic.class);\n            } catch (NamingException e) {\n                try {\n                    result = session.createTopic(topicName);\n                } catch (JMSException e1) {\n                    String errStr = \"Failed to look-up or create Topic for name: \" + topicName;\n                    LOG.error(errStr, e);\n                    JMSException jmsEx = new JMSException(errStr);\n                    jmsEx.setLinkedException(e1);\n                    throw jmsEx;\n                }\n            }\n        } else {\n            try {\n                result = session.createTopic(topicName);\n            } catch (JMSException e) {\n                // look-up the Topic\n                try {\n                    result = jndiOutboundTemplate.lookup(topicName, Topic.class);\n                } catch (NamingException e1) {\n                    String errStr = \"Failed to look-up Topic for name: \" + topicName;\n                    LOG.error(errStr, e);\n                    JMSException jmsEx = new JMSException(errStr);\n                    jmsEx.setLinkedException(e1);\n                    throw jmsEx;\n                }\n            }\n        }\n\n        return result;\n    }"
        ]
    ],
    "c81a9348ee370627093d9291fba8b3ddb4400d1e": [
        [
            "PooledConnectionSecurityExceptionTest::testFailureGetsNewConnectionOnRetry()",
            " 108  \n 109  \n 110 -\n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124 -\n 125  \n 126  \n 127  \n 128 -\n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136 -\n 137  ",
            "    @Test\n    public void testFailureGetsNewConnectionOnRetry() throws Exception {\n        final Connection connection1 = pooledConnFact.createConnection(\"invalid\", \"credentials\");\n\n        try {\n            connection1.start();\n            fail(\"Should fail to connect\");\n        } catch (JMSSecurityException ex) {\n            LOG.info(\"Caught expected security error\");\n        }\n\n        // The pool should process the async error\n        assertTrue(\"Should get new connection\", Wait.waitFor(new Wait.Condition() {\n\n            @Override\n            public boolean isSatisified() throws Exception {\n                return connection1 != pooledConnFact.createConnection(\"invalid\", \"credentials\");\n            }\n        }));\n\n        Connection connection2 = pooledConnFact.createConnection(\"invalid\", \"credentials\");\n        try {\n            connection2.start();\n            fail(\"Should fail to connect\");\n        } catch (JMSSecurityException ex) {\n            LOG.info(\"Caught expected security error\");\n        }\n\n        assertNotSame(connection1, connection2);\n    }",
            " 108  \n 109  \n 110 +\n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124 +\n 125 +\n 126  \n 127  \n 128  \n 129 +\n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137 +\n 138  ",
            "    @Test\n    public void testFailureGetsNewConnectionOnRetry() throws Exception {\n        final PooledConnection connection1 = (PooledConnection) pooledConnFact.createConnection(\"invalid\", \"credentials\");\n\n        try {\n            connection1.start();\n            fail(\"Should fail to connect\");\n        } catch (JMSSecurityException ex) {\n            LOG.info(\"Caught expected security error\");\n        }\n\n        // The pool should process the async error\n        assertTrue(\"Should get new connection\", Wait.waitFor(new Wait.Condition() {\n\n            @Override\n            public boolean isSatisified() throws Exception {\n                return connection1.getConnection() !=\n                          ((PooledConnection) pooledConnFact.createConnection(\"invalid\", \"credentials\")).getConnection();\n            }\n        }));\n\n        PooledConnection connection2 = (PooledConnection) pooledConnFact.createConnection(\"invalid\", \"credentials\");\n        try {\n            connection2.start();\n            fail(\"Should fail to connect\");\n        } catch (JMSSecurityException ex) {\n            LOG.info(\"Caught expected security error\");\n        }\n\n        assertNotSame(connection1.getConnection(), connection2.getConnection());\n    }"
        ],
        [
            "PooledConnectionSecurityExceptionTest::testFailureGetsNewConnectionOnRetryBigPool()",
            " 139  \n 140  \n 141  \n 142  \n 143  \n 144 -\n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  ",
            "    @Test\n    public void testFailureGetsNewConnectionOnRetryBigPool() throws JMSException {\n        pooledConnFact.setMaxConnections(10);\n\n        Connection connection1 = pooledConnFact.createConnection(\"invalid\", \"credentials\");\n\n        try {\n            connection1.start();\n            fail(\"Should fail to connect\");\n        } catch (JMSSecurityException ex) {\n            LOG.info(\"Caught expected security error\");\n        }\n\n        Connection connection2 = pooledConnFact.createConnection(\"invalid\", \"credentials\");\n        try {\n            connection2.start();\n            fail(\"Should fail to connect\");\n        } catch (JMSSecurityException ex) {\n            LOG.info(\"Caught expected security error\");\n        }\n\n        assertNotSame(connection1, connection2);\n    }",
            " 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  ",
            "    @Test\n    public void testFailureGetsNewConnectionOnRetryBigPool() throws JMSException {\n        pooledConnFact.setMaxConnections(10);\n\n        Connection connection1 = pooledConnFact.createConnection(\"invalid\", \"credentials\");\n        try {\n            connection1.start();\n            fail(\"Should fail to connect\");\n        } catch (JMSSecurityException ex) {\n            LOG.info(\"Caught expected security error\");\n        }\n\n        Connection connection2 = pooledConnFact.createConnection(\"invalid\", \"credentials\");\n        try {\n            connection2.start();\n            fail(\"Should fail to connect\");\n        } catch (JMSSecurityException ex) {\n            LOG.info(\"Caught expected security error\");\n        }\n\n        assertNotSame(connection1, connection2);\n    }"
        ],
        [
            "PooledConnectionSecurityExceptionTest::testFailoverWithInvalidCredentials()",
            " 188  \n 189  \n 190  \n 191  \n 192 -\n 193  \n 194  \n 195  \n 196  \n 197  \n 198 -\n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213 -\n 214  \n 215  \n 216  \n 217 -\n 218 -\n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  ",
            "    @Test\n    public void testFailoverWithInvalidCredentials() throws Exception {\n\n        ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory(\n            \"failover:(\" + connectionURI + \")\");\n\n        pooledConnFact = new PooledConnectionFactory();\n        pooledConnFact.setConnectionFactory(cf);\n        pooledConnFact.setMaxConnections(1);\n\n        final Connection connection1 = pooledConnFact.createConnection(\"invalid\", \"credentials\");\n\n        try {\n            connection1.start();\n            fail(\"Should fail to connect\");\n        } catch (JMSSecurityException ex) {\n            LOG.info(\"Caught expected security error\");\n            // Intentionally don't close here to see that async pool reconnect takes place.\n        }\n\n        // The pool should process the async error\n        assertTrue(\"Should get new connection\", Wait.waitFor(new Wait.Condition() {\n\n            @Override\n            public boolean isSatisified() throws Exception {\n                return connection1 != pooledConnFact.createConnection(\"invalid\", \"credentials\");\n            }\n        }));\n\n        final Connection connection2 = pooledConnFact.createConnection(\"invalid\", \"credentials\");\n        assertNotSame(connection1, connection2);\n\n        try {\n            connection2.start();\n            fail(\"Should fail to connect\");\n        } catch (JMSSecurityException ex) {\n            LOG.info(\"Caught expected security error\");\n            connection2.close();\n        }\n    }",
            " 188  \n 189  \n 190  \n 191  \n 192 +\n 193  \n 194  \n 195  \n 196  \n 197  \n 198 +\n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213 +\n 214 +\n 215  \n 216  \n 217  \n 218 +\n 219 +\n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  ",
            "    @Test\n    public void testFailoverWithInvalidCredentials() throws Exception {\n\n        ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory(\n            \"failover:(\" + connectionURI + \"?trace=true)\");\n\n        pooledConnFact = new PooledConnectionFactory();\n        pooledConnFact.setConnectionFactory(cf);\n        pooledConnFact.setMaxConnections(1);\n\n        final PooledConnection connection1 = (PooledConnection) pooledConnFact.createConnection(\"invalid\", \"credentials\");\n\n        try {\n            connection1.start();\n            fail(\"Should fail to connect\");\n        } catch (JMSSecurityException ex) {\n            LOG.info(\"Caught expected security error\");\n            // Intentionally don't close here to see that async pool reconnect takes place.\n        }\n\n        // The pool should process the async error\n        assertTrue(\"Should get new connection\", Wait.waitFor(new Wait.Condition() {\n\n            @Override\n            public boolean isSatisified() throws Exception {\n                return connection1.getConnection() !=\n                          ((PooledConnection) pooledConnFact.createConnection(\"invalid\", \"credentials\")).getConnection();\n            }\n        }));\n\n        final PooledConnection connection2 = (PooledConnection) pooledConnFact.createConnection(\"invalid\", \"credentials\");\n        assertNotSame(connection1.getConnection(), connection2.getConnection());\n\n        try {\n            connection2.start();\n            fail(\"Should fail to connect\");\n        } catch (JMSSecurityException ex) {\n            LOG.info(\"Caught expected security error\");\n            connection2.close();\n        }\n    }"
        ]
    ],
    "2013c6a54f483f0206e6727bd1088616ba98daa2": [
        [
            "AmqpReceiver::processDelivery(Delivery,Buffer)",
            " 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223 -\n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244 -\n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  ",
            "    @Override\n    protected void processDelivery(final Delivery delivery, Buffer deliveryBytes) throws Exception {\n        if (!isClosed()) {\n            EncodedMessage em = new EncodedMessage(delivery.getMessageFormat(), deliveryBytes.data, deliveryBytes.offset, deliveryBytes.length);\n            final ActiveMQMessage message = (ActiveMQMessage) getInboundTransformer().transform(em);\n            current = null;\n\n            if (isAnonymous()) {\n                Destination toDestination = message.getJMSDestination();\n                if (toDestination == null || !(toDestination instanceof ActiveMQDestination)) {\n                    Rejected rejected = new Rejected();\n                    ErrorCondition condition = new ErrorCondition();\n                    condition.setCondition(Symbol.valueOf(\"failed\"));\n                    condition.setDescription(\"Missing to field for message sent to an anonymous producer\");\n                    rejected.setError(condition);\n                    delivery.disposition(rejected);\n                    return;\n                }\n            } else {\n                message.setJMSDestination(getDestination());\n            }\n\n            message.setProducerId(getProducerId());\n\n            // Always override the AMQP client's MessageId with our own.  Preserve\n            // the original in the TextView property for later Ack.\n            MessageId messageId = new MessageId(getProducerId(), messageIdGenerator.getNextSequenceId());\n\n            MessageId amqpMessageId = message.getMessageId();\n            if (amqpMessageId != null) {\n                if (amqpMessageId.getTextView() != null) {\n                    messageId.setTextView(amqpMessageId.getTextView());\n                } else {\n                    messageId.setTextView(amqpMessageId.toString());\n                }\n            }\n\n            message.setMessageId(messageId);\n\n            LOG.trace(\"Inbound Message:{} from Producer:{}\",\n                      message.getMessageId(), getProducerId() + \":\" + messageId.getProducerSequenceId());\n\n            final DeliveryState remoteState = delivery.getRemoteState();\n            if (remoteState != null && remoteState instanceof TransactionalState) {\n                TransactionalState s = (TransactionalState) remoteState;\n                long txid = toLong(s.getTxnId());\n                message.setTransactionId(new LocalTransactionId(session.getConnection().getConnectionId(), txid));\n            }\n\n            message.onSend();\n            if (!delivery.remotelySettled()) {\n                sendToActiveMQ(message, new ResponseHandler() {\n\n                    @Override\n                    public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {\n                        if (response.isException()) {\n                            ExceptionResponse er = (ExceptionResponse) response;\n                            Rejected rejected = new Rejected();\n                            ErrorCondition condition = new ErrorCondition();\n                            condition.setCondition(Symbol.valueOf(\"failed\"));\n                            condition.setDescription(er.getException().getMessage());\n                            rejected.setError(condition);\n                            delivery.disposition(rejected);\n                        } else {\n                            if (getEndpoint().getCredit() <= (getConfiguredReceiverCredit() * .2)) {\n                                LOG.trace(\"Sending more credit ({}) to producer: {}\", getConfiguredReceiverCredit() - getEndpoint().getCredit(), getProducerId());\n                                getEndpoint().flow(getConfiguredReceiverCredit() - getEndpoint().getCredit());\n                            }\n\n                            if (remoteState != null && remoteState instanceof TransactionalState) {\n                                TransactionalState txAccepted = new TransactionalState();\n                                txAccepted.setOutcome(Accepted.getInstance());\n                                txAccepted.setTxnId(((TransactionalState) remoteState).getTxnId());\n\n                                delivery.disposition(txAccepted);\n                            } else {\n                                delivery.disposition(Accepted.getInstance());\n                            }\n                        }\n\n                        delivery.settle();\n                        session.pumpProtonToSocket();\n                    }\n                });\n            } else {\n                if (getEndpoint().getCredit() <= (getConfiguredReceiverCredit() * .2)) {\n                    LOG.trace(\"Sending more credit ({}) to producer: {}\", getConfiguredReceiverCredit() - getEndpoint().getCredit(), getProducerId());\n                    getEndpoint().flow(getConfiguredReceiverCredit() - getEndpoint().getCredit());\n                    session.pumpProtonToSocket();\n                }\n\n                delivery.settle();\n                sendToActiveMQ(message);\n            }\n        }\n    }",
            " 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223 +\n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244 +\n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  ",
            "    @Override\n    protected void processDelivery(final Delivery delivery, Buffer deliveryBytes) throws Exception {\n        if (!isClosed()) {\n            EncodedMessage em = new EncodedMessage(delivery.getMessageFormat(), deliveryBytes.data, deliveryBytes.offset, deliveryBytes.length);\n            final ActiveMQMessage message = (ActiveMQMessage) getInboundTransformer().transform(em);\n            current = null;\n\n            if (isAnonymous()) {\n                Destination toDestination = message.getJMSDestination();\n                if (toDestination == null || !(toDestination instanceof ActiveMQDestination)) {\n                    Rejected rejected = new Rejected();\n                    ErrorCondition condition = new ErrorCondition();\n                    condition.setCondition(Symbol.valueOf(\"failed\"));\n                    condition.setDescription(\"Missing to field for message sent to an anonymous producer\");\n                    rejected.setError(condition);\n                    delivery.disposition(rejected);\n                    return;\n                }\n            } else {\n                message.setJMSDestination(getDestination());\n            }\n\n            message.setProducerId(getProducerId());\n\n            // Always override the AMQP client's MessageId with our own.  Preserve\n            // the original in the TextView property for later Ack.\n            MessageId messageId = new MessageId(getProducerId(), messageIdGenerator.getNextSequenceId());\n\n            MessageId amqpMessageId = message.getMessageId();\n            if (amqpMessageId != null) {\n                if (amqpMessageId.getTextView() != null) {\n                    messageId.setTextView(amqpMessageId.getTextView());\n                } else {\n                    messageId.setTextView(amqpMessageId.toString());\n                }\n            }\n\n            message.setMessageId(messageId);\n\n            LOG.trace(\"Inbound Message:{} from Producer:{}\",\n                      message.getMessageId(), getProducerId() + \":\" + messageId.getProducerSequenceId());\n\n            final DeliveryState remoteState = delivery.getRemoteState();\n            if (remoteState != null && remoteState instanceof TransactionalState) {\n                TransactionalState s = (TransactionalState) remoteState;\n                long txid = toLong(s.getTxnId());\n                message.setTransactionId(new LocalTransactionId(session.getConnection().getConnectionId(), txid));\n            }\n\n            message.onSend();\n            if (!delivery.remotelySettled()) {\n                sendToActiveMQ(message, new ResponseHandler() {\n\n                    @Override\n                    public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {\n                        if (response.isException()) {\n                            ExceptionResponse er = (ExceptionResponse) response;\n                            Rejected rejected = new Rejected();\n                            ErrorCondition condition = new ErrorCondition();\n                            condition.setCondition(Symbol.valueOf(\"failed\"));\n                            condition.setDescription(er.getException().getMessage());\n                            rejected.setError(condition);\n                            delivery.disposition(rejected);\n                        } else {\n                            if (getEndpoint().getCredit() <= (getConfiguredReceiverCredit() * .2)) {\n                                LOG.debug(\"Sending more credit ({}) to producer: {}\", getConfiguredReceiverCredit() - getEndpoint().getCredit(), getProducerId());\n                                getEndpoint().flow(getConfiguredReceiverCredit() - getEndpoint().getCredit());\n                            }\n\n                            if (remoteState != null && remoteState instanceof TransactionalState) {\n                                TransactionalState txAccepted = new TransactionalState();\n                                txAccepted.setOutcome(Accepted.getInstance());\n                                txAccepted.setTxnId(((TransactionalState) remoteState).getTxnId());\n\n                                delivery.disposition(txAccepted);\n                            } else {\n                                delivery.disposition(Accepted.getInstance());\n                            }\n                        }\n\n                        delivery.settle();\n                        session.pumpProtonToSocket();\n                    }\n                });\n            } else {\n                if (getEndpoint().getCredit() <= (getConfiguredReceiverCredit() * .2)) {\n                    LOG.debug(\"Sending more credit ({}) to producer: {}\", getConfiguredReceiverCredit() - getEndpoint().getCredit(), getProducerId());\n                    getEndpoint().flow(getConfiguredReceiverCredit() - getEndpoint().getCredit());\n                    session.pumpProtonToSocket();\n                }\n\n                delivery.settle();\n                sendToActiveMQ(message);\n            }\n        }\n    }"
        ],
        [
            "AmqpSender::pumpOutbound()",
            " 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400 -\n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  \n 423  \n 424  \n 425  ",
            "    public void pumpOutbound() throws Exception {\n        while (!closed) {\n            while (currentBuffer != null) {\n                int sent = getEndpoint().send(currentBuffer.data, currentBuffer.offset, currentBuffer.length);\n                if (sent > 0) {\n                    currentBuffer.moveHead(sent);\n                    if (currentBuffer.length == 0) {\n                        if (presettle) {\n                            settle(currentDelivery, MessageAck.INDIVIDUAL_ACK_TYPE);\n                        } else {\n                            getEndpoint().advance();\n                        }\n                        currentBuffer = null;\n                        currentDelivery = null;\n                    }\n                } else {\n                    return;\n                }\n            }\n\n            if (outbound.isEmpty()) {\n                return;\n            }\n\n            final MessageDispatch md = outbound.removeFirst();\n            try {\n\n                ActiveMQMessage temp = null;\n                if (md.getMessage() != null) {\n\n                    // Topics can dispatch the same Message to more than one consumer\n                    // so we must copy to prevent concurrent read / write to the same\n                    // message object.\n                    if (md.getDestination().isTopic()) {\n                        synchronized (md.getMessage()) {\n                            temp = (ActiveMQMessage) md.getMessage().copy();\n                        }\n                    } else {\n                        temp = (ActiveMQMessage) md.getMessage();\n                    }\n\n                    if (!temp.getProperties().containsKey(MESSAGE_FORMAT_KEY)) {\n                        temp.setProperty(MESSAGE_FORMAT_KEY, 0);\n                    }\n                }\n\n                final ActiveMQMessage jms = temp;\n                if (jms == null) {\n                    LOG.info(\"End of browse signals endpoint drained.\");\n                    // It's the end of browse signal in response to a MessagePull\n                    getEndpoint().drained();\n                    draining = false;\n                } else {\n                    jms.setRedeliveryCounter(md.getRedeliveryCounter());\n                    jms.setReadOnlyBody(true);\n                    final EncodedMessage amqp = outboundTransformer.transform(jms);\n                    if (amqp != null && amqp.getLength() > 0) {\n                        currentBuffer = new Buffer(amqp.getArray(), amqp.getArrayOffset(), amqp.getLength());\n                        if (presettle) {\n                            currentDelivery = getEndpoint().delivery(EMPTY_BYTE_ARRAY, 0, 0);\n                        } else {\n                            final byte[] tag = tagCache.getNextTag();\n                            currentDelivery = getEndpoint().delivery(tag, 0, tag.length);\n                        }\n                        currentDelivery.setContext(md);\n                    } else {\n                        // TODO: message could not be generated what now?\n                    }\n                }\n            } catch (Exception e) {\n                LOG.warn(\"Error detected while flushing outbound messages: {}\", e.getMessage());\n            }\n        }\n    }",
            " 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400 +\n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  \n 423  \n 424  \n 425  ",
            "    public void pumpOutbound() throws Exception {\n        while (!closed) {\n            while (currentBuffer != null) {\n                int sent = getEndpoint().send(currentBuffer.data, currentBuffer.offset, currentBuffer.length);\n                if (sent > 0) {\n                    currentBuffer.moveHead(sent);\n                    if (currentBuffer.length == 0) {\n                        if (presettle) {\n                            settle(currentDelivery, MessageAck.INDIVIDUAL_ACK_TYPE);\n                        } else {\n                            getEndpoint().advance();\n                        }\n                        currentBuffer = null;\n                        currentDelivery = null;\n                    }\n                } else {\n                    return;\n                }\n            }\n\n            if (outbound.isEmpty()) {\n                return;\n            }\n\n            final MessageDispatch md = outbound.removeFirst();\n            try {\n\n                ActiveMQMessage temp = null;\n                if (md.getMessage() != null) {\n\n                    // Topics can dispatch the same Message to more than one consumer\n                    // so we must copy to prevent concurrent read / write to the same\n                    // message object.\n                    if (md.getDestination().isTopic()) {\n                        synchronized (md.getMessage()) {\n                            temp = (ActiveMQMessage) md.getMessage().copy();\n                        }\n                    } else {\n                        temp = (ActiveMQMessage) md.getMessage();\n                    }\n\n                    if (!temp.getProperties().containsKey(MESSAGE_FORMAT_KEY)) {\n                        temp.setProperty(MESSAGE_FORMAT_KEY, 0);\n                    }\n                }\n\n                final ActiveMQMessage jms = temp;\n                if (jms == null) {\n                    LOG.trace(\"Sender:[{}] browse done.\", getEndpoint().getName());\n                    // It's the end of browse signal in response to a MessagePull\n                    getEndpoint().drained();\n                    draining = false;\n                } else {\n                    jms.setRedeliveryCounter(md.getRedeliveryCounter());\n                    jms.setReadOnlyBody(true);\n                    final EncodedMessage amqp = outboundTransformer.transform(jms);\n                    if (amqp != null && amqp.getLength() > 0) {\n                        currentBuffer = new Buffer(amqp.getArray(), amqp.getArrayOffset(), amqp.getLength());\n                        if (presettle) {\n                            currentDelivery = getEndpoint().delivery(EMPTY_BYTE_ARRAY, 0, 0);\n                        } else {\n                            final byte[] tag = tagCache.getNextTag();\n                            currentDelivery = getEndpoint().delivery(tag, 0, tag.length);\n                        }\n                        currentDelivery.setContext(md);\n                    } else {\n                        // TODO: message could not be generated what now?\n                    }\n                }\n            } catch (Exception e) {\n                LOG.warn(\"Error detected while flushing outbound messages: {}\", e.getMessage());\n            }\n        }\n    }"
        ]
    ]
}