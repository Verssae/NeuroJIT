{
    "c88d057ed364470703f017bafed18d106f088f0f": [
        [
            "GenericsUtils::correctToGenericsSpecRecurse(Map,ClassNode)",
            " 286  \n 287  \n 288 -\n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  ",
            "    public static ClassNode correctToGenericsSpecRecurse(Map genericsSpec, ClassNode type) {\n        if (type.isGenericsPlaceHolder()) {\n            String name = type.getGenericsTypes()[0].getName();\n            type = (ClassNode) genericsSpec.get(name);\n        }\n        if (type == null) type = ClassHelper.OBJECT_TYPE;\n        GenericsType[] oldgTypes = type.getGenericsTypes();\n        GenericsType[] newgTypes = new GenericsType[0];\n        if (oldgTypes != null) {\n            newgTypes = new GenericsType[oldgTypes.length];\n            for (int i = 0; i < newgTypes.length; i++) {\n                GenericsType oldgType = oldgTypes[i];\n                if (oldgType.isPlaceholder() ) {\n                    if (genericsSpec.get(oldgType.getName())!=null) {\n                        newgTypes[i] = new GenericsType((ClassNode) genericsSpec.get(oldgType.getName()));\n                    } else {\n                        newgTypes[i] = new GenericsType(ClassHelper.OBJECT_TYPE);\n                    }\n                } else if (oldgType.isWildcard()) {\n                    ClassNode oldLower = oldgType.getLowerBound();\n                    ClassNode lower = oldLower!=null?correctToGenericsSpecRecurse(genericsSpec, oldLower):null;\n                    ClassNode[] oldUpper = oldgType.getUpperBounds();\n                    ClassNode[] upper = null;\n                    if (oldUpper!=null) {\n                        upper = new ClassNode[oldUpper.length];\n                        for (int j = 0; j < oldUpper.length; j++) {\n                            upper[j] = correctToGenericsSpecRecurse(genericsSpec,oldUpper[j]);\n                        }\n                    }\n                    GenericsType fixed = new GenericsType(oldgType.getType(), upper, lower);\n                    fixed.setWildcard(true);\n                    newgTypes[i] = fixed;\n                } else {\n                    newgTypes[i] = new GenericsType(correctToGenericsSpec(genericsSpec, oldgType));\n                }\n            }\n        }\n        return makeClassSafeWithGenerics(type, newgTypes);\n    }",
            " 286  \n 287  \n 288 +\n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  ",
            "    public static ClassNode correctToGenericsSpecRecurse(Map genericsSpec, ClassNode type) {\n        if (type.isGenericsPlaceHolder()) {\n            String name = type.getUnresolvedName();\n            type = (ClassNode) genericsSpec.get(name);\n        }\n        if (type == null) type = ClassHelper.OBJECT_TYPE;\n        GenericsType[] oldgTypes = type.getGenericsTypes();\n        GenericsType[] newgTypes = new GenericsType[0];\n        if (oldgTypes != null) {\n            newgTypes = new GenericsType[oldgTypes.length];\n            for (int i = 0; i < newgTypes.length; i++) {\n                GenericsType oldgType = oldgTypes[i];\n                if (oldgType.isPlaceholder() ) {\n                    if (genericsSpec.get(oldgType.getName())!=null) {\n                        newgTypes[i] = new GenericsType((ClassNode) genericsSpec.get(oldgType.getName()));\n                    } else {\n                        newgTypes[i] = new GenericsType(ClassHelper.OBJECT_TYPE);\n                    }\n                } else if (oldgType.isWildcard()) {\n                    ClassNode oldLower = oldgType.getLowerBound();\n                    ClassNode lower = oldLower!=null?correctToGenericsSpecRecurse(genericsSpec, oldLower):null;\n                    ClassNode[] oldUpper = oldgType.getUpperBounds();\n                    ClassNode[] upper = null;\n                    if (oldUpper!=null) {\n                        upper = new ClassNode[oldUpper.length];\n                        for (int j = 0; j < oldUpper.length; j++) {\n                            upper[j] = correctToGenericsSpecRecurse(genericsSpec,oldUpper[j]);\n                        }\n                    }\n                    GenericsType fixed = new GenericsType(oldgType.getType(), upper, lower);\n                    fixed.setWildcard(true);\n                    newgTypes[i] = fixed;\n                } else {\n                    newgTypes[i] = new GenericsType(correctToGenericsSpec(genericsSpec, oldgType));\n                }\n            }\n        }\n        return makeClassSafeWithGenerics(type, newgTypes);\n    }"
        ],
        [
            "Traits::collectAllInterfacesReverseOrder(ClassNode,LinkedHashSet)",
            " 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270 -\n 271  \n 272  \n 273  \n 274  ",
            "    /**\n     * Collects all interfaces of a class node, but reverses the order of the declaration of direct interfaces\n     * of this class node. This is used to make sure a trait implementing A,B where both A and B have the same\n     * method will take the method from B (latest), aligning the behavior with categories.\n     * @param cNode a class node\n     * @param interfaces ordered set of interfaces\n     */\n    public static LinkedHashSet<ClassNode> collectAllInterfacesReverseOrder(ClassNode cNode, LinkedHashSet<ClassNode> interfaces) {\n        if (cNode.isInterface())\n            interfaces.add(cNode);\n\n        ClassNode[] directInterfaces = cNode.getInterfaces();\n        for (int i = directInterfaces.length-1; i >=0 ; i--) {\n            final ClassNode anInterface = directInterfaces[i];\n            interfaces.add(anInterface);\n            collectAllInterfacesReverseOrder(anInterface, interfaces);\n        }\n        return interfaces;\n    }",
            " 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271 +\n 272  \n 273  \n 274  \n 275  ",
            "    /**\n     * Collects all interfaces of a class node, but reverses the order of the declaration of direct interfaces\n     * of this class node. This is used to make sure a trait implementing A,B where both A and B have the same\n     * method will take the method from B (latest), aligning the behavior with categories.\n     * @param cNode a class node\n     * @param interfaces ordered set of interfaces\n     */\n    public static LinkedHashSet<ClassNode> collectAllInterfacesReverseOrder(ClassNode cNode, LinkedHashSet<ClassNode> interfaces) {\n        if (cNode.isInterface())\n            interfaces.add(cNode);\n\n        ClassNode[] directInterfaces = cNode.getInterfaces();\n        for (int i = directInterfaces.length-1; i >=0 ; i--) {\n            final ClassNode anInterface = directInterfaces[i];\n            interfaces.add(GenericsUtils.parameterizeType(cNode,anInterface));\n            collectAllInterfacesReverseOrder(anInterface, interfaces);\n        }\n        return interfaces;\n    }"
        ]
    ],
    "552495bd4a180bf31d2ddc31cb795ca151a899f4": [
        [
            "StaticTypeCheckingSupport::extractGenericsConnections(Map,GenericsType,GenericsType)",
            "1539  \n1540  \n1541  \n1542  \n1543  \n1544  \n1545  \n1546  \n1547  \n1548  \n1549  \n1550  \n1551  \n1552  \n1553  \n1554  \n1555  \n1556  \n1557  \n1558  \n1559  \n1560  \n1561  \n1562  \n1563  \n1564  \n1565  \n1566  ",
            "    private static void extractGenericsConnections(Map<String, GenericsType> connections, GenericsType[] usage, GenericsType[] declaration) {\n        // if declaration does not provide generics, there is no connection to make \n        if (usage==null || declaration==null || declaration.length==0) return;\n        if (usage.length!=declaration.length) return;\n\n        // both have generics\n        for (int i=0; i<usage.length; i++) {\n            GenericsType ui = usage[i];\n            GenericsType di = declaration[i];\n            if (di.isPlaceholder()) {\n                connections.put(di.getName(), ui);\n            } else if (di.isWildcard()){\n                if (ui.isWildcard()) {\n                    extractGenericsConnections(connections, ui.getLowerBound(), di.getLowerBound());\n                    extractGenericsConnections(connections, ui.getUpperBounds(), di.getUpperBounds());\n                } else {\n                    ClassNode cu = ui.getType();\n                    extractGenericsConnections(connections, cu, di.getLowerBound());\n                    ClassNode[] upperBounds = di.getUpperBounds();\n                    if (upperBounds!=null) {\n                        for (ClassNode cn : upperBounds) {\n                            extractGenericsConnections(connections, cu, cn);\n                        }\n                    }\n                }\n            }\n        }\n    }",
            "1539  \n1540  \n1541  \n1542  \n1543  \n1544  \n1545  \n1546  \n1547  \n1548  \n1549  \n1550  \n1551  \n1552  \n1553  \n1554  \n1555  \n1556  \n1557  \n1558  \n1559  \n1560  \n1561  \n1562  \n1563  \n1564 +\n1565 +\n1566  \n1567  \n1568  ",
            "    private static void extractGenericsConnections(Map<String, GenericsType> connections, GenericsType[] usage, GenericsType[] declaration) {\n        // if declaration does not provide generics, there is no connection to make \n        if (usage==null || declaration==null || declaration.length==0) return;\n        if (usage.length!=declaration.length) return;\n\n        // both have generics\n        for (int i=0; i<usage.length; i++) {\n            GenericsType ui = usage[i];\n            GenericsType di = declaration[i];\n            if (di.isPlaceholder()) {\n                connections.put(di.getName(), ui);\n            } else if (di.isWildcard()){\n                if (ui.isWildcard()) {\n                    extractGenericsConnections(connections, ui.getLowerBound(), di.getLowerBound());\n                    extractGenericsConnections(connections, ui.getUpperBounds(), di.getUpperBounds());\n                } else {\n                    ClassNode cu = ui.getType();\n                    extractGenericsConnections(connections, cu, di.getLowerBound());\n                    ClassNode[] upperBounds = di.getUpperBounds();\n                    if (upperBounds!=null) {\n                        for (ClassNode cn : upperBounds) {\n                            extractGenericsConnections(connections, cu, cn);\n                        }\n                    }\n                }\n            } else {\n                extractGenericsConnections(connections, ui.getType(), di.getType());\n            }\n        }\n    }"
        ]
    ],
    "510ea5ea16ee59f5ea191745b7c62ed7bf27a790": [
        [
            "ExternalizeMethodsASTTransformation::createReadExternal(ClassNode,List,List)",
            "  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101 -\n 102 -\n 103  \n 104  \n 105  ",
            "    private void createReadExternal(ClassNode cNode, List<String> excludes, List<FieldNode> list) {\n        final BlockStatement body = new BlockStatement();\n        Parameter oin = param(OBJECTINPUT_TYPE, \"oin\");\n        for (FieldNode fNode : list) {\n            if (excludes.contains(fNode.getName())) continue;\n            if ((fNode.getModifiers() & ACC_TRANSIENT) != 0) continue;\n            Expression readObject = callX(varX(oin), \"read\" + suffixForField(fNode));\n            body.addStatement(assignS(varX(fNode), castX(fNode.getType(), readObject)));\n        }\n        cNode.addMethod(\"readExternal\", ACC_PUBLIC, ClassHelper.VOID_TYPE, params(oin), ClassNode.EMPTY_ARRAY, body);\n    }",
            "  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102 +\n 103 +\n 104 +\n 105  \n 106  \n 107  ",
            "    private void createReadExternal(ClassNode cNode, List<String> excludes, List<FieldNode> list) {\n        final BlockStatement body = new BlockStatement();\n        Parameter oin = param(OBJECTINPUT_TYPE, \"oin\");\n        for (FieldNode fNode : list) {\n            if (excludes.contains(fNode.getName())) continue;\n            if ((fNode.getModifiers() & ACC_TRANSIENT) != 0) continue;\n            String suffix = suffixForField(fNode);\n            Expression readObject = callX(varX(oin), \"read\" + suffix);\n            body.addStatement(assignS(varX(fNode), suffix.equals(\"Object\") ? castX(GenericsUtils.nonGeneric(fNode.getType()), readObject) : readObject));\n        }\n        cNode.addMethod(\"readExternal\", ACC_PUBLIC, ClassHelper.VOID_TYPE, params(oin), ClassNode.EMPTY_ARRAY, body);\n    }"
        ]
    ],
    "eeaa35e1470558f290a7085c187999dcf37bc2a2": [
        [
            "GenericsUtils::correctToGenericsSpecRecurse(Map,ClassNode)",
            " 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  ",
            "    public static ClassNode correctToGenericsSpecRecurse(Map<String,ClassNode> genericsSpec, ClassNode type) {\n        if (type.isArray()) {\n            return correctToGenericsSpecRecurse(genericsSpec, type.getComponentType()).makeArray();\n        }\n        if (type.isGenericsPlaceHolder()) {\n            String name = type.getGenericsTypes()[0].getName();\n            type = genericsSpec.get(name);\n        }\n        if (type == null) type = ClassHelper.OBJECT_TYPE;\n        GenericsType[] oldgTypes = type.getGenericsTypes();\n        GenericsType[] newgTypes = new GenericsType[0];\n        if (oldgTypes != null) {\n            newgTypes = new GenericsType[oldgTypes.length];\n            for (int i = 0; i < newgTypes.length; i++) {\n                GenericsType oldgType = oldgTypes[i];\n                if (oldgType.isPlaceholder() ) {\n                    if (genericsSpec.get(oldgType.getName())!=null) {\n                        newgTypes[i] = new GenericsType(genericsSpec.get(oldgType.getName()));\n                    } else {\n                        newgTypes[i] = new GenericsType(ClassHelper.OBJECT_TYPE);\n                    }\n                } else if (oldgType.isWildcard()) {\n                    ClassNode oldLower = oldgType.getLowerBound();\n                    ClassNode lower = oldLower!=null?correctToGenericsSpecRecurse(genericsSpec, oldLower):null;\n                    ClassNode[] oldUpper = oldgType.getUpperBounds();\n                    ClassNode[] upper = null;\n                    if (oldUpper!=null) {\n                        upper = new ClassNode[oldUpper.length];\n                        for (int j = 0; j < oldUpper.length; j++) {\n                            upper[j] = correctToGenericsSpecRecurse(genericsSpec,oldUpper[j]);\n                        }\n                    }\n                    GenericsType fixed = new GenericsType(oldgType.getType(), upper, lower);\n                    fixed.setWildcard(true);\n                    newgTypes[i] = fixed;\n                } else {\n                    newgTypes[i] = new GenericsType(correctToGenericsSpecRecurse(genericsSpec,correctToGenericsSpec(genericsSpec, oldgType)));\n                }\n            }\n        }\n        return makeClassSafeWithGenerics(type, newgTypes);\n    }",
            " 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299 +\n 300 +\n 301 +\n 302 +\n 303 +\n 304  \n 305  \n 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  ",
            "    public static ClassNode correctToGenericsSpecRecurse(Map<String,ClassNode> genericsSpec, ClassNode type) {\n        if (type.isArray()) {\n            return correctToGenericsSpecRecurse(genericsSpec, type.getComponentType()).makeArray();\n        }\n        if (type.isGenericsPlaceHolder()) {\n            String name = type.getGenericsTypes()[0].getName();\n            type = genericsSpec.get(name);\n            if (type != null && type.isGenericsPlaceHolder() && type.getGenericsTypes() == null) {\n                ClassNode placeholder = ClassHelper.makeWithoutCaching(type.getUnresolvedName());\n                placeholder.setGenericsPlaceHolder(true);\n                type = makeClassSafeWithGenerics(type, new GenericsType(placeholder));\n            }\n        }\n        if (type == null) type = ClassHelper.OBJECT_TYPE;\n        GenericsType[] oldgTypes = type.getGenericsTypes();\n        GenericsType[] newgTypes = new GenericsType[0];\n        if (oldgTypes != null) {\n            newgTypes = new GenericsType[oldgTypes.length];\n            for (int i = 0; i < newgTypes.length; i++) {\n                GenericsType oldgType = oldgTypes[i];\n                if (oldgType.isPlaceholder() ) {\n                    if (genericsSpec.get(oldgType.getName())!=null) {\n                        newgTypes[i] = new GenericsType(genericsSpec.get(oldgType.getName()));\n                    } else {\n                        newgTypes[i] = new GenericsType(ClassHelper.OBJECT_TYPE);\n                    }\n                } else if (oldgType.isWildcard()) {\n                    ClassNode oldLower = oldgType.getLowerBound();\n                    ClassNode lower = oldLower!=null?correctToGenericsSpecRecurse(genericsSpec, oldLower):null;\n                    ClassNode[] oldUpper = oldgType.getUpperBounds();\n                    ClassNode[] upper = null;\n                    if (oldUpper!=null) {\n                        upper = new ClassNode[oldUpper.length];\n                        for (int j = 0; j < oldUpper.length; j++) {\n                            upper[j] = correctToGenericsSpecRecurse(genericsSpec,oldUpper[j]);\n                        }\n                    }\n                    GenericsType fixed = new GenericsType(oldgType.getType(), upper, lower);\n                    fixed.setWildcard(true);\n                    newgTypes[i] = fixed;\n                } else {\n                    newgTypes[i] = new GenericsType(correctToGenericsSpecRecurse(genericsSpec,correctToGenericsSpec(genericsSpec, oldgType)));\n                }\n            }\n        }\n        return makeClassSafeWithGenerics(type, newgTypes);\n    }"
        ],
        [
            "GenericsUtils::makeClassSafe0(ClassNode,GenericsType)",
            " 260  \n 261  \n 262 -\n 263  \n 264  ",
            "    public static ClassNode makeClassSafe0(ClassNode type, GenericsType... genericTypes) {\n        ClassNode plainNodeReference = newClass(type);\n        if (genericTypes != null && genericTypes.length > 0) plainNodeReference.setGenericsTypes(genericTypes);\n        return plainNodeReference;\n    }",
            " 260  \n 261  \n 262 +\n 263 +\n 264 +\n 265 +\n 266  \n 267  ",
            "    public static ClassNode makeClassSafe0(ClassNode type, GenericsType... genericTypes) {\n        ClassNode plainNodeReference = newClass(type);\n        if (genericTypes != null && genericTypes.length > 0) {\n            plainNodeReference.setGenericsTypes(genericTypes);\n            if (type.isGenericsPlaceHolder()) plainNodeReference.setGenericsPlaceHolder(true);\n        }\n        return plainNodeReference;\n    }"
        ],
        [
            "InheritConstructorsASTTransformation::addConstructorUnlessAlreadyExisting(ClassNode,ConstructorNode)",
            "  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88 -\n  89 -\n  90 -\n  91 -\n  92  \n  93  \n  94  \n  95  ",
            "    private void addConstructorUnlessAlreadyExisting(ClassNode classNode, ConstructorNode consNode) {\n        Parameter[] origParams = consNode.getParameters();\n        if (consNode.isPrivate()) return;\n        Parameter[] params = new Parameter[origParams.length];\n        List<Expression> theArgs = new ArrayList<Expression>();\n        for (int i = 0; i < origParams.length; i++) {\n            Parameter p = origParams[i];\n            params[i] = p.hasInitialExpression() ?\n                    new Parameter(p.getType(), p.getName(), p.getInitialExpression()) :\n                    new Parameter(p.getType(), p.getName());\n            theArgs.add(varX(p.getName(), p.getType()));\n        }\n        if (isExisting(classNode, params)) return;\n        classNode.addConstructor(consNode.getModifiers(), params, consNode.getExceptions(), block(ctorSuperS(args(theArgs))));\n    }",
            "  86  \n  87  \n  88  \n  89  \n  90  \n  91 +\n  92 +\n  93  \n  94  \n  95 +\n  96 +\n  97 +\n  98  \n  99  \n 100  \n 101  ",
            "    private void addConstructorUnlessAlreadyExisting(ClassNode classNode, ConstructorNode consNode) {\n        Parameter[] origParams = consNode.getParameters();\n        if (consNode.isPrivate()) return;\n        Parameter[] params = new Parameter[origParams.length];\n        List<Expression> theArgs = new ArrayList<Expression>();\n        Map<String, ClassNode> genericsSpec = createGenericsSpec(classNode);\n        extractSuperClassGenerics(classNode, classNode.getSuperClass(), genericsSpec);\n        for (int i = 0; i < origParams.length; i++) {\n            Parameter p = origParams[i];\n            ClassNode newType = correctToGenericsSpecRecurse(genericsSpec, p.getType());\n            params[i] = p.hasInitialExpression() ? param(newType, p.getName(), p.getInitialExpression()) : param(newType, p.getName());\n            theArgs.add(varX(p.getName(), newType));\n        }\n        if (isExisting(classNode, params)) return;\n        classNode.addConstructor(consNode.getModifiers(), params, consNode.getExceptions(), block(ctorSuperS(args(theArgs))));\n    }"
        ]
    ],
    "17a8eb3858a42f99ad6ef00ba5e2d6ac7e39d3ec": [
        [
            "ReadWriteLockASTTransformation::visit(ASTNode,SourceUnit)",
            "  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87 -\n  88  \n  89 -\n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  ",
            "    public void visit(ASTNode[] nodes, SourceUnit source) {\n        init(nodes, source);\n        AnnotatedNode parent = (AnnotatedNode) nodes[1];\n        AnnotationNode node = (AnnotationNode) nodes[0];\n        final boolean isWriteLock;\n        if (READ_LOCK_TYPE.equals(node.getClassNode())) {\n            isWriteLock = false;\n        } else if (WRITE_LOCK_TYPE.equals(node.getClassNode())) {\n            isWriteLock = true;\n        } else {\n            throw new GroovyBugError(\"Internal error: expecting [\" + READ_LOCK_TYPE.getName() + \", \" + WRITE_LOCK_TYPE.getName() + \"]\" + \" but got: \" + node.getClassNode().getName());\n        }\n\n        String myTypeName = \"@\" + node.getClassNode().getNameWithoutPackage();\n\n        String value = getMemberStringValue(node, \"value\");\n\n        if (parent instanceof MethodNode) {\n            MethodNode mNode = (MethodNode) parent;\n            ClassNode cNode = mNode.getDeclaringClass();\n            String lockExpr = determineLock(value, cNode, mNode.isStatic(), myTypeName);\n            if (lockExpr == null) return;\n\n            // get lock type\n            final Expression lockType;\n            if (isWriteLock) {\n                lockType = callX(varX(lockExpr), \"writeLock\");\n            } else {\n                lockType = callX(varX(lockExpr), \"readLock\");\n            }\n\n            Expression acquireLock = callX(lockType, \"lock\");\n            Expression releaseLock = callX(lockType, \"unlock\");\n            Statement originalCode = mNode.getCode();\n\n            mNode.setCode(block(\n                    stmt(acquireLock),\n                    new TryCatchStatement(originalCode, stmt(releaseLock))));\n        }\n    }",
            "  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87 +\n  88  \n  89 +\n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  ",
            "    public void visit(ASTNode[] nodes, SourceUnit source) {\n        init(nodes, source);\n        AnnotatedNode parent = (AnnotatedNode) nodes[1];\n        AnnotationNode node = (AnnotationNode) nodes[0];\n        final boolean isWriteLock;\n        if (READ_LOCK_TYPE.equals(node.getClassNode())) {\n            isWriteLock = false;\n        } else if (WRITE_LOCK_TYPE.equals(node.getClassNode())) {\n            isWriteLock = true;\n        } else {\n            throw new GroovyBugError(\"Internal error: expecting [\" + READ_LOCK_TYPE.getName() + \", \" + WRITE_LOCK_TYPE.getName() + \"]\" + \" but got: \" + node.getClassNode().getName());\n        }\n\n        String myTypeName = \"@\" + node.getClassNode().getNameWithoutPackage();\n\n        String value = getMemberStringValue(node, \"value\");\n\n        if (parent instanceof MethodNode) {\n            MethodNode mNode = (MethodNode) parent;\n            ClassNode cNode = mNode.getDeclaringClass();\n            String lockExpr = determineLock(value, cNode, mNode.isStatic(), myTypeName);\n            if (lockExpr == null) return;\n\n            // get lock type\n            final Expression lockType;\n            if (isWriteLock) {\n                lockType = callX(varX(lockExpr, LOCK_TYPE), \"writeLock\");\n            } else {\n                lockType = callX(varX(lockExpr, LOCK_TYPE), \"readLock\");\n            }\n\n            Expression acquireLock = callX(lockType, \"lock\");\n            Expression releaseLock = callX(lockType, \"unlock\");\n            Statement originalCode = mNode.getCode();\n\n            mNode.setCode(block(\n                    stmt(acquireLock),\n                    new TryCatchStatement(originalCode, stmt(releaseLock))));\n        }\n    }"
        ]
    ],
    "aa6a3c064ceb07fd26c41842aa891bf939c21413": [
        [
            "GenericsUtils::parameterizeType(ClassNode,ClassNode)",
            " 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191 -\n 192 -\n 193 -\n 194 -\n 195 -\n 196 -\n 197 -\n 198 -\n 199 -\n 200 -\n 201 -\n 202 -\n 203 -\n 204 -\n 205 -\n 206 -\n 207 -\n 208  \n 209  \n 210 -\n 211 -\n 212 -\n 213 -\n 214  \n 215 -\n 216 -\n 217 -\n 218 -\n 219 -\n 220 -\n 221 -\n 222 -\n 223 -\n 224 -\n 225 -\n 226 -\n 227 -\n 228 -\n 229 -\n 230 -\n 231 -\n 232 -\n 233 -\n 234 -\n 235 -\n 236  ",
            "    /**\n     * Interface class nodes retrieved from {@link org.codehaus.groovy.ast.ClassNode#getInterfaces()}\n     * or {@link org.codehaus.groovy.ast.ClassNode#getAllInterfaces()} are returned with generic type\n     * arguments. This method allows returning a parameterized interface given the parameterized class\n     * node which implements this interface.\n     * @param hint the class node where generics types are parameterized\n     * @param target the interface we want to parameterize generics types\n     * @return a parameterized interface class node\n     */\n    public static ClassNode parameterizeType(final ClassNode hint, final ClassNode target) {\n        if (hint.isArray() && target.isArray()) {\n            return parameterizeType(hint.getComponentType(), target.getComponentType()).makeArray();\n        }\n        ClassNode interfaceFromClassNode = null;\n        if (hint.equals(target)) interfaceFromClassNode = hint;\n        if (ClassHelper.OBJECT_TYPE.equals(target) && target.isUsingGenerics() && target.getGenericsTypes()!=null\n                && target.getGenericsTypes()[0].isPlaceholder()) {\n            // Object<T>\n            return ClassHelper.getWrapper(hint);\n        }\n        if (interfaceFromClassNode==null) {\n            ClassNode[] interfaces = hint.getInterfaces();\n            for (ClassNode node : interfaces) {\n                if (node.equals(target)) {\n                    interfaceFromClassNode = node;\n                    break;\n                } else if (node.implementsInterface(target)) {\n                    // ex: classNode = LinkedList<A> , node=List<E> , anInterface = Iterable<T>\n                    return parameterizeType(parameterizeType(hint, node), target);\n                }\n            }\n        }\n        if (interfaceFromClassNode==null && hint.getUnresolvedSuperClass()!=null) {\n            return parameterizeType(hint.getUnresolvedSuperClass(), target);\n        }\n        if (interfaceFromClassNode==null) {\n\n//            return target;\n            interfaceFromClassNode = hint;\n        }\n        Map<String,GenericsType> parameters = new HashMap<String, GenericsType>();\n        extractPlaceholders(hint, parameters);\n        ClassNode node = target.getPlainNodeReference();\n        GenericsType[] interfaceGTs = interfaceFromClassNode.getGenericsTypes();\n        if (interfaceGTs==null) return target;\n        GenericsType[] types = new GenericsType[interfaceGTs.length];\n        for (int i = 0; i < interfaceGTs.length; i++) {\n            GenericsType interfaceGT = interfaceGTs[i];\n            types[i] = interfaceGT;\n            if (interfaceGT.isPlaceholder()) {\n                String name = interfaceGT.getName();\n                if (parameters.containsKey(name)) {\n                    types[i] = parameters.get(name);\n                }\n            }\n        }\n        node.setGenericsTypes(types);\n        return node;\n    }",
            " 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194 +\n 195 +\n 196 +\n 197 +\n 198 +\n 199 +\n 200 +\n 201  \n 202  \n 203 +\n 204 +\n 205 +\n 206 +\n 207 +\n 208  \n 209  ",
            "    /**\n     * Interface class nodes retrieved from {@link org.codehaus.groovy.ast.ClassNode#getInterfaces()}\n     * or {@link org.codehaus.groovy.ast.ClassNode#getAllInterfaces()} are returned with generic type\n     * arguments. This method allows returning a parameterized interface given the parameterized class\n     * node which implements this interface.\n     * @param hint the class node where generics types are parameterized\n     * @param target the interface we want to parameterize generics types\n     * @return a parameterized interface class node\n     */\n    public static ClassNode parameterizeType(final ClassNode hint, final ClassNode target) {\n        if (hint.isArray() && target.isArray()) {\n            return parameterizeType(hint.getComponentType(), target.getComponentType()).makeArray();\n        }\n        if (!target.equals(hint) && StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(target, hint)) {\n            ClassNode nextSuperClass = ClassHelper.getNextSuperClass(target, hint);\n            if (!hint.equals(nextSuperClass)) {\n                Map<String, ClassNode> genericsSpec = createGenericsSpec(hint);\n                extractSuperClassGenerics(hint, nextSuperClass, genericsSpec);\n                ClassNode result = correctToGenericsSpecRecurse(genericsSpec, nextSuperClass);\n                return parameterizeType(result, target);\n            }\n        }\n        Map<String, ClassNode> genericsSpec = createGenericsSpec(hint);\n        ClassNode targetRedirect = target.redirect();\n        genericsSpec = createGenericsSpec(targetRedirect, genericsSpec);\n        extractSuperClassGenerics(hint, targetRedirect, genericsSpec);\n        return correctToGenericsSpecRecurse(genericsSpec, targetRedirect);\n\n    }"
        ]
    ],
    "297f90d9da1b6c1a1b416d8ed17bc32de6dabb03": [
        [
            "StaticTypesCallSiteWriter::makeGetField(Expression,ClassNode,String,boolean,boolean,boolean)",
            " 487  \n 488  \n 489  \n 490  \n 491  \n 492  \n 493  \n 494  \n 495  \n 496  \n 497  \n 498  \n 499  \n 500  \n 501  \n 502  \n 503  \n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512  \n 513  \n 514  \n 515  \n 516  \n 517  \n 518  \n 519  \n 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528  \n 529  \n 530  \n 531  \n 532  \n 533  \n 534  \n 535  ",
            "    boolean makeGetField(final Expression receiver, final ClassNode receiverType, final String fieldName, final boolean safe, final boolean implicitThis, final boolean samePackage) {\n        FieldNode field = receiverType.getField(fieldName);\n        // direct access is allowed if we are in the same class as the declaring class\n        // or we are in an inner class\n        if (field !=null \n                && isDirectAccessAllowed(field, controller.getClassNode(), samePackage)) {\n            CompileStack compileStack = controller.getCompileStack();\n            MethodVisitor mv = controller.getMethodVisitor();\n            ClassNode replacementType = field.getOriginType();\n            OperandStack operandStack = controller.getOperandStack();\n            if (field.isStatic()) {\n                mv.visitFieldInsn(GETSTATIC, BytecodeHelper.getClassInternalName(field.getOwner()), fieldName, BytecodeHelper.getTypeDescription(replacementType));\n                operandStack.push(replacementType);\n            } else {\n                if (implicitThis) {\n                    compileStack.pushImplicitThis(implicitThis);\n                }\n                receiver.visit(controller.getAcg());\n                if (implicitThis) compileStack.popImplicitThis();\n                Label exit = new Label();\n                if (safe) {\n                    mv.visitInsn(DUP);\n                    Label doGet = new Label();\n                    mv.visitJumpInsn(IFNONNULL, doGet);\n                    mv.visitJumpInsn(GOTO, exit);\n                    mv.visitLabel(doGet);\n                }\n                if (!operandStack.getTopOperand().isDerivedFrom(field.getOwner())) {\n                    mv.visitTypeInsn(CHECKCAST, BytecodeHelper.getClassInternalName(field.getOwner()));\n                }\n                mv.visitFieldInsn(GETFIELD, BytecodeHelper.getClassInternalName(field.getOwner()), fieldName, BytecodeHelper.getTypeDescription(replacementType));\n                if (safe) {\n                    if (ClassHelper.isPrimitiveType(replacementType)) {\n                        operandStack.replace(replacementType);\n                        operandStack.box();\n                        replacementType = operandStack.getTopOperand();\n                    }\n                    mv.visitLabel(exit);\n                }\n            }\n            operandStack.replace(replacementType);\n            return true;\n        }\n        ClassNode superClass = receiverType.getSuperClass();\n        if (superClass !=null) {\n            return makeGetField(receiver, superClass, fieldName, safe, implicitThis, false);\n        }\n        return false;\n    }",
            " 487  \n 488  \n 489  \n 490  \n 491  \n 492  \n 493  \n 494  \n 495  \n 496  \n 497  \n 498  \n 499  \n 500  \n 501  \n 502  \n 503  \n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512  \n 513  \n 514  \n 515  \n 516  \n 517  \n 518  \n 519  \n 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528  \n 529  \n 530 +\n 531 +\n 532 +\n 533 +\n 534 +\n 535 +\n 536 +\n 537 +\n 538  \n 539  \n 540  \n 541  \n 542  \n 543  ",
            "    boolean makeGetField(final Expression receiver, final ClassNode receiverType, final String fieldName, final boolean safe, final boolean implicitThis, final boolean samePackage) {\n        FieldNode field = receiverType.getField(fieldName);\n        // direct access is allowed if we are in the same class as the declaring class\n        // or we are in an inner class\n        if (field !=null \n                && isDirectAccessAllowed(field, controller.getClassNode(), samePackage)) {\n            CompileStack compileStack = controller.getCompileStack();\n            MethodVisitor mv = controller.getMethodVisitor();\n            ClassNode replacementType = field.getOriginType();\n            OperandStack operandStack = controller.getOperandStack();\n            if (field.isStatic()) {\n                mv.visitFieldInsn(GETSTATIC, BytecodeHelper.getClassInternalName(field.getOwner()), fieldName, BytecodeHelper.getTypeDescription(replacementType));\n                operandStack.push(replacementType);\n            } else {\n                if (implicitThis) {\n                    compileStack.pushImplicitThis(implicitThis);\n                }\n                receiver.visit(controller.getAcg());\n                if (implicitThis) compileStack.popImplicitThis();\n                Label exit = new Label();\n                if (safe) {\n                    mv.visitInsn(DUP);\n                    Label doGet = new Label();\n                    mv.visitJumpInsn(IFNONNULL, doGet);\n                    mv.visitJumpInsn(GOTO, exit);\n                    mv.visitLabel(doGet);\n                }\n                if (!operandStack.getTopOperand().isDerivedFrom(field.getOwner())) {\n                    mv.visitTypeInsn(CHECKCAST, BytecodeHelper.getClassInternalName(field.getOwner()));\n                }\n                mv.visitFieldInsn(GETFIELD, BytecodeHelper.getClassInternalName(field.getOwner()), fieldName, BytecodeHelper.getTypeDescription(replacementType));\n                if (safe) {\n                    if (ClassHelper.isPrimitiveType(replacementType)) {\n                        operandStack.replace(replacementType);\n                        operandStack.box();\n                        replacementType = operandStack.getTopOperand();\n                    }\n                    mv.visitLabel(exit);\n                }\n            }\n            operandStack.replace(replacementType);\n            return true;\n        }\n\n        for (ClassNode intf : receiverType.getInterfaces()) {\n            // GROOVY-7039\n            if (intf!=receiverType && makeGetField(receiver, intf, fieldName, safe, implicitThis, false)) {\n                return true;\n            }\n        }\n\n        ClassNode superClass = receiverType.getSuperClass();\n        if (superClass !=null) {\n            return makeGetField(receiver, superClass, fieldName, safe, implicitThis, false);\n        }\n        return false;\n    }"
        ]
    ],
    "ca1f7ab61e7ca273e3ff07835f58e1f4fab88446": [
        [
            "ResolveVisitor::resolveNestedClass(ClassNode)",
            " 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291 -\n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300 -\n 301  \n 302  \n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332 -\n 333 -\n 334 -\n 335  ",
            "    private boolean resolveNestedClass(ClassNode type) {\n        // we have for example a class name A, are in class X\n        // and there is a nested class A$X. we want to be able \n        // to access that class directly, so A becomes a valid\n        // name in X.\n        // GROOVY-4043: Do this check up the hierarchy, if needed\n        Map<String, ClassNode> hierClasses = new LinkedHashMap<String, ClassNode>();\n        ClassNode val;\n        String name;\n        for(ClassNode classToCheck = currentClass; classToCheck != ClassHelper.OBJECT_TYPE; \n            classToCheck = classToCheck.getSuperClass()) {\n            if(classToCheck == null || hierClasses.containsKey(classToCheck.getName())) break;\n            hierClasses.put(classToCheck.getName(), classToCheck);\n        }\n        \n        for (ClassNode classToCheck : hierClasses.values()) {\n            name = classToCheck.getName()+\"$\"+type.getName();\n            val = ClassHelper.make(name);\n            if (resolveFromCompileUnit(val)) {\n                type.setRedirect(val);\n                return true;\n            }\n        }\n        \n        // another case we want to check here is if we are in a\n        // nested class A$B$C and want to access B without\n        // qualifying it by A.B. A alone will work, since that\n        // is the qualified (minus package) name of that class\n        // anyway. \n        \n        // That means if the current class is not an InnerClassNode\n        // there is nothing to be done.\n        if (!(currentClass instanceof InnerClassNode)) return false;\n        \n        // since we have B and want to get A we start with the most \n        // outer class, put them together and then see if that does\n        // already exist. In case of B from within A$B we are done \n        // after the first step already. In case of for example\n        // A.B.C.D.E.F and accessing E from F we test A$E=failed, \n        // A$B$E=failed, A$B$C$E=fail, A$B$C$D$E=success\n        \n        LinkedList<ClassNode> outerClasses = new LinkedList<ClassNode>();\n        ClassNode outer = currentClass.getOuterClass();\n        while (outer!=null) {\n            outerClasses.addFirst(outer);\n            outer = outer.getOuterClass();\n        }\n        // most outer class is now element 0\n        for (ClassNode testNode : outerClasses) {\n            name = testNode.getName()+\"$\"+type.getName();\n            val = ClassHelper.make(name);\n            if (resolveFromCompileUnit(val)) {\n                type.setRedirect(val);\n                return true;\n            }\n        }        \n        \n        return false;   \n    }",
            " 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291 +\n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299 +\n 300 +\n 301 +\n 302 +\n 303 +\n 304 +\n 305 +\n 306 +\n 307 +\n 308 +\n 309  \n 310 +\n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342 +\n 343 +\n 344 +\n 345 +\n 346 +\n 347 +\n 348 +\n 349 +\n 350 +\n 351 +\n 352 +\n 353 +\n 354 +\n 355  ",
            "    private boolean resolveNestedClass(ClassNode type) {\n        // we have for example a class name A, are in class X\n        // and there is a nested class A$X. we want to be able \n        // to access that class directly, so A becomes a valid\n        // name in X.\n        // GROOVY-4043: Do this check up the hierarchy, if needed\n        Map<String, ClassNode> hierClasses = new LinkedHashMap<String, ClassNode>();\n        ClassNode val;\n        String name;\n        for(ClassNode classToCheck = currentClass; classToCheck != ClassHelper.OBJECT_TYPE; \n            classToCheck = classToCheck.getSuperClass()) {\n            if(classToCheck == null || hierClasses.containsKey(classToCheck.getName())) break;\n            hierClasses.put(classToCheck.getName(), classToCheck);\n        }\n\n        for (ClassNode classToCheck : hierClasses.values()) {\n            name = classToCheck.getName()+\"$\"+type.getName();\n            val = ClassHelper.make(name);\n            if (resolveFromCompileUnit(val)) {\n                type.setRedirect(val);\n                return true;\n            }\n            // also check interfaces in case we have interfaces with nested classes\n            for (ClassNode next : classToCheck.getAllInterfaces()) {\n                if (type.getName().contains(next.getName())) continue;\n                name = next.getName()+\"$\"+type.getName();\n                val = ClassHelper.make(name);\n                if (resolve(val, false, false, false)) {\n                    type.setRedirect(val);\n                    return true;\n                }\n            }\n        }\n\n        // another case we want to check here is if we are in a\n        // nested class A$B$C and want to access B without\n        // qualifying it by A.B. A alone will work, since that\n        // is the qualified (minus package) name of that class\n        // anyway. \n        \n        // That means if the current class is not an InnerClassNode\n        // there is nothing to be done.\n        if (!(currentClass instanceof InnerClassNode)) return false;\n        \n        // since we have B and want to get A we start with the most \n        // outer class, put them together and then see if that does\n        // already exist. In case of B from within A$B we are done \n        // after the first step already. In case of for example\n        // A.B.C.D.E.F and accessing E from F we test A$E=failed, \n        // A$B$E=failed, A$B$C$E=fail, A$B$C$D$E=success\n        \n        LinkedList<ClassNode> outerClasses = new LinkedList<ClassNode>();\n        ClassNode outer = currentClass.getOuterClass();\n        while (outer!=null) {\n            outerClasses.addFirst(outer);\n            outer = outer.getOuterClass();\n        }\n        // most outer class is now element 0\n        for (ClassNode testNode : outerClasses) {\n            name = testNode.getName()+\"$\"+type.getName();\n            val = ClassHelper.make(name);\n            if (resolveFromCompileUnit(val)) {\n                type.setRedirect(val);\n                return true;\n            }\n            // also check interfaces in case we have interfaces with nested classes\n            for (ClassNode next : testNode.getAllInterfaces()) {\n                if (type.getName().contains(next.getName())) continue;\n                name = next.getName()+\"$\"+type.getName();\n                val = ClassHelper.make(name);\n                if (resolve(val, false, false, false)) {\n                    type.setRedirect(val);\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }"
        ]
    ],
    "37c1103adbc03f59d042875b5dc2ba58315c0389": [
        [
            "InvokerHelper::format(Object,boolean,int)",
            " 578  \n 579  \n 580  \n 581  \n 582  \n 583  \n 584  \n 585  \n 586  \n 587  \n 588  \n 589  \n 590  \n 591  \n 592  \n 593  \n 594  \n 595  \n 596  \n 597  \n 598  \n 599  \n 600  \n 601  \n 602  \n 603  \n 604  \n 605  \n 606  \n 607  \n 608  \n 609  \n 610  \n 611  \n 612  \n 613  \n 614  \n 615  \n 616  \n 617  \n 618  \n 619 -\n 620 -\n 621 -\n 622 -\n 623 -\n 624 -\n 625  \n 626  \n 627  \n 628  \n 629  \n 630  \n 631  \n 632  \n 633  ",
            "    public static String format(Object arguments, boolean verbose, int maxSize) {\n        if (arguments == null) {\n            final NullObject nullObject = NullObject.getNullObject();\n            return (String) nullObject.getMetaClass().invokeMethod(nullObject, \"toString\", EMPTY_ARGS);\n        }\n        if (arguments.getClass().isArray()) {\n            if (arguments instanceof char[]) {\n                return new String((char[]) arguments);\n            }\n            return format(DefaultTypeTransformation.asCollection(arguments), verbose, maxSize);\n        }\n        if (arguments instanceof Range) {\n            Range range = (Range) arguments;\n            if (verbose) {\n                return range.inspect();\n            } else {\n                return range.toString();\n            }\n        }\n        if (arguments instanceof Collection) {\n            return formatList((Collection) arguments, verbose, maxSize);\n        }\n        if (arguments instanceof Map) {\n            return formatMap((Map) arguments, verbose, maxSize);\n        }\n        if (arguments instanceof Element) {\n            try {\n                Method serialize = Class.forName(\"groovy.xml.XmlUtil\").getMethod(\"serialize\", Element.class);\n                return (String) serialize.invoke(null, arguments);\n            } catch (ClassNotFoundException e) {\n                throw new RuntimeException(e);\n            } catch (NoSuchMethodException e) {\n                throw new RuntimeException(e);\n            } catch (InvocationTargetException e) {\n                throw new RuntimeException(e);\n            } catch (IllegalAccessException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        if (arguments instanceof String) {\n            if (verbose) {\n                String arg = ((String) arguments).replaceAll(\"\\\\n\", \"\\\\\\\\n\");    // line feed\n                arg = arg.replaceAll(\"\\\\r\", \"\\\\\\\\r\");      // carriage return\n                arg = arg.replaceAll(\"\\\\t\", \"\\\\\\\\t\");      // tab\n                arg = arg.replaceAll(\"\\\\f\", \"\\\\\\\\f\");      // form feed\n                arg = arg.replaceAll(\"'\", \"\\\\\\\\'\");    // single quotation mark\n                arg = arg.replaceAll(\"\\\\\\\\\", \"\\\\\\\\\");      // backslash\n                return \"\\'\" + arg + \"\\'\";\n            } else {\n                return (String) arguments;\n            }\n        }\n        // TODO: For GROOVY-2599 do we need something like below but it breaks other things\n//        return (String) invokeMethod(arguments, \"toString\", EMPTY_ARGS);\n        return arguments.toString();\n    }",
            " 578  \n 579  \n 580  \n 581  \n 582  \n 583  \n 584  \n 585  \n 586  \n 587  \n 588  \n 589  \n 590  \n 591  \n 592  \n 593  \n 594  \n 595  \n 596  \n 597  \n 598  \n 599  \n 600  \n 601  \n 602  \n 603  \n 604  \n 605  \n 606  \n 607  \n 608  \n 609  \n 610  \n 611  \n 612  \n 613  \n 614  \n 615  \n 616  \n 617  \n 618  \n 619 +\n 620 +\n 621 +\n 622 +\n 623 +\n 624 +\n 625 +\n 626 +\n 627  \n 628  \n 629  \n 630  \n 631  \n 632  \n 633  \n 634  \n 635  ",
            "    public static String format(Object arguments, boolean verbose, int maxSize) {\n        if (arguments == null) {\n            final NullObject nullObject = NullObject.getNullObject();\n            return (String) nullObject.getMetaClass().invokeMethod(nullObject, \"toString\", EMPTY_ARGS);\n        }\n        if (arguments.getClass().isArray()) {\n            if (arguments instanceof char[]) {\n                return new String((char[]) arguments);\n            }\n            return format(DefaultTypeTransformation.asCollection(arguments), verbose, maxSize);\n        }\n        if (arguments instanceof Range) {\n            Range range = (Range) arguments;\n            if (verbose) {\n                return range.inspect();\n            } else {\n                return range.toString();\n            }\n        }\n        if (arguments instanceof Collection) {\n            return formatList((Collection) arguments, verbose, maxSize);\n        }\n        if (arguments instanceof Map) {\n            return formatMap((Map) arguments, verbose, maxSize);\n        }\n        if (arguments instanceof Element) {\n            try {\n                Method serialize = Class.forName(\"groovy.xml.XmlUtil\").getMethod(\"serialize\", Element.class);\n                return (String) serialize.invoke(null, arguments);\n            } catch (ClassNotFoundException e) {\n                throw new RuntimeException(e);\n            } catch (NoSuchMethodException e) {\n                throw new RuntimeException(e);\n            } catch (InvocationTargetException e) {\n                throw new RuntimeException(e);\n            } catch (IllegalAccessException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        if (arguments instanceof String) {\n            if (verbose) {\n                String arg = ((String) arguments)\n                        // must replace backslashes first, as the other replacements add backslashes not to be escaped\n                        .replace(\"\\\\\", \"\\\\\\\\\")      // backslash\n                        .replace(\"\\n\", \"\\\\n\")    // line feed\n                        .replaceAll(\"\\\\r\", \"\\\\\\\\r\")      // carriage return\n                        .replaceAll(\"\\\\t\", \"\\\\\\\\t\")      // tab\n                        .replaceAll(\"\\\\f\", \"\\\\\\\\f\")      // form feed\n                        .replaceAll(\"'\", \"\\\\\\\\'\");    // single quotation mark\n                return \"\\'\" + arg + \"\\'\";\n            } else {\n                return (String) arguments;\n            }\n        }\n        // TODO: For GROOVY-2599 do we need something like below but it breaks other things\n//        return (String) invokeMethod(arguments, \"toString\", EMPTY_ARGS);\n        return arguments.toString();\n    }"
        ]
    ],
    "21b3fadd70b0acc5c4d9fdc2e8c5dbdc8b52b86d": [
        [
            "InnerClassCompletionVisitor::addDefaultMethods(InnerClassNode)",
            " 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180 -\n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  ",
            "    private void addDefaultMethods(InnerClassNode node) {\r\n        final boolean isStatic = isStatic(node);\r\n\r\n        ClassNode outerClass = node.getOuterClass();\r\n        final String classInternalName = org.codehaus.groovy.classgen.asm.BytecodeHelper.getClassInternalName(node);\r\n        final String outerClassInternalName = getInternalName(outerClass, isStatic);\r\n        final String outerClassDescriptor = getTypeDescriptor(outerClass, isStatic);\r\n        final int objectDistance = getObjectDistance(outerClass);\r\n\r\n        // add method dispatcher\r\n        Parameter[] parameters = new Parameter[]{\r\n                new Parameter(ClassHelper.STRING_TYPE, \"name\"),\r\n                new Parameter(ClassHelper.OBJECT_TYPE, \"args\")\r\n        };\r\n\r\n        String methodName = \"methodMissing\";\r\n        if (isStatic)\r\n            addCompilationErrorOnCustomMethodNode(node, methodName, parameters);\r\n\r\n        MethodNode method = node.addSyntheticMethod(\r\n                methodName,\r\n                Opcodes.ACC_PUBLIC,\r\n                ClassHelper.OBJECT_TYPE,\r\n                parameters,\r\n                ClassNode.EMPTY_ARRAY,\r\n                null\r\n        );\r\n\r\n        BlockStatement block = new BlockStatement();\r\n        if (isStatic) {\r\n            setMethodDispatcherCode(block, new ClassExpression(outerClass), parameters);\r\n        } else {\r\n            block.addStatement(\r\n                    new BytecodeSequence(new BytecodeInstruction() {\r\n                        public void visit(MethodVisitor mv) {\r\n                            getThis(mv,classInternalName,outerClassDescriptor,outerClassInternalName);\r\n                            mv.visitVarInsn(ALOAD, 1);\r\n                            mv.visitVarInsn(ALOAD, 2);\r\n                            mv.visitMethodInsn(INVOKEVIRTUAL, outerClassInternalName, \"this$dist$invoke$\" + objectDistance, \"(Ljava/lang/String;Ljava/lang/Object;)Ljava/lang/Object;\", false);\r\n                            mv.visitInsn(ARETURN);\r\n                        }\r\n                    })\r\n            );\r\n        }\r\n        method.setCode(block);\r\n\r\n        // add property setter dispatcher\r\n        parameters = new Parameter[]{\r\n                new Parameter(ClassHelper.STRING_TYPE, \"name\"),\r\n                new Parameter(ClassHelper.OBJECT_TYPE, \"val\")\r\n        };\r\n\r\n        methodName = \"propertyMissing\";\r\n        if (isStatic)\r\n            addCompilationErrorOnCustomMethodNode(node, methodName, parameters);\r\n\r\n        method = node.addSyntheticMethod(\r\n                methodName,\r\n                Opcodes.ACC_PUBLIC,\r\n                ClassHelper.VOID_TYPE,\r\n                parameters,\r\n                ClassNode.EMPTY_ARRAY,\r\n                null\r\n        );\r\n\r\n        block = new BlockStatement();\r\n        if (isStatic) {\r\n            setPropertySetterDispatcher(block, new ClassExpression(node.getOuterClass()), parameters);\r\n        } else {\r\n            block.addStatement(\r\n                    new BytecodeSequence(new BytecodeInstruction() {\r\n                        public void visit(MethodVisitor mv) {\r\n                            getThis(mv,classInternalName,outerClassDescriptor,outerClassInternalName);\r\n                            mv.visitVarInsn(ALOAD, 1);\r\n                            mv.visitVarInsn(ALOAD, 2);\r\n                            mv.visitMethodInsn(INVOKEVIRTUAL, outerClassInternalName, \"this$dist$set$\" + objectDistance, \"(Ljava/lang/String;Ljava/lang/Object;)V\", false);\r\n                            mv.visitInsn(RETURN);\r\n                        }\r\n                    })\r\n            );\r\n        }\r\n        method.setCode(block);\r\n\r\n        // add property getter dispatcher\r\n        parameters = new Parameter[]{\r\n                new Parameter(ClassHelper.STRING_TYPE, \"name\")\r\n        };\r\n\r\n        methodName = \"propertyMissing\";\r\n        if (isStatic)\r\n            addCompilationErrorOnCustomMethodNode(node, methodName, parameters);\r\n\r\n        method = node.addSyntheticMethod(\r\n                methodName,\r\n                Opcodes.ACC_PUBLIC,\r\n                ClassHelper.OBJECT_TYPE,\r\n                parameters,\r\n                ClassNode.EMPTY_ARRAY,\r\n                null\r\n        );\r\n\r\n        block = new BlockStatement();\r\n        if (isStatic) {\r\n            setPropertyGetterDispatcher(block, new ClassExpression(node.getOuterClass()), parameters);\r\n        } else {\r\n            block.addStatement(\r\n                    new BytecodeSequence(new BytecodeInstruction() {\r\n                        public void visit(MethodVisitor mv) {\r\n                            getThis(mv,classInternalName,outerClassDescriptor,outerClassInternalName);\r\n                            mv.visitVarInsn(ALOAD, 1);\r\n                            mv.visitMethodInsn(INVOKEVIRTUAL, outerClassInternalName, \"this$dist$get$\" + objectDistance, \"(Ljava/lang/String;)Ljava/lang/Object;\", false);\r\n                            mv.visitInsn(ARETURN);\r\n                        }\r\n                    })\r\n            );\r\n        }\r\n        method.setCode(block);\r\n    }\r",
            " 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180 +\n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217 +\n 218 +\n 219 +\n 220 +\n 221 +\n 222 +\n 223 +\n 224 +\n 225 +\n 226 +\n 227 +\n 228 +\n 229 +\n 230 +\n 231 +\n 232 +\n 233 +\n 234 +\n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  \n 306  ",
            "    private void addDefaultMethods(InnerClassNode node) {\r\n        final boolean isStatic = isStatic(node);\r\n\r\n        ClassNode outerClass = node.getOuterClass();\r\n        final String classInternalName = org.codehaus.groovy.classgen.asm.BytecodeHelper.getClassInternalName(node);\r\n        final String outerClassInternalName = getInternalName(outerClass, isStatic);\r\n        final String outerClassDescriptor = getTypeDescriptor(outerClass, isStatic);\r\n        final int objectDistance = getObjectDistance(outerClass);\r\n\r\n        // add missing method dispatcher\r\n        Parameter[] parameters = new Parameter[]{\r\n                new Parameter(ClassHelper.STRING_TYPE, \"name\"),\r\n                new Parameter(ClassHelper.OBJECT_TYPE, \"args\")\r\n        };\r\n\r\n        String methodName = \"methodMissing\";\r\n        if (isStatic)\r\n            addCompilationErrorOnCustomMethodNode(node, methodName, parameters);\r\n\r\n        MethodNode method = node.addSyntheticMethod(\r\n                methodName,\r\n                Opcodes.ACC_PUBLIC,\r\n                ClassHelper.OBJECT_TYPE,\r\n                parameters,\r\n                ClassNode.EMPTY_ARRAY,\r\n                null\r\n        );\r\n\r\n        BlockStatement block = new BlockStatement();\r\n        if (isStatic) {\r\n            setMethodDispatcherCode(block, new ClassExpression(outerClass), parameters);\r\n        } else {\r\n            block.addStatement(\r\n                    new BytecodeSequence(new BytecodeInstruction() {\r\n                        public void visit(MethodVisitor mv) {\r\n                            getThis(mv,classInternalName,outerClassDescriptor,outerClassInternalName);\r\n                            mv.visitVarInsn(ALOAD, 1);\r\n                            mv.visitVarInsn(ALOAD, 2);\r\n                            mv.visitMethodInsn(INVOKEVIRTUAL, outerClassInternalName, \"this$dist$invoke$\" + objectDistance, \"(Ljava/lang/String;Ljava/lang/Object;)Ljava/lang/Object;\", false);\r\n                            mv.visitInsn(ARETURN);\r\n                        }\r\n                    })\r\n            );\r\n        }\r\n        method.setCode(block);\r\n\r\n        // add static missing method dispatcher\r\n        methodName = \"$static_methodMissing\";\r\n        if (isStatic)\r\n            addCompilationErrorOnCustomMethodNode(node, methodName, parameters);\r\n\r\n        method = node.addSyntheticMethod(\r\n                methodName,\r\n                Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\r\n                ClassHelper.OBJECT_TYPE,\r\n                parameters,\r\n                ClassNode.EMPTY_ARRAY,\r\n                null\r\n        );\r\n\r\n        block = new BlockStatement();\r\n        setMethodDispatcherCode(block, new ClassExpression(outerClass), parameters);\r\n        method.setCode(block);\r\n\r\n        // add property setter dispatcher\r\n        parameters = new Parameter[]{\r\n                new Parameter(ClassHelper.STRING_TYPE, \"name\"),\r\n                new Parameter(ClassHelper.OBJECT_TYPE, \"val\")\r\n        };\r\n\r\n        methodName = \"propertyMissing\";\r\n        if (isStatic)\r\n            addCompilationErrorOnCustomMethodNode(node, methodName, parameters);\r\n\r\n        method = node.addSyntheticMethod(\r\n                methodName,\r\n                Opcodes.ACC_PUBLIC,\r\n                ClassHelper.VOID_TYPE,\r\n                parameters,\r\n                ClassNode.EMPTY_ARRAY,\r\n                null\r\n        );\r\n\r\n        block = new BlockStatement();\r\n        if (isStatic) {\r\n            setPropertySetterDispatcher(block, new ClassExpression(node.getOuterClass()), parameters);\r\n        } else {\r\n            block.addStatement(\r\n                    new BytecodeSequence(new BytecodeInstruction() {\r\n                        public void visit(MethodVisitor mv) {\r\n                            getThis(mv,classInternalName,outerClassDescriptor,outerClassInternalName);\r\n                            mv.visitVarInsn(ALOAD, 1);\r\n                            mv.visitVarInsn(ALOAD, 2);\r\n                            mv.visitMethodInsn(INVOKEVIRTUAL, outerClassInternalName, \"this$dist$set$\" + objectDistance, \"(Ljava/lang/String;Ljava/lang/Object;)V\", false);\r\n                            mv.visitInsn(RETURN);\r\n                        }\r\n                    })\r\n            );\r\n        }\r\n        method.setCode(block);\r\n\r\n        // add property getter dispatcher\r\n        parameters = new Parameter[]{\r\n                new Parameter(ClassHelper.STRING_TYPE, \"name\")\r\n        };\r\n\r\n        methodName = \"propertyMissing\";\r\n        if (isStatic)\r\n            addCompilationErrorOnCustomMethodNode(node, methodName, parameters);\r\n\r\n        method = node.addSyntheticMethod(\r\n                methodName,\r\n                Opcodes.ACC_PUBLIC,\r\n                ClassHelper.OBJECT_TYPE,\r\n                parameters,\r\n                ClassNode.EMPTY_ARRAY,\r\n                null\r\n        );\r\n\r\n        block = new BlockStatement();\r\n        if (isStatic) {\r\n            setPropertyGetterDispatcher(block, new ClassExpression(node.getOuterClass()), parameters);\r\n        } else {\r\n            block.addStatement(\r\n                    new BytecodeSequence(new BytecodeInstruction() {\r\n                        public void visit(MethodVisitor mv) {\r\n                            getThis(mv,classInternalName,outerClassDescriptor,outerClassInternalName);\r\n                            mv.visitVarInsn(ALOAD, 1);\r\n                            mv.visitMethodInsn(INVOKEVIRTUAL, outerClassInternalName, \"this$dist$get$\" + objectDistance, \"(Ljava/lang/String;)Ljava/lang/Object;\", false);\r\n                            mv.visitInsn(ARETURN);\r\n                        }\r\n                    })\r\n            );\r\n        }\r\n        method.setCode(block);\r\n    }\r"
        ]
    ],
    "cfbd6d298bf76c00bb37ecc6839b044d393a4ebd": [
        [
            "ClassNodeUtils::addDeclaredMethodsFromInterfaces(ClassNode,Map)",
            "  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93 -\n  94  \n  95 -\n  96 -\n  97  \n  98  \n  99  \n 100  ",
            "    /**\n     * Add in methods from all interfaces. Existing entries in the methods map take precedence.\n     * Methods from interfaces visited early take precedence over later ones.\n     *\n     * @param cNode The ClassNode\n     * @param methodsMap A map of existing methods to alter\n     */\n    public static void addDeclaredMethodsFromInterfaces(ClassNode cNode, Map<String, MethodNode> methodsMap) {\n        // add in unimplemented abstract methods from the interfaces\n        for (ClassNode iface : cNode.getInterfaces()) {\n            Map<String, MethodNode> ifaceMethodsMap = iface.getDeclaredMethodsMap();\n            for (String methSig : ifaceMethodsMap.keySet()) {\n                if (!methodsMap.containsKey(methSig)) {\n                    MethodNode methNode = ifaceMethodsMap.get(methSig);\n                    methodsMap.put(methSig, methNode);\n                }\n            }\n        }\n    }",
            "  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93 +\n  94 +\n  95  \n  96 +\n  97  \n  98  \n  99  \n 100  ",
            "    /**\n     * Add in methods from all interfaces. Existing entries in the methods map take precedence.\n     * Methods from interfaces visited early take precedence over later ones.\n     *\n     * @param cNode The ClassNode\n     * @param methodsMap A map of existing methods to alter\n     */\n    public static void addDeclaredMethodsFromInterfaces(ClassNode cNode, Map<String, MethodNode> methodsMap) {\n        // add in unimplemented abstract methods from the interfaces\n        for (ClassNode iface : cNode.getInterfaces()) {\n            Map<String, MethodNode> ifaceMethodsMap = iface.getDeclaredMethodsMap();\n            for (Map.Entry<String, MethodNode> entry : ifaceMethodsMap.entrySet()) {\n                String methSig = entry.getKey();\n                if (!methodsMap.containsKey(methSig)) {\n                    methodsMap.put(methSig, entry.getValue());\n                }\n            }\n        }\n    }"
        ],
        [
            "Builder::Builder(Map)",
            "  32  \n  33 -\n  34 -\n  35 -\n  36 -\n  37 -\n  38 -\n  39 -\n  40 -\n  41  \n  42  ",
            "    public Builder(final Map namespaceMethodMap) {\n    final Iterator keyIterator = namespaceMethodMap.keySet().iterator();\n        \n        while (keyIterator.hasNext()) {\n        final Object key = keyIterator.next();\n        final List value = (List)namespaceMethodMap.get(key);\n        final Closure dg = ((Closure)value.get(1)).asWritable();\n        \n            this.namespaceMethodMap.put(key, new Object[]{value.get(0), dg, fettleMethodMap(dg, (Map)value.get(2))});\n        }\n    }",
            "  32  \n  33 +\n  34 +\n  35 +\n  36 +\n  37 +\n  38 +\n  39 +\n  40  \n  41  ",
            "    public Builder(final Map namespaceMethodMap) {\n        for (Object e : namespaceMethodMap.entrySet()) {\n            Map.Entry entry = (Map.Entry) e;\n            final Object key = entry.getKey();\n            final List value = (List) entry.getValue();\n            final Closure dg = ((Closure) value.get(1)).asWritable();\n\n            this.namespaceMethodMap.put(key, new Object[] { value.get(0), dg, fettleMethodMap(dg, (Map) value.get(2)) });\n        }\n    }"
        ],
        [
            "SimpleGroovyRootDoc::classNamed(GroovyClassDoc,String)",
            "  44  \n  45  \n  46 -\n  47 -\n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57 -\n  58  \n  59  \n  60  \n  61  \n  62  ",
            "    public GroovyClassDoc classNamed(GroovyClassDoc groovyClassDoc, String name) {\n        // look for full match or match excluding package\n        for (String key : classDocs.keySet()) {\n            if (key.equals(name)) return classDocs.get(key);\n            int lastSlashIdx = key.lastIndexOf('/');\n            if (lastSlashIdx > 0) {\n                String shortKey = key.substring(lastSlashIdx + 1);\n                String fullPathName = groovyClassDoc != null ? groovyClassDoc.getFullPathName() : null;\n\n                boolean hasPackage = (fullPathName != null && fullPathName.lastIndexOf('/') > 0);\n                if (hasPackage) fullPathName = fullPathName.substring(0, fullPathName.lastIndexOf('/'));\n\n                if (shortKey.equals(name) && (!hasPackage || key.startsWith(fullPathName))) {\n                    return classDocs.get(key);\n                }\n            }\n        }\n        return null;\n    }",
            "  44  \n  45  \n  46 +\n  47 +\n  48 +\n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58 +\n  59  \n  60  \n  61  \n  62  \n  63  ",
            "    public GroovyClassDoc classNamed(GroovyClassDoc groovyClassDoc, String name) {\n        // look for full match or match excluding package\n        for (Map.Entry<String, GroovyClassDoc> entry : classDocs.entrySet()) {\n            String key = entry.getKey();\n            if (key.equals(name)) return entry.getValue();\n            int lastSlashIdx = key.lastIndexOf('/');\n            if (lastSlashIdx > 0) {\n                String shortKey = key.substring(lastSlashIdx + 1);\n                String fullPathName = groovyClassDoc != null ? groovyClassDoc.getFullPathName() : null;\n\n                boolean hasPackage = (fullPathName != null && fullPathName.lastIndexOf('/') > 0);\n                if (hasPackage) fullPathName = fullPathName.substring(0, fullPathName.lastIndexOf('/'));\n\n                if (shortKey.equals(name) && (!hasPackage || key.startsWith(fullPathName))) {\n                    return entry.getValue();\n                }\n            }\n        }\n        return null;\n    }"
        ],
        [
            "SimpleGroovyRootDoc::getVisibleClasses(List)",
            " 121  \n 122  \n 123 -\n 124  \n 125  \n 126  \n 127 -\n 128  \n 129  \n 130  \n 131  \n 132  ",
            "    public Map<String, GroovyClassDoc> getVisibleClasses(List importedClassesAndPackages) {\n        Map<String, GroovyClassDoc> visibleClasses = new LinkedHashMap<String, GroovyClassDoc>();\n        for (String fullClassName : classDocs.keySet()) {\n            String equivalentPackageImport = fullClassName.replaceAll(\"[^/]+$\", \"*\");\n            if (importedClassesAndPackages.contains(fullClassName) ||\n                    importedClassesAndPackages.contains(equivalentPackageImport)) {\n                GroovyClassDoc classDoc = classDocs.get(fullClassName);\n                visibleClasses.put(classDoc.name(), classDoc);\n            }\n        }\n        return visibleClasses;\n    }",
            " 123  \n 124  \n 125 +\n 126 +\n 127  \n 128  \n 129  \n 130 +\n 131  \n 132  \n 133  \n 134  \n 135  ",
            "    public Map<String, GroovyClassDoc> getVisibleClasses(List importedClassesAndPackages) {\n        Map<String, GroovyClassDoc> visibleClasses = new LinkedHashMap<String, GroovyClassDoc>();\n        for (Map.Entry<String, GroovyClassDoc> entry : classDocs.entrySet()) {\n            String fullClassName = entry.getKey();\n            String equivalentPackageImport = fullClassName.replaceAll(\"[^/]+$\", \"*\");\n            if (importedClassesAndPackages.contains(fullClassName) ||\n                    importedClassesAndPackages.contains(equivalentPackageImport)) {\n                GroovyClassDoc classDoc = entry.getValue();\n                visibleClasses.put(classDoc.name(), classDoc);\n            }\n        }\n        return visibleClasses;\n    }"
        ],
        [
            "JavaStubGenerator::printAnnotation(PrintWriter,AnnotationNode)",
            " 847  \n 848  \n 849  \n 850  \n 851 -\n 852  \n 853  \n 854 -\n 855  \n 856  \n 857  ",
            "    private void printAnnotation(PrintWriter out, AnnotationNode annotation) {\n        out.print(\"@\" + annotation.getClassNode().getName().replace('$', '.') + \"(\");\n        boolean first = true;\n        Map<String, Expression> members = annotation.getMembers();\n        for (String key : members.keySet()) {\n            if (first) first = false;\n            else out.print(\", \");\n            out.print(key + \"=\" + getAnnotationValue(members.get(key)).replace('$', '.'));\n        }\n        out.print(\") \");\n    }",
            " 847  \n 848  \n 849  \n 850  \n 851 +\n 852 +\n 853  \n 854  \n 855 +\n 856  \n 857  \n 858  ",
            "    private void printAnnotation(PrintWriter out, AnnotationNode annotation) {\n        out.print(\"@\" + annotation.getClassNode().getName().replace('$', '.') + \"(\");\n        boolean first = true;\n        Map<String, Expression> members = annotation.getMembers();\n        for (Map.Entry<String, Expression> entry : members.entrySet()) {\n            String key = entry.getKey();\n            if (first) first = false;\n            else out.print(\", \");\n            out.print(key + \"=\" + getAnnotationValue(entry.getValue()).replace('$', '.'));\n        }\n        out.print(\") \");\n    }"
        ],
        [
            "ASTTransformationCollectorCodeVisitor::deleteExisting(boolean,Map,List)",
            " 145  \n 146  \n 147 -\n 148 -\n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  ",
            "    private static void deleteExisting(boolean mergeParams, Map<Integer, List<AnnotationNode>> existingMap, List<AnnotationNode> replacements) {\n        for (AnnotationNode replacement : replacements) {\n            for (Integer key : existingMap.keySet()) {\n                List<AnnotationNode> annotationNodes = new ArrayList<AnnotationNode>(existingMap.get(key));\n                Iterator<AnnotationNode> iterator = annotationNodes.iterator();\n                while (iterator.hasNext()) {\n                    AnnotationNode existing = iterator.next();\n                    if (replacement.getClassNode().getName().equals(existing.getClassNode().getName())) {\n                        if (mergeParams) {\n                            mergeParameters(replacement, existing);\n                        }\n                        iterator.remove();\n                    }\n                }\n                existingMap.put(key, annotationNodes);\n            }\n        }\n    }",
            " 145  \n 146  \n 147 +\n 148 +\n 149 +\n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  ",
            "    private static void deleteExisting(boolean mergeParams, Map<Integer, List<AnnotationNode>> existingMap, List<AnnotationNode> replacements) {\n        for (AnnotationNode replacement : replacements) {\n            for (Map.Entry<Integer, List<AnnotationNode>> entry : existingMap.entrySet()) {\n                Integer key = entry.getKey();\n                List<AnnotationNode> annotationNodes = new ArrayList<AnnotationNode>(entry.getValue());\n                Iterator<AnnotationNode> iterator = annotationNodes.iterator();\n                while (iterator.hasNext()) {\n                    AnnotationNode existing = iterator.next();\n                    if (replacement.getClassNode().getName().equals(existing.getClassNode().getName())) {\n                        if (mergeParams) {\n                            mergeParameters(replacement, existing);\n                        }\n                        iterator.remove();\n                    }\n                }\n                existingMap.put(key, annotationNodes);\n            }\n        }\n    }"
        ],
        [
            "SimpleGroovyRootDoc::classNamedExact(String)",
            "  64  \n  65 -\n  66 -\n  67  \n  68  \n  69  ",
            "    public GroovyClassDoc classNamedExact(String name) {\n        for (String key : classDocs.keySet()) {\n            if (key.equals(name)) return classDocs.get(key);\n        }\n        return null;\n    }",
            "  65  \n  66 +\n  67 +\n  68 +\n  69  \n  70  \n  71  ",
            "    public GroovyClassDoc classNamedExact(String name) {\n        for (Map.Entry<String, GroovyClassDoc> entry : classDocs.entrySet()) {\n            String key = entry.getKey();\n            if (key.equals(name)) return entry.getValue();\n        }\n        return null;\n    }"
        ],
        [
            "AntProjectPropertiesDelegate::putAll(Map)",
            " 102  \n 103 -\n 104 -\n 105 -\n 106 -\n 107 -\n 108  \n 109  ",
            "    public synchronized void putAll(Map t) {\n        Set keySet = t.keySet();\n        for (Iterator iterator = keySet.iterator(); iterator.hasNext();) {\n            Object key = iterator.next();\n            Object value = t.get(key);\n            put(key, value);\n        }\n    }",
            " 102  \n 103 +\n 104 +\n 105 +\n 106  \n 107  ",
            "    public synchronized void putAll(Map t) {\n        for (Object e : t.entrySet()) {\n            Map.Entry entry = (Map.Entry) e;\n            put(entry.getKey(), entry.getValue());\n        }\n    }"
        ]
    ],
    "1f0b5e9bd459e81c198b1d98228090ff4a2606df": [
        [
            "VariableScopeVisitor::visitConstructorCallExpression(ConstructorCallExpression)",
            " 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564  \n 565  \n 566  \n 567  \n 568  \n 569  \n 570  \n 571  \n 572  \n 573  \n 574  \n 575  \n 576  \n 577  \n 578  \n 579  \n 580  ",
            "    public void visitConstructorCallExpression(ConstructorCallExpression call) {\n        isSpecialConstructorCall = call.isSpecialCall();\n        super.visitConstructorCallExpression(call);\n        isSpecialConstructorCall = false;\n        if (!call.isUsingAnonymousInnerClass()) return;\n\n        pushState();\n        InnerClassNode innerClass = (InnerClassNode) call.getType();\n        innerClass.setVariableScope(currentScope);\n        for (MethodNode method : innerClass.getMethods()) {\n            Parameter[] parameters = method.getParameters();\n            if (parameters.length == 0) parameters = null; // null means no implicit \"it\"\n            ClosureExpression cl = new ClosureExpression(parameters, method.getCode());\n            visitClosureExpression(cl);\n        }\n\n        for (FieldNode field : innerClass.getFields()) {\n            final Expression expression = field.getInitialExpression();\n            pushState(field.isStatic());\n            if (expression != null) {\n                if (expression instanceof VariableExpression) {\n                    VariableExpression vexp = (VariableExpression) expression;\n                    if (vexp.getAccessedVariable() instanceof Parameter) {\n                        // workaround for GROOVY-6834: accessing a parameter which is not yet seen in scope\n                        continue;\n                    }\n                }\n                expression.visit(this);\n            }\n            popState();\n        }\n\n        for (Statement statement : innerClass.getObjectInitializerStatements()) {\n            statement.visit(this);\n        }\n        markClosureSharedVariables();\n        popState();\n    }",
            " 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564  \n 565  \n 566  \n 567 +\n 568  \n 569  \n 570  \n 571  \n 572  \n 573  \n 574  \n 575  \n 576  \n 577  \n 578  \n 579  \n 580  \n 581  ",
            "    public void visitConstructorCallExpression(ConstructorCallExpression call) {\n        isSpecialConstructorCall = call.isSpecialCall();\n        super.visitConstructorCallExpression(call);\n        isSpecialConstructorCall = false;\n        if (!call.isUsingAnonymousInnerClass()) return;\n\n        pushState();\n        InnerClassNode innerClass = (InnerClassNode) call.getType();\n        innerClass.setVariableScope(currentScope);\n        for (MethodNode method : innerClass.getMethods()) {\n            Parameter[] parameters = method.getParameters();\n            if (parameters.length == 0) parameters = null; // null means no implicit \"it\"\n            ClosureExpression cl = new ClosureExpression(parameters, method.getCode());\n            visitClosureExpression(cl);\n        }\n\n        for (FieldNode field : innerClass.getFields()) {\n            final Expression expression = field.getInitialExpression();\n            pushState(field.isStatic());\n            if (expression != null) {\n                if (expression instanceof VariableExpression) {\n                    VariableExpression vexp = (VariableExpression) expression;\n                    if (vexp.getAccessedVariable() instanceof Parameter) {\n                        // workaround for GROOVY-6834: accessing a parameter which is not yet seen in scope\n                        popState();\n                        continue;\n                    }\n                }\n                expression.visit(this);\n            }\n            popState();\n        }\n\n        for (Statement statement : innerClass.getObjectInitializerStatements()) {\n            statement.visit(this);\n        }\n        markClosureSharedVariables();\n        popState();\n    }"
        ]
    ],
    "d8731a7f9ed0f6d9e6c123f371ef0aca1f5a231f": [
        [
            "StaticTypesCallSiteWriter::isDirectAccessAllowed(FieldNode,ClassNode,boolean)",
            " 633 -\n 634 -\n 635  \n 636  \n 637 -\n 638  \n 639 -\n 640 -\n 641 -\n 642 -\n 643  \n 644  \n 645  \n 646 -\n 647 -\n 648  ",
            "    private static boolean isDirectAccessAllowed(FieldNode a, ClassNode receiver, boolean isSamePackage) {\n        ClassNode declaringClass = a.getDeclaringClass().redirect();\n        ClassNode receiverType = receiver.redirect();\n\n        // first, direct access from within the class or inner class nodes\n        if (declaringClass.equals(receiverType)) return true;\n        if (receiverType instanceof InnerClassNode) {\n            while (receiverType instanceof InnerClassNode) {\n                if (declaringClass.equals(receiverType)) return true;\n                receiverType = receiverType.getOuterClass();\n            }\n        }\n\n        // no getter\n        return a.isPublic() || (a.isProtected() && isSamePackage);\n    }",
            " 633 +\n 634 +\n 635  \n 636  \n 637 +\n 638  \n 639 +\n 640 +\n 641 +\n 642 +\n 643 +\n 644 +\n 645 +\n 646  \n 647 +\n 648  \n 649  \n 650 +\n 651 +\n 652  ",
            "    private static boolean isDirectAccessAllowed(FieldNode field, ClassNode receiver, boolean isSamePackage) {\n        ClassNode declaringClass = field.getDeclaringClass().redirect();\n        ClassNode receiverType = receiver.redirect();\n\n        // first, direct access from within the class\n        if (declaringClass.equals(receiverType)) return true;\n        if (field.isPrivate()) return false;\n\n        // now, inner class node access to outer class fields\n        receiverType = receiverType.getOuterClass();\n        while (receiverType != null) {\n            if (declaringClass.equals(receiverType)) {\n                return true;\n            }\n            receiverType = receiverType.getOuterClass();\n        }\n\n        // finally public and inherited\n        return field.isPublic() || isSamePackage;\n    }"
        ]
    ],
    "c32cc5a012f524dad2c292579ba727fe10d9406b": [
        [
            "DefaultStrategy::buildClass(BuilderASTTransformation,ClassNode,AnnotationNode)",
            " 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203 -\n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  ",
            "    public void buildClass(BuilderASTTransformation transform, ClassNode buildee, AnnotationNode anno) {\n        List<String> excludes = new ArrayList<String>();\n        List<String> includes = new ArrayList<String>();\n        includes.add(Undefined.STRING);\n        if (!getIncludeExclude(transform, anno, buildee, excludes, includes)) return;\n        if (includes.size() == 1 && Undefined.isUndefined(includes.get(0))) includes = null;\n        ClassNode builder = createBuilder(anno, buildee);\n        markAsGenerated(buildee, builder);\n        createBuilderFactoryMethod(anno, buildee, builder);\n//        List<FieldNode> fields = getFields(transform, anno, buildee);\n        boolean allNames = transform.memberHasValue(anno, \"allNames\", true);\n        boolean allProperties = !transform.memberHasValue(anno, \"allProperties\", false);\n        List<PropertyInfo> props = getPropertyInfos(transform, anno, buildee, excludes, includes, allNames, allProperties);\n        for (PropertyInfo pi : props) {\n            ClassNode correctedType = getCorrectedType(buildee, pi.getType(), builder);\n            String fieldName = pi.getName();\n            builder.addField(createFieldCopy(buildee, fieldName, correctedType));\n            addGeneratedMethod(builder, createBuilderMethodForProp(builder, new PropertyInfo(fieldName, correctedType), getPrefix(anno)));\n        }\n        addGeneratedMethod(builder, createBuildMethod(anno, buildee, props));\n    }",
            " 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  ",
            "    public void buildClass(BuilderASTTransformation transform, ClassNode buildee, AnnotationNode anno) {\n        List<String> excludes = new ArrayList<String>();\n        List<String> includes = new ArrayList<String>();\n        includes.add(Undefined.STRING);\n        if (!getIncludeExclude(transform, anno, buildee, excludes, includes)) return;\n        if (includes.size() == 1 && Undefined.isUndefined(includes.get(0))) includes = null;\n        ClassNode builder = createBuilder(anno, buildee);\n        createBuilderFactoryMethod(anno, buildee, builder);\n//        List<FieldNode> fields = getFields(transform, anno, buildee);\n        boolean allNames = transform.memberHasValue(anno, \"allNames\", true);\n        boolean allProperties = !transform.memberHasValue(anno, \"allProperties\", false);\n        List<PropertyInfo> props = getPropertyInfos(transform, anno, buildee, excludes, includes, allNames, allProperties);\n        for (PropertyInfo pi : props) {\n            ClassNode correctedType = getCorrectedType(buildee, pi.getType(), builder);\n            String fieldName = pi.getName();\n            builder.addField(createFieldCopy(buildee, fieldName, correctedType));\n            addGeneratedMethod(builder, createBuilderMethodForProp(builder, new PropertyInfo(fieldName, correctedType), getPrefix(anno)));\n        }\n        addGeneratedMethod(builder, createBuildMethod(anno, buildee, props));\n    }"
        ],
        [
            "InitializerStrategy::buildCommon(ClassNode,AnnotationNode,List,ClassNode)",
            " 213  \n 214  \n 215  \n 216  \n 217 -\n 218  \n 219 -\n 220  \n 221 -\n 222  \n 223 -\n 224  ",
            "    private void buildCommon(ClassNode buildee, AnnotationNode anno, List<FieldNode> fieldNodes, ClassNode builder) {\n        String prefix = getMemberStringValue(anno, \"prefix\", \"\");\n        String buildMethodName = getMemberStringValue(anno, \"buildMethodName\", \"create\");\n        createBuilderConstructors(builder, buildee, fieldNodes);\n        buildee.getModule().addClass(builder);\n        String builderMethodName = getMemberStringValue(anno, \"builderMethodName\", \"createInitializer\");\n        buildee.addMethod(createBuilderMethod(buildMethodName, builder, fieldNodes.size(), builderMethodName));\n        for (int i = 0; i < fieldNodes.size(); i++) {\n            builder.addMethod(createBuilderMethodForField(builder, fieldNodes, prefix, i));\n        }\n        builder.addMethod(createBuildMethod(builder, buildMethodName, fieldNodes));\n    }",
            " 214  \n 215  \n 216  \n 217 +\n 218  \n 219  \n 220 +\n 221  \n 222 +\n 223  \n 224 +\n 225  ",
            "    private void buildCommon(ClassNode buildee, AnnotationNode anno, List<FieldNode> fieldNodes, ClassNode builder) {\n        String prefix = getMemberStringValue(anno, \"prefix\", \"\");\n        String buildMethodName = getMemberStringValue(anno, \"buildMethodName\", \"create\");\n        addGeneratedInnerClass(buildee, builder);\n        createBuilderConstructors(builder, buildee, fieldNodes);\n        String builderMethodName = getMemberStringValue(anno, \"builderMethodName\", \"createInitializer\");\n        addGeneratedMethod(buildee, createBuilderMethod(buildMethodName, builder, fieldNodes.size(), builderMethodName));\n        for (int i = 0; i < fieldNodes.size(); i++) {\n            addGeneratedMethod(builder, createBuilderMethodForField(builder, fieldNodes, prefix, i));\n        }\n        addGeneratedMethod(builder, createBuildMethod(builder, buildMethodName, fieldNodes));\n    }"
        ],
        [
            "InitializerStrategy::createBuildeeConstructors(BuilderASTTransformation,ClassNode,ClassNode,List,boolean,boolean)",
            " 280  \n 281 -\n 282 -\n 283  \n 284  \n 285  \n 286  \n 287 -\n 288 -\n 289  \n 290  ",
            "    private static void createBuildeeConstructors(BuilderASTTransformation transform, ClassNode buildee, ClassNode builder, List<FieldNode> fields, boolean needsConstructor, boolean useSetters) {\n        ConstructorNode initializer = createInitializerConstructor(buildee, builder, fields);\n        markAsGenerated(buildee, initializer);\n        if (needsConstructor) {\n            final BlockStatement body = new BlockStatement();\n            body.addStatement(ctorSuperS());\n            initializeFields(fields, body, useSetters);\n            ConstructorNode helperCons = buildee.addConstructor(ACC_PRIVATE | ACC_SYNTHETIC, getParams(fields, buildee), NO_EXCEPTIONS, body);\n            markAsGenerated(buildee, helperCons);\n        }\n    }",
            " 281  \n 282 +\n 283  \n 284  \n 285  \n 286  \n 287 +\n 288  \n 289  ",
            "    private static void createBuildeeConstructors(BuilderASTTransformation transform, ClassNode buildee, ClassNode builder, List<FieldNode> fields, boolean needsConstructor, boolean useSetters) {\n        createInitializerConstructor(buildee, builder, fields);\n        if (needsConstructor) {\n            final BlockStatement body = new BlockStatement();\n            body.addStatement(ctorSuperS());\n            initializeFields(fields, body, useSetters);\n            addGeneratedConstructor(buildee, ACC_PRIVATE | ACC_SYNTHETIC, getParams(fields, buildee), NO_EXCEPTIONS, body);\n        }\n    }"
        ],
        [
            "InitializerStrategy::createBuilderConstructors(ClassNode,ClassNode,List)",
            " 272  \n 273 -\n 274  \n 275  \n 276  \n 277 -\n 278  ",
            "    private static void createBuilderConstructors(ClassNode builder, ClassNode buildee, List<FieldNode> fields) {\n        builder.addConstructor(ACC_PRIVATE, NO_PARAMS, NO_EXCEPTIONS, block(ctorSuperS()));\n        final BlockStatement body = new BlockStatement();\n        body.addStatement(ctorSuperS());\n        initializeFields(fields, body, false);\n        builder.addConstructor(ACC_PRIVATE, getParams(fields, buildee), NO_EXCEPTIONS, body);\n    }",
            " 273  \n 274 +\n 275  \n 276  \n 277  \n 278 +\n 279  ",
            "    private static void createBuilderConstructors(ClassNode builder, ClassNode buildee, List<FieldNode> fields) {\n        addGeneratedConstructor(builder, ACC_PRIVATE, NO_PARAMS, NO_EXCEPTIONS, block(ctorSuperS()));\n        final BlockStatement body = new BlockStatement();\n        body.addStatement(ctorSuperS());\n        initializeFields(fields, body, false);\n        addGeneratedConstructor(builder, ACC_PRIVATE, getParams(fields, buildee), NO_EXCEPTIONS, body);\n    }"
        ],
        [
            "DefaultStrategy::buildMethod(BuilderASTTransformation,MethodNode,AnnotationNode)",
            " 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187 -\n 188  \n 189  \n 190  \n 191 -\n 192  \n 193 -\n 194  ",
            "    public void buildMethod(BuilderASTTransformation transform, MethodNode mNode, AnnotationNode anno) {\n        if (transform.getMemberValue(anno, \"includes\") != null || transform.getMemberValue(anno, \"excludes\") != null) {\n            transform.addError(\"Error during \" + BuilderASTTransformation.MY_TYPE_NAME +\n                    \" processing: includes/excludes only allowed on classes\", anno);\n        }\n        ClassNode buildee = mNode.getDeclaringClass();\n        ClassNode builder = createBuilder(anno, buildee);\n        markAsGenerated(buildee, builder);\n        createBuilderFactoryMethod(anno, buildee, builder);\n        for (Parameter parameter : mNode.getParameters()) {\n            builder.addField(createFieldCopy(buildee, parameter));\n            builder.addMethod(createBuilderMethodForProp(builder, new PropertyInfo(parameter.getName(), parameter.getType()), getPrefix(anno)));\n        }\n        addGeneratedMethod(buildee, createBuildMethodForMethod(anno, buildee, mNode, mNode.getParameters()));\n    }",
            " 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190 +\n 191  \n 192 +\n 193  ",
            "    public void buildMethod(BuilderASTTransformation transform, MethodNode mNode, AnnotationNode anno) {\n        if (transform.getMemberValue(anno, \"includes\") != null || transform.getMemberValue(anno, \"excludes\") != null) {\n            transform.addError(\"Error during \" + BuilderASTTransformation.MY_TYPE_NAME +\n                    \" processing: includes/excludes only allowed on classes\", anno);\n        }\n        ClassNode buildee = mNode.getDeclaringClass();\n        ClassNode builder = createBuilder(anno, buildee);\n        createBuilderFactoryMethod(anno, buildee, builder);\n        for (Parameter parameter : mNode.getParameters()) {\n            builder.addField(createFieldCopy(buildee, parameter));\n            addGeneratedMethod(builder, createBuilderMethodForProp(builder, new PropertyInfo(parameter.getName(), parameter.getType()), getPrefix(anno)));\n        }\n        addGeneratedMethod(builder, createBuildMethodForMethod(anno, buildee, mNode, mNode.getParameters()));\n    }"
        ],
        [
            "InitializerStrategy::createInitializerConstructor(ClassNode,ClassNode,List)",
            " 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330 -\n 331  ",
            "    private static ConstructorNode createInitializerConstructor(ClassNode buildee, ClassNode builder, List<FieldNode> fields) {\n        ClassNode paramType = makeClassSafeWithGenerics(builder, setGenTypes(fields.size()));\n        List<Expression> argsList = new ArrayList<Expression>();\n        Parameter initParam = param(paramType, \"initializer\");\n        for (FieldNode fieldNode : fields) {\n            argsList.add(propX(varX(initParam), fieldNode.getName()));\n        }\n        return buildee.addConstructor(ACC_PUBLIC, params(param(paramType, \"initializer\")), NO_EXCEPTIONS, block(ctorThisS(args(argsList))));\n    }",
            " 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329 +\n 330  ",
            "    private static ConstructorNode createInitializerConstructor(ClassNode buildee, ClassNode builder, List<FieldNode> fields) {\n        ClassNode paramType = makeClassSafeWithGenerics(builder, setGenTypes(fields.size()));\n        List<Expression> argsList = new ArrayList<Expression>();\n        Parameter initParam = param(paramType, \"initializer\");\n        for (FieldNode fieldNode : fields) {\n            argsList.add(propX(varX(initParam), fieldNode.getName()));\n        }\n        return addGeneratedConstructor(buildee, ACC_PUBLIC, params(param(paramType, \"initializer\")), NO_EXCEPTIONS, block(ctorThisS(args(argsList))));\n    }"
        ],
        [
            "DefaultStrategy::createBuilderFactoryMethod(AnnotationNode,ClassNode,ClassNode)",
            " 224  \n 225 -\n 226  \n 227  ",
            "    private static void createBuilderFactoryMethod(AnnotationNode anno, ClassNode buildee, ClassNode builder) {\n        buildee.getModule().addClass(builder);\n        addGeneratedMethod(buildee, createBuilderMethod(anno, builder));\n    }",
            " 222  \n 223 +\n 224  \n 225  ",
            "    private static void createBuilderFactoryMethod(AnnotationNode anno, ClassNode buildee, ClassNode builder) {\n        addGeneratedInnerClass(buildee, builder);\n        addGeneratedMethod(buildee, createBuilderMethod(anno, builder));\n    }"
        ],
        [
            "InitializerStrategy::createBuildeeMethods(ClassNode,MethodNode,ClassNode,List)",
            " 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300 -\n 301  \n 302  \n 303  ",
            "    private static void createBuildeeMethods(ClassNode buildee, MethodNode mNode, ClassNode builder, List<FieldNode> fields) {\n        ClassNode paramType = makeClassSafeWithGenerics(builder, setGenTypes(fields.size()));\n        List<Expression> argsList = new ArrayList<Expression>();\n        Parameter initParam = param(paramType, \"initializer\");\n        for (FieldNode fieldNode : fields) {\n            argsList.add(propX(varX(initParam), fieldNode.getName()));\n        }\n        String newName = \"$\" + mNode.getName(); // can't have private and public methods of the same name, so rename original\n        buildee.addMethod(mNode.getName(), PUBLIC_STATIC, mNode.getReturnType(), params(param(paramType, \"initializer\")), NO_EXCEPTIONS,\n                block(stmt(callX(buildee, newName, args(argsList)))));\n        renameMethod(buildee, mNode, newName);\n    }",
            " 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299 +\n 300  \n 301  \n 302  ",
            "    private static void createBuildeeMethods(ClassNode buildee, MethodNode mNode, ClassNode builder, List<FieldNode> fields) {\n        ClassNode paramType = makeClassSafeWithGenerics(builder, setGenTypes(fields.size()));\n        List<Expression> argsList = new ArrayList<Expression>();\n        Parameter initParam = param(paramType, \"initializer\");\n        for (FieldNode fieldNode : fields) {\n            argsList.add(propX(varX(initParam), fieldNode.getName()));\n        }\n        String newName = \"$\" + mNode.getName(); // can't have private and public methods of the same name, so rename original\n        addGeneratedMethod(buildee, mNode.getName(), PUBLIC_STATIC, mNode.getReturnType(), params(param(paramType, \"initializer\")), NO_EXCEPTIONS,\n                block(stmt(callX(buildee, newName, args(argsList)))));\n        renameMethod(buildee, mNode, newName);\n    }"
        ],
        [
            "ExternalStrategy::build(BuilderASTTransformation,AnnotatedNode,AnnotationNode)",
            "  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108 -\n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  ",
            "    public void build(BuilderASTTransformation transform, AnnotatedNode annotatedNode, AnnotationNode anno) {\n        if (!(annotatedNode instanceof ClassNode)) {\n            transform.addError(\"Error during \" + BuilderASTTransformation.MY_TYPE_NAME + \" processing: building for \" +\n                    annotatedNode.getClass().getSimpleName() + \" not supported by \" + getClass().getSimpleName(), annotatedNode);\n            return;\n        }\n        ClassNode builder = (ClassNode) annotatedNode;\n        String prefix = transform.getMemberStringValue(anno, \"prefix\", \"\");\n        ClassNode buildee = transform.getMemberClassValue(anno, \"forClass\");\n        if (buildee == null) {\n            transform.addError(\"Error during \" + MY_TYPE_NAME + \" processing: 'forClass' must be specified for \" + getClass().getName(), anno);\n            return;\n        }\n        markAsGenerated(buildee, builder);\n        List<String> excludes = new ArrayList<String>();\n        List<String> includes = new ArrayList<String>();\n        includes.add(Undefined.STRING);\n        if (!getIncludeExclude(transform, anno, buildee, excludes, includes)) return;\n        if (includes.size() == 1 && Undefined.isUndefined(includes.get(0))) includes = null;\n        if (unsupportedAttribute(transform, anno, \"builderClassName\")) return;\n        if (unsupportedAttribute(transform, anno, \"builderMethodName\")) return;\n        if (unsupportedAttribute(transform, anno, \"force\")) return;\n        boolean allNames = transform.memberHasValue(anno, \"allNames\", true);\n        boolean allProperties = !transform.memberHasValue(anno, \"allProperties\", false);\n        List<PropertyInfo> props = getPropertyInfos(transform, anno, buildee, excludes, includes, allNames, allProperties);\n        if (includes != null) {\n            for (String name : includes) {\n                checkKnownProperty(transform, anno, name, props);\n            }\n        }\n        for (PropertyInfo prop : props) {\n            builder.addField(createFieldCopy(builder, prop));\n            addGeneratedMethod(builder, createBuilderMethodForField(builder, prop, prefix));\n        }\n        addGeneratedMethod(builder, createBuildMethod(transform, anno, buildee, props));\n    }",
            "  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  ",
            "    public void build(BuilderASTTransformation transform, AnnotatedNode annotatedNode, AnnotationNode anno) {\n        if (!(annotatedNode instanceof ClassNode)) {\n            transform.addError(\"Error during \" + BuilderASTTransformation.MY_TYPE_NAME + \" processing: building for \" +\n                    annotatedNode.getClass().getSimpleName() + \" not supported by \" + getClass().getSimpleName(), annotatedNode);\n            return;\n        }\n        ClassNode builder = (ClassNode) annotatedNode;\n        String prefix = transform.getMemberStringValue(anno, \"prefix\", \"\");\n        ClassNode buildee = transform.getMemberClassValue(anno, \"forClass\");\n        if (buildee == null) {\n            transform.addError(\"Error during \" + MY_TYPE_NAME + \" processing: 'forClass' must be specified for \" + getClass().getName(), anno);\n            return;\n        }\n        List<String> excludes = new ArrayList<String>();\n        List<String> includes = new ArrayList<String>();\n        includes.add(Undefined.STRING);\n        if (!getIncludeExclude(transform, anno, buildee, excludes, includes)) return;\n        if (includes.size() == 1 && Undefined.isUndefined(includes.get(0))) includes = null;\n        if (unsupportedAttribute(transform, anno, \"builderClassName\")) return;\n        if (unsupportedAttribute(transform, anno, \"builderMethodName\")) return;\n        if (unsupportedAttribute(transform, anno, \"force\")) return;\n        boolean allNames = transform.memberHasValue(anno, \"allNames\", true);\n        boolean allProperties = !transform.memberHasValue(anno, \"allProperties\", false);\n        List<PropertyInfo> props = getPropertyInfos(transform, anno, buildee, excludes, includes, allNames, allProperties);\n        if (includes != null) {\n            for (String name : includes) {\n                checkKnownProperty(transform, anno, name, props);\n            }\n        }\n        for (PropertyInfo prop : props) {\n            builder.addField(createFieldCopy(builder, prop));\n            addGeneratedMethod(builder, createBuilderMethodForField(builder, prop, prefix));\n        }\n        addGeneratedMethod(builder, createBuildMethod(transform, anno, buildee, props));\n    }"
        ]
    ]
}