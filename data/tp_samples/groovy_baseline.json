{
    "c88d057ed364470703f017bafed18d106f088f0f": [
        [
            "GenericsUtils::correctToGenericsSpecRecurse(Map,ClassNode)",
            " 286  \n 287  \n 288 -\n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  ",
            "    public static ClassNode correctToGenericsSpecRecurse(Map genericsSpec, ClassNode type) {\n        if (type.isGenericsPlaceHolder()) {\n            String name = type.getGenericsTypes()[0].getName();\n            type = (ClassNode) genericsSpec.get(name);\n        }\n        if (type == null) type = ClassHelper.OBJECT_TYPE;\n        GenericsType[] oldgTypes = type.getGenericsTypes();\n        GenericsType[] newgTypes = new GenericsType[0];\n        if (oldgTypes != null) {\n            newgTypes = new GenericsType[oldgTypes.length];\n            for (int i = 0; i < newgTypes.length; i++) {\n                GenericsType oldgType = oldgTypes[i];\n                if (oldgType.isPlaceholder() ) {\n                    if (genericsSpec.get(oldgType.getName())!=null) {\n                        newgTypes[i] = new GenericsType((ClassNode) genericsSpec.get(oldgType.getName()));\n                    } else {\n                        newgTypes[i] = new GenericsType(ClassHelper.OBJECT_TYPE);\n                    }\n                } else if (oldgType.isWildcard()) {\n                    ClassNode oldLower = oldgType.getLowerBound();\n                    ClassNode lower = oldLower!=null?correctToGenericsSpecRecurse(genericsSpec, oldLower):null;\n                    ClassNode[] oldUpper = oldgType.getUpperBounds();\n                    ClassNode[] upper = null;\n                    if (oldUpper!=null) {\n                        upper = new ClassNode[oldUpper.length];\n                        for (int j = 0; j < oldUpper.length; j++) {\n                            upper[j] = correctToGenericsSpecRecurse(genericsSpec,oldUpper[j]);\n                        }\n                    }\n                    GenericsType fixed = new GenericsType(oldgType.getType(), upper, lower);\n                    fixed.setWildcard(true);\n                    newgTypes[i] = fixed;\n                } else {\n                    newgTypes[i] = new GenericsType(correctToGenericsSpec(genericsSpec, oldgType));\n                }\n            }\n        }\n        return makeClassSafeWithGenerics(type, newgTypes);\n    }",
            " 286  \n 287  \n 288 +\n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  ",
            "    public static ClassNode correctToGenericsSpecRecurse(Map genericsSpec, ClassNode type) {\n        if (type.isGenericsPlaceHolder()) {\n            String name = type.getUnresolvedName();\n            type = (ClassNode) genericsSpec.get(name);\n        }\n        if (type == null) type = ClassHelper.OBJECT_TYPE;\n        GenericsType[] oldgTypes = type.getGenericsTypes();\n        GenericsType[] newgTypes = new GenericsType[0];\n        if (oldgTypes != null) {\n            newgTypes = new GenericsType[oldgTypes.length];\n            for (int i = 0; i < newgTypes.length; i++) {\n                GenericsType oldgType = oldgTypes[i];\n                if (oldgType.isPlaceholder() ) {\n                    if (genericsSpec.get(oldgType.getName())!=null) {\n                        newgTypes[i] = new GenericsType((ClassNode) genericsSpec.get(oldgType.getName()));\n                    } else {\n                        newgTypes[i] = new GenericsType(ClassHelper.OBJECT_TYPE);\n                    }\n                } else if (oldgType.isWildcard()) {\n                    ClassNode oldLower = oldgType.getLowerBound();\n                    ClassNode lower = oldLower!=null?correctToGenericsSpecRecurse(genericsSpec, oldLower):null;\n                    ClassNode[] oldUpper = oldgType.getUpperBounds();\n                    ClassNode[] upper = null;\n                    if (oldUpper!=null) {\n                        upper = new ClassNode[oldUpper.length];\n                        for (int j = 0; j < oldUpper.length; j++) {\n                            upper[j] = correctToGenericsSpecRecurse(genericsSpec,oldUpper[j]);\n                        }\n                    }\n                    GenericsType fixed = new GenericsType(oldgType.getType(), upper, lower);\n                    fixed.setWildcard(true);\n                    newgTypes[i] = fixed;\n                } else {\n                    newgTypes[i] = new GenericsType(correctToGenericsSpec(genericsSpec, oldgType));\n                }\n            }\n        }\n        return makeClassSafeWithGenerics(type, newgTypes);\n    }"
        ],
        [
            "Traits::collectAllInterfacesReverseOrder(ClassNode,LinkedHashSet)",
            " 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270 -\n 271  \n 272  \n 273  \n 274  ",
            "    /**\n     * Collects all interfaces of a class node, but reverses the order of the declaration of direct interfaces\n     * of this class node. This is used to make sure a trait implementing A,B where both A and B have the same\n     * method will take the method from B (latest), aligning the behavior with categories.\n     * @param cNode a class node\n     * @param interfaces ordered set of interfaces\n     */\n    public static LinkedHashSet<ClassNode> collectAllInterfacesReverseOrder(ClassNode cNode, LinkedHashSet<ClassNode> interfaces) {\n        if (cNode.isInterface())\n            interfaces.add(cNode);\n\n        ClassNode[] directInterfaces = cNode.getInterfaces();\n        for (int i = directInterfaces.length-1; i >=0 ; i--) {\n            final ClassNode anInterface = directInterfaces[i];\n            interfaces.add(anInterface);\n            collectAllInterfacesReverseOrder(anInterface, interfaces);\n        }\n        return interfaces;\n    }",
            " 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271 +\n 272  \n 273  \n 274  \n 275  ",
            "    /**\n     * Collects all interfaces of a class node, but reverses the order of the declaration of direct interfaces\n     * of this class node. This is used to make sure a trait implementing A,B where both A and B have the same\n     * method will take the method from B (latest), aligning the behavior with categories.\n     * @param cNode a class node\n     * @param interfaces ordered set of interfaces\n     */\n    public static LinkedHashSet<ClassNode> collectAllInterfacesReverseOrder(ClassNode cNode, LinkedHashSet<ClassNode> interfaces) {\n        if (cNode.isInterface())\n            interfaces.add(cNode);\n\n        ClassNode[] directInterfaces = cNode.getInterfaces();\n        for (int i = directInterfaces.length-1; i >=0 ; i--) {\n            final ClassNode anInterface = directInterfaces[i];\n            interfaces.add(GenericsUtils.parameterizeType(cNode,anInterface));\n            collectAllInterfacesReverseOrder(anInterface, interfaces);\n        }\n        return interfaces;\n    }"
        ]
    ],
    "1f0b5e9bd459e81c198b1d98228090ff4a2606df": [
        [
            "VariableScopeVisitor::visitConstructorCallExpression(ConstructorCallExpression)",
            " 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564  \n 565  \n 566  \n 567  \n 568  \n 569  \n 570  \n 571  \n 572  \n 573  \n 574  \n 575  \n 576  \n 577  \n 578  \n 579  \n 580  ",
            "    public void visitConstructorCallExpression(ConstructorCallExpression call) {\n        isSpecialConstructorCall = call.isSpecialCall();\n        super.visitConstructorCallExpression(call);\n        isSpecialConstructorCall = false;\n        if (!call.isUsingAnonymousInnerClass()) return;\n\n        pushState();\n        InnerClassNode innerClass = (InnerClassNode) call.getType();\n        innerClass.setVariableScope(currentScope);\n        for (MethodNode method : innerClass.getMethods()) {\n            Parameter[] parameters = method.getParameters();\n            if (parameters.length == 0) parameters = null; // null means no implicit \"it\"\n            ClosureExpression cl = new ClosureExpression(parameters, method.getCode());\n            visitClosureExpression(cl);\n        }\n\n        for (FieldNode field : innerClass.getFields()) {\n            final Expression expression = field.getInitialExpression();\n            pushState(field.isStatic());\n            if (expression != null) {\n                if (expression instanceof VariableExpression) {\n                    VariableExpression vexp = (VariableExpression) expression;\n                    if (vexp.getAccessedVariable() instanceof Parameter) {\n                        // workaround for GROOVY-6834: accessing a parameter which is not yet seen in scope\n                        continue;\n                    }\n                }\n                expression.visit(this);\n            }\n            popState();\n        }\n\n        for (Statement statement : innerClass.getObjectInitializerStatements()) {\n            statement.visit(this);\n        }\n        markClosureSharedVariables();\n        popState();\n    }",
            " 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564  \n 565  \n 566  \n 567 +\n 568  \n 569  \n 570  \n 571  \n 572  \n 573  \n 574  \n 575  \n 576  \n 577  \n 578  \n 579  \n 580  \n 581  ",
            "    public void visitConstructorCallExpression(ConstructorCallExpression call) {\n        isSpecialConstructorCall = call.isSpecialCall();\n        super.visitConstructorCallExpression(call);\n        isSpecialConstructorCall = false;\n        if (!call.isUsingAnonymousInnerClass()) return;\n\n        pushState();\n        InnerClassNode innerClass = (InnerClassNode) call.getType();\n        innerClass.setVariableScope(currentScope);\n        for (MethodNode method : innerClass.getMethods()) {\n            Parameter[] parameters = method.getParameters();\n            if (parameters.length == 0) parameters = null; // null means no implicit \"it\"\n            ClosureExpression cl = new ClosureExpression(parameters, method.getCode());\n            visitClosureExpression(cl);\n        }\n\n        for (FieldNode field : innerClass.getFields()) {\n            final Expression expression = field.getInitialExpression();\n            pushState(field.isStatic());\n            if (expression != null) {\n                if (expression instanceof VariableExpression) {\n                    VariableExpression vexp = (VariableExpression) expression;\n                    if (vexp.getAccessedVariable() instanceof Parameter) {\n                        // workaround for GROOVY-6834: accessing a parameter which is not yet seen in scope\n                        popState();\n                        continue;\n                    }\n                }\n                expression.visit(this);\n            }\n            popState();\n        }\n\n        for (Statement statement : innerClass.getObjectInitializerStatements()) {\n            statement.visit(this);\n        }\n        markClosureSharedVariables();\n        popState();\n    }"
        ]
    ],
    "510ea5ea16ee59f5ea191745b7c62ed7bf27a790": [
        [
            "ExternalizeMethodsASTTransformation::createReadExternal(ClassNode,List,List)",
            "  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101 -\n 102 -\n 103  \n 104  \n 105  ",
            "    private void createReadExternal(ClassNode cNode, List<String> excludes, List<FieldNode> list) {\n        final BlockStatement body = new BlockStatement();\n        Parameter oin = param(OBJECTINPUT_TYPE, \"oin\");\n        for (FieldNode fNode : list) {\n            if (excludes.contains(fNode.getName())) continue;\n            if ((fNode.getModifiers() & ACC_TRANSIENT) != 0) continue;\n            Expression readObject = callX(varX(oin), \"read\" + suffixForField(fNode));\n            body.addStatement(assignS(varX(fNode), castX(fNode.getType(), readObject)));\n        }\n        cNode.addMethod(\"readExternal\", ACC_PUBLIC, ClassHelper.VOID_TYPE, params(oin), ClassNode.EMPTY_ARRAY, body);\n    }",
            "  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102 +\n 103 +\n 104 +\n 105  \n 106  \n 107  ",
            "    private void createReadExternal(ClassNode cNode, List<String> excludes, List<FieldNode> list) {\n        final BlockStatement body = new BlockStatement();\n        Parameter oin = param(OBJECTINPUT_TYPE, \"oin\");\n        for (FieldNode fNode : list) {\n            if (excludes.contains(fNode.getName())) continue;\n            if ((fNode.getModifiers() & ACC_TRANSIENT) != 0) continue;\n            String suffix = suffixForField(fNode);\n            Expression readObject = callX(varX(oin), \"read\" + suffix);\n            body.addStatement(assignS(varX(fNode), suffix.equals(\"Object\") ? castX(GenericsUtils.nonGeneric(fNode.getType()), readObject) : readObject));\n        }\n        cNode.addMethod(\"readExternal\", ACC_PUBLIC, ClassHelper.VOID_TYPE, params(oin), ClassNode.EMPTY_ARRAY, body);\n    }"
        ]
    ],
    "df58d08a86194aef8427b30ffbf1053647ee413b": [
        [
            "DefaultTypeTransformation::continueCastOnCollection(Object,Class)",
            " 230  \n 231  \n 232  \n 233 -\n 234 -\n 235 -\n 236  \n 237  \n 238  \n 239  \n 240 -\n 241 -\n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  ",
            "    private static Object continueCastOnCollection(Object object, Class type) {\n        int modifiers = type.getModifiers();\n        Collection answer;\n        if (object instanceof Collection && type.isAssignableFrom(HashSet.class) &&\n                (type == HashSet.class || Modifier.isAbstract(modifiers) || Modifier.isInterface(modifiers))) {\n            return new HashSet((Collection)object);\n        }\n        if (object.getClass().isArray()) {\n            if (type.isAssignableFrom(ArrayList.class) && (Modifier.isAbstract(modifiers) || Modifier.isInterface(modifiers))) {\n                answer = new ArrayList();\n            } else if (type.isAssignableFrom(HashSet.class) && (Modifier.isAbstract(modifiers) || Modifier.isInterface(modifiers))) {\n                answer = new HashSet();\n            } else {\n                // let's call the collections constructor\n                // passing in the list wrapper\n                try {\n                    answer = (Collection) type.newInstance();\n                }\n                catch (Exception e) {\n                   throw new GroovyCastException(\"Could not instantiate instance of: \" + type.getName() + \". Reason: \" + e);\n                }\n            }\n\n            // we cannot just wrap in a List as we support primitive type arrays\n            int length = Array.getLength(object);\n            for (int i = 0; i < length; i++) {\n                Object element = Array.get(object, i);\n                answer.add(element);\n            }\n            return answer;\n        }\n\n        return continueCastOnNumber(object,type);\n    }",
            " 230  \n 231  \n 232  \n 233 +\n 234 +\n 235 +\n 236  \n 237  \n 238  \n 239  \n 240 +\n 241 +\n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  ",
            "    private static Object continueCastOnCollection(Object object, Class type) {\n        int modifiers = type.getModifiers();\n        Collection answer;\n        if (object instanceof Collection && type.isAssignableFrom(LinkedHashSet.class) &&\n                (type == LinkedHashSet.class || Modifier.isAbstract(modifiers) || Modifier.isInterface(modifiers))) {\n            return new LinkedHashSet((Collection)object);\n        }\n        if (object.getClass().isArray()) {\n            if (type.isAssignableFrom(ArrayList.class) && (Modifier.isAbstract(modifiers) || Modifier.isInterface(modifiers))) {\n                answer = new ArrayList();\n            } else if (type.isAssignableFrom(LinkedHashSet.class) && (Modifier.isAbstract(modifiers) || Modifier.isInterface(modifiers))) {\n                answer = new LinkedHashSet();\n            } else {\n                // let's call the collections constructor\n                // passing in the list wrapper\n                try {\n                    answer = (Collection) type.newInstance();\n                }\n                catch (Exception e) {\n                   throw new GroovyCastException(\"Could not instantiate instance of: \" + type.getName() + \". Reason: \" + e);\n                }\n            }\n\n            // we cannot just wrap in a List as we support primitive type arrays\n            int length = Array.getLength(object);\n            for (int i = 0; i < length; i++) {\n                Object element = Array.get(object, i);\n                answer.add(element);\n            }\n            return answer;\n        }\n\n        return continueCastOnNumber(object,type);\n    }"
        ]
    ],
    "17a8eb3858a42f99ad6ef00ba5e2d6ac7e39d3ec": [
        [
            "ReadWriteLockASTTransformation::visit(ASTNode,SourceUnit)",
            "  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87 -\n  88  \n  89 -\n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  ",
            "    public void visit(ASTNode[] nodes, SourceUnit source) {\n        init(nodes, source);\n        AnnotatedNode parent = (AnnotatedNode) nodes[1];\n        AnnotationNode node = (AnnotationNode) nodes[0];\n        final boolean isWriteLock;\n        if (READ_LOCK_TYPE.equals(node.getClassNode())) {\n            isWriteLock = false;\n        } else if (WRITE_LOCK_TYPE.equals(node.getClassNode())) {\n            isWriteLock = true;\n        } else {\n            throw new GroovyBugError(\"Internal error: expecting [\" + READ_LOCK_TYPE.getName() + \", \" + WRITE_LOCK_TYPE.getName() + \"]\" + \" but got: \" + node.getClassNode().getName());\n        }\n\n        String myTypeName = \"@\" + node.getClassNode().getNameWithoutPackage();\n\n        String value = getMemberStringValue(node, \"value\");\n\n        if (parent instanceof MethodNode) {\n            MethodNode mNode = (MethodNode) parent;\n            ClassNode cNode = mNode.getDeclaringClass();\n            String lockExpr = determineLock(value, cNode, mNode.isStatic(), myTypeName);\n            if (lockExpr == null) return;\n\n            // get lock type\n            final Expression lockType;\n            if (isWriteLock) {\n                lockType = callX(varX(lockExpr), \"writeLock\");\n            } else {\n                lockType = callX(varX(lockExpr), \"readLock\");\n            }\n\n            Expression acquireLock = callX(lockType, \"lock\");\n            Expression releaseLock = callX(lockType, \"unlock\");\n            Statement originalCode = mNode.getCode();\n\n            mNode.setCode(block(\n                    stmt(acquireLock),\n                    new TryCatchStatement(originalCode, stmt(releaseLock))));\n        }\n    }",
            "  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87 +\n  88  \n  89 +\n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  ",
            "    public void visit(ASTNode[] nodes, SourceUnit source) {\n        init(nodes, source);\n        AnnotatedNode parent = (AnnotatedNode) nodes[1];\n        AnnotationNode node = (AnnotationNode) nodes[0];\n        final boolean isWriteLock;\n        if (READ_LOCK_TYPE.equals(node.getClassNode())) {\n            isWriteLock = false;\n        } else if (WRITE_LOCK_TYPE.equals(node.getClassNode())) {\n            isWriteLock = true;\n        } else {\n            throw new GroovyBugError(\"Internal error: expecting [\" + READ_LOCK_TYPE.getName() + \", \" + WRITE_LOCK_TYPE.getName() + \"]\" + \" but got: \" + node.getClassNode().getName());\n        }\n\n        String myTypeName = \"@\" + node.getClassNode().getNameWithoutPackage();\n\n        String value = getMemberStringValue(node, \"value\");\n\n        if (parent instanceof MethodNode) {\n            MethodNode mNode = (MethodNode) parent;\n            ClassNode cNode = mNode.getDeclaringClass();\n            String lockExpr = determineLock(value, cNode, mNode.isStatic(), myTypeName);\n            if (lockExpr == null) return;\n\n            // get lock type\n            final Expression lockType;\n            if (isWriteLock) {\n                lockType = callX(varX(lockExpr, LOCK_TYPE), \"writeLock\");\n            } else {\n                lockType = callX(varX(lockExpr, LOCK_TYPE), \"readLock\");\n            }\n\n            Expression acquireLock = callX(lockType, \"lock\");\n            Expression releaseLock = callX(lockType, \"unlock\");\n            Statement originalCode = mNode.getCode();\n\n            mNode.setCode(block(\n                    stmt(acquireLock),\n                    new TryCatchStatement(originalCode, stmt(releaseLock))));\n        }\n    }"
        ]
    ],
    "aa6a3c064ceb07fd26c41842aa891bf939c21413": [
        [
            "GenericsUtils::parameterizeType(ClassNode,ClassNode)",
            " 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191 -\n 192 -\n 193 -\n 194 -\n 195 -\n 196 -\n 197 -\n 198 -\n 199 -\n 200 -\n 201 -\n 202 -\n 203 -\n 204 -\n 205 -\n 206 -\n 207 -\n 208  \n 209  \n 210 -\n 211 -\n 212 -\n 213 -\n 214  \n 215 -\n 216 -\n 217 -\n 218 -\n 219 -\n 220 -\n 221 -\n 222 -\n 223 -\n 224 -\n 225 -\n 226 -\n 227 -\n 228 -\n 229 -\n 230 -\n 231 -\n 232 -\n 233 -\n 234 -\n 235 -\n 236  ",
            "    /**\n     * Interface class nodes retrieved from {@link org.codehaus.groovy.ast.ClassNode#getInterfaces()}\n     * or {@link org.codehaus.groovy.ast.ClassNode#getAllInterfaces()} are returned with generic type\n     * arguments. This method allows returning a parameterized interface given the parameterized class\n     * node which implements this interface.\n     * @param hint the class node where generics types are parameterized\n     * @param target the interface we want to parameterize generics types\n     * @return a parameterized interface class node\n     */\n    public static ClassNode parameterizeType(final ClassNode hint, final ClassNode target) {\n        if (hint.isArray() && target.isArray()) {\n            return parameterizeType(hint.getComponentType(), target.getComponentType()).makeArray();\n        }\n        ClassNode interfaceFromClassNode = null;\n        if (hint.equals(target)) interfaceFromClassNode = hint;\n        if (ClassHelper.OBJECT_TYPE.equals(target) && target.isUsingGenerics() && target.getGenericsTypes()!=null\n                && target.getGenericsTypes()[0].isPlaceholder()) {\n            // Object<T>\n            return ClassHelper.getWrapper(hint);\n        }\n        if (interfaceFromClassNode==null) {\n            ClassNode[] interfaces = hint.getInterfaces();\n            for (ClassNode node : interfaces) {\n                if (node.equals(target)) {\n                    interfaceFromClassNode = node;\n                    break;\n                } else if (node.implementsInterface(target)) {\n                    // ex: classNode = LinkedList<A> , node=List<E> , anInterface = Iterable<T>\n                    return parameterizeType(parameterizeType(hint, node), target);\n                }\n            }\n        }\n        if (interfaceFromClassNode==null && hint.getUnresolvedSuperClass()!=null) {\n            return parameterizeType(hint.getUnresolvedSuperClass(), target);\n        }\n        if (interfaceFromClassNode==null) {\n\n//            return target;\n            interfaceFromClassNode = hint;\n        }\n        Map<String,GenericsType> parameters = new HashMap<String, GenericsType>();\n        extractPlaceholders(hint, parameters);\n        ClassNode node = target.getPlainNodeReference();\n        GenericsType[] interfaceGTs = interfaceFromClassNode.getGenericsTypes();\n        if (interfaceGTs==null) return target;\n        GenericsType[] types = new GenericsType[interfaceGTs.length];\n        for (int i = 0; i < interfaceGTs.length; i++) {\n            GenericsType interfaceGT = interfaceGTs[i];\n            types[i] = interfaceGT;\n            if (interfaceGT.isPlaceholder()) {\n                String name = interfaceGT.getName();\n                if (parameters.containsKey(name)) {\n                    types[i] = parameters.get(name);\n                }\n            }\n        }\n        node.setGenericsTypes(types);\n        return node;\n    }",
            " 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194 +\n 195 +\n 196 +\n 197 +\n 198 +\n 199 +\n 200 +\n 201  \n 202  \n 203 +\n 204 +\n 205 +\n 206 +\n 207 +\n 208  \n 209  ",
            "    /**\n     * Interface class nodes retrieved from {@link org.codehaus.groovy.ast.ClassNode#getInterfaces()}\n     * or {@link org.codehaus.groovy.ast.ClassNode#getAllInterfaces()} are returned with generic type\n     * arguments. This method allows returning a parameterized interface given the parameterized class\n     * node which implements this interface.\n     * @param hint the class node where generics types are parameterized\n     * @param target the interface we want to parameterize generics types\n     * @return a parameterized interface class node\n     */\n    public static ClassNode parameterizeType(final ClassNode hint, final ClassNode target) {\n        if (hint.isArray() && target.isArray()) {\n            return parameterizeType(hint.getComponentType(), target.getComponentType()).makeArray();\n        }\n        if (!target.equals(hint) && StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(target, hint)) {\n            ClassNode nextSuperClass = ClassHelper.getNextSuperClass(target, hint);\n            if (!hint.equals(nextSuperClass)) {\n                Map<String, ClassNode> genericsSpec = createGenericsSpec(hint);\n                extractSuperClassGenerics(hint, nextSuperClass, genericsSpec);\n                ClassNode result = correctToGenericsSpecRecurse(genericsSpec, nextSuperClass);\n                return parameterizeType(result, target);\n            }\n        }\n        Map<String, ClassNode> genericsSpec = createGenericsSpec(hint);\n        ClassNode targetRedirect = target.redirect();\n        genericsSpec = createGenericsSpec(targetRedirect, genericsSpec);\n        extractSuperClassGenerics(hint, targetRedirect, genericsSpec);\n        return correctToGenericsSpecRecurse(genericsSpec, targetRedirect);\n\n    }"
        ]
    ],
    "e2b1e727e70dc97bcf3d29993ff320e2fa80af69": [
        [
            "JavaStubGenerator::printMethods(PrintWriter,ClassNode,boolean)",
            " 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  ",
            "    private void printMethods(PrintWriter out, ClassNode classNode, boolean isEnum) {\n        if (!isEnum) printConstructors(out, classNode);\n\n        @SuppressWarnings(\"unchecked\")\n        List<MethodNode> methods = (List) propertyMethods.clone();\n        methods.addAll(classNode.getMethods());\n        for (MethodNode method : methods) {\n            if (isEnum && method.isSynthetic()) {\n                // skip values() method and valueOf(String)\n                String name = method.getName();\n                Parameter[] params = method.getParameters();\n                if (name.equals(\"values\") && params.length == 0) continue;\n                if (name.equals(\"valueOf\") &&\n                        params.length == 1 &&\n                        params[0].getType().equals(ClassHelper.STRING_TYPE)) {\n                    continue;\n                }\n            }\n            printMethod(out, classNode, method);\n        }\n    }",
            " 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283 +\n 284 +\n 285 +\n 286 +\n 287 +\n 288 +\n 289 +\n 290 +\n 291 +\n 292 +\n 293 +\n 294 +\n 295 +\n 296  ",
            "    private void printMethods(PrintWriter out, ClassNode classNode, boolean isEnum) {\n        if (!isEnum) printConstructors(out, classNode);\n\n        @SuppressWarnings(\"unchecked\")\n        List<MethodNode> methods = (List) propertyMethods.clone();\n        methods.addAll(classNode.getMethods());\n        for (MethodNode method : methods) {\n            if (isEnum && method.isSynthetic()) {\n                // skip values() method and valueOf(String)\n                String name = method.getName();\n                Parameter[] params = method.getParameters();\n                if (name.equals(\"values\") && params.length == 0) continue;\n                if (name.equals(\"valueOf\") &&\n                        params.length == 1 &&\n                        params[0].getType().equals(ClassHelper.STRING_TYPE)) {\n                    continue;\n                }\n            }\n            printMethod(out, classNode, method);\n        }\n\n        for (ClassNode node : classNode.getInterfaces()) {\n            if (Traits.isTrait(node)) {\n                List<MethodNode> traitMethods = node.getMethods();\n                for (MethodNode traitMethod : traitMethods) {\n                    MethodNode method = classNode.getMethod(traitMethod.getName(), traitMethod.getParameters());\n                    if (method == null) {\n                        printMethod(out, classNode, traitMethod);\n                    }\n                }\n            }\n        }\n\n    }"
        ]
    ],
    "297f90d9da1b6c1a1b416d8ed17bc32de6dabb03": [
        [
            "StaticTypesCallSiteWriter::makeGetField(Expression,ClassNode,String,boolean,boolean,boolean)",
            " 487  \n 488  \n 489  \n 490  \n 491  \n 492  \n 493  \n 494  \n 495  \n 496  \n 497  \n 498  \n 499  \n 500  \n 501  \n 502  \n 503  \n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512  \n 513  \n 514  \n 515  \n 516  \n 517  \n 518  \n 519  \n 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528  \n 529  \n 530  \n 531  \n 532  \n 533  \n 534  \n 535  ",
            "    boolean makeGetField(final Expression receiver, final ClassNode receiverType, final String fieldName, final boolean safe, final boolean implicitThis, final boolean samePackage) {\n        FieldNode field = receiverType.getField(fieldName);\n        // direct access is allowed if we are in the same class as the declaring class\n        // or we are in an inner class\n        if (field !=null \n                && isDirectAccessAllowed(field, controller.getClassNode(), samePackage)) {\n            CompileStack compileStack = controller.getCompileStack();\n            MethodVisitor mv = controller.getMethodVisitor();\n            ClassNode replacementType = field.getOriginType();\n            OperandStack operandStack = controller.getOperandStack();\n            if (field.isStatic()) {\n                mv.visitFieldInsn(GETSTATIC, BytecodeHelper.getClassInternalName(field.getOwner()), fieldName, BytecodeHelper.getTypeDescription(replacementType));\n                operandStack.push(replacementType);\n            } else {\n                if (implicitThis) {\n                    compileStack.pushImplicitThis(implicitThis);\n                }\n                receiver.visit(controller.getAcg());\n                if (implicitThis) compileStack.popImplicitThis();\n                Label exit = new Label();\n                if (safe) {\n                    mv.visitInsn(DUP);\n                    Label doGet = new Label();\n                    mv.visitJumpInsn(IFNONNULL, doGet);\n                    mv.visitJumpInsn(GOTO, exit);\n                    mv.visitLabel(doGet);\n                }\n                if (!operandStack.getTopOperand().isDerivedFrom(field.getOwner())) {\n                    mv.visitTypeInsn(CHECKCAST, BytecodeHelper.getClassInternalName(field.getOwner()));\n                }\n                mv.visitFieldInsn(GETFIELD, BytecodeHelper.getClassInternalName(field.getOwner()), fieldName, BytecodeHelper.getTypeDescription(replacementType));\n                if (safe) {\n                    if (ClassHelper.isPrimitiveType(replacementType)) {\n                        operandStack.replace(replacementType);\n                        operandStack.box();\n                        replacementType = operandStack.getTopOperand();\n                    }\n                    mv.visitLabel(exit);\n                }\n            }\n            operandStack.replace(replacementType);\n            return true;\n        }\n        ClassNode superClass = receiverType.getSuperClass();\n        if (superClass !=null) {\n            return makeGetField(receiver, superClass, fieldName, safe, implicitThis, false);\n        }\n        return false;\n    }",
            " 487  \n 488  \n 489  \n 490  \n 491  \n 492  \n 493  \n 494  \n 495  \n 496  \n 497  \n 498  \n 499  \n 500  \n 501  \n 502  \n 503  \n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512  \n 513  \n 514  \n 515  \n 516  \n 517  \n 518  \n 519  \n 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528  \n 529  \n 530 +\n 531 +\n 532 +\n 533 +\n 534 +\n 535 +\n 536 +\n 537 +\n 538  \n 539  \n 540  \n 541  \n 542  \n 543  ",
            "    boolean makeGetField(final Expression receiver, final ClassNode receiverType, final String fieldName, final boolean safe, final boolean implicitThis, final boolean samePackage) {\n        FieldNode field = receiverType.getField(fieldName);\n        // direct access is allowed if we are in the same class as the declaring class\n        // or we are in an inner class\n        if (field !=null \n                && isDirectAccessAllowed(field, controller.getClassNode(), samePackage)) {\n            CompileStack compileStack = controller.getCompileStack();\n            MethodVisitor mv = controller.getMethodVisitor();\n            ClassNode replacementType = field.getOriginType();\n            OperandStack operandStack = controller.getOperandStack();\n            if (field.isStatic()) {\n                mv.visitFieldInsn(GETSTATIC, BytecodeHelper.getClassInternalName(field.getOwner()), fieldName, BytecodeHelper.getTypeDescription(replacementType));\n                operandStack.push(replacementType);\n            } else {\n                if (implicitThis) {\n                    compileStack.pushImplicitThis(implicitThis);\n                }\n                receiver.visit(controller.getAcg());\n                if (implicitThis) compileStack.popImplicitThis();\n                Label exit = new Label();\n                if (safe) {\n                    mv.visitInsn(DUP);\n                    Label doGet = new Label();\n                    mv.visitJumpInsn(IFNONNULL, doGet);\n                    mv.visitJumpInsn(GOTO, exit);\n                    mv.visitLabel(doGet);\n                }\n                if (!operandStack.getTopOperand().isDerivedFrom(field.getOwner())) {\n                    mv.visitTypeInsn(CHECKCAST, BytecodeHelper.getClassInternalName(field.getOwner()));\n                }\n                mv.visitFieldInsn(GETFIELD, BytecodeHelper.getClassInternalName(field.getOwner()), fieldName, BytecodeHelper.getTypeDescription(replacementType));\n                if (safe) {\n                    if (ClassHelper.isPrimitiveType(replacementType)) {\n                        operandStack.replace(replacementType);\n                        operandStack.box();\n                        replacementType = operandStack.getTopOperand();\n                    }\n                    mv.visitLabel(exit);\n                }\n            }\n            operandStack.replace(replacementType);\n            return true;\n        }\n\n        for (ClassNode intf : receiverType.getInterfaces()) {\n            // GROOVY-7039\n            if (intf!=receiverType && makeGetField(receiver, intf, fieldName, safe, implicitThis, false)) {\n                return true;\n            }\n        }\n\n        ClassNode superClass = receiverType.getSuperClass();\n        if (superClass !=null) {\n            return makeGetField(receiver, superClass, fieldName, safe, implicitThis, false);\n        }\n        return false;\n    }"
        ]
    ],
    "ca1f7ab61e7ca273e3ff07835f58e1f4fab88446": [
        [
            "ResolveVisitor::resolveNestedClass(ClassNode)",
            " 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291 -\n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300 -\n 301  \n 302  \n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332 -\n 333 -\n 334 -\n 335  ",
            "    private boolean resolveNestedClass(ClassNode type) {\n        // we have for example a class name A, are in class X\n        // and there is a nested class A$X. we want to be able \n        // to access that class directly, so A becomes a valid\n        // name in X.\n        // GROOVY-4043: Do this check up the hierarchy, if needed\n        Map<String, ClassNode> hierClasses = new LinkedHashMap<String, ClassNode>();\n        ClassNode val;\n        String name;\n        for(ClassNode classToCheck = currentClass; classToCheck != ClassHelper.OBJECT_TYPE; \n            classToCheck = classToCheck.getSuperClass()) {\n            if(classToCheck == null || hierClasses.containsKey(classToCheck.getName())) break;\n            hierClasses.put(classToCheck.getName(), classToCheck);\n        }\n        \n        for (ClassNode classToCheck : hierClasses.values()) {\n            name = classToCheck.getName()+\"$\"+type.getName();\n            val = ClassHelper.make(name);\n            if (resolveFromCompileUnit(val)) {\n                type.setRedirect(val);\n                return true;\n            }\n        }\n        \n        // another case we want to check here is if we are in a\n        // nested class A$B$C and want to access B without\n        // qualifying it by A.B. A alone will work, since that\n        // is the qualified (minus package) name of that class\n        // anyway. \n        \n        // That means if the current class is not an InnerClassNode\n        // there is nothing to be done.\n        if (!(currentClass instanceof InnerClassNode)) return false;\n        \n        // since we have B and want to get A we start with the most \n        // outer class, put them together and then see if that does\n        // already exist. In case of B from within A$B we are done \n        // after the first step already. In case of for example\n        // A.B.C.D.E.F and accessing E from F we test A$E=failed, \n        // A$B$E=failed, A$B$C$E=fail, A$B$C$D$E=success\n        \n        LinkedList<ClassNode> outerClasses = new LinkedList<ClassNode>();\n        ClassNode outer = currentClass.getOuterClass();\n        while (outer!=null) {\n            outerClasses.addFirst(outer);\n            outer = outer.getOuterClass();\n        }\n        // most outer class is now element 0\n        for (ClassNode testNode : outerClasses) {\n            name = testNode.getName()+\"$\"+type.getName();\n            val = ClassHelper.make(name);\n            if (resolveFromCompileUnit(val)) {\n                type.setRedirect(val);\n                return true;\n            }\n        }        \n        \n        return false;   \n    }",
            " 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291 +\n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299 +\n 300 +\n 301 +\n 302 +\n 303 +\n 304 +\n 305 +\n 306 +\n 307 +\n 308 +\n 309  \n 310 +\n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342 +\n 343 +\n 344 +\n 345 +\n 346 +\n 347 +\n 348 +\n 349 +\n 350 +\n 351 +\n 352 +\n 353 +\n 354 +\n 355  ",
            "    private boolean resolveNestedClass(ClassNode type) {\n        // we have for example a class name A, are in class X\n        // and there is a nested class A$X. we want to be able \n        // to access that class directly, so A becomes a valid\n        // name in X.\n        // GROOVY-4043: Do this check up the hierarchy, if needed\n        Map<String, ClassNode> hierClasses = new LinkedHashMap<String, ClassNode>();\n        ClassNode val;\n        String name;\n        for(ClassNode classToCheck = currentClass; classToCheck != ClassHelper.OBJECT_TYPE; \n            classToCheck = classToCheck.getSuperClass()) {\n            if(classToCheck == null || hierClasses.containsKey(classToCheck.getName())) break;\n            hierClasses.put(classToCheck.getName(), classToCheck);\n        }\n\n        for (ClassNode classToCheck : hierClasses.values()) {\n            name = classToCheck.getName()+\"$\"+type.getName();\n            val = ClassHelper.make(name);\n            if (resolveFromCompileUnit(val)) {\n                type.setRedirect(val);\n                return true;\n            }\n            // also check interfaces in case we have interfaces with nested classes\n            for (ClassNode next : classToCheck.getAllInterfaces()) {\n                if (type.getName().contains(next.getName())) continue;\n                name = next.getName()+\"$\"+type.getName();\n                val = ClassHelper.make(name);\n                if (resolve(val, false, false, false)) {\n                    type.setRedirect(val);\n                    return true;\n                }\n            }\n        }\n\n        // another case we want to check here is if we are in a\n        // nested class A$B$C and want to access B without\n        // qualifying it by A.B. A alone will work, since that\n        // is the qualified (minus package) name of that class\n        // anyway. \n        \n        // That means if the current class is not an InnerClassNode\n        // there is nothing to be done.\n        if (!(currentClass instanceof InnerClassNode)) return false;\n        \n        // since we have B and want to get A we start with the most \n        // outer class, put them together and then see if that does\n        // already exist. In case of B from within A$B we are done \n        // after the first step already. In case of for example\n        // A.B.C.D.E.F and accessing E from F we test A$E=failed, \n        // A$B$E=failed, A$B$C$E=fail, A$B$C$D$E=success\n        \n        LinkedList<ClassNode> outerClasses = new LinkedList<ClassNode>();\n        ClassNode outer = currentClass.getOuterClass();\n        while (outer!=null) {\n            outerClasses.addFirst(outer);\n            outer = outer.getOuterClass();\n        }\n        // most outer class is now element 0\n        for (ClassNode testNode : outerClasses) {\n            name = testNode.getName()+\"$\"+type.getName();\n            val = ClassHelper.make(name);\n            if (resolveFromCompileUnit(val)) {\n                type.setRedirect(val);\n                return true;\n            }\n            // also check interfaces in case we have interfaces with nested classes\n            for (ClassNode next : testNode.getAllInterfaces()) {\n                if (type.getName().contains(next.getName())) continue;\n                name = next.getName()+\"$\"+type.getName();\n                val = ClassHelper.make(name);\n                if (resolve(val, false, false, false)) {\n                    type.setRedirect(val);\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }"
        ]
    ],
    "0991152f5918fb51b8dc375e4681d766bd88ceec": [
        [
            "TraitReceiverTransformer::transform(Expression)",
            "  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104 -\n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  ",
            "    @Override\n    public Expression transform(final Expression exp) {\n        ClassNode weavedType = weaved.getOriginType();\n        if (exp instanceof BinaryExpression) {\n            Expression leftExpression = ((BinaryExpression) exp).getLeftExpression();\n            Expression rightExpression = ((BinaryExpression) exp).getRightExpression();\n            Token operation = ((BinaryExpression) exp).getOperation();\n            if (operation.getText().equals(\"=\")) {\n                String leftFieldName = null;\n                // it's an assignment\n                if (leftExpression instanceof VariableExpression && ((VariableExpression) leftExpression).getAccessedVariable() instanceof FieldNode) {\n                    leftFieldName = ((VariableExpression) leftExpression).getAccessedVariable().getName();\n                } else if (leftExpression instanceof FieldExpression) {\n                    leftFieldName = ((FieldExpression) leftExpression).getFieldName();\n                } else if (leftExpression instanceof PropertyExpression\n                        && (((PropertyExpression) leftExpression).isImplicitThis() || \"this\".equals(((PropertyExpression) leftExpression).getObjectExpression().getText()))) {\n                    leftFieldName = ((PropertyExpression) leftExpression).getPropertyAsString();\n                    FieldNode fn = weavedType.getDeclaredField(leftFieldName);\n\n                    if (fieldHelper == null || fn==null && !fieldHelper.hasPossibleMethod(Traits.helperSetterName(new FieldNode(leftFieldName, 0, ClassHelper.OBJECT_TYPE, weavedType, null)), rightExpression)) {\n                        return new BinaryExpression(\n                                new PropertyExpression(\n                                        new VariableExpression(weaved),\n                                        leftFieldName\n                                ),\n                                operation,\n                                transform(rightExpression));\n                    }\n                }\n                if (leftFieldName!=null) {\n                    FieldNode fn = weavedType.getDeclaredField(leftFieldName);\n                    if (fn==null) {\n                        fn = new FieldNode(leftFieldName, 0, ClassHelper.OBJECT_TYPE, weavedType, null);\n                    }\n                    Expression receiver = createFieldHelperReceiver();\n                    if (fn.isStatic()) {\n                        receiver = new PropertyExpression(receiver, \"class\");\n                    }\n                    String method = Traits.helperSetterName(fn);\n                    MethodCallExpression mce = new MethodCallExpression(\n                            receiver,\n                            method,\n                            new ArgumentListExpression(super.transform(rightExpression))\n                    );\n                    mce.setSourcePosition(exp);\n                    mce.setImplicitThis(false);\n                    return mce;\n                }\n            }\n            Expression leftTransform = transform(leftExpression);\n            Expression rightTransform = transform(rightExpression);\n            Expression ret =\n                    exp instanceof DeclarationExpression ?new DeclarationExpression(\n                            leftTransform, operation, rightTransform\n                    ):\n                    new BinaryExpression(leftTransform, operation, rightTransform);\n            ret.setSourcePosition(exp);\n            ret.copyNodeMetaData(exp);\n            return ret;\n        } else if (exp instanceof StaticMethodCallExpression) {\n            StaticMethodCallExpression call = (StaticMethodCallExpression) exp;\n            ClassNode ownerType = call.getOwnerType();\n            if (traitClass.equals(ownerType)) {\n                MethodCallExpression result = new MethodCallExpression(\n                        new VariableExpression(weaved),\n                        call.getMethod(),\n                        transform(call.getArguments())\n                );\n                result.setSafe(false);\n                result.setImplicitThis(false);\n                result.setSpreadSafe(false);\n                result.setSourcePosition(call);\n                return result;\n            }\n        } else if (exp instanceof MethodCallExpression) {\n            MethodCallExpression call = (MethodCallExpression) exp;\n            Expression obj = call.getObjectExpression();\n            if (call.isImplicitThis() || \"this\".equals(obj.getText())) {\n                return transformMethodCallOnThis(call);\n            } else if (\"super\".equals(obj.getText())) {\n                return transformSuperMethodCall(call);\n            }\n        } else if (exp instanceof FieldExpression) {\n            FieldNode field = ((FieldExpression) exp).getField();\n            MethodCallExpression mce = new MethodCallExpression(\n                    createFieldHelperReceiver(),\n                    Traits.helperGetterName(field),\n                    ArgumentListExpression.EMPTY_ARGUMENTS\n            );\n            mce.setSourcePosition(exp);\n            mce.setImplicitThis(false);\n            return mce;\n        } else if (exp instanceof VariableExpression) {\n            VariableExpression vexp = (VariableExpression) exp;\n            Variable accessedVariable = vexp.getAccessedVariable();\n            if (accessedVariable instanceof FieldNode) {\n                FieldNode fn = (FieldNode) accessedVariable;\n                Expression receiver = createFieldHelperReceiver();\n                MethodCallExpression mce;\n                if (fn.isStatic()) {\n                    receiver = new TernaryExpression(\n                            new BooleanExpression(new BinaryExpression(\n                                    receiver,\n                                    Token.newSymbol(Types.KEYWORD_INSTANCEOF, -1, -1),\n                                    new ClassExpression(ClassHelper.CLASS_Type)\n                            )),\n                            receiver,\n                            new MethodCallExpression(createFieldHelperReceiver(), \"getClass\", ArgumentListExpression.EMPTY_ARGUMENTS)\n                    );\n                }\n                mce = new MethodCallExpression(\n                            receiver,\n                            Traits.helperGetterName((FieldNode) accessedVariable),\n                            ArgumentListExpression.EMPTY_ARGUMENTS\n                );\n                mce.setSourcePosition(exp);\n                mce.setImplicitThis(false);\n                return mce;\n            } else if (accessedVariable instanceof PropertyNode) {\n                String propName = accessedVariable.getName();\n                if (knownFields.contains(propName)) {\n                    String method = Traits.helperGetterName(new FieldNode(propName, 0, ClassHelper.OBJECT_TYPE, weavedType, null));\n                    MethodCallExpression mce = new MethodCallExpression(\n                            createFieldHelperReceiver(),\n                            method,\n                            ArgumentListExpression.EMPTY_ARGUMENTS\n                    );\n                    mce.setSourcePosition(exp);\n                    mce.setImplicitThis(false);\n                    return mce;\n                } else {\n                    return new PropertyExpression(\n                            new VariableExpression(weaved),\n                            accessedVariable.getName()\n                    );\n                }\n            } else if (accessedVariable instanceof DynamicVariable) {\n                return new PropertyExpression(\n                        new VariableExpression(weaved),\n                        accessedVariable.getName()\n                );\n            }\n            if (vexp.isThisExpression()) {\n                VariableExpression res = new VariableExpression(weaved);\n                res.setSourcePosition(exp);\n                return res;\n            }\n            if (vexp.isSuperExpression()) {\n                throwSuperError(vexp);\n            }\n        } else if (exp instanceof PropertyExpression) {\n            PropertyExpression pexp = (PropertyExpression) exp;\n            Expression object = pexp.getObjectExpression();\n            if (pexp.isImplicitThis() || \"this\".equals(object.getText())) {\n                String propName = pexp.getPropertyAsString();\n                if (knownFields.contains(propName)) {\n                    String method = Traits.helperGetterName(new FieldNode(propName, 0, ClassHelper.OBJECT_TYPE, weavedType, null));\n                    MethodCallExpression mce = new MethodCallExpression(\n                            createFieldHelperReceiver(),\n                            method,\n                            ArgumentListExpression.EMPTY_ARGUMENTS\n                    );\n                    mce.setSourcePosition(exp);\n                    mce.setImplicitThis(false);\n                    return mce;\n                }\n            }\n        } else if (exp instanceof ClosureExpression) {\n            MethodCallExpression mce = new MethodCallExpression(\n                    exp,\n                    \"rehydrate\",\n                    new ArgumentListExpression(\n                            new VariableExpression(weaved),\n                            new VariableExpression(weaved),\n                            new VariableExpression(weaved)\n                    )\n            );\n            mce.setImplicitThis(false);\n            mce.setSourcePosition(exp);\n            return mce;\n        }\n\n        // todo: unary expressions (field++, field+=, ...)\n        return super.transform(exp);\n    }",
            "  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105 +\n 106 +\n 107 +\n 108 +\n 109 +\n 110 +\n 111 +\n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  ",
            "    @Override\n    public Expression transform(final Expression exp) {\n        ClassNode weavedType = weaved.getOriginType();\n        if (exp instanceof BinaryExpression) {\n            Expression leftExpression = ((BinaryExpression) exp).getLeftExpression();\n            Expression rightExpression = ((BinaryExpression) exp).getRightExpression();\n            Token operation = ((BinaryExpression) exp).getOperation();\n            if (operation.getText().equals(\"=\")) {\n                String leftFieldName = null;\n                // it's an assignment\n                if (leftExpression instanceof VariableExpression && ((VariableExpression) leftExpression).getAccessedVariable() instanceof FieldNode) {\n                    leftFieldName = ((VariableExpression) leftExpression).getAccessedVariable().getName();\n                } else if (leftExpression instanceof FieldExpression) {\n                    leftFieldName = ((FieldExpression) leftExpression).getFieldName();\n                } else if (leftExpression instanceof PropertyExpression\n                        && (((PropertyExpression) leftExpression).isImplicitThis() || \"this\".equals(((PropertyExpression) leftExpression).getObjectExpression().getText()))) {\n                    leftFieldName = ((PropertyExpression) leftExpression).getPropertyAsString();\n                    FieldNode fn = weavedType.getDeclaredField(leftFieldName);\n                    if (fn==null && ClassHelper.CLASS_Type.equals(weavedType)) {\n                        GenericsType[] genericsTypes = weavedType.getGenericsTypes();\n                        if (genericsTypes !=null && genericsTypes.length==1) {\n                            // for static properties\n                            fn = genericsTypes[0].getType().getDeclaredField(leftFieldName);\n                        }\n                    }\n                    if (fieldHelper == null || fn==null && !fieldHelper.hasPossibleMethod(Traits.helperSetterName(new FieldNode(leftFieldName, 0, ClassHelper.OBJECT_TYPE, weavedType, null)), rightExpression)) {\n                        return new BinaryExpression(\n                                new PropertyExpression(\n                                        new VariableExpression(weaved),\n                                        leftFieldName\n                                ),\n                                operation,\n                                transform(rightExpression));\n                    }\n                }\n                if (leftFieldName!=null) {\n                    FieldNode fn = weavedType.getDeclaredField(leftFieldName);\n                    if (fn==null) {\n                        fn = new FieldNode(leftFieldName, 0, ClassHelper.OBJECT_TYPE, weavedType, null);\n                    }\n                    Expression receiver = createFieldHelperReceiver();\n                    if (fn.isStatic()) {\n                        receiver = new PropertyExpression(receiver, \"class\");\n                    }\n                    String method = Traits.helperSetterName(fn);\n                    MethodCallExpression mce = new MethodCallExpression(\n                            receiver,\n                            method,\n                            new ArgumentListExpression(super.transform(rightExpression))\n                    );\n                    mce.setSourcePosition(exp);\n                    mce.setImplicitThis(false);\n                    return mce;\n                }\n            }\n            Expression leftTransform = transform(leftExpression);\n            Expression rightTransform = transform(rightExpression);\n            Expression ret =\n                    exp instanceof DeclarationExpression ?new DeclarationExpression(\n                            leftTransform, operation, rightTransform\n                    ):\n                    new BinaryExpression(leftTransform, operation, rightTransform);\n            ret.setSourcePosition(exp);\n            ret.copyNodeMetaData(exp);\n            return ret;\n        } else if (exp instanceof StaticMethodCallExpression) {\n            StaticMethodCallExpression call = (StaticMethodCallExpression) exp;\n            ClassNode ownerType = call.getOwnerType();\n            if (traitClass.equals(ownerType)) {\n                MethodCallExpression result = new MethodCallExpression(\n                        new VariableExpression(weaved),\n                        call.getMethod(),\n                        transform(call.getArguments())\n                );\n                result.setSafe(false);\n                result.setImplicitThis(false);\n                result.setSpreadSafe(false);\n                result.setSourcePosition(call);\n                return result;\n            }\n        } else if (exp instanceof MethodCallExpression) {\n            MethodCallExpression call = (MethodCallExpression) exp;\n            Expression obj = call.getObjectExpression();\n            if (call.isImplicitThis() || \"this\".equals(obj.getText())) {\n                return transformMethodCallOnThis(call);\n            } else if (\"super\".equals(obj.getText())) {\n                return transformSuperMethodCall(call);\n            }\n        } else if (exp instanceof FieldExpression) {\n            FieldNode field = ((FieldExpression) exp).getField();\n            MethodCallExpression mce = new MethodCallExpression(\n                    createFieldHelperReceiver(),\n                    Traits.helperGetterName(field),\n                    ArgumentListExpression.EMPTY_ARGUMENTS\n            );\n            mce.setSourcePosition(exp);\n            mce.setImplicitThis(false);\n            return mce;\n        } else if (exp instanceof VariableExpression) {\n            VariableExpression vexp = (VariableExpression) exp;\n            Variable accessedVariable = vexp.getAccessedVariable();\n            if (accessedVariable instanceof FieldNode) {\n                FieldNode fn = (FieldNode) accessedVariable;\n                Expression receiver = createFieldHelperReceiver();\n                MethodCallExpression mce;\n                if (fn.isStatic()) {\n                    receiver = new TernaryExpression(\n                            new BooleanExpression(new BinaryExpression(\n                                    receiver,\n                                    Token.newSymbol(Types.KEYWORD_INSTANCEOF, -1, -1),\n                                    new ClassExpression(ClassHelper.CLASS_Type)\n                            )),\n                            receiver,\n                            new MethodCallExpression(createFieldHelperReceiver(), \"getClass\", ArgumentListExpression.EMPTY_ARGUMENTS)\n                    );\n                }\n                mce = new MethodCallExpression(\n                            receiver,\n                            Traits.helperGetterName((FieldNode) accessedVariable),\n                            ArgumentListExpression.EMPTY_ARGUMENTS\n                );\n                mce.setSourcePosition(exp);\n                mce.setImplicitThis(false);\n                return mce;\n            } else if (accessedVariable instanceof PropertyNode) {\n                String propName = accessedVariable.getName();\n                if (knownFields.contains(propName)) {\n                    String method = Traits.helperGetterName(new FieldNode(propName, 0, ClassHelper.OBJECT_TYPE, weavedType, null));\n                    MethodCallExpression mce = new MethodCallExpression(\n                            createFieldHelperReceiver(),\n                            method,\n                            ArgumentListExpression.EMPTY_ARGUMENTS\n                    );\n                    mce.setSourcePosition(exp);\n                    mce.setImplicitThis(false);\n                    return mce;\n                } else {\n                    return new PropertyExpression(\n                            new VariableExpression(weaved),\n                            accessedVariable.getName()\n                    );\n                }\n            } else if (accessedVariable instanceof DynamicVariable) {\n                return new PropertyExpression(\n                        new VariableExpression(weaved),\n                        accessedVariable.getName()\n                );\n            }\n            if (vexp.isThisExpression()) {\n                VariableExpression res = new VariableExpression(weaved);\n                res.setSourcePosition(exp);\n                return res;\n            }\n            if (vexp.isSuperExpression()) {\n                throwSuperError(vexp);\n            }\n        } else if (exp instanceof PropertyExpression) {\n            PropertyExpression pexp = (PropertyExpression) exp;\n            Expression object = pexp.getObjectExpression();\n            if (pexp.isImplicitThis() || \"this\".equals(object.getText())) {\n                String propName = pexp.getPropertyAsString();\n                if (knownFields.contains(propName)) {\n                    String method = Traits.helperGetterName(new FieldNode(propName, 0, ClassHelper.OBJECT_TYPE, weavedType, null));\n                    MethodCallExpression mce = new MethodCallExpression(\n                            createFieldHelperReceiver(),\n                            method,\n                            ArgumentListExpression.EMPTY_ARGUMENTS\n                    );\n                    mce.setSourcePosition(exp);\n                    mce.setImplicitThis(false);\n                    return mce;\n                }\n            }\n        } else if (exp instanceof ClosureExpression) {\n            MethodCallExpression mce = new MethodCallExpression(\n                    exp,\n                    \"rehydrate\",\n                    new ArgumentListExpression(\n                            new VariableExpression(weaved),\n                            new VariableExpression(weaved),\n                            new VariableExpression(weaved)\n                    )\n            );\n            mce.setImplicitThis(false);\n            mce.setSourcePosition(exp);\n            return mce;\n        }\n\n        // todo: unary expressions (field++, field+=, ...)\n        return super.transform(exp);\n    }"
        ]
    ],
    "24ec32e6a5cfb653f9ca8aa151bbf6a671905098": [
        [
            "ResolveVisitor::transformBinaryExpression(BinaryExpression)",
            " 962  \n 963  \n 964  \n 965  \n 966  \n 967  \n 968  \n 969  \n 970  \n 971  \n 972  \n 973  \n 974  \n 975  \n 976  \n 977  \n 978  \n 979  \n 980  \n 981  \n 982  \n 983  \n 984  \n 985  \n 986  \n 987  \n 988  \n 989  \n 990  \n 991  \n 992  \n 993  \n 994  \n 995  \n 996  \n 997  \n 998  \n 999  \n1000  \n1001  \n1002  \n1003  \n1004  \n1005  \n1006  \n1007  \n1008  \n1009  \n1010  \n1011  \n1012  \n1013  \n1014  \n1015  \n1016  \n1017  \n1018  \n1019  \n1020  \n1021  ",
            "    protected Expression transformBinaryExpression(BinaryExpression be) {\n        Expression left = transform(be.getLeftExpression());\n        int type = be.getOperation().getType();\n        if ((type == Types.ASSIGNMENT_OPERATOR || type == Types.EQUAL) &&\n                left instanceof ClassExpression) {\n            ClassExpression ce = (ClassExpression) left;\n            String error = \"you tried to assign a value to the class '\" + ce.getType().getName() + \"'\";\n            if (ce.getType().isScript()) {\n                error += \". Do you have a script with this name?\";\n            }\n            addError(error, be.getLeftExpression());\n            return be;\n        }\n        if (left instanceof ClassExpression && isLeftSquareBracket(type)) {\n            if (be.getRightExpression() instanceof ListExpression) {\n                ListExpression list = (ListExpression) be.getRightExpression();\n                if (list.getExpressions().isEmpty()) {\n                    // we have C[] if the list is empty -> should be an array then!\n                    final ClassExpression ce = new ClassExpression(left.getType().makeArray());\n                    ce.setSourcePosition(be);\n                    return ce;\n                }\n                else {\n                    // may be we have C[k1:v1, k2:v2] -> should become (C)([k1:v1, k2:v2])\n                    boolean map = true;\n                    for (Expression expression : list.getExpressions()) {\n                        if(!(expression instanceof MapEntryExpression)) {\n                            map = false;\n                            break;\n                        }\n                    }\n\n                    if (map) {\n                        final MapExpression me = new MapExpression();\n                        for (Expression expression : list.getExpressions()) {\n                            me.addMapEntryExpression((MapEntryExpression) transform(expression));\n                        }\n                        me.setSourcePosition(list);\n                        final CastExpression ce = new CastExpression(left.getType(), me);\n                        ce.setSourcePosition(be);\n                        return ce;\n                    }\n                }\n            }\n\n            if (be.getRightExpression() instanceof MapEntryExpression) {\n                // may be we have C[k1:v1] -> should become (C)([k1:v1])\n                final MapExpression me = new MapExpression();\n                me.addMapEntryExpression((MapEntryExpression) transform(be.getRightExpression()));\n                me.setSourcePosition(be.getRightExpression());\n                final CastExpression ce = new CastExpression(left.getType(), me);\n                ce.setSourcePosition(be);\n                return ce;\n            }\n        }\n        Expression right = transform(be.getRightExpression());\n        be.setLeftExpression(left);\n        be.setRightExpression(right);\n        return be;\n    }",
            " 962  \n 963  \n 964  \n 965  \n 966  \n 967  \n 968  \n 969  \n 970  \n 971  \n 972  \n 973  \n 974  \n 975  \n 976  \n 977  \n 978  \n 979  \n 980  \n 981  \n 982  \n 983  \n 984  \n 985  \n 986  \n 987  \n 988  \n 989  \n 990  \n 991  \n 992  \n 993  \n 994  \n 995  \n 996  \n 997  \n 998  \n 999  \n1000  \n1001  \n1002  \n1003  \n1004  \n1005 +\n1006 +\n1007 +\n1008 +\n1009 +\n1010 +\n1011 +\n1012  \n1013  \n1014  \n1015  \n1016  \n1017  \n1018  \n1019  \n1020  \n1021  \n1022  \n1023  \n1024  \n1025  \n1026  \n1027  \n1028  ",
            "    protected Expression transformBinaryExpression(BinaryExpression be) {\n        Expression left = transform(be.getLeftExpression());\n        int type = be.getOperation().getType();\n        if ((type == Types.ASSIGNMENT_OPERATOR || type == Types.EQUAL) &&\n                left instanceof ClassExpression) {\n            ClassExpression ce = (ClassExpression) left;\n            String error = \"you tried to assign a value to the class '\" + ce.getType().getName() + \"'\";\n            if (ce.getType().isScript()) {\n                error += \". Do you have a script with this name?\";\n            }\n            addError(error, be.getLeftExpression());\n            return be;\n        }\n        if (left instanceof ClassExpression && isLeftSquareBracket(type)) {\n            if (be.getRightExpression() instanceof ListExpression) {\n                ListExpression list = (ListExpression) be.getRightExpression();\n                if (list.getExpressions().isEmpty()) {\n                    // we have C[] if the list is empty -> should be an array then!\n                    final ClassExpression ce = new ClassExpression(left.getType().makeArray());\n                    ce.setSourcePosition(be);\n                    return ce;\n                }\n                else {\n                    // may be we have C[k1:v1, k2:v2] -> should become (C)([k1:v1, k2:v2])\n                    boolean map = true;\n                    for (Expression expression : list.getExpressions()) {\n                        if(!(expression instanceof MapEntryExpression)) {\n                            map = false;\n                            break;\n                        }\n                    }\n\n                    if (map) {\n                        final MapExpression me = new MapExpression();\n                        for (Expression expression : list.getExpressions()) {\n                            me.addMapEntryExpression((MapEntryExpression) transform(expression));\n                        }\n                        me.setSourcePosition(list);\n                        final CastExpression ce = new CastExpression(left.getType(), me);\n                        ce.setSourcePosition(be);\n                        return ce;\n                    }\n                }\n            } else if (be.getRightExpression() instanceof SpreadMapExpression) {\n                // we have C[*:map] -> should become (C) map\n                SpreadMapExpression mapExpression = (SpreadMapExpression) be.getRightExpression();\n                Expression right = transform(mapExpression.getExpression());\n                Expression ce = new CastExpression(left.getType(), right);\n                ce.setSourcePosition(be);\n                return ce;\n            }\n\n            if (be.getRightExpression() instanceof MapEntryExpression) {\n                // may be we have C[k1:v1] -> should become (C)([k1:v1])\n                final MapExpression me = new MapExpression();\n                me.addMapEntryExpression((MapEntryExpression) transform(be.getRightExpression()));\n                me.setSourcePosition(be.getRightExpression());\n                final CastExpression ce = new CastExpression(left.getType(), me);\n                ce.setSourcePosition(be);\n                return ce;\n            }\n        }\n        Expression right = transform(be.getRightExpression());\n        be.setLeftExpression(left);\n        be.setRightExpression(right);\n        return be;\n    }"
        ]
    ],
    "1aba752185bdd187d35b538b92a02f45e368634b": [
        [
            "StaticInvocationWriter::tryBridgeMethod(MethodNode,Expression,boolean,TupleExpression)",
            " 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190 -\n 191  \n 192 -\n 193 -\n 194 -\n 195 -\n 196 -\n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  ",
            "    /**\n     * Attempts to make a direct method call on a bridge method, if it exists.\n     */\n    protected boolean tryBridgeMethod(MethodNode target, Expression receiver, boolean implicitThis, TupleExpression args) {\n        ClassNode lookupClassNode;\n        if (target.isProtected()) {\n            lookupClassNode = controller.getClassNode();\n            if (controller.isInClosure()) {\n                lookupClassNode = lookupClassNode.getOuterClass();\n            }\n        } else {\n            lookupClassNode = target.getDeclaringClass().redirect();\n        }\n        Map<MethodNode, MethodNode> bridges = lookupClassNode.getNodeMetaData(PRIVATE_BRIDGE_METHODS);\n        MethodNode bridge = bridges==null?null:bridges.get(target);\n        if (bridge != null) {\n            Expression fixedReceiver = receiver;\n            ClassNode classNode = implicitThis?controller.getClassNode():null;\n            ClassNode declaringClass = bridge.getDeclaringClass();\n            if (implicitThis && !controller.isInClosure()\n                    && !classNode.isDerivedFrom(declaringClass)\n                    && !classNode.implementsInterface(declaringClass)\n                    && classNode instanceof InnerClassNode) {\n                fixedReceiver = new PropertyExpression(new ClassExpression(classNode.getOuterClass()), \"this\");\n            }\n            ArgumentListExpression newArgs = new ArgumentListExpression(target.isStatic()?new ConstantExpression(null):fixedReceiver);\n            for (Expression expression : args.getExpressions()) {\n                newArgs.addExpression(expression);\n            }\n            return writeDirectMethodCall(bridge, implicitThis, fixedReceiver, newArgs);\n        }\n        return false;\n    }",
            " 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191 +\n 192 +\n 193 +\n 194 +\n 195 +\n 196 +\n 197 +\n 198 +\n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  ",
            "    /**\n     * Attempts to make a direct method call on a bridge method, if it exists.\n     */\n    protected boolean tryBridgeMethod(MethodNode target, Expression receiver, boolean implicitThis, TupleExpression args) {\n        ClassNode lookupClassNode;\n        if (target.isProtected()) {\n            lookupClassNode = controller.getClassNode();\n            if (controller.isInClosure()) {\n                lookupClassNode = lookupClassNode.getOuterClass();\n            }\n        } else {\n            lookupClassNode = target.getDeclaringClass().redirect();\n        }\n        Map<MethodNode, MethodNode> bridges = lookupClassNode.getNodeMetaData(PRIVATE_BRIDGE_METHODS);\n        MethodNode bridge = bridges==null?null:bridges.get(target);\n        if (bridge != null) {\n            Expression fixedReceiver = receiver;\n            ClassNode declaringClass = bridge.getDeclaringClass();\n            if (implicitThis && !controller.isInClosure()) {\n                ClassNode classNode = controller.getClassNode();\n                while (!classNode.isDerivedFrom(declaringClass)\n                        && !classNode.implementsInterface(declaringClass)\n                        && classNode instanceof InnerClassNode) {\n                    classNode = classNode.getOuterClass();\n                }\n                fixedReceiver = new PropertyExpression(new ClassExpression(classNode), \"this\");\n            }\n            ArgumentListExpression newArgs = new ArgumentListExpression(target.isStatic()?new ConstantExpression(null):fixedReceiver);\n            for (Expression expression : args.getExpressions()) {\n                newArgs.addExpression(expression);\n            }\n            return writeDirectMethodCall(bridge, implicitThis, fixedReceiver, newArgs);\n        }\n        return false;\n    }"
        ]
    ],
    "21b3fadd70b0acc5c4d9fdc2e8c5dbdc8b52b86d": [
        [
            "InnerClassCompletionVisitor::addDefaultMethods(InnerClassNode)",
            " 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180 -\n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  ",
            "    private void addDefaultMethods(InnerClassNode node) {\r\n        final boolean isStatic = isStatic(node);\r\n\r\n        ClassNode outerClass = node.getOuterClass();\r\n        final String classInternalName = org.codehaus.groovy.classgen.asm.BytecodeHelper.getClassInternalName(node);\r\n        final String outerClassInternalName = getInternalName(outerClass, isStatic);\r\n        final String outerClassDescriptor = getTypeDescriptor(outerClass, isStatic);\r\n        final int objectDistance = getObjectDistance(outerClass);\r\n\r\n        // add method dispatcher\r\n        Parameter[] parameters = new Parameter[]{\r\n                new Parameter(ClassHelper.STRING_TYPE, \"name\"),\r\n                new Parameter(ClassHelper.OBJECT_TYPE, \"args\")\r\n        };\r\n\r\n        String methodName = \"methodMissing\";\r\n        if (isStatic)\r\n            addCompilationErrorOnCustomMethodNode(node, methodName, parameters);\r\n\r\n        MethodNode method = node.addSyntheticMethod(\r\n                methodName,\r\n                Opcodes.ACC_PUBLIC,\r\n                ClassHelper.OBJECT_TYPE,\r\n                parameters,\r\n                ClassNode.EMPTY_ARRAY,\r\n                null\r\n        );\r\n\r\n        BlockStatement block = new BlockStatement();\r\n        if (isStatic) {\r\n            setMethodDispatcherCode(block, new ClassExpression(outerClass), parameters);\r\n        } else {\r\n            block.addStatement(\r\n                    new BytecodeSequence(new BytecodeInstruction() {\r\n                        public void visit(MethodVisitor mv) {\r\n                            getThis(mv,classInternalName,outerClassDescriptor,outerClassInternalName);\r\n                            mv.visitVarInsn(ALOAD, 1);\r\n                            mv.visitVarInsn(ALOAD, 2);\r\n                            mv.visitMethodInsn(INVOKEVIRTUAL, outerClassInternalName, \"this$dist$invoke$\" + objectDistance, \"(Ljava/lang/String;Ljava/lang/Object;)Ljava/lang/Object;\", false);\r\n                            mv.visitInsn(ARETURN);\r\n                        }\r\n                    })\r\n            );\r\n        }\r\n        method.setCode(block);\r\n\r\n        // add property setter dispatcher\r\n        parameters = new Parameter[]{\r\n                new Parameter(ClassHelper.STRING_TYPE, \"name\"),\r\n                new Parameter(ClassHelper.OBJECT_TYPE, \"val\")\r\n        };\r\n\r\n        methodName = \"propertyMissing\";\r\n        if (isStatic)\r\n            addCompilationErrorOnCustomMethodNode(node, methodName, parameters);\r\n\r\n        method = node.addSyntheticMethod(\r\n                methodName,\r\n                Opcodes.ACC_PUBLIC,\r\n                ClassHelper.VOID_TYPE,\r\n                parameters,\r\n                ClassNode.EMPTY_ARRAY,\r\n                null\r\n        );\r\n\r\n        block = new BlockStatement();\r\n        if (isStatic) {\r\n            setPropertySetterDispatcher(block, new ClassExpression(node.getOuterClass()), parameters);\r\n        } else {\r\n            block.addStatement(\r\n                    new BytecodeSequence(new BytecodeInstruction() {\r\n                        public void visit(MethodVisitor mv) {\r\n                            getThis(mv,classInternalName,outerClassDescriptor,outerClassInternalName);\r\n                            mv.visitVarInsn(ALOAD, 1);\r\n                            mv.visitVarInsn(ALOAD, 2);\r\n                            mv.visitMethodInsn(INVOKEVIRTUAL, outerClassInternalName, \"this$dist$set$\" + objectDistance, \"(Ljava/lang/String;Ljava/lang/Object;)V\", false);\r\n                            mv.visitInsn(RETURN);\r\n                        }\r\n                    })\r\n            );\r\n        }\r\n        method.setCode(block);\r\n\r\n        // add property getter dispatcher\r\n        parameters = new Parameter[]{\r\n                new Parameter(ClassHelper.STRING_TYPE, \"name\")\r\n        };\r\n\r\n        methodName = \"propertyMissing\";\r\n        if (isStatic)\r\n            addCompilationErrorOnCustomMethodNode(node, methodName, parameters);\r\n\r\n        method = node.addSyntheticMethod(\r\n                methodName,\r\n                Opcodes.ACC_PUBLIC,\r\n                ClassHelper.OBJECT_TYPE,\r\n                parameters,\r\n                ClassNode.EMPTY_ARRAY,\r\n                null\r\n        );\r\n\r\n        block = new BlockStatement();\r\n        if (isStatic) {\r\n            setPropertyGetterDispatcher(block, new ClassExpression(node.getOuterClass()), parameters);\r\n        } else {\r\n            block.addStatement(\r\n                    new BytecodeSequence(new BytecodeInstruction() {\r\n                        public void visit(MethodVisitor mv) {\r\n                            getThis(mv,classInternalName,outerClassDescriptor,outerClassInternalName);\r\n                            mv.visitVarInsn(ALOAD, 1);\r\n                            mv.visitMethodInsn(INVOKEVIRTUAL, outerClassInternalName, \"this$dist$get$\" + objectDistance, \"(Ljava/lang/String;)Ljava/lang/Object;\", false);\r\n                            mv.visitInsn(ARETURN);\r\n                        }\r\n                    })\r\n            );\r\n        }\r\n        method.setCode(block);\r\n    }\r",
            " 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180 +\n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217 +\n 218 +\n 219 +\n 220 +\n 221 +\n 222 +\n 223 +\n 224 +\n 225 +\n 226 +\n 227 +\n 228 +\n 229 +\n 230 +\n 231 +\n 232 +\n 233 +\n 234 +\n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  \n 306  ",
            "    private void addDefaultMethods(InnerClassNode node) {\r\n        final boolean isStatic = isStatic(node);\r\n\r\n        ClassNode outerClass = node.getOuterClass();\r\n        final String classInternalName = org.codehaus.groovy.classgen.asm.BytecodeHelper.getClassInternalName(node);\r\n        final String outerClassInternalName = getInternalName(outerClass, isStatic);\r\n        final String outerClassDescriptor = getTypeDescriptor(outerClass, isStatic);\r\n        final int objectDistance = getObjectDistance(outerClass);\r\n\r\n        // add missing method dispatcher\r\n        Parameter[] parameters = new Parameter[]{\r\n                new Parameter(ClassHelper.STRING_TYPE, \"name\"),\r\n                new Parameter(ClassHelper.OBJECT_TYPE, \"args\")\r\n        };\r\n\r\n        String methodName = \"methodMissing\";\r\n        if (isStatic)\r\n            addCompilationErrorOnCustomMethodNode(node, methodName, parameters);\r\n\r\n        MethodNode method = node.addSyntheticMethod(\r\n                methodName,\r\n                Opcodes.ACC_PUBLIC,\r\n                ClassHelper.OBJECT_TYPE,\r\n                parameters,\r\n                ClassNode.EMPTY_ARRAY,\r\n                null\r\n        );\r\n\r\n        BlockStatement block = new BlockStatement();\r\n        if (isStatic) {\r\n            setMethodDispatcherCode(block, new ClassExpression(outerClass), parameters);\r\n        } else {\r\n            block.addStatement(\r\n                    new BytecodeSequence(new BytecodeInstruction() {\r\n                        public void visit(MethodVisitor mv) {\r\n                            getThis(mv,classInternalName,outerClassDescriptor,outerClassInternalName);\r\n                            mv.visitVarInsn(ALOAD, 1);\r\n                            mv.visitVarInsn(ALOAD, 2);\r\n                            mv.visitMethodInsn(INVOKEVIRTUAL, outerClassInternalName, \"this$dist$invoke$\" + objectDistance, \"(Ljava/lang/String;Ljava/lang/Object;)Ljava/lang/Object;\", false);\r\n                            mv.visitInsn(ARETURN);\r\n                        }\r\n                    })\r\n            );\r\n        }\r\n        method.setCode(block);\r\n\r\n        // add static missing method dispatcher\r\n        methodName = \"$static_methodMissing\";\r\n        if (isStatic)\r\n            addCompilationErrorOnCustomMethodNode(node, methodName, parameters);\r\n\r\n        method = node.addSyntheticMethod(\r\n                methodName,\r\n                Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\r\n                ClassHelper.OBJECT_TYPE,\r\n                parameters,\r\n                ClassNode.EMPTY_ARRAY,\r\n                null\r\n        );\r\n\r\n        block = new BlockStatement();\r\n        setMethodDispatcherCode(block, new ClassExpression(outerClass), parameters);\r\n        method.setCode(block);\r\n\r\n        // add property setter dispatcher\r\n        parameters = new Parameter[]{\r\n                new Parameter(ClassHelper.STRING_TYPE, \"name\"),\r\n                new Parameter(ClassHelper.OBJECT_TYPE, \"val\")\r\n        };\r\n\r\n        methodName = \"propertyMissing\";\r\n        if (isStatic)\r\n            addCompilationErrorOnCustomMethodNode(node, methodName, parameters);\r\n\r\n        method = node.addSyntheticMethod(\r\n                methodName,\r\n                Opcodes.ACC_PUBLIC,\r\n                ClassHelper.VOID_TYPE,\r\n                parameters,\r\n                ClassNode.EMPTY_ARRAY,\r\n                null\r\n        );\r\n\r\n        block = new BlockStatement();\r\n        if (isStatic) {\r\n            setPropertySetterDispatcher(block, new ClassExpression(node.getOuterClass()), parameters);\r\n        } else {\r\n            block.addStatement(\r\n                    new BytecodeSequence(new BytecodeInstruction() {\r\n                        public void visit(MethodVisitor mv) {\r\n                            getThis(mv,classInternalName,outerClassDescriptor,outerClassInternalName);\r\n                            mv.visitVarInsn(ALOAD, 1);\r\n                            mv.visitVarInsn(ALOAD, 2);\r\n                            mv.visitMethodInsn(INVOKEVIRTUAL, outerClassInternalName, \"this$dist$set$\" + objectDistance, \"(Ljava/lang/String;Ljava/lang/Object;)V\", false);\r\n                            mv.visitInsn(RETURN);\r\n                        }\r\n                    })\r\n            );\r\n        }\r\n        method.setCode(block);\r\n\r\n        // add property getter dispatcher\r\n        parameters = new Parameter[]{\r\n                new Parameter(ClassHelper.STRING_TYPE, \"name\")\r\n        };\r\n\r\n        methodName = \"propertyMissing\";\r\n        if (isStatic)\r\n            addCompilationErrorOnCustomMethodNode(node, methodName, parameters);\r\n\r\n        method = node.addSyntheticMethod(\r\n                methodName,\r\n                Opcodes.ACC_PUBLIC,\r\n                ClassHelper.OBJECT_TYPE,\r\n                parameters,\r\n                ClassNode.EMPTY_ARRAY,\r\n                null\r\n        );\r\n\r\n        block = new BlockStatement();\r\n        if (isStatic) {\r\n            setPropertyGetterDispatcher(block, new ClassExpression(node.getOuterClass()), parameters);\r\n        } else {\r\n            block.addStatement(\r\n                    new BytecodeSequence(new BytecodeInstruction() {\r\n                        public void visit(MethodVisitor mv) {\r\n                            getThis(mv,classInternalName,outerClassDescriptor,outerClassInternalName);\r\n                            mv.visitVarInsn(ALOAD, 1);\r\n                            mv.visitMethodInsn(INVOKEVIRTUAL, outerClassInternalName, \"this$dist$get$\" + objectDistance, \"(Ljava/lang/String;)Ljava/lang/Object;\", false);\r\n                            mv.visitInsn(ARETURN);\r\n                        }\r\n                    })\r\n            );\r\n        }\r\n        method.setCode(block);\r\n    }\r"
        ]
    ],
    "894ce576aa572afc3d10d38f379ea895c0e5d591": [
        [
            "NioGroovyMethods::write(Path,String)",
            " 447  \n 448  \n 449  \n 450  \n 451  \n 452  \n 453  \n 454  \n 455  \n 456  \n 457  \n 458 -\n 459  \n 460  \n 461  \n 462  \n 463  \n 464  \n 465  \n 466  \n 467  \n 468  ",
            "    /**\n     * Write the text to the Path.\n     *\n     * @param self a Path\n     * @param text the text to write to the Path\n     * @throws java.io.IOException if an IOException occurs.\n     * @since 2.3.0\n     */\n    public static void write(Path self, String text) throws IOException {\n        Writer writer = null;\n        try {\n            writer = new OutputStreamWriter(Files.newOutputStream(self, CREATE, APPEND), Charset.defaultCharset());\n            writer.write(text);\n            writer.flush();\n\n            Writer temp = writer;\n            writer = null;\n            temp.close();\n        } finally {\n            closeWithWarning(writer);\n        }\n    }",
            " 447  \n 448  \n 449  \n 450  \n 451  \n 452  \n 453  \n 454  \n 455  \n 456  \n 457  \n 458 +\n 459  \n 460  \n 461  \n 462  \n 463  \n 464  \n 465  \n 466  \n 467  \n 468  ",
            "    /**\n     * Write the text to the Path.\n     *\n     * @param self a Path\n     * @param text the text to write to the Path\n     * @throws java.io.IOException if an IOException occurs.\n     * @since 2.3.0\n     */\n    public static void write(Path self, String text) throws IOException {\n        Writer writer = null;\n        try {\n            writer = new OutputStreamWriter(Files.newOutputStream(self), Charset.defaultCharset());\n            writer.write(text);\n            writer.flush();\n\n            Writer temp = writer;\n            writer = null;\n            temp.close();\n        } finally {\n            closeWithWarning(writer);\n        }\n    }"
        ]
    ],
    "aa4b1cd63062b6960bbffc5b611531bd5b1b8b32": [
        [
            "ExtendedVerifier::visitOverride(AnnotatedNode,AnnotationNode)",
            " 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198 -\n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  ",
            "    private void visitOverride(AnnotatedNode node, AnnotationNode visited) {\r\n        ClassNode annotationClassNode = visited.getClassNode();\r\n        if (annotationClassNode.isResolved() && annotationClassNode.getName().equals(\"java.lang.Override\")) {\r\n            if (node instanceof MethodNode) {\r\n                MethodNode origMethod = (MethodNode) node;\r\n                ClassNode cNode = node.getDeclaringClass();\r\n                ClassNode next = cNode;\r\n                outer:\r\n                while (next != null) {\r\n                    Map genericsSpec = createGenericsSpec(next, new HashMap());\r\n                    MethodNode mn = correctToGenericsSpec(genericsSpec, origMethod);\r\n                    if (next != cNode) {\r\n                        ClassNode correctedNext = correctToGenericsSpecRecurse(genericsSpec, next);\r\n                        MethodNode found = getDeclaredMethodCorrected(genericsSpec, mn, correctedNext);\r\n                        if (found != null) break;\r\n                    }\r\n                    List<ClassNode> ifaces = new ArrayList<ClassNode>();\r\n                    ifaces.addAll(Arrays.asList(next.getInterfaces()));\r\n                    Map updatedGenericsSpec = new HashMap(genericsSpec);\r\n                    while (!ifaces.isEmpty()) {\r\n                        ClassNode origInterface = ifaces.remove(0);\r\n                        if (!origInterface.equals(ClassHelper.OBJECT_TYPE)) {\r\n                            updatedGenericsSpec = createGenericsSpec(origInterface, updatedGenericsSpec);\r\n                            ClassNode iNode = correctToGenericsSpecRecurse(updatedGenericsSpec, origInterface);\r\n                            MethodNode found2 = getDeclaredMethodCorrected(updatedGenericsSpec, mn, iNode);\r\n                            if (found2 != null) break outer;\r\n                            ifaces.addAll(Arrays.asList(iNode.getInterfaces()));\r\n                        }\r\n                    }\r\n                    next = next.getUnresolvedSuperClass();\r\n                }\r\n                if (next == null) {\r\n                    addError(\"Method '\" + origMethod.getName() + \"' from class '\" + cNode.getName() + \"' does not override \" +\r\n                            \"method from its superclass or interfaces but is annotated with @Override.\", visited);\r\n                }\r\n            }\r\n        }\r\n    }\r",
            " 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198 +\n 199 +\n 200 +\n 201 +\n 202 +\n 203 +\n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  ",
            "    private void visitOverride(AnnotatedNode node, AnnotationNode visited) {\r\n        ClassNode annotationClassNode = visited.getClassNode();\r\n        if (annotationClassNode.isResolved() && annotationClassNode.getName().equals(\"java.lang.Override\")) {\r\n            if (node instanceof MethodNode) {\r\n                MethodNode origMethod = (MethodNode) node;\r\n                ClassNode cNode = node.getDeclaringClass();\r\n                ClassNode next = cNode;\r\n                outer:\r\n                while (next != null) {\r\n                    Map genericsSpec = createGenericsSpec(next, new HashMap());\r\n                    MethodNode mn = correctToGenericsSpec(genericsSpec, origMethod);\r\n                    if (next != cNode) {\r\n                        ClassNode correctedNext = correctToGenericsSpecRecurse(genericsSpec, next);\r\n                        MethodNode found = getDeclaredMethodCorrected(genericsSpec, mn, correctedNext);\r\n                        if (found != null) break;\r\n                    }\r\n                    List<ClassNode> ifaces = new ArrayList<ClassNode>();\r\n                    ifaces.addAll(Arrays.asList(next.getInterfaces()));\r\n                    Map updatedGenericsSpec = new HashMap(genericsSpec);\r\n                    while (!ifaces.isEmpty()) {\r\n                        ClassNode origInterface = ifaces.remove(0);\r\n                        if (!origInterface.equals(ClassHelper.OBJECT_TYPE)) {\r\n                            updatedGenericsSpec = createGenericsSpec(origInterface, updatedGenericsSpec);\r\n                            ClassNode iNode = correctToGenericsSpecRecurse(updatedGenericsSpec, origInterface);\r\n                            MethodNode found2 = getDeclaredMethodCorrected(updatedGenericsSpec, mn, iNode);\r\n                            if (found2 != null) break outer;\r\n                            ifaces.addAll(Arrays.asList(iNode.getInterfaces()));\r\n                        }\r\n                    }\r\n                    ClassNode superClass = next.getUnresolvedSuperClass();\r\n                    if (superClass!=null) {\r\n                        next =  correctToGenericsSpecRecurse(updatedGenericsSpec, superClass);\r\n                    } else {\r\n                        next = null;\r\n                    }\r\n                }\r\n                if (next == null) {\r\n                    addError(\"Method '\" + origMethod.getName() + \"' from class '\" + cNode.getName() + \"' does not override \" +\r\n                            \"method from its superclass or interfaces but is annotated with @Override.\", visited);\r\n                }\r\n            }\r\n        }\r\n    }\r"
        ]
    ],
    "6506cab40a06d36af680b158c0085698d9f368a6": [
        [
            "TraitReceiverTransformer::transform(Expression)",
            "  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167 -\n 168  \n 169 -\n 170 -\n 171 -\n 172 -\n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  ",
            "    @Override\n    public Expression transform(final Expression exp) {\n        ClassNode weavedType = weaved.getOriginType();\n        if (exp instanceof BinaryExpression) {\n            Expression leftExpression = ((BinaryExpression) exp).getLeftExpression();\n            Expression rightExpression = ((BinaryExpression) exp).getRightExpression();\n            Token operation = ((BinaryExpression) exp).getOperation();\n            if (operation.getText().equals(\"=\")) {\n                String leftFieldName = null;\n                // it's an assignment\n                if (leftExpression instanceof VariableExpression && ((VariableExpression) leftExpression).getAccessedVariable() instanceof FieldNode) {\n                    leftFieldName = ((VariableExpression) leftExpression).getAccessedVariable().getName();\n                } else if (leftExpression instanceof FieldExpression) {\n                    leftFieldName = ((FieldExpression) leftExpression).getFieldName();\n                } else if (leftExpression instanceof PropertyExpression\n                        && (((PropertyExpression) leftExpression).isImplicitThis() || \"this\".equals(((PropertyExpression) leftExpression).getObjectExpression().getText()))) {\n                    leftFieldName = ((PropertyExpression) leftExpression).getPropertyAsString();\n                }\n                if (leftFieldName!=null) {\n                    FieldNode fn = weavedType.getDeclaredField(leftFieldName);\n                    if (fn==null) {\n                        fn = new FieldNode(leftFieldName, 0, ClassHelper.OBJECT_TYPE, weavedType, null);\n                    }\n                    Expression receiver = createFieldHelperReceiver();\n                    if (fn.isStatic()) {\n                        receiver = new PropertyExpression(receiver, \"class\");\n                    }\n                    String method = Traits.helperSetterName(fn);\n                    MethodCallExpression mce = new MethodCallExpression(\n                            receiver,\n                            method,\n                            new ArgumentListExpression(super.transform(rightExpression))\n                    );\n                    mce.setSourcePosition(exp);\n                    mce.setImplicitThis(false);\n                    return mce;\n                }\n            }\n            Expression leftTransform = transform(leftExpression);\n            Expression rightTransform = transform(rightExpression);\n            Expression ret =\n                    exp instanceof DeclarationExpression ?new DeclarationExpression(\n                            leftTransform, operation, rightTransform\n                    ):\n                    new BinaryExpression(leftTransform, operation, rightTransform);\n            ret.setSourcePosition(exp);\n            ret.copyNodeMetaData(exp);\n            return ret;\n        } else if (exp instanceof StaticMethodCallExpression) {\n            StaticMethodCallExpression call = (StaticMethodCallExpression) exp;\n            ClassNode ownerType = call.getOwnerType();\n            if (traitClass.equals(ownerType)) {\n                MethodCallExpression result = new MethodCallExpression(\n                        new VariableExpression(weaved),\n                        call.getMethod(),\n                        transform(call.getArguments())\n                );\n                result.setSafe(false);\n                result.setImplicitThis(false);\n                result.setSpreadSafe(false);\n                result.setSourcePosition(call);\n                return result;\n            }\n        } else if (exp instanceof MethodCallExpression) {\n            MethodCallExpression call = (MethodCallExpression) exp;\n            Expression obj = call.getObjectExpression();\n            if (call.isImplicitThis() || \"this\".equals(obj.getText())) {\n                return transformMethodCallOnThis(call);\n            } else if (\"super\".equals(obj.getText())) {\n                return transformSuperMethodCall(call);\n            }\n        } else if (exp instanceof FieldExpression) {\n            FieldNode field = ((FieldExpression) exp).getField();\n            MethodCallExpression mce = new MethodCallExpression(\n                    createFieldHelperReceiver(),\n                    Traits.helperGetterName(field),\n                    ArgumentListExpression.EMPTY_ARGUMENTS\n            );\n            mce.setSourcePosition(exp);\n            mce.setImplicitThis(false);\n            return mce;\n        } else if (exp instanceof VariableExpression) {\n            VariableExpression vexp = (VariableExpression) exp;\n            Variable accessedVariable = vexp.getAccessedVariable();\n            if (accessedVariable instanceof FieldNode) {\n                FieldNode fn = (FieldNode) accessedVariable;\n                Expression receiver = createFieldHelperReceiver();\n                if (fn.isStatic()) {\n                    receiver = new PropertyExpression(createFieldHelperReceiver(), \"class\");\n                }\n                MethodCallExpression mce = new MethodCallExpression(\n                        receiver,\n                        Traits.helperGetterName((FieldNode) accessedVariable),\n                        ArgumentListExpression.EMPTY_ARGUMENTS\n                );\n                mce.setSourcePosition(exp);\n                mce.setImplicitThis(false);\n                return mce;\n            } else if (accessedVariable instanceof PropertyNode) {\n                String propName = accessedVariable.getName();\n                if (knownFields.contains(propName)) {\n                    String method = Traits.helperGetterName(new FieldNode(propName, 0, ClassHelper.OBJECT_TYPE, weavedType, null));\n                    MethodCallExpression mce = new MethodCallExpression(\n                            createFieldHelperReceiver(),\n                            method,\n                            ArgumentListExpression.EMPTY_ARGUMENTS\n                    );\n                    mce.setSourcePosition(exp);\n                    mce.setImplicitThis(false);\n                    return mce;\n                } else {\n                    return new PropertyExpression(\n                            new VariableExpression(weaved),\n                            accessedVariable.getName()\n                    );\n                }\n            } else if (accessedVariable instanceof DynamicVariable) {\n                return new PropertyExpression(\n                        new VariableExpression(weaved),\n                        accessedVariable.getName()\n                );\n            }\n            if (vexp.isThisExpression()) {\n                VariableExpression res = new VariableExpression(weaved);\n                res.setSourcePosition(exp);\n                return res;\n            }\n            if (vexp.isSuperExpression()) {\n                throwSuperError(vexp);\n            }\n        } else if (exp instanceof PropertyExpression) {\n            PropertyExpression pexp = (PropertyExpression) exp;\n            Expression object = pexp.getObjectExpression();\n            if (pexp.isImplicitThis() || \"this\".equals(object.getText())) {\n                String propName = pexp.getPropertyAsString();\n                if (knownFields.contains(propName)) {\n                    String method = Traits.helperGetterName(new FieldNode(propName, 0, ClassHelper.OBJECT_TYPE, weavedType, null));\n                    MethodCallExpression mce = new MethodCallExpression(\n                            createFieldHelperReceiver(),\n                            method,\n                            ArgumentListExpression.EMPTY_ARGUMENTS\n                    );\n                    mce.setSourcePosition(exp);\n                    mce.setImplicitThis(false);\n                    return mce;\n                }\n            }\n        } else if (exp instanceof ClosureExpression) {\n            MethodCallExpression mce = new MethodCallExpression(\n                    exp,\n                    \"rehydrate\",\n                    new ArgumentListExpression(\n                            new VariableExpression(weaved),\n                            new VariableExpression(weaved),\n                            new VariableExpression(weaved)\n                    )\n            );\n            mce.setImplicitThis(false);\n            mce.setSourcePosition(exp);\n            return mce;\n        }\n\n        // todo: unary expressions (field++, field+=, ...)\n        return super.transform(exp);\n    }",
            "  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  \n 141  \n 142  \n 143  \n 144  \n 145  \n 146  \n 147  \n 148  \n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173 +\n 174  \n 175 +\n 176 +\n 177 +\n 178 +\n 179 +\n 180 +\n 181 +\n 182 +\n 183 +\n 184  \n 185 +\n 186 +\n 187 +\n 188 +\n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  ",
            "    @Override\n    public Expression transform(final Expression exp) {\n        ClassNode weavedType = weaved.getOriginType();\n        if (exp instanceof BinaryExpression) {\n            Expression leftExpression = ((BinaryExpression) exp).getLeftExpression();\n            Expression rightExpression = ((BinaryExpression) exp).getRightExpression();\n            Token operation = ((BinaryExpression) exp).getOperation();\n            if (operation.getText().equals(\"=\")) {\n                String leftFieldName = null;\n                // it's an assignment\n                if (leftExpression instanceof VariableExpression && ((VariableExpression) leftExpression).getAccessedVariable() instanceof FieldNode) {\n                    leftFieldName = ((VariableExpression) leftExpression).getAccessedVariable().getName();\n                } else if (leftExpression instanceof FieldExpression) {\n                    leftFieldName = ((FieldExpression) leftExpression).getFieldName();\n                } else if (leftExpression instanceof PropertyExpression\n                        && (((PropertyExpression) leftExpression).isImplicitThis() || \"this\".equals(((PropertyExpression) leftExpression).getObjectExpression().getText()))) {\n                    leftFieldName = ((PropertyExpression) leftExpression).getPropertyAsString();\n                }\n                if (leftFieldName!=null) {\n                    FieldNode fn = weavedType.getDeclaredField(leftFieldName);\n                    if (fn==null) {\n                        fn = new FieldNode(leftFieldName, 0, ClassHelper.OBJECT_TYPE, weavedType, null);\n                    }\n                    Expression receiver = createFieldHelperReceiver();\n                    if (fn.isStatic()) {\n                        receiver = new PropertyExpression(receiver, \"class\");\n                    }\n                    String method = Traits.helperSetterName(fn);\n                    MethodCallExpression mce = new MethodCallExpression(\n                            receiver,\n                            method,\n                            new ArgumentListExpression(super.transform(rightExpression))\n                    );\n                    mce.setSourcePosition(exp);\n                    mce.setImplicitThis(false);\n                    return mce;\n                }\n            }\n            Expression leftTransform = transform(leftExpression);\n            Expression rightTransform = transform(rightExpression);\n            Expression ret =\n                    exp instanceof DeclarationExpression ?new DeclarationExpression(\n                            leftTransform, operation, rightTransform\n                    ):\n                    new BinaryExpression(leftTransform, operation, rightTransform);\n            ret.setSourcePosition(exp);\n            ret.copyNodeMetaData(exp);\n            return ret;\n        } else if (exp instanceof StaticMethodCallExpression) {\n            StaticMethodCallExpression call = (StaticMethodCallExpression) exp;\n            ClassNode ownerType = call.getOwnerType();\n            if (traitClass.equals(ownerType)) {\n                MethodCallExpression result = new MethodCallExpression(\n                        new VariableExpression(weaved),\n                        call.getMethod(),\n                        transform(call.getArguments())\n                );\n                result.setSafe(false);\n                result.setImplicitThis(false);\n                result.setSpreadSafe(false);\n                result.setSourcePosition(call);\n                return result;\n            }\n        } else if (exp instanceof MethodCallExpression) {\n            MethodCallExpression call = (MethodCallExpression) exp;\n            Expression obj = call.getObjectExpression();\n            if (call.isImplicitThis() || \"this\".equals(obj.getText())) {\n                return transformMethodCallOnThis(call);\n            } else if (\"super\".equals(obj.getText())) {\n                return transformSuperMethodCall(call);\n            }\n        } else if (exp instanceof FieldExpression) {\n            FieldNode field = ((FieldExpression) exp).getField();\n            MethodCallExpression mce = new MethodCallExpression(\n                    createFieldHelperReceiver(),\n                    Traits.helperGetterName(field),\n                    ArgumentListExpression.EMPTY_ARGUMENTS\n            );\n            mce.setSourcePosition(exp);\n            mce.setImplicitThis(false);\n            return mce;\n        } else if (exp instanceof VariableExpression) {\n            VariableExpression vexp = (VariableExpression) exp;\n            Variable accessedVariable = vexp.getAccessedVariable();\n            if (accessedVariable instanceof FieldNode) {\n                FieldNode fn = (FieldNode) accessedVariable;\n                Expression receiver = createFieldHelperReceiver();\n                MethodCallExpression mce;\n                if (fn.isStatic()) {\n                    receiver = new TernaryExpression(\n                            new BooleanExpression(new BinaryExpression(\n                                    receiver,\n                                    Token.newSymbol(Types.KEYWORD_INSTANCEOF, -1, -1),\n                                    new ClassExpression(ClassHelper.CLASS_Type)\n                            )),\n                            receiver,\n                            new MethodCallExpression(createFieldHelperReceiver(), \"getClass\", ArgumentListExpression.EMPTY_ARGUMENTS)\n                    );\n                }\n                mce = new MethodCallExpression(\n                            receiver,\n                            Traits.helperGetterName((FieldNode) accessedVariable),\n                            ArgumentListExpression.EMPTY_ARGUMENTS\n                );\n                mce.setSourcePosition(exp);\n                mce.setImplicitThis(false);\n                return mce;\n            } else if (accessedVariable instanceof PropertyNode) {\n                String propName = accessedVariable.getName();\n                if (knownFields.contains(propName)) {\n                    String method = Traits.helperGetterName(new FieldNode(propName, 0, ClassHelper.OBJECT_TYPE, weavedType, null));\n                    MethodCallExpression mce = new MethodCallExpression(\n                            createFieldHelperReceiver(),\n                            method,\n                            ArgumentListExpression.EMPTY_ARGUMENTS\n                    );\n                    mce.setSourcePosition(exp);\n                    mce.setImplicitThis(false);\n                    return mce;\n                } else {\n                    return new PropertyExpression(\n                            new VariableExpression(weaved),\n                            accessedVariable.getName()\n                    );\n                }\n            } else if (accessedVariable instanceof DynamicVariable) {\n                return new PropertyExpression(\n                        new VariableExpression(weaved),\n                        accessedVariable.getName()\n                );\n            }\n            if (vexp.isThisExpression()) {\n                VariableExpression res = new VariableExpression(weaved);\n                res.setSourcePosition(exp);\n                return res;\n            }\n            if (vexp.isSuperExpression()) {\n                throwSuperError(vexp);\n            }\n        } else if (exp instanceof PropertyExpression) {\n            PropertyExpression pexp = (PropertyExpression) exp;\n            Expression object = pexp.getObjectExpression();\n            if (pexp.isImplicitThis() || \"this\".equals(object.getText())) {\n                String propName = pexp.getPropertyAsString();\n                if (knownFields.contains(propName)) {\n                    String method = Traits.helperGetterName(new FieldNode(propName, 0, ClassHelper.OBJECT_TYPE, weavedType, null));\n                    MethodCallExpression mce = new MethodCallExpression(\n                            createFieldHelperReceiver(),\n                            method,\n                            ArgumentListExpression.EMPTY_ARGUMENTS\n                    );\n                    mce.setSourcePosition(exp);\n                    mce.setImplicitThis(false);\n                    return mce;\n                }\n            }\n        } else if (exp instanceof ClosureExpression) {\n            MethodCallExpression mce = new MethodCallExpression(\n                    exp,\n                    \"rehydrate\",\n                    new ArgumentListExpression(\n                            new VariableExpression(weaved),\n                            new VariableExpression(weaved),\n                            new VariableExpression(weaved)\n                    )\n            );\n            mce.setImplicitThis(false);\n            mce.setSourcePosition(exp);\n            return mce;\n        }\n\n        // todo: unary expressions (field++, field+=, ...)\n        return super.transform(exp);\n    }"
        ]
    ],
    "0b776237f64301d74b0610795b8375b544050977": [
        [
            "GenericsUtils::findParameterizedTypeFromCache(ClassNode,ClassNode)",
            " 667  \n 668  \n 669  \n 670  \n 671  \n 672 -\n 673  ",
            "    /**\n     * Try to get the parameterized type from the cache.\n     * If no cached item found, cache and return the result of {@link #findParameterizedType(ClassNode, ClassNode)}\n     */\n    public static ClassNode findParameterizedTypeFromCache(final ClassNode genericsClass, final ClassNode actualType) {\n        return PARAMETERIZED_TYPE_CACHE.getAndPut(new ParameterizedTypeCacheKey(genericsClass, actualType), key -> findParameterizedType(key.getGenericsClass(), key.getActualType()));\n    }",
            " 668  \n 669  \n 670  \n 671  \n 672  \n 673 +\n 674 +\n 675 +\n 676  ",
            "    /**\n     * Try to get the parameterized type from the cache.\n     * If no cached item found, cache and return the result of {@link #findParameterizedType(ClassNode, ClassNode)}\n     */\n    public static ClassNode findParameterizedTypeFromCache(final ClassNode genericsClass, final ClassNode actualType) {\n        SoftReference<ClassNode> sr = PARAMETERIZED_TYPE_CACHE.getAndPut(new ParameterizedTypeCacheKey(genericsClass, actualType), key -> new SoftReference<>(findParameterizedType(key.getGenericsClass(), key.getActualType())));\n\n        return null == sr ? null : sr.get();\n    }"
        ]
    ],
    "5efaeaa9c21acba9f834ab1dc0b55346074d0111": [
        [
            "StaticCompilationVisitor::addPrivateBridgeMethods(ClassNode)",
            " 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228 -\n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250 -\n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  ",
            "    /**\n     * This method is used to add \"bridge\" methods for private methods of an inner/outer\n     * class, so that the outer class is capable of calling them. It does basically\n     * the same job as access$000 like methods in Java.\n     *\n     * @param node an inner/outer class node for which to generate bridge methods\n     */\n    @SuppressWarnings(\"unchecked\")\n    private void addPrivateBridgeMethods(final ClassNode node) {\n        Set<ASTNode> accessedMethods = (Set<ASTNode>) node.getNodeMetaData(StaticTypesMarker.PV_METHODS_ACCESS);\n        if (accessedMethods==null) return;\n        List<MethodNode> methods = new ArrayList<MethodNode>(node.getAllDeclaredMethods());\n        Map<MethodNode, MethodNode> privateBridgeMethods = (Map<MethodNode, MethodNode>) node.getNodeMetaData(PRIVATE_BRIDGE_METHODS);\n        if (privateBridgeMethods!=null) {\n            // private bridge methods already added\n            return;\n        }\n        privateBridgeMethods = new HashMap<MethodNode, MethodNode>();\n        int i=-1;\n        final int access = Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC;\n        for (MethodNode method : methods) {\n            if (accessedMethods.contains(method)) {\n                i++;\n                ClassNode declaringClass = method.getDeclaringClass();\n                Map<String,ClassNode> genericsSpec = createGenericsSpec(node);\n                genericsSpec = addMethodGenerics(method, genericsSpec);\n                extractSuperClassGenerics(node, declaringClass, genericsSpec);\n                Parameter[] methodParameters = method.getParameters();\n                Parameter[] newParams = new Parameter[methodParameters.length+1];\n                for (int j = 1; j < newParams.length; j++) {\n                    Parameter orig = methodParameters[j-1];\n                    newParams[j] = new Parameter(\n                            correctToGenericsSpecRecurse(genericsSpec, orig.getOriginType(),methodSpecificGenerics(method)),\n                            orig.getName()\n                    );\n                }\n                newParams[0] = new Parameter(node.getPlainNodeReference(), \"$that\");\n                Expression arguments;\n                if (method.getParameters()==null || method.getParameters().length==0) {\n                    arguments = ArgumentListExpression.EMPTY_ARGUMENTS;\n                } else {\n                    List<Expression> args = new LinkedList<Expression>();\n                    for (Parameter parameter : methodParameters) {\n                        args.add(new VariableExpression(parameter));\n                    }\n                    arguments = new ArgumentListExpression(args);\n                }\n                Expression receiver = method.isStatic()?new ClassExpression(node):new VariableExpression(newParams[0]);\n                MethodCallExpression mce = new MethodCallExpression(receiver, method.getName(), arguments);\n                mce.setMethodTarget(method);\n\n                ExpressionStatement returnStatement = new ExpressionStatement(mce);\n                MethodNode bridge = node.addMethod(\n                        \"access$\"+i, access,\n                        correctToGenericsSpecRecurse(genericsSpec, method.getReturnType(), methodSpecificGenerics(method)),\n                        newParams,\n                        method.getExceptions(),\n                        returnStatement);\n                privateBridgeMethods.put(method, bridge);\n                bridge.addAnnotation(new AnnotationNode(COMPILESTATIC_CLASSNODE));\n            }\n        }\n        if (!privateBridgeMethods.isEmpty()) {\n            node.setNodeMetaData(PRIVATE_BRIDGE_METHODS, privateBridgeMethods);\n        }\n    }",
            " 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218 +\n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229 +\n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251 +\n 252  \n 253  \n 254  \n 255 +\n 256 +\n 257 +\n 258 +\n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  ",
            "    /**\n     * This method is used to add \"bridge\" methods for private methods of an inner/outer\n     * class, so that the outer class is capable of calling them. It does basically\n     * the same job as access$000 like methods in Java.\n     *\n     * @param node an inner/outer class node for which to generate bridge methods\n     */\n    @SuppressWarnings(\"unchecked\")\n    private void addPrivateBridgeMethods(final ClassNode node) {\n        Set<ASTNode> accessedMethods = (Set<ASTNode>) node.getNodeMetaData(StaticTypesMarker.PV_METHODS_ACCESS);\n        if (accessedMethods==null) return;\n        List<MethodNode> methods = new ArrayList<MethodNode>(node.getAllDeclaredMethods());\n        Map<MethodNode, MethodNode> privateBridgeMethods = (Map<MethodNode, MethodNode>) node.getNodeMetaData(PRIVATE_BRIDGE_METHODS);\n        if (privateBridgeMethods!=null) {\n            // private bridge methods already added\n            return;\n        }\n        privateBridgeMethods = new HashMap<MethodNode, MethodNode>();\n        int i=-1;\n        final int access = Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC;\n        for (MethodNode method : methods) {\n            if (accessedMethods.contains(method)) {\n                List<String> methodSpecificGenerics = methodSpecificGenerics(method);\n                i++;\n                ClassNode declaringClass = method.getDeclaringClass();\n                Map<String,ClassNode> genericsSpec = createGenericsSpec(node);\n                genericsSpec = addMethodGenerics(method, genericsSpec);\n                extractSuperClassGenerics(node, declaringClass, genericsSpec);\n                Parameter[] methodParameters = method.getParameters();\n                Parameter[] newParams = new Parameter[methodParameters.length+1];\n                for (int j = 1; j < newParams.length; j++) {\n                    Parameter orig = methodParameters[j-1];\n                    newParams[j] = new Parameter(\n                            correctToGenericsSpecRecurse(genericsSpec, orig.getOriginType(), methodSpecificGenerics),\n                            orig.getName()\n                    );\n                }\n                newParams[0] = new Parameter(node.getPlainNodeReference(), \"$that\");\n                Expression arguments;\n                if (method.getParameters()==null || method.getParameters().length==0) {\n                    arguments = ArgumentListExpression.EMPTY_ARGUMENTS;\n                } else {\n                    List<Expression> args = new LinkedList<Expression>();\n                    for (Parameter parameter : methodParameters) {\n                        args.add(new VariableExpression(parameter));\n                    }\n                    arguments = new ArgumentListExpression(args);\n                }\n                Expression receiver = method.isStatic()?new ClassExpression(node):new VariableExpression(newParams[0]);\n                MethodCallExpression mce = new MethodCallExpression(receiver, method.getName(), arguments);\n                mce.setMethodTarget(method);\n\n                ExpressionStatement returnStatement = new ExpressionStatement(mce);\n                MethodNode bridge = node.addMethod(\n                        \"access$\"+i, access,\n                        correctToGenericsSpecRecurse(genericsSpec, method.getReturnType(), methodSpecificGenerics),\n                        newParams,\n                        method.getExceptions(),\n                        returnStatement);\n                GenericsType[] origGenericsTypes = method.getGenericsTypes();\n                if (origGenericsTypes !=null) {\n                    bridge.setGenericsTypes(applyGenericsContextToPlaceHolders(genericsSpec,origGenericsTypes));\n                }\n                privateBridgeMethods.put(method, bridge);\n                bridge.addAnnotation(new AnnotationNode(COMPILESTATIC_CLASSNODE));\n            }\n        }\n        if (!privateBridgeMethods.isEmpty()) {\n            node.setNodeMetaData(PRIVATE_BRIDGE_METHODS, privateBridgeMethods);\n        }\n    }"
        ]
    ],
    "d8731a7f9ed0f6d9e6c123f371ef0aca1f5a231f": [
        [
            "StaticTypesCallSiteWriter::isDirectAccessAllowed(FieldNode,ClassNode,boolean)",
            " 633 -\n 634 -\n 635  \n 636  \n 637 -\n 638  \n 639 -\n 640 -\n 641 -\n 642 -\n 643  \n 644  \n 645  \n 646 -\n 647 -\n 648  ",
            "    private static boolean isDirectAccessAllowed(FieldNode a, ClassNode receiver, boolean isSamePackage) {\n        ClassNode declaringClass = a.getDeclaringClass().redirect();\n        ClassNode receiverType = receiver.redirect();\n\n        // first, direct access from within the class or inner class nodes\n        if (declaringClass.equals(receiverType)) return true;\n        if (receiverType instanceof InnerClassNode) {\n            while (receiverType instanceof InnerClassNode) {\n                if (declaringClass.equals(receiverType)) return true;\n                receiverType = receiverType.getOuterClass();\n            }\n        }\n\n        // no getter\n        return a.isPublic() || (a.isProtected() && isSamePackage);\n    }",
            " 633 +\n 634 +\n 635  \n 636  \n 637 +\n 638  \n 639 +\n 640 +\n 641 +\n 642 +\n 643 +\n 644 +\n 645 +\n 646  \n 647 +\n 648  \n 649  \n 650 +\n 651 +\n 652  ",
            "    private static boolean isDirectAccessAllowed(FieldNode field, ClassNode receiver, boolean isSamePackage) {\n        ClassNode declaringClass = field.getDeclaringClass().redirect();\n        ClassNode receiverType = receiver.redirect();\n\n        // first, direct access from within the class\n        if (declaringClass.equals(receiverType)) return true;\n        if (field.isPrivate()) return false;\n\n        // now, inner class node access to outer class fields\n        receiverType = receiverType.getOuterClass();\n        while (receiverType != null) {\n            if (declaringClass.equals(receiverType)) {\n                return true;\n            }\n            receiverType = receiverType.getOuterClass();\n        }\n\n        // finally public and inherited\n        return field.isPublic() || isSamePackage;\n    }"
        ]
    ]
}