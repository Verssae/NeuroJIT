{
    "bf8d0de57b303e3e8b137e21ac96162a9b1fb921": [
        [
            "BlueprintCamelContext::maybeStart()",
            " 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  ",
            "    private void maybeStart() throws Exception {\n        LOG.trace(\"maybeStart: {}\", this);\n\n        // allow to register the BluerintCamelContext eager in the OSGi Service Registry, which ex is needed\n        // for unit testing with camel-test-blueprint\n        boolean eager = \"true\".equalsIgnoreCase(System.getProperty(\"registerBlueprintCamelContextEager\"));\n        if (eager) {\n            for (EventNotifier notifier : getManagementStrategy().getEventNotifiers()) {\n                if (notifier instanceof OsgiCamelContextPublisher) {\n                    OsgiCamelContextPublisher publisher = (OsgiCamelContextPublisher) notifier;\n                    publisher.registerCamelContext(this);\n                    break;\n                }\n            }\n        }\n\n        // for example from unit testing we want to start Camel later and not\n        // when blueprint loading the bundle\n        boolean skip = \"true\".equalsIgnoreCase(System.getProperty(\"skipStartingCamelContext\"));\n        if (skip) {\n            LOG.trace(\"maybeStart: {} is skipping as System property skipStartingCamelContext is set\", this);\n            return;\n        }\n\n        if (!isStarted() && !isStarting()) {\n            LOG.debug(\"Starting {}\", this);\n            start();\n        } else {\n            // ignore as Camel is already started\n            LOG.trace(\"Ignoring maybeStart() as {} is already started\", this);\n        }\n    }",
            " 197  \n 198  \n 199  \n 200 +\n 201 +\n 202 +\n 203 +\n 204 +\n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  ",
            "    private void maybeStart() throws Exception {\n        LOG.trace(\"maybeStart: {}\", this);\n\n        if(!routeDefinitionValid.get()){\n            LOG.trace(\"maybeStart: {} is skipping since CamelRoute definition is not correct.\", this);\n            return;\n        }\n\n        // allow to register the BluerintCamelContext eager in the OSGi Service Registry, which ex is needed\n        // for unit testing with camel-test-blueprint\n        boolean eager = \"true\".equalsIgnoreCase(System.getProperty(\"registerBlueprintCamelContextEager\"));\n        if (eager) {\n            for (EventNotifier notifier : getManagementStrategy().getEventNotifiers()) {\n                if (notifier instanceof OsgiCamelContextPublisher) {\n                    OsgiCamelContextPublisher publisher = (OsgiCamelContextPublisher) notifier;\n                    publisher.registerCamelContext(this);\n                    break;\n                }\n            }\n        }\n\n        // for example from unit testing we want to start Camel later and not\n        // when blueprint loading the bundle\n        boolean skip = \"true\".equalsIgnoreCase(System.getProperty(\"skipStartingCamelContext\"));\n        if (skip) {\n            LOG.trace(\"maybeStart: {} is skipping as System property skipStartingCamelContext is set\", this);\n            return;\n        }\n\n        if (!isStarted() && !isStarting()) {\n            LOG.debug(\"Starting {}\", this);\n            start();\n        } else {\n            // ignore as Camel is already started\n            LOG.trace(\"Ignoring maybeStart() as {} is already started\", this);\n        }\n    }"
        ],
        [
            "BlueprintCamelContext::start()",
            " 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186 -\n 187  \n 188  \n 189  ",
            "    @Override\n    public void start() throws Exception {\n        final ClassLoader original = Thread.currentThread().getContextClassLoader();\n        try {\n            // let's set a more suitable TCCL while starting the context\n            Thread.currentThread().setContextClassLoader(getApplicationContextClassLoader());\n            super.start();\n        } finally {\n            Thread.currentThread().setContextClassLoader(original);\n        }\n    }",
            " 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189 +\n 190 +\n 191 +\n 192 +\n 193  \n 194  \n 195  ",
            "    @Override\n    public void start() throws Exception {\n        final ClassLoader original = Thread.currentThread().getContextClassLoader();\n        try {\n            // let's set a more suitable TCCL while starting the context\n            Thread.currentThread().setContextClassLoader(getApplicationContextClassLoader());\n            super.start();\n        } catch (FailedToCreateRouteException e){\n            routeDefinitionValid.set(false);\n        }\n        finally {\n            Thread.currentThread().setContextClassLoader(original);\n        }\n    }"
        ]
    ],
    "a15cbb47d9459e462e758318e5e9bb7d32e50df4": [
        [
            "BOMResolver::BOMResolver()",
            "  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84 -\n  85  \n  86  \n  87  ",
            "    @SuppressWarnings(\"unchecked\")\n    private BOMResolver() {\n        try {\n            cleanupLocalRepo();\n\n            if (canUseCache()) {\n                try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(CACHE_FILE))) {\n                    this.versions = (Map<String, String>) in.readObject();\n                }\n            } else {\n                retrieveUpstreamBOMVersions();\n\n                CACHE_FILE.delete();\n                try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(CACHE_FILE))) {\n                    out.writeObject(versions);\n                }\n            }\n\n        } catch (Exception e) {\n            throw new IllegalStateException(\"Cannot initialize the version resolver\");\n        }\n\n    }",
            "  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84 +\n  85  \n  86  \n  87  ",
            "    @SuppressWarnings(\"unchecked\")\n    private BOMResolver() {\n        try {\n            cleanupLocalRepo();\n\n            if (canUseCache()) {\n                try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(CACHE_FILE))) {\n                    this.versions = (Map<String, String>) in.readObject();\n                }\n            } else {\n                retrieveUpstreamBOMVersions();\n\n                CACHE_FILE.delete();\n                try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(CACHE_FILE))) {\n                    out.writeObject(versions);\n                }\n            }\n\n        } catch (Exception e) {\n            throw new IllegalStateException(\"Cannot initialize the version resolver\", e);\n        }\n\n    }"
        ],
        [
            "DependencyResolver::resolveSpringBootParentProperty(String)",
            " 101  \n 102 -\n 103  ",
            "    public static String resolveSpringBootParentProperty(String property) {\n        return resolveProperty(camelRoot(\"spring-boot-dm/pom.xml\"), property, 0);\n    }",
            " 101  \n 102 +\n 103  ",
            "    public static String resolveSpringBootParentProperty(String property) {\n        return resolveProperty(camelRoot(\"platforms/spring-boot/spring-boot-dm/pom.xml\"), property, 0);\n    }"
        ],
        [
            "BOMResolver::retrieveUpstreamBOMVersions()",
            " 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112 -\n 113 -\n 114 -\n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  ",
            "    private void retrieveUpstreamBOMVersions() throws Exception {\n        RepositorySystem system = newRepositorySystem();\n        DefaultRepositorySystemSession session = MavenRepositorySystemUtils.newSession();\n        LocalRepository localRepo = new LocalRepository(LOCAL_REPO);\n        session.setLocalRepositoryManager(system.newLocalRepositoryManager(session, localRepo));\n\n        String camelVersion = DependencyResolver.resolveCamelParentProperty(\"${project.version}\");\n\n        List<Artifact> neededArtifacts = new LinkedList<>();\n        neededArtifacts.add(new DefaultArtifact(\"org.apache.camel:camel:pom:\" + camelVersion).setFile(camelRoot(\"pom.xml\")));\n        neededArtifacts.add(new DefaultArtifact(\"org.apache.camel:camel-parent:pom:\" + camelVersion).setFile(camelRoot(\"parent/pom.xml\")));\n        neededArtifacts.add(new DefaultArtifact(\"org.apache.camel:camel-spring-boot-dm:pom:\" + camelVersion).setFile(camelRoot(\"spring-boot-dm/pom.xml\")));\n        neededArtifacts.add(new DefaultArtifact(\"org.apache.camel:camel-spring-boot-dependencies:pom:\" + camelVersion).setFile(camelRoot(\"spring-boot-dm/camel-spring-boot-dependencies/pom.xml\")));\n        Artifact camelSpringBootParent = new DefaultArtifact(\"org.apache.camel:camel-starter-parent:pom:\" + camelVersion).setFile(camelRoot(\"spring-boot-dm/camel-starter-parent/pom.xml\"));\n        neededArtifacts.add(camelSpringBootParent);\n\n        RemoteRepository localRepoDist = new RemoteRepository.Builder(\"org.apache.camel.itest.springboot\", \"default\", new File(LOCAL_REPO).toURI().toString()).build();\n\n        for (Artifact artifact : neededArtifacts) {\n            DeployRequest deployRequest = new DeployRequest();\n            deployRequest.addArtifact(artifact);\n            deployRequest.setRepository(localRepoDist);\n\n            system.deploy(session, deployRequest);\n        }\n\n\n        RemoteRepository mavenCentral = new RemoteRepository.Builder(\"central\", \"default\", \"http://repo1.maven.org/maven2/\").build();\n\n        ArtifactDescriptorRequest dReq = new ArtifactDescriptorRequest(camelSpringBootParent, Arrays.asList(localRepoDist, mavenCentral), null);\n        ArtifactDescriptorResult dRes = system.readArtifactDescriptor(session, dReq);\n\n        this.versions = new TreeMap<>();\n        for (Dependency dependency : dRes.getManagedDependencies()) {\n            Artifact a = dependency.getArtifact();\n            String key = a.getGroupId() + \":\" + a.getArtifactId();\n            versions.put(key, dependency.getArtifact().getVersion());\n        }\n    }",
            " 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112 +\n 113 +\n 114 +\n 115 +\n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  \n 140  ",
            "    private void retrieveUpstreamBOMVersions() throws Exception {\n        RepositorySystem system = newRepositorySystem();\n        DefaultRepositorySystemSession session = MavenRepositorySystemUtils.newSession();\n        LocalRepository localRepo = new LocalRepository(LOCAL_REPO);\n        session.setLocalRepositoryManager(system.newLocalRepositoryManager(session, localRepo));\n\n        String camelVersion = DependencyResolver.resolveCamelParentProperty(\"${project.version}\");\n\n        List<Artifact> neededArtifacts = new LinkedList<>();\n        neededArtifacts.add(new DefaultArtifact(\"org.apache.camel:camel:pom:\" + camelVersion).setFile(camelRoot(\"pom.xml\")));\n        neededArtifacts.add(new DefaultArtifact(\"org.apache.camel:camel-parent:pom:\" + camelVersion).setFile(camelRoot(\"parent/pom.xml\")));\n        neededArtifacts.add(new DefaultArtifact(\"org.apache.camel:spring-boot:pom:\" + camelVersion).setFile(camelRoot(\"platforms/spring-boot/pom.xml\")));\n        neededArtifacts.add(new DefaultArtifact(\"org.apache.camel:camel-spring-boot-dm:pom:\" + camelVersion).setFile(camelRoot(\"platforms/spring-boot/spring-boot-dm/pom.xml\")));\n        neededArtifacts.add(new DefaultArtifact(\"org.apache.camel:camel-spring-boot-dependencies:pom:\" + camelVersion).setFile(camelRoot(\"platforms/spring-boot/spring-boot-dm/camel-spring-boot-dependencies/pom.xml\")));\n        Artifact camelSpringBootParent = new DefaultArtifact(\"org.apache.camel:camel-starter-parent:pom:\" + camelVersion).setFile(camelRoot(\"platforms/spring-boot/spring-boot-dm/camel-starter-parent/pom.xml\"));\n        neededArtifacts.add(camelSpringBootParent);\n\n        RemoteRepository localRepoDist = new RemoteRepository.Builder(\"org.apache.camel.itest.springboot\", \"default\", new File(LOCAL_REPO).toURI().toString()).build();\n\n        for (Artifact artifact : neededArtifacts) {\n            DeployRequest deployRequest = new DeployRequest();\n            deployRequest.addArtifact(artifact);\n            deployRequest.setRepository(localRepoDist);\n\n            system.deploy(session, deployRequest);\n        }\n\n\n        RemoteRepository mavenCentral = new RemoteRepository.Builder(\"central\", \"default\", \"http://repo1.maven.org/maven2/\").build();\n\n        ArtifactDescriptorRequest dReq = new ArtifactDescriptorRequest(camelSpringBootParent, Arrays.asList(localRepoDist, mavenCentral), null);\n        ArtifactDescriptorResult dRes = system.readArtifactDescriptor(session, dReq);\n\n        this.versions = new TreeMap<>();\n        for (Dependency dependency : dRes.getManagedDependencies()) {\n            Artifact a = dependency.getArtifact();\n            String key = a.getGroupId() + \":\" + a.getArtifactId();\n            versions.put(key, dependency.getArtifact().getVersion());\n        }\n    }"
        ]
    ],
    "45527056536d1251e6af2013742d2b13a74a4cbe": [
        [
            "BatchGoogleMailClientFactory::makeClient(String,String,Collection,String,String,String)",
            "  40  \n  41  \n  42 -\n  43  \n  44 -\n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54 -\n  55  \n  56 -\n  57  ",
            "    @Override\n    public Gmail makeClient(String clientId, String clientSecret, Collection<String> scopes, String applicationName, String refreshToken, String accessToken) {\n        Credential credential;\n        try {\n            credential = authorize(clientId, clientSecret, scopes);\n\n            if (refreshToken != null && !\"\".equals(refreshToken)) {\n                credential.setRefreshToken(refreshToken);\n            }\n            if (accessToken != null && !\"\".equals(accessToken)) {\n                credential.setAccessToken(accessToken);\n            }\n            return new Gmail.Builder(transport, jsonFactory, credential).setApplicationName(applicationName).build();\n        } catch (Exception e) {\n            LOG.error(\"Could not create Google Drive client.\", e);\n        }\n        return null;\n    }",
            "  41  \n  42  \n  43 +\n  44 +\n  45 +\n  46  \n  47 +\n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57 +\n  58  \n  59  ",
            "    @Override\n    public Gmail makeClient(String clientId, String clientSecret, Collection<String> scopes, String applicationName, String refreshToken, String accessToken) {\n        if (clientId == null || clientSecret == null) {\n            throw new IllegalArgumentException(\"clientId and clientSecret are required to create Gmail client.\");\n        }\n        try {\n            Credential credential = authorize(clientId, clientSecret, scopes);\n\n            if (refreshToken != null && !\"\".equals(refreshToken)) {\n                credential.setRefreshToken(refreshToken);\n            }\n            if (accessToken != null && !\"\".equals(accessToken)) {\n                credential.setAccessToken(accessToken);\n            }\n            return new Gmail.Builder(transport, jsonFactory, credential).setApplicationName(applicationName).build();\n        } catch (Exception e) {\n            throw new RuntimeCamelException(\"Could not create Gmail client.\", e);\n        }\n    }"
        ],
        [
            "BatchGoogleCalendarClientFactory::makeClient(String,String,Collection,String,String,String,String,String,String)",
            "  43  \n  44  \n  45  \n  46  \n  47  \n  48 -\n  49  \n  50 -\n  51 -\n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64 -\n  65  \n  66 -\n  67  ",
            "    @Override\n    public Calendar makeClient(String clientId, String clientSecret,\n                               Collection<String> scopes, String applicationName, String refreshToken,\n                               String accessToken, String emailAddress, String p12FileName, String user) {\n\n        Credential credential;\n        try {\n            // if emailAddress and p12FileName values are present, assume Google Service Account\n            if (null != emailAddress && !\"\".equals(emailAddress) && null != p12FileName && !\"\".equals(p12FileName)) {\n                credential = authorizeServiceAccount(emailAddress, p12FileName, scopes, user);\n            } else {\n                credential = authorize(clientId, clientSecret, scopes);\n                if (refreshToken != null && !\"\".equals(refreshToken)) {\n                    credential.setRefreshToken(refreshToken);\n                }\n                if (accessToken != null && !\"\".equals(accessToken)) {\n                    credential.setAccessToken(accessToken);\n                }\n            }\n            return new Calendar.Builder(transport, jsonFactory, credential).setApplicationName(applicationName).build();\n        } catch (Exception e) {\n            LOG.error(\"Could not create Google Drive client.\", e);\n        }\n        return null;\n    }",
            "  44  \n  45  \n  46  \n  47  \n  48 +\n  49 +\n  50 +\n  51 +\n  52 +\n  53 +\n  54 +\n  55 +\n  56  \n  57  \n  58 +\n  59 +\n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72 +\n  73  \n  74  ",
            "    @Override\n    public Calendar makeClient(String clientId, String clientSecret,\n                               Collection<String> scopes, String applicationName, String refreshToken,\n                               String accessToken, String emailAddress, String p12FileName, String user) {\n        boolean serviceAccount = false;\n        // if emailAddress and p12FileName values are present, assume Google Service Account\n        if (null != emailAddress && !\"\".equals(emailAddress) && null != p12FileName && !\"\".equals(p12FileName)) {\n            serviceAccount = true;\n        }\n        if (!serviceAccount && (clientId == null || clientSecret == null)) {\n            throw new IllegalArgumentException(\"clientId and clientSecret are required to create Google Calendar client.\");\n        }\n\n        try {\n            Credential credential;\n            if (serviceAccount) {\n                credential = authorizeServiceAccount(emailAddress, p12FileName, scopes, user);\n            } else {\n                credential = authorize(clientId, clientSecret, scopes);\n                if (refreshToken != null && !\"\".equals(refreshToken)) {\n                    credential.setRefreshToken(refreshToken);\n                }\n                if (accessToken != null && !\"\".equals(accessToken)) {\n                    credential.setAccessToken(accessToken);\n                }\n            }\n            return new Calendar.Builder(transport, jsonFactory, credential).setApplicationName(applicationName).build();\n        } catch (Exception e) {\n            throw new RuntimeCamelException(\"Could not create Google Calendar client.\", e);\n        }\n    }"
        ],
        [
            "BatchGoogleDriveClientFactory::makeClient(String,String,Collection,String,String,String)",
            "  40  \n  41  \n  42 -\n  43  \n  44 -\n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54 -\n  55  \n  56 -\n  57  ",
            "    @Override\n    public Drive makeClient(String clientId, String clientSecret, Collection<String> scopes, String applicationName, String refreshToken, String accessToken) {\n        Credential credential;\n        try {\n            credential = authorize(clientId, clientSecret, scopes);\n\n            if (refreshToken != null && !\"\".equals(refreshToken)) {\n                credential.setRefreshToken(refreshToken);\n            } \n            if (accessToken != null && !\"\".equals(accessToken)) {\n                credential.setAccessToken(accessToken);\n            }\n            return new Drive.Builder(transport, jsonFactory, credential).setApplicationName(applicationName).build();\n        } catch (Exception e) {\n            LOG.error(\"Could not create Google Drive client.\", e);            \n        }\n        return null;\n    }",
            "  41  \n  42  \n  43 +\n  44 +\n  45 +\n  46  \n  47 +\n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57 +\n  58  \n  59  ",
            "    @Override\n    public Drive makeClient(String clientId, String clientSecret, Collection<String> scopes, String applicationName, String refreshToken, String accessToken) {\n        if (clientId == null || clientSecret == null) {\n            throw new IllegalArgumentException(\"clientId and clientSecret are required to create Google Drive client.\");\n        }\n        try {\n            Credential credential = authorize(clientId, clientSecret, scopes);\n\n            if (refreshToken != null && !\"\".equals(refreshToken)) {\n                credential.setRefreshToken(refreshToken);\n            } \n            if (accessToken != null && !\"\".equals(accessToken)) {\n                credential.setAccessToken(accessToken);\n            }\n            return new Drive.Builder(transport, jsonFactory, credential).setApplicationName(applicationName).build();\n        } catch (Exception e) {\n            throw new RuntimeCamelException(\"Could not create Google Drive client.\", e);\n        }\n    }"
        ]
    ],
    "409427932593ac2003a487435fe9cd9682326b2b": [
        [
            "DefaultNettyHttpBinding::toNettyRequest(Message,String,NettyHttpConfiguration)",
            " 472  \n 473  \n 474  \n 475  \n 476  \n 477  \n 478  \n 479  \n 480  \n 481  \n 482  \n 483  \n 484  \n 485  \n 486  \n 487  \n 488  \n 489  \n 490  \n 491  \n 492  \n 493  \n 494  \n 495  \n 496  \n 497  \n 498  \n 499  \n 500  \n 501  \n 502  \n 503  \n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512 -\n 513 -\n 514 -\n 515 -\n 516 -\n 517 -\n 518 -\n 519 -\n 520 -\n 521 -\n 522 -\n 523 -\n 524 -\n 525 -\n 526 -\n 527  \n 528  \n 529  \n 530  \n 531 -\n 532 -\n 533 -\n 534 -\n 535 -\n 536 -\n 537 -\n 538  \n 539  \n 540 -\n 541 -\n 542 -\n 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564  \n 565  \n 566  \n 567  \n 568  \n 569  \n 570  \n 571  \n 572  \n 573  \n 574  \n 575  \n 576  \n 577  \n 578  \n 579  \n 580  \n 581  \n 582  \n 583  \n 584  \n 585  \n 586  \n 587  \n 588  \n 589  \n 590  \n 591  \n 592  \n 593  \n 594  \n 595  \n 596  \n 597  \n 598  \n 599  \n 600  \n 601  \n 602  \n 603  \n 604  \n 605  \n 606  \n 607  \n 608  \n 609  \n 610  \n 611  \n 612  \n 613  ",
            "    @Override\n    public HttpRequest toNettyRequest(Message message, String fullUri, NettyHttpConfiguration configuration) throws Exception {\n        LOG.trace(\"toNettyRequest: {}\", message);\n\n        Object body = message.getBody();\n        // the message body may already be a Netty HTTP response\n        if (body instanceof HttpRequest) {\n            return (HttpRequest) message.getBody();\n        }\n\n        String uriForRequest = fullUri;\n        if (configuration.isUseRelativePath()) {\n            final URI uri = new URI(uriForRequest);\n            final String rawPath = uri.getRawPath();\n            if (rawPath != null) {\n                uriForRequest = rawPath;\n            }\n            final String rawQuery = uri.getRawQuery();\n            if (rawQuery != null) {\n                uriForRequest += \"?\" + rawQuery;\n            }\n        }\n\n        final String headerProtocolVersion = message.getHeader(Exchange.HTTP_PROTOCOL_VERSION, String.class);\n        final HttpVersion protocol;\n        if (headerProtocolVersion == null) {\n            protocol = HttpVersion.HTTP_1_1;\n        } else {\n            protocol = HttpVersion.valueOf(headerProtocolVersion);\n        }\n\n        final String headerMethod = message.getHeader(Exchange.HTTP_METHOD, String.class);\n\n        final HttpMethod httpMethod;\n        if (headerMethod == null) {\n            httpMethod = HttpMethod.GET;\n        } else {\n            httpMethod = HttpMethod.valueOf(headerMethod);\n        }\n\n        FullHttpRequest request = new DefaultFullHttpRequest(protocol, httpMethod, uriForRequest);\n        if (body != null) {\n            // support bodies as native Netty\n            ByteBuf buffer;\n            if (body instanceof ByteBuf) {\n                buffer = (ByteBuf) body;\n            } else {\n                // try to convert to buffer first\n                buffer = message.getBody(ByteBuf.class);\n                if (buffer == null) {\n                    // fallback to byte array as last resort\n                    byte[] data = message.getMandatoryBody(byte[].class);\n\n                    if (data.length > 0) {\n                        buffer = NettyConverter.toByteBuffer(data);\n                    }\n                }\n            }\n\n            if (buffer != null && buffer.readableBytes() > 0) {\n                request = request.replace(buffer);\n                int len = buffer.readableBytes();\n                // set content-length\n                request.headers().set(HttpHeaderNames.CONTENT_LENGTH.toString(), len);\n                LOG.trace(\"Content-Length: {}\", len);\n            }\n        }\n\n        // update HTTP method accordingly as we know if we have a body or not\n        HttpMethod method = NettyHttpHelper.createMethod(message, body != null);\n        request.setMethod(method);\n\n        TypeConverter tc = message.getExchange().getContext().getTypeConverter();\n\n        // if we bridge endpoint then we need to skip matching headers with the HTTP_QUERY to avoid sending\n        // duplicated headers to the receiver, so use this skipRequestHeaders as the list of headers to skip\n        Map<String, Object> skipRequestHeaders = null;\n        if (configuration.isBridgeEndpoint()) {\n            String queryString = message.getHeader(Exchange.HTTP_QUERY, String.class);\n            if (queryString != null) {\n                skipRequestHeaders = URISupport.parseQuery(queryString, false, true);\n            }\n            // Need to remove the Host key as it should be not used\n            message.getHeaders().remove(\"host\");\n        }\n\n        // append headers\n        // must use entrySet to ensure case of keys is preserved\n        for (Map.Entry<String, Object> entry : message.getHeaders().entrySet()) {\n            String key = entry.getKey();\n            Object value = entry.getValue();\n\n            // we should not add headers for the parameters in the uri if we bridge the endpoint\n            // as then we would duplicate headers on both the endpoint uri, and in HTTP headers as well\n            if (skipRequestHeaders != null && skipRequestHeaders.containsKey(key)) {\n                continue;\n            }\n\n            // use an iterator as there can be multiple values. (must not use a delimiter)\n            final Iterator<?> it = ObjectHelper.createIterator(value, null, true);\n            while (it.hasNext()) {\n                String headerValue = tc.convertTo(String.class, it.next());\n\n                if (headerValue != null && headerFilterStrategy != null\n                        && !headerFilterStrategy.applyFilterToCamelHeaders(key, headerValue, message.getExchange())) {\n                    LOG.trace(\"HTTP-Header: {}={}\", key, headerValue);\n                    request.headers().add(key, headerValue);\n                }\n            }\n        }\n\n        // set the content type in the response.\n        String contentType = MessageHelper.getContentType(message);\n        if (contentType != null) {\n            // set content-type\n            request.headers().set(HttpHeaderNames.CONTENT_TYPE.toString(), contentType);\n            LOG.trace(\"Content-Type: {}\", contentType);\n        }\n\n        // must include HOST header as required by HTTP 1.1\n        // use URI as its faster than URL (no DNS lookup)\n        URI u = new URI(fullUri);\n        String hostHeader = u.getHost() + (u.getPort() == 80 ? \"\" : \":\" + u.getPort());\n        request.headers().set(HttpHeaderNames.HOST.toString(), hostHeader);\n        LOG.trace(\"Host: {}\", hostHeader);\n\n        // configure connection to accordingly to keep alive configuration\n        // favor using the header from the message\n        String connection = message.getHeader(HttpHeaderNames.CONNECTION.toString(), String.class);\n        if (connection == null) {\n            // fallback and use the keep alive from the configuration\n            if (configuration.isKeepAlive()) {\n                connection = HttpHeaderValues.KEEP_ALIVE.toString();\n            } else {\n                connection = HttpHeaderValues.CLOSE.toString();\n            }\n        }\n        request.headers().set(HttpHeaderNames.CONNECTION.toString(), connection);\n        LOG.trace(\"Connection: {}\", connection);\n\n        return request;\n    }",
            " 472  \n 473  \n 474  \n 475  \n 476  \n 477  \n 478  \n 479  \n 480  \n 481  \n 482  \n 483  \n 484  \n 485  \n 486  \n 487  \n 488  \n 489  \n 490  \n 491  \n 492  \n 493  \n 494  \n 495  \n 496  \n 497  \n 498  \n 499  \n 500  \n 501  \n 502  \n 503  \n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512 +\n 513 +\n 514 +\n 515 +\n 516 +\n 517 +\n 518 +\n 519 +\n 520 +\n 521 +\n 522 +\n 523 +\n 524 +\n 525 +\n 526 +\n 527 +\n 528 +\n 529 +\n 530 +\n 531 +\n 532 +\n 533 +\n 534 +\n 535 +\n 536 +\n 537 +\n 538 +\n 539 +\n 540 +\n 541 +\n 542 +\n 543 +\n 544 +\n 545 +\n 546 +\n 547 +\n 548 +\n 549 +\n 550 +\n 551 +\n 552 +\n 553 +\n 554 +\n 555 +\n 556 +\n 557 +\n 558 +\n 559 +\n 560 +\n 561 +\n 562 +\n 563 +\n 564 +\n 565  \n 566  \n 567  \n 568  \n 569 +\n 570 +\n 571 +\n 572  \n 573  \n 574  \n 575  \n 576  \n 577  \n 578  \n 579  \n 580  \n 581  \n 582  \n 583  \n 584  \n 585  \n 586  \n 587  \n 588  \n 589  \n 590  \n 591  \n 592  \n 593  \n 594  \n 595  \n 596  \n 597  \n 598  \n 599  \n 600  \n 601  \n 602  \n 603  \n 604  \n 605  \n 606  \n 607  \n 608  \n 609  \n 610  \n 611  \n 612  \n 613  \n 614  \n 615  \n 616  \n 617  \n 618  \n 619  \n 620  \n 621  \n 622  \n 623  \n 624  \n 625  \n 626  \n 627  \n 628  \n 629  \n 630  \n 631  \n 632  \n 633  \n 634  \n 635  \n 636  \n 637  \n 638  \n 639  \n 640  \n 641  \n 642  \n 643  \n 644  ",
            "    @Override\n    public HttpRequest toNettyRequest(Message message, String fullUri, NettyHttpConfiguration configuration) throws Exception {\n        LOG.trace(\"toNettyRequest: {}\", message);\n\n        Object body = message.getBody();\n        // the message body may already be a Netty HTTP response\n        if (body instanceof HttpRequest) {\n            return (HttpRequest) message.getBody();\n        }\n\n        String uriForRequest = fullUri;\n        if (configuration.isUseRelativePath()) {\n            final URI uri = new URI(uriForRequest);\n            final String rawPath = uri.getRawPath();\n            if (rawPath != null) {\n                uriForRequest = rawPath;\n            }\n            final String rawQuery = uri.getRawQuery();\n            if (rawQuery != null) {\n                uriForRequest += \"?\" + rawQuery;\n            }\n        }\n\n        final String headerProtocolVersion = message.getHeader(Exchange.HTTP_PROTOCOL_VERSION, String.class);\n        final HttpVersion protocol;\n        if (headerProtocolVersion == null) {\n            protocol = HttpVersion.HTTP_1_1;\n        } else {\n            protocol = HttpVersion.valueOf(headerProtocolVersion);\n        }\n\n        final String headerMethod = message.getHeader(Exchange.HTTP_METHOD, String.class);\n\n        final HttpMethod httpMethod;\n        if (headerMethod == null) {\n            httpMethod = HttpMethod.GET;\n        } else {\n            httpMethod = HttpMethod.valueOf(headerMethod);\n        }\n\n        final Exchange exchange = message.getExchange();\n        final Object proxyRequest;\n        if (exchange != null) {\n            proxyRequest = exchange.getProperty(NettyHttpConstants.PROXY_REQUEST);\n        } else {\n            proxyRequest = null;\n        }\n\n        FullHttpRequest request = null;\n        if (message instanceof NettyHttpMessage) {\n            // if the request is already given we should set the values\n            // from message headers and pass on the same request\n            final FullHttpRequest givenRequest = ((NettyHttpMessage) message).getHttpRequest();\n            // we need to make sure that the givenRequest is the original\n            // request received by the proxy\n            if (givenRequest != null && proxyRequest == givenRequest) {\n                request = givenRequest\n                        .setProtocolVersion(protocol)\n                        .setMethod(httpMethod)\n                        .setUri(uriForRequest);\n            }\n        }\n\n        if (request == null) {\n            request = new DefaultFullHttpRequest(protocol, httpMethod, uriForRequest);\n\n            if (body != null) {\n                // support bodies as native Netty\n                ByteBuf buffer;\n                if (body instanceof ByteBuf) {\n                    buffer = (ByteBuf) body;\n                } else {\n                    // try to convert to buffer first\n                    buffer = message.getBody(ByteBuf.class);\n                    if (buffer == null) {\n                        // fallback to byte array as last resort\n                        byte[] data = message.getMandatoryBody(byte[].class);\n    \n                        if (data.length > 0) {\n                            buffer = NettyConverter.toByteBuffer(data);\n                        }\n                    }\n                }\n    \n                if (buffer != null) {\n                    if (buffer.readableBytes() > 0) {\n                        request = request.replace(buffer);\n                        int len = buffer.readableBytes();\n                        // set content-length\n                        request.headers().set(HttpHeaderNames.CONTENT_LENGTH.toString(), len);\n                        LOG.trace(\"Content-Length: {}\", len);\n                    } else {\n                        buffer.release();\n                    }\n                }\n            }\n\n            // update HTTP method accordingly as we know if we have a body or not\n            HttpMethod method = NettyHttpHelper.createMethod(message, body != null);\n            request.setMethod(method);\n        }\n\n\n        TypeConverter tc = message.getExchange().getContext().getTypeConverter();\n\n        // if we bridge endpoint then we need to skip matching headers with the HTTP_QUERY to avoid sending\n        // duplicated headers to the receiver, so use this skipRequestHeaders as the list of headers to skip\n        Map<String, Object> skipRequestHeaders = null;\n        if (configuration.isBridgeEndpoint()) {\n            String queryString = message.getHeader(Exchange.HTTP_QUERY, String.class);\n            if (queryString != null) {\n                skipRequestHeaders = URISupport.parseQuery(queryString, false, true);\n            }\n            // Need to remove the Host key as it should be not used\n            message.getHeaders().remove(\"host\");\n        }\n\n        // append headers\n        // must use entrySet to ensure case of keys is preserved\n        for (Map.Entry<String, Object> entry : message.getHeaders().entrySet()) {\n            String key = entry.getKey();\n            Object value = entry.getValue();\n\n            // we should not add headers for the parameters in the uri if we bridge the endpoint\n            // as then we would duplicate headers on both the endpoint uri, and in HTTP headers as well\n            if (skipRequestHeaders != null && skipRequestHeaders.containsKey(key)) {\n                continue;\n            }\n\n            // use an iterator as there can be multiple values. (must not use a delimiter)\n            final Iterator<?> it = ObjectHelper.createIterator(value, null, true);\n            while (it.hasNext()) {\n                String headerValue = tc.convertTo(String.class, it.next());\n\n                if (headerValue != null && headerFilterStrategy != null\n                        && !headerFilterStrategy.applyFilterToCamelHeaders(key, headerValue, message.getExchange())) {\n                    LOG.trace(\"HTTP-Header: {}={}\", key, headerValue);\n                    request.headers().add(key, headerValue);\n                }\n            }\n        }\n\n        // set the content type in the response.\n        String contentType = MessageHelper.getContentType(message);\n        if (contentType != null) {\n            // set content-type\n            request.headers().set(HttpHeaderNames.CONTENT_TYPE.toString(), contentType);\n            LOG.trace(\"Content-Type: {}\", contentType);\n        }\n\n        // must include HOST header as required by HTTP 1.1\n        // use URI as its faster than URL (no DNS lookup)\n        URI u = new URI(fullUri);\n        String hostHeader = u.getHost() + (u.getPort() == 80 ? \"\" : \":\" + u.getPort());\n        request.headers().set(HttpHeaderNames.HOST.toString(), hostHeader);\n        LOG.trace(\"Host: {}\", hostHeader);\n\n        // configure connection to accordingly to keep alive configuration\n        // favor using the header from the message\n        String connection = message.getHeader(HttpHeaderNames.CONNECTION.toString(), String.class);\n        if (connection == null) {\n            // fallback and use the keep alive from the configuration\n            if (configuration.isKeepAlive()) {\n                connection = HttpHeaderValues.KEEP_ALIVE.toString();\n            } else {\n                connection = HttpHeaderValues.CLOSE.toString();\n            }\n        }\n        request.headers().set(HttpHeaderNames.CONNECTION.toString(), connection);\n        LOG.trace(\"Connection: {}\", connection);\n\n        return request;\n    }"
        ],
        [
            "HttpServerChannelHandler::beforeProcess(Exchange,ChannelHandlerContext,Object)",
            " 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  ",
            "    @Override\n    protected void beforeProcess(Exchange exchange, final ChannelHandlerContext ctx, final Object message) {\n        final NettyHttpConfiguration configuration = consumer.getConfiguration();\n\n        if (configuration.isBridgeEndpoint()) {\n            exchange.setProperty(Exchange.SKIP_GZIP_ENCODING, Boolean.TRUE);\n            exchange.setProperty(Exchange.SKIP_WWW_FORM_URLENCODED, Boolean.TRUE);\n        }\n        HttpRequest request = (HttpRequest) message;\n        // setup the connection property in case of the message header is removed\n        boolean keepAlive = HttpUtil.isKeepAlive(request);\n        if (!keepAlive) {\n            // Just make sure we close the connection this time.\n            exchange.setProperty(HttpHeaderNames.CONNECTION.toString(), HttpHeaderValues.CLOSE.toString());\n        }\n\n        final Message in = exchange.getIn();\n        if (configuration.isHttpProxy()) {\n            in.removeHeader(\"Proxy-Connection\");\n        }\n    }",
            " 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286 +\n 287  \n 288  \n 289  ",
            "    @Override\n    protected void beforeProcess(Exchange exchange, final ChannelHandlerContext ctx, final Object message) {\n        final NettyHttpConfiguration configuration = consumer.getConfiguration();\n\n        if (configuration.isBridgeEndpoint()) {\n            exchange.setProperty(Exchange.SKIP_GZIP_ENCODING, Boolean.TRUE);\n            exchange.setProperty(Exchange.SKIP_WWW_FORM_URLENCODED, Boolean.TRUE);\n        }\n        HttpRequest request = (HttpRequest) message;\n        // setup the connection property in case of the message header is removed\n        boolean keepAlive = HttpUtil.isKeepAlive(request);\n        if (!keepAlive) {\n            // Just make sure we close the connection this time.\n            exchange.setProperty(HttpHeaderNames.CONNECTION.toString(), HttpHeaderValues.CLOSE.toString());\n        }\n\n        final Message in = exchange.getIn();\n        if (configuration.isHttpProxy()) {\n            exchange.setProperty(NettyHttpConstants.PROXY_REQUEST, request);\n            in.removeHeader(\"Proxy-Connection\");\n        }\n    }"
        ]
    ],
    "e61138b9f2834bf4a3d0c3e8cf868e5de8faea70": [
        [
            "PlatformEventsConsumerIntegrationTest::shouldConsumePlatformEvents()",
            "  35  \n  36  \n  37  \n  38  \n  39 -\n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  ",
            "    @Test\n    public void shouldConsumePlatformEvents() throws InterruptedException, ExecutionException {\n        final ExecutorService parallel = Executors.newSingleThreadExecutor();\n\n        final Future<PlatformEvent> futurePlatformEvent = parallel.submit(() -> consumer.receiveBody(\"salesforce:event/TestEvent__e\", PlatformEvent.class));\n\n        // it takes some time for the subscriber to subscribe, so we'll try to\n        // send repeated platform events and wait until the first one is\n        // received\n        Awaitility.await().atMost(10, TimeUnit.SECONDS).untilAsserted(() -> {\n            template.sendBody(\"direct:sendPlatformEvent\", \"{\\\"Test_Field__c\\\": \\\"data\\\"}\");\n\n            Assertions.assertThat(futurePlatformEvent.isDone()).isTrue();\n        });\n\n        final PlatformEvent platformEvent = futurePlatformEvent.get();\n        Assertions.assertThat(platformEvent).isNotNull();\n        Assertions.assertThat(platformEvent.getEventData()).containsOnly(entry(\"Test_Field__c\", \"data\"));\n    }",
            "  35  \n  36  \n  37  \n  38  \n  39 +\n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  ",
            "    @Test\n    public void shouldConsumePlatformEvents() throws InterruptedException, ExecutionException {\n        final ExecutorService parallel = Executors.newSingleThreadExecutor();\n\n        final Future<PlatformEvent> futurePlatformEvent = parallel.submit(() -> consumer.receiveBody(\"salesforce:event/TestEvent__e?replayId=-1\", PlatformEvent.class));\n\n        // it takes some time for the subscriber to subscribe, so we'll try to\n        // send repeated platform events and wait until the first one is\n        // received\n        Awaitility.await().atMost(10, TimeUnit.SECONDS).untilAsserted(() -> {\n            template.sendBody(\"direct:sendPlatformEvent\", \"{\\\"Test_Field__c\\\": \\\"data\\\"}\");\n\n            Assertions.assertThat(futurePlatformEvent.isDone()).isTrue();\n        });\n\n        final PlatformEvent platformEvent = futurePlatformEvent.get();\n        Assertions.assertThat(platformEvent).isNotNull();\n        Assertions.assertThat(platformEvent.getEventData()).containsOnly(entry(\"Test_Field__c\", \"data\"));\n    }"
        ],
        [
            "HttpProxyIntegrationTest::setupServer()",
            "  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123 -\n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  ",
            "    @BeforeClass\n    public static void setupServer() throws Exception {\n        // start a local HTTP proxy using Jetty server\n        server = new Server();\n\n        ServerConnector connector = new ServerConnector(server);\n\n        connector.setHost(HTTP_PROXY_HOST);\n        server.addConnector(connector);\n\n        final String authenticationString = \"Basic \"\n            + B64Code.encode(HTTP_PROXY_USER_NAME + \":\" + HTTP_PROXY_PASSWORD, StringUtil.__ISO_8859_1);\n\n        ConnectHandler connectHandler = new ConnectHandler() {\n            @Override\n            protected boolean handleAuthentication(HttpServletRequest request, HttpServletResponse response, String address) {\n                // validate proxy-authentication header\n                final String header = request.getHeader(PROXY_AUTHORIZATION.toString());\n                if (!authenticationString.equals(header)) {\n                    LOG.warn(\"Missing header \" + PROXY_AUTHORIZATION);\n                    // ask for authentication header\n                    response.setHeader(PROXY_AUTHENTICATE.toString(), String.format(\"Basic realm=\\\"%s\\\"\", HTTP_PROXY_REALM));\n                    return false;\n                }\n                LOG.info(\"Request contains required header \" + PROXY_AUTHORIZATION);\n                WENT_TORUGH_PROXY.set(true);\n                return true;\n            }\n        };\n        server.setHandler(connectHandler);\n\n        LOG.info(\"Starting proxy server...\");\n        server.start();\n\n        httpProxyPort = connector.getLocalPort();\n        LOG.info(\"Started proxy server on port {}\", httpProxyPort);\n    }",
            "  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123 +\n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  ",
            "    @BeforeClass\n    public static void setupServer() throws Exception {\n        // start a local HTTP proxy using Jetty server\n        server = new Server();\n\n        ServerConnector connector = new ServerConnector(server);\n\n        connector.setHost(HTTP_PROXY_HOST);\n        server.addConnector(connector);\n\n        final String authenticationString = \"Basic \"\n            + B64Code.encode(HTTP_PROXY_USER_NAME + \":\" + HTTP_PROXY_PASSWORD, StringUtil.__ISO_8859_1);\n\n        ConnectHandler connectHandler = new ConnectHandler() {\n            @Override\n            protected boolean handleAuthentication(HttpServletRequest request, HttpServletResponse response, String address) {\n                // validate proxy-authentication header\n                final String header = request.getHeader(PROXY_AUTHORIZATION.toString());\n                if (!authenticationString.equals(header)) {\n                    LOG.warn(\"Missing header \" + PROXY_AUTHORIZATION);\n                    // ask for authentication header\n                    response.setHeader(PROXY_AUTHENTICATE.toString(), String.format(\"Basic realm=\\\"%s\\\"\", HTTP_PROXY_REALM));\n                    return false;\n                }\n                LOG.info(\"Request contains required header \" + PROXY_AUTHORIZATION);\n                WENT_THROUGH_PROXY.set(true);\n                return true;\n            }\n        };\n        server.setHandler(connectHandler);\n\n        LOG.info(\"Starting proxy server...\");\n        server.start();\n\n        httpProxyPort = connector.getLocalPort();\n        LOG.info(\"Started proxy server on port {}\", httpProxyPort);\n    }"
        ],
        [
            "SalesforceComponentVerifierExtension::verifyConnectivity(Map)",
            "  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80 -\n  81 -\n  82  \n  83  \n  84  \n  85 -\n  86 -\n  87 -\n  88 -\n  89 -\n  90  \n  91 -\n  92 -\n  93 -\n  94  \n  95  \n  96  \n  97  ",
            "    @Override\n    protected Result verifyConnectivity(Map<String, Object> parameters) {\n        // Default is success\n        ResultBuilder builder = ResultBuilder.withStatusAndScope(Result.Status.OK, Scope.CONNECTIVITY);\n\n        try {\n            SalesforceClientTemplate.invoke(getCamelContext(), parameters, client -> {\n                client.getVersions(Collections.emptyMap(),\n                    (response, headers, exception) ->  processSalesforceException(builder, Optional.ofNullable(exception)));\n                return null;\n            });\n        } catch (NoSuchOptionException e) {\n            builder.error(\n                ResultErrorBuilder.withMissingOption(e.getOptionName()).build()\n            );\n        } catch (SalesforceException e) {\n            processSalesforceException(builder, Optional.of(e));\n        } catch (Exception e) {\n            builder.error(\n                ResultErrorBuilder.withException(e).build()\n            );\n        }\n\n        return builder.build();\n    }",
            "  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80 +\n  81  \n  82  \n  83  \n  84 +\n  85  \n  86 +\n  87 +\n  88 +\n  89 +\n  90 +\n  91  \n  92  \n  93  \n  94  ",
            "    @Override\n    protected Result verifyConnectivity(Map<String, Object> parameters) {\n        // Default is success\n        ResultBuilder builder = ResultBuilder.withStatusAndScope(Result.Status.OK, Scope.CONNECTIVITY);\n\n        try {\n            SalesforceClientTemplate.invoke(getCamelContext(), parameters, client -> {\n                client.getVersions(Collections.emptyMap(), (response, headers, exception) -> processSalesforceException(builder, Optional.ofNullable(exception)));\n                return null;\n            });\n        } catch (NoSuchOptionException e) {\n            builder.error(ResultErrorBuilder.withMissingOption(e.getOptionName()).build());\n        } catch (Exception e) {\n            if (e.getCause() instanceof SalesforceException) {\n                processSalesforceException(builder, Optional.of((SalesforceException)e.getCause()));\n            } else {\n                builder.error(ResultErrorBuilder.withException(e).build());\n            }\n        }\n\n        return builder.build();\n    }"
        ],
        [
            "HttpProxyIntegrationTest::testGetVersions()",
            "  75  \n  76  \n  77  \n  78  \n  79  \n  80 -\n  81  ",
            "    @Test\n    public void testGetVersions() throws Exception {\n        doTestGetVersions(\"\");\n        doTestGetVersions(\"Xml\");\n\n        assertTrue(\"Should have gone through the test proxy\", WENT_TORUGH_PROXY.get());\n    }",
            "  75  \n  76  \n  77  \n  78  \n  79  \n  80 +\n  81  ",
            "    @Test\n    public void testGetVersions() throws Exception {\n        doTestGetVersions(\"\");\n        doTestGetVersions(\"Xml\");\n\n        assertTrue(\"Should have gone through the test proxy\", WENT_THROUGH_PROXY.get());\n    }"
        ]
    ]
}