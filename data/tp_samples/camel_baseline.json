{
    "bf8d0de57b303e3e8b137e21ac96162a9b1fb921": [
        [
            "BlueprintCamelContext::maybeStart()",
            " 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  ",
            "    private void maybeStart() throws Exception {\n        LOG.trace(\"maybeStart: {}\", this);\n\n        // allow to register the BluerintCamelContext eager in the OSGi Service Registry, which ex is needed\n        // for unit testing with camel-test-blueprint\n        boolean eager = \"true\".equalsIgnoreCase(System.getProperty(\"registerBlueprintCamelContextEager\"));\n        if (eager) {\n            for (EventNotifier notifier : getManagementStrategy().getEventNotifiers()) {\n                if (notifier instanceof OsgiCamelContextPublisher) {\n                    OsgiCamelContextPublisher publisher = (OsgiCamelContextPublisher) notifier;\n                    publisher.registerCamelContext(this);\n                    break;\n                }\n            }\n        }\n\n        // for example from unit testing we want to start Camel later and not\n        // when blueprint loading the bundle\n        boolean skip = \"true\".equalsIgnoreCase(System.getProperty(\"skipStartingCamelContext\"));\n        if (skip) {\n            LOG.trace(\"maybeStart: {} is skipping as System property skipStartingCamelContext is set\", this);\n            return;\n        }\n\n        if (!isStarted() && !isStarting()) {\n            LOG.debug(\"Starting {}\", this);\n            start();\n        } else {\n            // ignore as Camel is already started\n            LOG.trace(\"Ignoring maybeStart() as {} is already started\", this);\n        }\n    }",
            " 197  \n 198  \n 199  \n 200 +\n 201 +\n 202 +\n 203 +\n 204 +\n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  ",
            "    private void maybeStart() throws Exception {\n        LOG.trace(\"maybeStart: {}\", this);\n\n        if(!routeDefinitionValid.get()){\n            LOG.trace(\"maybeStart: {} is skipping since CamelRoute definition is not correct.\", this);\n            return;\n        }\n\n        // allow to register the BluerintCamelContext eager in the OSGi Service Registry, which ex is needed\n        // for unit testing with camel-test-blueprint\n        boolean eager = \"true\".equalsIgnoreCase(System.getProperty(\"registerBlueprintCamelContextEager\"));\n        if (eager) {\n            for (EventNotifier notifier : getManagementStrategy().getEventNotifiers()) {\n                if (notifier instanceof OsgiCamelContextPublisher) {\n                    OsgiCamelContextPublisher publisher = (OsgiCamelContextPublisher) notifier;\n                    publisher.registerCamelContext(this);\n                    break;\n                }\n            }\n        }\n\n        // for example from unit testing we want to start Camel later and not\n        // when blueprint loading the bundle\n        boolean skip = \"true\".equalsIgnoreCase(System.getProperty(\"skipStartingCamelContext\"));\n        if (skip) {\n            LOG.trace(\"maybeStart: {} is skipping as System property skipStartingCamelContext is set\", this);\n            return;\n        }\n\n        if (!isStarted() && !isStarting()) {\n            LOG.debug(\"Starting {}\", this);\n            start();\n        } else {\n            // ignore as Camel is already started\n            LOG.trace(\"Ignoring maybeStart() as {} is already started\", this);\n        }\n    }"
        ],
        [
            "BlueprintCamelContext::start()",
            " 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186 -\n 187  \n 188  \n 189  ",
            "    @Override\n    public void start() throws Exception {\n        final ClassLoader original = Thread.currentThread().getContextClassLoader();\n        try {\n            // let's set a more suitable TCCL while starting the context\n            Thread.currentThread().setContextClassLoader(getApplicationContextClassLoader());\n            super.start();\n        } finally {\n            Thread.currentThread().setContextClassLoader(original);\n        }\n    }",
            " 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189 +\n 190 +\n 191 +\n 192 +\n 193  \n 194  \n 195  ",
            "    @Override\n    public void start() throws Exception {\n        final ClassLoader original = Thread.currentThread().getContextClassLoader();\n        try {\n            // let's set a more suitable TCCL while starting the context\n            Thread.currentThread().setContextClassLoader(getApplicationContextClassLoader());\n            super.start();\n        } catch (FailedToCreateRouteException e){\n            routeDefinitionValid.set(false);\n        }\n        finally {\n            Thread.currentThread().setContextClassLoader(original);\n        }\n    }"
        ]
    ],
    "5737fe6086f60f9421c54e0096d5887f1449dc11": [
        [
            "IOConverter::toInputStream(File,String)",
            "  81  \n  82  \n  83  \n  84 -\n  85  \n  86  \n  87  \n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  ",
            "    public static InputStream toInputStream(File file, String charset) throws IOException {\n        if (charset != null) {\n            final BufferedReader reader = toReader(file, charset);\n            final Charset defaultStreamCharset = Charset.defaultCharset();\n            return new InputStream() {\n                private ByteBuffer bufferBytes;\n                private CharBuffer bufferedChars = CharBuffer.allocate(4096);\n\n                @Override\n                public int read() throws IOException {\n                    if (bufferBytes == null || bufferBytes.remaining() <= 0) {\n                        bufferedChars.clear();\n                        int len = reader.read(bufferedChars);\n                        bufferedChars.flip();\n                        if (len == -1) {\n                            return -1;\n                        }\n                        bufferBytes = defaultStreamCharset.encode(bufferedChars);\n                    }\n                    return bufferBytes.get();\n                }\n\n                @Override\n                public void close() throws IOException {\n                    reader.close();\n                }\n\n                @Override\n                public void reset() throws IOException {\n                    reader.reset();\n                }\n            };\n        } else {\n            return IOHelper.buffered(new FileInputStream(file));\n        }\n    }",
            "  84  \n  85  \n  86  \n  87 +\n  88  \n  89  \n  90  \n  91  \n  92  \n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  ",
            "    public static InputStream toInputStream(File file, String charset) throws IOException {\n        if (charset != null) {\n            final BufferedReader reader = toReader(file, charset);\n            final Charset defaultStreamCharset = defaultCharset.get();\n            return new InputStream() {\n                private ByteBuffer bufferBytes;\n                private CharBuffer bufferedChars = CharBuffer.allocate(4096);\n\n                @Override\n                public int read() throws IOException {\n                    if (bufferBytes == null || bufferBytes.remaining() <= 0) {\n                        bufferedChars.clear();\n                        int len = reader.read(bufferedChars);\n                        bufferedChars.flip();\n                        if (len == -1) {\n                            return -1;\n                        }\n                        bufferBytes = defaultStreamCharset.encode(bufferedChars);\n                    }\n                    return bufferBytes.get();\n                }\n\n                @Override\n                public void close() throws IOException {\n                    reader.close();\n                }\n\n                @Override\n                public void reset() throws IOException {\n                    reader.reset();\n                }\n            };\n        } else {\n            return IOHelper.buffered(new FileInputStream(file));\n        }\n    }"
        ],
        [
            "IOConverterCharsetTest::switchToDefaultCharset(String)",
            " 144 -\n 145 -\n 146 -\n 147 -\n 148 -\n 149 -\n 150 -\n 151 -\n 152  ",
            "    private void switchToDefaultCharset(String charset) {\n        try {\n            Field defaultCharset = Charset.class.getDeclaredField(\"defaultCharset\");\n            defaultCharset.setAccessible(true);\n            defaultCharset.set(null, Charset.forName(charset));\n        } catch (Exception e) {\n            // Do nothing here\n        }\n    }",
            " 144 +\n 145 +\n 146 +\n 147 +\n 148  ",
            "    private void switchToDefaultCharset(final String charset) {\n        final Charset newCharset = Charset.forName(charset);\n\n        IOConverter.defaultCharset = () -> newCharset;\n    }"
        ],
        [
            "IOConverterCharsetTest::testToInputStreamFileWithCharsetUTF8withOtherDefaultEncoding()",
            "  59  \n  60  \n  61  \n  62  \n  63  \n  64 -\n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  ",
            "    public void testToInputStreamFileWithCharsetUTF8withOtherDefaultEncoding() throws Exception {\n        switchToDefaultCharset(\"ISO-8859-1\");\n        File file = new File(\"src/test/resources/org/apache/camel/converter/german.utf-8.txt\");\n        InputStream in = IOConverter.toInputStream(file, \"UTF-8\");\n        // do read with default charset!\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n        BufferedReader naiveReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), \"UTF-8\"));\n        try {   \n            String line = reader.readLine();\n            String naiveLine = naiveReader.readLine();\n            assertEquals(naiveLine, line);\n            assertEquals(CONTENT, line);\n        } finally {\n            reader.close();\n            naiveReader.close();\n        }\n        \n    }",
            "  59  \n  60  \n  61  \n  62  \n  63  \n  64 +\n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  ",
            "    public void testToInputStreamFileWithCharsetUTF8withOtherDefaultEncoding() throws Exception {\n        switchToDefaultCharset(\"ISO-8859-1\");\n        File file = new File(\"src/test/resources/org/apache/camel/converter/german.utf-8.txt\");\n        InputStream in = IOConverter.toInputStream(file, \"UTF-8\");\n        // do read with default charset!\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in, StandardCharsets.ISO_8859_1));\n        BufferedReader naiveReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), \"UTF-8\"));\n        try {   \n            String line = reader.readLine();\n            String naiveLine = naiveReader.readLine();\n            assertEquals(naiveLine, line);\n            assertEquals(CONTENT, line);\n        } finally {\n            reader.close();\n            naiveReader.close();\n        }\n        \n    }"
        ]
    ],
    "18a110cc4e78968b623564fe02484d54af7f906f": [
        [
            "RsClientBlueprintBean::setLoggingSizeLimit(int)",
            "  74  \n  75  \n  76  \n  77 -\n  78  \n  79 -\n  80 -\n  81 -\n  82  \n  83 -\n  84  \n  85  ",
            "    public void setLoggingSizeLimit(int loggingSizeLimit) {\n        this.loggingSizeLimit = loggingSizeLimit;\n        if (loggingFeature != null) {\n            getFeatures().remove(loggingFeature);\n            if (loggingSizeLimit > 0) {\n                loggingFeature = new LoggingFeature(loggingSizeLimit);\n            } else {\n                loggingFeature = new LoggingFeature();\n            }\n            getFeatures().add(loggingFeature);\n        }\n    }",
            "  73  \n  74  \n  75  \n  76  \n  77 +\n  78  \n  79  \n  80  ",
            "    public void setLoggingSizeLimit(int loggingSizeLimit) {\n        this.loggingSizeLimit = loggingSizeLimit;\n        if (loggingFeature != null) {\n            if (loggingSizeLimit > 0) {\n                loggingFeature.setLimit(loggingSizeLimit);\n            }\n        }\n    }"
        ],
        [
            "CxfEndpoint::setupClientFactoryBean(ClientFactoryBean,Class)",
            " 476  \n 477  \n 478  \n 479  \n 480  \n 481  \n 482  \n 483  \n 484  \n 485  \n 486  \n 487  \n 488  \n 489  \n 490  \n 491  \n 492  \n 493  \n 494  \n 495  \n 496  \n 497  \n 498  \n 499  \n 500  \n 501  \n 502  \n 503  \n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512  \n 513  \n 514  \n 515  \n 516  \n 517  \n 518  \n 519  \n 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528  \n 529  \n 530  \n 531  \n 532  \n 533 -\n 534 -\n 535 -\n 536 -\n 537  \n 538  \n 539  \n 540  \n 541  \n 542  \n 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564  \n 565  \n 566  \n 567  \n 568  \n 569  \n 570  \n 571  \n 572  \n 573  \n 574  \n 575  \n 576  \n 577  \n 578  \n 579  \n 580  \n 581  \n 582  \n 583  \n 584  ",
            "    protected void setupClientFactoryBean(ClientFactoryBean factoryBean, Class<?> cls) {\n        if (cls != null) {\n            factoryBean.setServiceClass(cls);\n        }\n        factoryBean.setInInterceptors(in);\n        factoryBean.setOutInterceptors(out);\n        factoryBean.setOutFaultInterceptors(outFault);\n        factoryBean.setInFaultInterceptors(inFault);\n        factoryBean.setFeatures(features);\n        factoryBean.setTransportId(transportId);\n        factoryBean.setBindingId(bindingId);\n\n        if (bindingConfig != null) {\n            factoryBean.setBindingConfig(bindingConfig);\n        }\n\n        if (dataBinding != null) {\n            factoryBean.setDataBinding(dataBinding);\n        }\n\n        if (serviceFactoryBean != null) {\n            setServiceFactory(factoryBean, serviceFactoryBean);\n        }\n\n        // address\n        factoryBean.setAddress(getAddress());\n\n        // wsdl url\n        if (getWsdlURL() != null) {\n            factoryBean.setWsdlURL(getWsdlURL());\n        }\n\n        // service name qname\n        if (getServiceName() != null) {\n            factoryBean.setServiceName(getServiceName());\n        }\n\n        // port name qname\n        if (getPortName() != null) {\n            factoryBean.setEndpointName(getPortName());\n        }\n\n        // apply feature here\n        if (getDataFormat().dealias() == DataFormat.RAW) {\n            RAWDataFormatFeature feature = new RAWDataFormatFeature();\n            feature.addInIntercepters(getInInterceptors());\n            feature.addOutInterceptors(getOutInterceptors());\n            factoryBean.getFeatures().add(feature);\n        } else if (getDataFormat().dealias() == DataFormat.CXF_MESSAGE) {\n            factoryBean.getFeatures().add(new CXFMessageDataFormatFeature());\n            factoryBean.setDataBinding(new SourceDataBinding());\n        } else if (getDataFormat() == DataFormat.PAYLOAD) {\n            factoryBean.getFeatures().add(new PayLoadDataFormatFeature(allowStreaming));\n            factoryBean.setDataBinding(new HybridSourceDataBinding());\n        }\n\n        if (isLoggingFeatureEnabled()) {\n            if (getLoggingSizeLimit() != 0) {\n                factoryBean.getFeatures().add(new LoggingFeature(getLoggingSizeLimit()));\n            } else {\n                factoryBean.getFeatures().add(new LoggingFeature());\n            }\n        }\n\n        // set the document-literal wrapped style\n        if (getWrappedStyle() != null) {\n            setWrapped(factoryBean, getWrappedStyle());\n        }\n\n        // any optional properties\n        if (getProperties() != null) {\n            if (factoryBean.getProperties() != null) {\n                // add to existing properties\n                factoryBean.getProperties().putAll(getProperties());\n            } else {\n                factoryBean.setProperties(getProperties());\n            }\n            LOG.debug(\"ClientFactoryBean: {} added properties: {}\", factoryBean, getProperties());\n        }\n\n        // setup the basic authentication property\n        if (ObjectHelper.isNotEmpty(username)) {\n            AuthorizationPolicy authPolicy = new AuthorizationPolicy();\n            authPolicy.setUserName(username);\n            authPolicy.setPassword(password);\n            if (factoryBean.getProperties() == null) {\n                factoryBean.setProperties(new HashMap<String, Object>());\n            }\n            factoryBean.getProperties().put(AuthorizationPolicy.class.getName(), authPolicy);\n        }\n\n        if (this.isSkipPayloadMessagePartCheck()) {\n            if (factoryBean.getProperties() == null) {\n                factoryBean.setProperties(new HashMap<String, Object>());\n            }\n            factoryBean.getProperties().put(\"soap.no.validate.parts\", Boolean.TRUE);\n        }\n\n        if (this.isSkipFaultLogging()) {\n            if (factoryBean.getProperties() == null) {\n                factoryBean.setProperties(new HashMap<String, Object>());\n            }\n            factoryBean.getProperties().put(FaultListener.class.getName(), new NullFaultListener());\n        }\n\n        factoryBean.setBus(getBus());\n\n        getNullSafeCxfEndpointConfigurer().configure(factoryBean);\n    }",
            " 476  \n 477  \n 478  \n 479  \n 480  \n 481  \n 482  \n 483  \n 484  \n 485  \n 486  \n 487  \n 488  \n 489  \n 490  \n 491  \n 492  \n 493  \n 494  \n 495  \n 496  \n 497  \n 498  \n 499  \n 500  \n 501  \n 502  \n 503  \n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512  \n 513  \n 514  \n 515  \n 516  \n 517  \n 518  \n 519  \n 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528  \n 529  \n 530  \n 531  \n 532  \n 533 +\n 534 +\n 535 +\n 536 +\n 537  \n 538 +\n 539  \n 540  \n 541  \n 542  \n 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564  \n 565  \n 566  \n 567  \n 568  \n 569  \n 570  \n 571  \n 572  \n 573  \n 574  \n 575  \n 576  \n 577  \n 578  \n 579  \n 580  \n 581  \n 582  \n 583  \n 584  \n 585  ",
            "    protected void setupClientFactoryBean(ClientFactoryBean factoryBean, Class<?> cls) {\n        if (cls != null) {\n            factoryBean.setServiceClass(cls);\n        }\n        factoryBean.setInInterceptors(in);\n        factoryBean.setOutInterceptors(out);\n        factoryBean.setOutFaultInterceptors(outFault);\n        factoryBean.setInFaultInterceptors(inFault);\n        factoryBean.setFeatures(features);\n        factoryBean.setTransportId(transportId);\n        factoryBean.setBindingId(bindingId);\n\n        if (bindingConfig != null) {\n            factoryBean.setBindingConfig(bindingConfig);\n        }\n\n        if (dataBinding != null) {\n            factoryBean.setDataBinding(dataBinding);\n        }\n\n        if (serviceFactoryBean != null) {\n            setServiceFactory(factoryBean, serviceFactoryBean);\n        }\n\n        // address\n        factoryBean.setAddress(getAddress());\n\n        // wsdl url\n        if (getWsdlURL() != null) {\n            factoryBean.setWsdlURL(getWsdlURL());\n        }\n\n        // service name qname\n        if (getServiceName() != null) {\n            factoryBean.setServiceName(getServiceName());\n        }\n\n        // port name qname\n        if (getPortName() != null) {\n            factoryBean.setEndpointName(getPortName());\n        }\n\n        // apply feature here\n        if (getDataFormat().dealias() == DataFormat.RAW) {\n            RAWDataFormatFeature feature = new RAWDataFormatFeature();\n            feature.addInIntercepters(getInInterceptors());\n            feature.addOutInterceptors(getOutInterceptors());\n            factoryBean.getFeatures().add(feature);\n        } else if (getDataFormat().dealias() == DataFormat.CXF_MESSAGE) {\n            factoryBean.getFeatures().add(new CXFMessageDataFormatFeature());\n            factoryBean.setDataBinding(new SourceDataBinding());\n        } else if (getDataFormat() == DataFormat.PAYLOAD) {\n            factoryBean.getFeatures().add(new PayLoadDataFormatFeature(allowStreaming));\n            factoryBean.setDataBinding(new HybridSourceDataBinding());\n        }\n\n        if (isLoggingFeatureEnabled()) {\n            LoggingFeature loggingFeature = new LoggingFeature();\n            if (getLoggingSizeLimit() > 0) {\n                loggingFeature.setLimit(getLoggingSizeLimit());\n\n            }\n            factoryBean.getFeatures().add(loggingFeature);\n        }\n\n        // set the document-literal wrapped style\n        if (getWrappedStyle() != null) {\n            setWrapped(factoryBean, getWrappedStyle());\n        }\n\n        // any optional properties\n        if (getProperties() != null) {\n            if (factoryBean.getProperties() != null) {\n                // add to existing properties\n                factoryBean.getProperties().putAll(getProperties());\n            } else {\n                factoryBean.setProperties(getProperties());\n            }\n            LOG.debug(\"ClientFactoryBean: {} added properties: {}\", factoryBean, getProperties());\n        }\n\n        // setup the basic authentication property\n        if (ObjectHelper.isNotEmpty(username)) {\n            AuthorizationPolicy authPolicy = new AuthorizationPolicy();\n            authPolicy.setUserName(username);\n            authPolicy.setPassword(password);\n            if (factoryBean.getProperties() == null) {\n                factoryBean.setProperties(new HashMap<String, Object>());\n            }\n            factoryBean.getProperties().put(AuthorizationPolicy.class.getName(), authPolicy);\n        }\n\n        if (this.isSkipPayloadMessagePartCheck()) {\n            if (factoryBean.getProperties() == null) {\n                factoryBean.setProperties(new HashMap<String, Object>());\n            }\n            factoryBean.getProperties().put(\"soap.no.validate.parts\", Boolean.TRUE);\n        }\n\n        if (this.isSkipFaultLogging()) {\n            if (factoryBean.getProperties() == null) {\n                factoryBean.setProperties(new HashMap<String, Object>());\n            }\n            factoryBean.getProperties().put(FaultListener.class.getName(), new NullFaultListener());\n        }\n\n        factoryBean.setBus(getBus());\n\n        getNullSafeCxfEndpointConfigurer().configure(factoryBean);\n    }"
        ],
        [
            "CxfEndpoint::setupServerFactoryBean(ServerFactoryBean,Class)",
            " 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344 -\n 345 -\n 346 -\n 347 -\n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  ",
            "    /**\n     * Populate server factory bean\n     */\n    protected void setupServerFactoryBean(ServerFactoryBean sfb, Class<?> cls) {\n\n        // address\n        sfb.setAddress(getAddress());\n\n        sfb.setServiceClass(cls);\n\n        sfb.setInInterceptors(in);\n        sfb.setOutInterceptors(out);\n        sfb.setOutFaultInterceptors(outFault);\n        sfb.setInFaultInterceptors(inFault);\n        sfb.setFeatures(features);\n        if (schemaLocations != null) {\n            sfb.setSchemaLocations(schemaLocations);\n        }\n        if (bindingConfig != null) {\n            sfb.setBindingConfig(bindingConfig);\n        }\n\n        if (dataBinding != null) {\n            sfb.setDataBinding(dataBinding);\n        }\n\n        if (serviceFactoryBean != null) {\n            setServiceFactory(sfb, serviceFactoryBean);\n        }\n\n        if (sfb instanceof JaxWsServerFactoryBean && handlers != null) {\n            ((JaxWsServerFactoryBean)sfb).setHandlers(handlers);\n        }\n        if (getTransportId() != null) {\n            sfb.setTransportId(getTransportId());\n        }\n        if (getBindingId() != null) {\n            sfb.setBindingId(getBindingId());\n        }\n\n        // wsdl url\n        if (getWsdlURL() != null) {\n            sfb.setWsdlURL(getWsdlURL());\n        }\n\n        // service  name qname\n        if (getServiceName() != null) {\n            sfb.setServiceName(getServiceName());\n        }\n\n        // port qname\n        if (getPortName() != null) {\n            sfb.setEndpointName(getPortName());\n        }\n\n        // apply feature here\n        if (!CxfEndpointUtils.hasAnnotation(cls, WebServiceProvider.class)) {\n            if (getDataFormat() == DataFormat.PAYLOAD) {\n                sfb.getFeatures().add(new PayLoadDataFormatFeature(allowStreaming));\n            } else if (getDataFormat().dealias() == DataFormat.CXF_MESSAGE) {\n                sfb.getFeatures().add(new CXFMessageDataFormatFeature());\n                sfb.setDataBinding(new SourceDataBinding());\n            } else if (getDataFormat().dealias() == DataFormat.RAW) {\n                RAWDataFormatFeature feature = new RAWDataFormatFeature();\n                if (this.getExchangePattern().equals(ExchangePattern.InOnly)) {\n                    //if DataFormat is RAW|MESSAGE, can't read message so can't\n                    //determine it's oneway so need get the MEP from URI explicitly\n                    feature.setOneway(true);\n                }\n                feature.addInIntercepters(getInInterceptors());\n                feature.addOutInterceptors(getOutInterceptors());\n                sfb.getFeatures().add(feature);\n            }\n        } else {\n            LOG.debug(\"Ignore DataFormat mode {} since SEI class is annotated with WebServiceProvider\", getDataFormat());\n        }\n\n        if (isLoggingFeatureEnabled()) {\n            if (getLoggingSizeLimit() != 0) {\n                sfb.getFeatures().add(new LoggingFeature(getLoggingSizeLimit()));\n            } else {\n                sfb.getFeatures().add(new LoggingFeature());\n            }\n        }\n\n        if (getDataFormat() == DataFormat.PAYLOAD) {\n            sfb.setDataBinding(new HybridSourceDataBinding());\n        }\n\n        // set the document-literal wrapped style\n        if (getWrappedStyle() != null && getDataFormat().dealias() != DataFormat.CXF_MESSAGE) {\n            setWrapped(sfb, getWrappedStyle());\n        }\n\n        // any optional properties\n        if (getProperties() != null) {\n            if (sfb.getProperties() != null) {\n                // add to existing properties\n                sfb.getProperties().putAll(getProperties());\n            } else {\n                sfb.setProperties(getProperties());\n            }\n            LOG.debug(\"ServerFactoryBean: {} added properties: {}\", sfb, getProperties());\n        }\n        if (this.isSkipPayloadMessagePartCheck()) {\n            if (sfb.getProperties() == null) {\n                sfb.setProperties(new HashMap<String, Object>());\n            }\n            sfb.getProperties().put(\"soap.no.validate.parts\", Boolean.TRUE);\n        }\n\n        if (this.isSkipFaultLogging()) {\n            if (sfb.getProperties() == null) {\n                sfb.setProperties(new HashMap<String, Object>());\n            }\n            sfb.getProperties().put(FaultListener.class.getName(), new NullFaultListener());\n        }\n\n        sfb.setBus(getBus());\n        sfb.setStart(false);\n        getNullSafeCxfEndpointConfigurer().configure(sfb);\n    }",
            " 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  \n 290  \n 291  \n 292  \n 293  \n 294  \n 295  \n 296  \n 297  \n 298  \n 299  \n 300  \n 301  \n 302  \n 303  \n 304  \n 305  \n 306  \n 307  \n 308  \n 309  \n 310  \n 311  \n 312  \n 313  \n 314  \n 315  \n 316  \n 317  \n 318  \n 319  \n 320  \n 321  \n 322  \n 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344 +\n 345 +\n 346 +\n 347  \n 348 +\n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  ",
            "    /**\n     * Populate server factory bean\n     */\n    protected void setupServerFactoryBean(ServerFactoryBean sfb, Class<?> cls) {\n\n        // address\n        sfb.setAddress(getAddress());\n\n        sfb.setServiceClass(cls);\n\n        sfb.setInInterceptors(in);\n        sfb.setOutInterceptors(out);\n        sfb.setOutFaultInterceptors(outFault);\n        sfb.setInFaultInterceptors(inFault);\n        sfb.setFeatures(features);\n        if (schemaLocations != null) {\n            sfb.setSchemaLocations(schemaLocations);\n        }\n        if (bindingConfig != null) {\n            sfb.setBindingConfig(bindingConfig);\n        }\n\n        if (dataBinding != null) {\n            sfb.setDataBinding(dataBinding);\n        }\n\n        if (serviceFactoryBean != null) {\n            setServiceFactory(sfb, serviceFactoryBean);\n        }\n\n        if (sfb instanceof JaxWsServerFactoryBean && handlers != null) {\n            ((JaxWsServerFactoryBean)sfb).setHandlers(handlers);\n        }\n        if (getTransportId() != null) {\n            sfb.setTransportId(getTransportId());\n        }\n        if (getBindingId() != null) {\n            sfb.setBindingId(getBindingId());\n        }\n\n        // wsdl url\n        if (getWsdlURL() != null) {\n            sfb.setWsdlURL(getWsdlURL());\n        }\n\n        // service  name qname\n        if (getServiceName() != null) {\n            sfb.setServiceName(getServiceName());\n        }\n\n        // port qname\n        if (getPortName() != null) {\n            sfb.setEndpointName(getPortName());\n        }\n\n        // apply feature here\n        if (!CxfEndpointUtils.hasAnnotation(cls, WebServiceProvider.class)) {\n            if (getDataFormat() == DataFormat.PAYLOAD) {\n                sfb.getFeatures().add(new PayLoadDataFormatFeature(allowStreaming));\n            } else if (getDataFormat().dealias() == DataFormat.CXF_MESSAGE) {\n                sfb.getFeatures().add(new CXFMessageDataFormatFeature());\n                sfb.setDataBinding(new SourceDataBinding());\n            } else if (getDataFormat().dealias() == DataFormat.RAW) {\n                RAWDataFormatFeature feature = new RAWDataFormatFeature();\n                if (this.getExchangePattern().equals(ExchangePattern.InOnly)) {\n                    //if DataFormat is RAW|MESSAGE, can't read message so can't\n                    //determine it's oneway so need get the MEP from URI explicitly\n                    feature.setOneway(true);\n                }\n                feature.addInIntercepters(getInInterceptors());\n                feature.addOutInterceptors(getOutInterceptors());\n                sfb.getFeatures().add(feature);\n            }\n        } else {\n            LOG.debug(\"Ignore DataFormat mode {} since SEI class is annotated with WebServiceProvider\", getDataFormat());\n        }\n\n        if (isLoggingFeatureEnabled()) {\n            LoggingFeature loggingFeature = new LoggingFeature();\n            if (getLoggingSizeLimit() > 0) {\n                loggingFeature.setLimit(getLoggingSizeLimit());\n            }\n            sfb.getFeatures().add(loggingFeature);\n        }\n\n        if (getDataFormat() == DataFormat.PAYLOAD) {\n            sfb.setDataBinding(new HybridSourceDataBinding());\n        }\n\n        // set the document-literal wrapped style\n        if (getWrappedStyle() != null && getDataFormat().dealias() != DataFormat.CXF_MESSAGE) {\n            setWrapped(sfb, getWrappedStyle());\n        }\n\n        // any optional properties\n        if (getProperties() != null) {\n            if (sfb.getProperties() != null) {\n                // add to existing properties\n                sfb.getProperties().putAll(getProperties());\n            } else {\n                sfb.setProperties(getProperties());\n            }\n            LOG.debug(\"ServerFactoryBean: {} added properties: {}\", sfb, getProperties());\n        }\n        if (this.isSkipPayloadMessagePartCheck()) {\n            if (sfb.getProperties() == null) {\n                sfb.setProperties(new HashMap<String, Object>());\n            }\n            sfb.getProperties().put(\"soap.no.validate.parts\", Boolean.TRUE);\n        }\n\n        if (this.isSkipFaultLogging()) {\n            if (sfb.getProperties() == null) {\n                sfb.setProperties(new HashMap<String, Object>());\n            }\n            sfb.getProperties().put(FaultListener.class.getName(), new NullFaultListener());\n        }\n\n        sfb.setBus(getBus());\n        sfb.setStart(false);\n        getNullSafeCxfEndpointConfigurer().configure(sfb);\n    }"
        ],
        [
            "RsClientBlueprintBean::setLoggingFeatureEnabled(boolean)",
            "  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61 -\n  62 -\n  63 -\n  64  \n  65  \n  66  \n  67  \n  68  ",
            "    public void setLoggingFeatureEnabled(boolean loggingFeatureEnabled) {\n        if (loggingFeature != null) {\n            getFeatures().remove(loggingFeature);\n            loggingFeature = null;\n        }\n        if (loggingFeatureEnabled) {\n            if (getLoggingSizeLimit() > 0) {\n                loggingFeature = new LoggingFeature(getLoggingSizeLimit());\n            } else {\n                loggingFeature = new LoggingFeature();\n            }\n            getFeatures().add(loggingFeature);\n        }\n        \n    }",
            "  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60 +\n  61  \n  62 +\n  63  \n  64  \n  65  \n  66  \n  67  ",
            "    public void setLoggingFeatureEnabled(boolean loggingFeatureEnabled) {\n        if (loggingFeature != null) {\n            getFeatures().remove(loggingFeature);\n            loggingFeature = null;\n        }\n        if (loggingFeatureEnabled) {\n            loggingFeature = new LoggingFeature();\n            if (getLoggingSizeLimit() > 0) {\n                loggingFeature.setLimit(getLoggingSizeLimit());\n            }\n            getFeatures().add(loggingFeature);\n        }\n        \n    }"
        ],
        [
            "CxfRsEndpoint::setupCommonFactoryProperties(AbstractJAXRSFactoryBean)",
            " 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344  \n 345  \n 346  \n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363 -\n 364 -\n 365 -\n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  ",
            "    protected void setupCommonFactoryProperties(AbstractJAXRSFactoryBean factory) {\n        // let customer to override the default setting of provider\n        if (!getProviders().isEmpty()) {\n            factory.setProviders(getProviders());\n        }\n        // setup the features\n        if (!getFeatures().isEmpty()) {\n            factory.getFeatures().addAll(getFeatures());\n        }\n\n        if (publishedEndpointUrl != null) {\n            factory.setPublishedEndpointUrl(publishedEndpointUrl);\n        }\n\n        // we need to avoid flushing the setting from spring or blueprint\n        if (!interceptorHolder.getInInterceptors().isEmpty()) {\n            factory.setInInterceptors(interceptorHolder.getInInterceptors());\n        }\n        if (!interceptorHolder.getOutInterceptors().isEmpty()) {\n            factory.setOutInterceptors(interceptorHolder.getOutInterceptors());\n        }\n        if (!interceptorHolder.getOutFaultInterceptors().isEmpty()) {\n            factory.setOutFaultInterceptors(interceptorHolder.getOutFaultInterceptors());\n        }\n        if (!interceptorHolder.getInFaultInterceptors().isEmpty()) {\n            factory.setInFaultInterceptors(interceptorHolder.getInFaultInterceptors());\n        }\n\n        if (getProperties() != null) {\n            if (factory.getProperties() != null) {\n                // add to existing properties\n                factory.getProperties().putAll(getProperties());\n            } else {\n                factory.setProperties(getProperties());\n            }\n            LOG.debug(\"JAXRS FactoryBean: {} added properties: {}\", factory, getProperties());\n        }\n\n        if (isLoggingFeatureEnabled()) {\n            if (getLoggingSizeLimit() > 0) {\n                factory.getFeatures().add(new LoggingFeature(getLoggingSizeLimit()));\n            } else {\n                factory.getFeatures().add(new LoggingFeature());\n            }\n        }\n        if (this.isSkipFaultLogging()) {\n            if (factory.getProperties() == null) {\n                factory.setProperties(new HashMap<String, Object>());\n            }\n            factory.getProperties().put(FaultListener.class.getName(), new NullFaultListener());\n        }\n    }",
            " 323  \n 324  \n 325  \n 326  \n 327  \n 328  \n 329  \n 330  \n 331  \n 332  \n 333  \n 334  \n 335  \n 336  \n 337  \n 338  \n 339  \n 340  \n 341  \n 342  \n 343  \n 344  \n 345  \n 346  \n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362 +\n 363  \n 364 +\n 365  \n 366 +\n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  ",
            "    protected void setupCommonFactoryProperties(AbstractJAXRSFactoryBean factory) {\n        // let customer to override the default setting of provider\n        if (!getProviders().isEmpty()) {\n            factory.setProviders(getProviders());\n        }\n        // setup the features\n        if (!getFeatures().isEmpty()) {\n            factory.getFeatures().addAll(getFeatures());\n        }\n\n        if (publishedEndpointUrl != null) {\n            factory.setPublishedEndpointUrl(publishedEndpointUrl);\n        }\n\n        // we need to avoid flushing the setting from spring or blueprint\n        if (!interceptorHolder.getInInterceptors().isEmpty()) {\n            factory.setInInterceptors(interceptorHolder.getInInterceptors());\n        }\n        if (!interceptorHolder.getOutInterceptors().isEmpty()) {\n            factory.setOutInterceptors(interceptorHolder.getOutInterceptors());\n        }\n        if (!interceptorHolder.getOutFaultInterceptors().isEmpty()) {\n            factory.setOutFaultInterceptors(interceptorHolder.getOutFaultInterceptors());\n        }\n        if (!interceptorHolder.getInFaultInterceptors().isEmpty()) {\n            factory.setInFaultInterceptors(interceptorHolder.getInFaultInterceptors());\n        }\n\n        if (getProperties() != null) {\n            if (factory.getProperties() != null) {\n                // add to existing properties\n                factory.getProperties().putAll(getProperties());\n            } else {\n                factory.setProperties(getProperties());\n            }\n            LOG.debug(\"JAXRS FactoryBean: {} added properties: {}\", factory, getProperties());\n        }\n\n        if (isLoggingFeatureEnabled()) {\n            LoggingFeature loggingFeature = new LoggingFeature();\n            if (getLoggingSizeLimit() > 0) {\n                loggingFeature.setLimit(getLoggingSizeLimit());\n            }\n            factory.getFeatures().add(loggingFeature);\n        }\n        if (this.isSkipFaultLogging()) {\n            if (factory.getProperties() == null) {\n                factory.setProperties(new HashMap<String, Object>());\n            }\n            factory.getProperties().put(FaultListener.class.getName(), new NullFaultListener());\n        }\n    }"
        ]
    ],
    "2ac341d32163788783add4faf3b12816e6b5118a": [
        [
            "RestSwaggerSupport::renderResourceListing(RestApiResponseAdapter,BeanConfig,String,String,boolean,boolean,ClassResolver,RestConfiguration)",
            " 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207 -\n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226 -\n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  ",
            "    public void renderResourceListing(RestApiResponseAdapter response, BeanConfig swaggerConfig, String contextId, String route, boolean json, boolean yaml,\n                                      ClassResolver classResolver, RestConfiguration configuration) throws Exception {\n        LOG.trace(\"renderResourceListing\");\n\n        if (cors) {\n            setupCorsHeaders(response, configuration.getCorsHeaders());\n        }\n\n        List<RestDefinition> rests = getRestDefinitions(contextId);\n        if (rests != null) {\n            if (json) {\n                response.setHeader(Exchange.CONTENT_TYPE, \"application/json\");\n\n                // read the rest-dsl into swagger model\n                Swagger swagger = reader.read(rests, route, swaggerConfig, contextId, classResolver);\n\n                if (!configuration.isApiVendorExtension()) {\n                    clearVendorExtensions(swagger);\n                }\n\n                ObjectMapper mapper = new ObjectMapper();\n                mapper.enable(SerializationFeature.INDENT_OUTPUT);\n                mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);\n                byte[] bytes = mapper.writeValueAsBytes(swagger);\n\n                int len = bytes.length;\n                response.setHeader(Exchange.CONTENT_LENGTH, \"\" + len);\n\n                response.writeBytes(bytes);\n            } else {\n                response.setHeader(Exchange.CONTENT_TYPE, \"text/yaml\");\n\n                // read the rest-dsl into swagger model\n                Swagger swagger = reader.read(rests, route, swaggerConfig, contextId, classResolver);\n\n                if (!configuration.isApiVendorExtension()) {\n                    clearVendorExtensions(swagger);\n                }\n\n                ObjectMapper mapper = new ObjectMapper();\n                mapper.enable(SerializationFeature.INDENT_OUTPUT);\n                mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);\n                byte[] jsonData = mapper.writeValueAsBytes(swagger);\n\n                // json to yaml\n                JsonNode node = mapper.readTree(jsonData);\n                byte[] bytes = Yaml.mapper().writerWithDefaultPrettyPrinter().writeValueAsBytes(node);\n\n                int len = bytes.length;\n                response.setHeader(Exchange.CONTENT_LENGTH, \"\" + len);\n\n                response.writeBytes(bytes);\n            }\n        } else {\n            response.noContent();\n        }\n    }",
            " 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206 +\n 207  \n 208 +\n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227 +\n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  ",
            "    public void renderResourceListing(RestApiResponseAdapter response, BeanConfig swaggerConfig, String contextId, String route, boolean json, boolean yaml,\n                                      ClassResolver classResolver, RestConfiguration configuration) throws Exception {\n        LOG.trace(\"renderResourceListing\");\n\n        if (cors) {\n            setupCorsHeaders(response, configuration.getCorsHeaders());\n        }\n\n        List<RestDefinition> rests = getRestDefinitions(contextId);\n        if (rests != null) {\n            final Map<String, Object> apiProperties = configuration.getApiProperties();\n            if (json) {\n                response.setHeader(Exchange.CONTENT_TYPE, (String) apiProperties.getOrDefault(\"api.specification.contentType.json\", \"application/json\"));\n\n                // read the rest-dsl into swagger model\n                Swagger swagger = reader.read(rests, route, swaggerConfig, contextId, classResolver);\n\n                if (!configuration.isApiVendorExtension()) {\n                    clearVendorExtensions(swagger);\n                }\n\n                ObjectMapper mapper = new ObjectMapper();\n                mapper.enable(SerializationFeature.INDENT_OUTPUT);\n                mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);\n                byte[] bytes = mapper.writeValueAsBytes(swagger);\n\n                int len = bytes.length;\n                response.setHeader(Exchange.CONTENT_LENGTH, \"\" + len);\n\n                response.writeBytes(bytes);\n            } else {\n                response.setHeader(Exchange.CONTENT_TYPE, (String) apiProperties.getOrDefault(\"api.specification.contentType.yaml\", \"text/yaml\"));\n\n                // read the rest-dsl into swagger model\n                Swagger swagger = reader.read(rests, route, swaggerConfig, contextId, classResolver);\n\n                if (!configuration.isApiVendorExtension()) {\n                    clearVendorExtensions(swagger);\n                }\n\n                ObjectMapper mapper = new ObjectMapper();\n                mapper.enable(SerializationFeature.INDENT_OUTPUT);\n                mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);\n                byte[] jsonData = mapper.writeValueAsBytes(swagger);\n\n                // json to yaml\n                JsonNode node = mapper.readTree(jsonData);\n                byte[] bytes = Yaml.mapper().writerWithDefaultPrettyPrinter().writeValueAsBytes(node);\n\n                int len = bytes.length;\n                response.setHeader(Exchange.CONTENT_LENGTH, \"\" + len);\n\n                response.writeBytes(bytes);\n            }\n        } else {\n            response.noContent();\n        }\n    }"
        ]
    ],
    "3e3790365d9a807eedabd81392e4a76a818723de": [
        [
            "RunMojo::resolveExecutableDependencies(Artifact,boolean)",
            "1052  \n1053  \n1054  \n1055  \n1056  \n1057  \n1058  \n1059  \n1060  \n1061 -\n1062  \n1063  \n1064  \n1065 -\n1066 -\n1067  \n1068  \n1069  \n1070  \n1071  \n1072  \n1073  \n1074  \n1075  \n1076  \n1077  \n1078  \n1079  \n1080  \n1081  \n1082  \n1083  \n1084  \n1085  \n1086  \n1087  \n1088  \n1089  \n1090  \n1091  ",
            "    private Set<Artifact> resolveExecutableDependencies(Artifact executablePomArtifact, boolean ignoreFailures) throws MojoExecutionException {\n\n        Set<Artifact> executableDependencies = null;\n        try {\n            MavenProject executableProject = this.projectBuilder.buildFromRepository(executablePomArtifact,\n                                                                                     this.remoteRepositories,\n                                                                                     this.localRepository);\n\n            // get all of the dependencies for the executable project\n            List<Artifact> dependencies = CastUtils.cast(executableProject.getDependencies());\n\n            // make Artifacts of all the dependencies\n            Set<Artifact> dependencyArtifacts \n                = CastUtils.cast(MavenMetadataSource.createArtifacts(this.artifactFactory, dependencies,\n                                                                          null, null, null));\n\n            // not forgetting the Artifact of the project itself\n            dependencyArtifacts.add(executableProject.getArtifact());\n\n            // resolve runtime dependencies transitively to obtain a comprehensive list of assemblies\n            ArtifactResolutionResult result = artifactResolver.resolveTransitively(dependencyArtifacts,\n                                                                                   executablePomArtifact,\n                                                                                   Collections.emptyMap(),\n                                                                                   this.localRepository,\n                                                                                   this.remoteRepositories,\n                                                                                   metadataSource, new ScopeArtifactFilter(Artifact.SCOPE_RUNTIME),\n                                                                                   Collections.emptyList());\n            executableDependencies = CastUtils.cast(result.getArtifacts());\n\n        } catch (Exception ex) {\n            if (ignoreFailures) {\n                getLog().debug(\"Ignoring maven resolving dependencies failure \" + ex.getMessage());\n            } else {\n                throw new MojoExecutionException(\"Encountered problems resolving dependencies of the executable \"\n                        + \"in preparation for its execution.\", ex);\n            }\n        }\n\n        return executableDependencies;\n    }",
            "1032  \n1033  \n1034  \n1035  \n1036  \n1037  \n1038  \n1039  \n1040  \n1041 +\n1042  \n1043  \n1044  \n1045 +\n1046 +\n1047  \n1048  \n1049  \n1050  \n1051  \n1052  \n1053  \n1054  \n1055  \n1056  \n1057  \n1058  \n1059  \n1060  \n1061  \n1062  \n1063  \n1064  \n1065  \n1066  \n1067  \n1068  \n1069  \n1070  \n1071  ",
            "    private Set<Artifact> resolveExecutableDependencies(Artifact executablePomArtifact, boolean ignoreFailures) throws MojoExecutionException {\n\n        Set<Artifact> executableDependencies = null;\n        try {\n            MavenProject executableProject = this.projectBuilder.buildFromRepository(executablePomArtifact,\n                                                                                     this.remoteRepositories,\n                                                                                     this.localRepository);\n\n            // get all of the dependencies for the executable project\n            List<Dependency> dependencies = executableProject.getDependencies();\n\n            // make Artifacts of all the dependencies\n            Set<Artifact> dependencyArtifacts \n                = MavenMetadataSource.createArtifacts(this.artifactFactory, dependencies,\n                                                                          null, null, null);\n\n            // not forgetting the Artifact of the project itself\n            dependencyArtifacts.add(executableProject.getArtifact());\n\n            // resolve runtime dependencies transitively to obtain a comprehensive list of assemblies\n            ArtifactResolutionResult result = artifactResolver.resolveTransitively(dependencyArtifacts,\n                                                                                   executablePomArtifact,\n                                                                                   Collections.emptyMap(),\n                                                                                   this.localRepository,\n                                                                                   this.remoteRepositories,\n                                                                                   metadataSource, new ScopeArtifactFilter(Artifact.SCOPE_RUNTIME),\n                                                                                   Collections.emptyList());\n            executableDependencies = CastUtils.cast(result.getArtifacts());\n\n        } catch (Exception ex) {\n            if (ignoreFailures) {\n                getLog().debug(\"Ignoring maven resolving dependencies failure \" + ex.getMessage());\n            } else {\n                throw new MojoExecutionException(\"Encountered problems resolving dependencies of the executable \"\n                        + \"in preparation for its execution.\", ex);\n            }\n        }\n\n        return executableDependencies;\n    }"
        ]
    ],
    "9524f5572b44a418e2ec9bdf575e4e0ec200d3f8": [
        [
            "SWFEndpoint::doStart()",
            "  71  \n  72  \n  73  \n  74 -\n  75  \n  76  \n  77  ",
            "    @Override\n    protected void doStart() throws Exception {\n        if (configuration.getAmazonSWClient() == null) {\n            amazonSWClient = createSWClient();\n        }\n        super.doStart();\n    }",
            "  75  \n  76  \n  77  \n  78 +\n  79  \n  80  \n  81  ",
            "    @Override\n    protected void doStart() throws Exception {\n        if (configuration.getAmazonSWClient() == null) {\n            amazonSWClient = (AmazonSimpleWorkflowClient) createSWClient();\n        }\n        super.doStart();\n    }"
        ],
        [
            "SWFEndpoint::createSWClient()",
            "  92 -\n  93  \n  94  \n  95  \n  96  \n  97  \n  98  \n  99  \n 100 -\n 101  \n 102  \n 103  \n 104  \n 105  ",
            "    private AmazonSimpleWorkflowClient createSWClient() throws Exception {\n        AWSCredentials credentials = new BasicAWSCredentials(configuration.getAccessKey(), configuration.getSecretKey());\n\n        ClientConfiguration clientConfiguration = new ClientConfiguration();\n        if (!configuration.getClientConfigurationParameters().isEmpty()) {\n            setProperties(clientConfiguration, configuration.getClientConfigurationParameters());\n        }\n\n        AmazonSimpleWorkflowClient client = new AmazonSimpleWorkflowClient(credentials, clientConfiguration);\n        if (!configuration.getSWClientParameters().isEmpty()) {\n            setProperties(client, configuration.getSWClientParameters());\n        }\n        return client;\n    }",
            "  96 +\n  97  \n  98 +\n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105 +\n 106  \n 107  \n 108  \n 109  \n 110  ",
            "    private AmazonSimpleWorkflow createSWClient() throws Exception {\n        AWSCredentials credentials = new BasicAWSCredentials(configuration.getAccessKey(), configuration.getSecretKey());\n        AWSCredentialsProvider credentialsProvider = new AWSStaticCredentialsProvider(credentials);\n\n        ClientConfiguration clientConfiguration = new ClientConfiguration();\n        if (!configuration.getClientConfigurationParameters().isEmpty()) {\n            setProperties(clientConfiguration, configuration.getClientConfigurationParameters());\n        }\n\n        AmazonSimpleWorkflow client = AmazonSimpleWorkflowClientBuilder.standard().withClientConfiguration(clientConfiguration).withCredentials(credentialsProvider).build();\n        if (!configuration.getSWClientParameters().isEmpty()) {\n            setProperties(client, configuration.getSWClientParameters());\n        }\n        return client;\n    }"
        ]
    ],
    "f7d102597776b8a2e1d95843931dba1df0e568e2": [
        [
            "Olingo2Consumer::poll()",
            "  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84 -\n  85  \n  86  \n  87  \n  88  \n  89  ",
            "    @Override\n    protected int poll() throws Exception {\n        // invoke the consumer method\n        final Map<String, Object> args = new HashMap<>();\n        args.putAll(endpoint.getEndpointProperties());\n\n        // let the endpoint and the Consumer intercept properties\n        endpoint.interceptProperties(args);\n        interceptProperties(args);\n\n        try {\n            // create responseHandler\n            final CountDownLatch latch = new CountDownLatch(1);\n            final Object[] result = new Object[1];\n            final Exception[] error = new Exception[1];\n\n            args.put(Olingo2Endpoint.RESPONSE_HANDLER_PROPERTY, new Olingo2ResponseHandler<Object>() {\n                @Override\n                public void onResponse(Object response, Map<String, String> responseHeaders) {\n                    result[0] = response;\n                    latch.countDown();\n                }\n\n                @Override\n                public void onException(Exception ex) {\n                    error[0] = ex;\n                    latch.countDown();\n                }\n\n                @Override\n                public void onCanceled() {\n                    error[0] = new RuntimeCamelException(\"OData HTTP Request cancelled\");\n                    latch.countDown();\n                }\n            });\n\n            doInvokeMethod(args);\n\n            // guaranteed to return, since an exception on timeout is expected!!!\n            latch.await();\n\n            if (error[0] != null) {\n                throw error[0];\n            }\n\n            return ApiConsumerHelper.getResultsProcessed(this, result[0], isSplitResult());\n\n        } catch (Throwable t) {\n            throw RuntimeCamelException.wrapRuntimeCamelException(t);\n        }\n    }",
            "  39  \n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  \n  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84 +\n  85 +\n  86 +\n  87 +\n  88 +\n  89 +\n  90 +\n  91 +\n  92 +\n  93  \n  94  \n  95  \n  96  \n  97  ",
            "    @Override\n    protected int poll() throws Exception {\n        // invoke the consumer method\n        final Map<String, Object> args = new HashMap<>();\n        args.putAll(endpoint.getEndpointProperties());\n\n        // let the endpoint and the Consumer intercept properties\n        endpoint.interceptProperties(args);\n        interceptProperties(args);\n\n        try {\n            // create responseHandler\n            final CountDownLatch latch = new CountDownLatch(1);\n            final Object[] result = new Object[1];\n            final Exception[] error = new Exception[1];\n\n            args.put(Olingo2Endpoint.RESPONSE_HANDLER_PROPERTY, new Olingo2ResponseHandler<Object>() {\n                @Override\n                public void onResponse(Object response, Map<String, String> responseHeaders) {\n                    result[0] = response;\n                    latch.countDown();\n                }\n\n                @Override\n                public void onException(Exception ex) {\n                    error[0] = ex;\n                    latch.countDown();\n                }\n\n                @Override\n                public void onCanceled() {\n                    error[0] = new RuntimeCamelException(\"OData HTTP Request cancelled\");\n                    latch.countDown();\n                }\n            });\n\n            doInvokeMethod(args);\n\n            // guaranteed to return, since an exception on timeout is expected!!!\n            latch.await();\n\n            if (error[0] != null) {\n                throw error[0];\n            }\n\n            //\n            // Allow consumer idle properties to properly handle an empty polling response\n            //\n            if (result[0] instanceof ODataFeed && (((ODataFeed) result[0]).getEntries().isEmpty())) {\n                return 0;\n            } else {\n                int processed = ApiConsumerHelper.getResultsProcessed(this, result[0], isSplitResult());\n                return processed;\n            }\n\n        } catch (Throwable t) {\n            throw RuntimeCamelException.wrapRuntimeCamelException(t);\n        }\n    }"
        ]
    ],
    "e4ad40f2eebb68cfde175b171538e26b278f63f6": [
        [
            "CxfRsConsumerTest::AbstractTestProcessor::processGetCustomer(Exchange)",
            " 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224 -\n 225  \n 226  \n 227 -\n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  ",
            "        public void processGetCustomer(Exchange exchange) throws Exception {\n            Message inMessage = exchange.getIn();                        \n            String httpMethod = inMessage.getHeader(Exchange.HTTP_METHOD, String.class);\n            assertEquals(\"Get a wrong http method\", \"GET\", httpMethod);\n            String path = inMessage.getHeader(Exchange.HTTP_PATH, String.class);\n            // The parameter of the invocation is stored in the body of in message\n            String id = inMessage.getBody(String.class);\n            if (\"/customerservice/customers/126\".equals(path)) {                            \n                Customer customer = new Customer();\n                customer.setId(Long.parseLong(id));\n                customer.setName(\"Willem\");\n                // We just put the response Object into the out message body\n                exchange.getOut().setBody(customer);\n            } else {\n                if (\"/customerservice/customers/400\".equals(path)) {\n                    // We return the remote client IP address this time\n                    org.apache.cxf.message.Message cxfMessage = inMessage.getHeader(CxfConstants.CAMEL_CXF_MESSAGE, org.apache.cxf.message.Message.class);\n                    ServletRequest request = (ServletRequest) cxfMessage.get(\"HTTP.REQUEST\");\n                    // Just make sure the request object is not null\n                    assertNotNull(\"The request object should not be null\", request);\n                    Response r = Response.status(200).entity(\"The remoteAddress is 127.0.0.1\").build();\n                    exchange.getOut().setBody(r);\n                    return;\n                }\n                if (\"/customerservice/customers/123\".equals(path)) {\n                    // send a customer response back\n                    Response r = Response.status(200).entity(\"customer response back!\").build();\n                    exchange.getOut().setBody(r);\n                    return;\n                }\n                if (\"/customerservice/customers/456\".equals(path)) {\n                    Response r = Response.status(404).entity(\"Can't found the customer with uri \" + path).build();\n                    throw new WebApplicationException(r);\n                } else if (\"/customerservice/customers/234\".equals(path)) {\n                    Response r = Response.status(404).entity(\"Can't found the customer with uri \" + path).build();\n                    exchange.getOut().setBody(r);\n                    exchange.getOut().setFault(true);\n                } else {\n                    throw new RuntimeCamelException(\"Can't found the customer with uri \" + path);\n                }\n            }\n        }",
            " 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223  \n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234 +\n 235 +\n 236  \n 237  \n 238 +\n 239 +\n 240  \n 241  \n 242 +\n 243 +\n 244 +\n 245 +\n 246 +\n 247  \n 248  \n 249  \n 250  \n 251  ",
            "        public void processGetCustomer(Exchange exchange) throws Exception {\n            Message inMessage = exchange.getIn();                        \n            String httpMethod = inMessage.getHeader(Exchange.HTTP_METHOD, String.class);\n            assertEquals(\"Get a wrong http method\", \"GET\", httpMethod);\n            String path = inMessage.getHeader(Exchange.HTTP_PATH, String.class);\n            // The parameter of the invocation is stored in the body of in message\n            String id = inMessage.getBody(String.class);\n            if (\"/customerservice/customers/126\".equals(path)) {                            \n                Customer customer = new Customer();\n                customer.setId(Long.parseLong(id));\n                customer.setName(\"Willem\");\n                // We just put the response Object into the out message body\n                exchange.getOut().setBody(customer);\n            } else {\n                if (\"/customerservice/customers/400\".equals(path)) {\n                    // We return the remote client IP address this time\n                    org.apache.cxf.message.Message cxfMessage = inMessage.getHeader(CxfConstants.CAMEL_CXF_MESSAGE, org.apache.cxf.message.Message.class);\n                    ServletRequest request = (ServletRequest) cxfMessage.get(\"HTTP.REQUEST\");\n                    // Just make sure the request object is not null\n                    assertNotNull(\"The request object should not be null\", request);\n                    Response r = Response.status(200).entity(\"The remoteAddress is 127.0.0.1\").build();\n                    exchange.getOut().setBody(r);\n                    return;\n                }\n                if (\"/customerservice/customers/123\".equals(path)) {\n                    // send a customer response back\n                    Response r = Response.status(200).entity(\"customer response back!\").build();\n                    exchange.getOut().setBody(r);\n                    return;\n                }\n                if (\"/customerservice/customers/456\".equals(path)) {\n                    Response r = Response.status(404).entity(\"Can't found the customer with uri \" + path)\n                        .header(\"Content-Type\", \"text/plain\").build();\n                    throw new WebApplicationException(r);\n                } else if (\"/customerservice/customers/234\".equals(path)) {\n                    Response r = Response.status(404).entity(\"Can't found the customer with uri \" + path)\n                        .header(\"Content-Type\", \"text/plain\").build();\n                    exchange.getOut().setBody(r);\n                    exchange.getOut().setFault(true);\n                } else if (\"/customerservice/customers/789\".equals(path)) {\n                    exchange.getOut().setBody(\"Can't found the customer with uri \" + path);\n                    exchange.getOut().setHeader(Exchange.CONTENT_TYPE, \"text/plain\");\n                    exchange.getOut().setHeader(Exchange.HTTP_RESPONSE_CODE, \"404\");                    \n                    exchange.getOut().setFault(true);\n                } else {\n                    throw new RuntimeCamelException(\"Can't found the customer with uri \" + path);\n                }\n            }\n        }"
        ],
        [
            "CxfRsConsumerTest::testGetWrongCustomer()",
            " 146  \n 147  \n 148 -\n 149  \n 150  \n 151  \n 152  \n 153  \n 154  \n 155  \n 156  \n 157  \n 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  ",
            "    @Test\n    public void testGetWrongCustomer() throws Exception {\n        URL url = new URL(\"http://localhost:\" + CXT + \"/rest/customerservice/customers/456\");\n        try {\n            url.openStream();\n            fail(\"Expect to get exception here\");\n        } catch (FileNotFoundException exception) {\n            // do nothing here\n        }\n        \n        url = new URL(\"http://localhost:\" + CXT + \"/rest/customerservice/customers/234\");\n        try {\n            url.openStream();\n            fail(\"Expect to get exception here\");\n        } catch (FileNotFoundException exception) {\n            // do nothing here\n        }\n        \n        url = new URL(\"http://localhost:\" + CXT + \"/rest/customerservice/customers/256\");\n        try {\n            url.openStream();\n            fail(\"Expect to get exception here\");\n        } catch (IOException exception) {\n            // expect the Internal error exception\n        }\n        \n    }",
            " 146  \n 147  \n 148 +\n 149 +\n 150 +\n 151 +\n 152 +\n 153 +\n 154 +\n 155 +\n 156 +\n 157 +\n 158 +\n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  ",
            "    @Test\n    public void testGetWrongCustomer() throws Exception {\n        URL url;\n        \n        url = new URL(\"http://localhost:\" + CXT + \"/rest/customerservice/customers/789\");\n        try {\n            url.openStream();\n            fail(\"Expect to get exception here\");\n        } catch (IOException exception) {\n            // expect the Internal error exception\n        }\n        \n        url = new URL(\"http://localhost:\" + CXT + \"/rest/customerservice/customers/456\");\n        try {\n            url.openStream();\n            fail(\"Expect to get exception here\");\n        } catch (FileNotFoundException exception) {\n            // do nothing here\n        }\n        \n        url = new URL(\"http://localhost:\" + CXT + \"/rest/customerservice/customers/234\");\n        try {\n            url.openStream();\n            fail(\"Expect to get exception here\");\n        } catch (FileNotFoundException exception) {\n            // do nothing here\n        }\n        \n        url = new URL(\"http://localhost:\" + CXT + \"/rest/customerservice/customers/256\");\n        try {\n            url.openStream();\n            fail(\"Expect to get exception here\");\n        } catch (IOException exception) {\n            // expect the Internal error exception\n        }\n        \n    }"
        ],
        [
            "DefaultCxfRsBinding::populateCxfRsResponseFromExchange(Exchange,org)",
            "  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85 -\n  86  ",
            "    public Object populateCxfRsResponseFromExchange(Exchange camelExchange,\n                                                    org.apache.cxf.message.Exchange cxfExchange) throws Exception {\n        // Need to check if the exchange has the exception\n        if (camelExchange.isFailed() && camelExchange.getException() != null) {\n            throw camelExchange.getException();\n        }\n\n        org.apache.camel.Message response;\n        if (camelExchange.getPattern().isOutCapable()) {\n            if (camelExchange.hasOut()) {\n                response = camelExchange.getOut();\n                LOG.trace(\"Get the response from the out message\");\n            } else {\n                response = camelExchange.getIn();\n                LOG.trace(\"Get the response from the in message as a fallback\");\n            }\n        } else {\n            response = camelExchange.getIn();\n            LOG.trace(\"Get the response from the in message\");\n        }\n\n        return response.getBody();\n    }",
            "  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  \n  86  \n  87  \n  88 +\n  89 +\n  90 +\n  91 +\n  92 +\n  93 +\n  94 +\n  95 +\n  96 +\n  97 +\n  98 +\n  99 +\n 100 +\n 101 +\n 102 +\n 103 +\n 104 +\n 105 +\n 106 +\n 107 +\n 108 +\n 109 +\n 110 +\n 111 +\n 112 +\n 113 +\n 114 +\n 115 +\n 116 +\n 117 +\n 118 +\n 119 +\n 120 +\n 121 +\n 122 +\n 123 +\n 124 +\n 125 +\n 126 +\n 127 +\n 128 +\n 129  ",
            "    public Object populateCxfRsResponseFromExchange(Exchange camelExchange,\n                                                    org.apache.cxf.message.Exchange cxfExchange) throws Exception {\n        // Need to check if the exchange has the exception\n        if (camelExchange.isFailed() && camelExchange.getException() != null) {\n            throw camelExchange.getException();\n        }\n\n        org.apache.camel.Message response;\n        if (camelExchange.getPattern().isOutCapable()) {\n            if (camelExchange.hasOut()) {\n                response = camelExchange.getOut();\n                LOG.trace(\"Get the response from the out message\");\n            } else {\n                response = camelExchange.getIn();\n                LOG.trace(\"Get the response from the in message as a fallback\");\n            }\n        } else {\n            response = camelExchange.getIn();\n            LOG.trace(\"Get the response from the in message\");\n        }\n\n        Object o = response.getBody();\n        if (!(o instanceof Response)) {\n            //not a JAX-RS Response object, we need to set the headers from the Camel values\n            \n            \n            if (response.getHeader(org.apache.cxf.message.Message.PROTOCOL_HEADERS) != null) {\n                Map<String, Object> headers = CastUtils.cast((Map<?, ?>)response.getHeader(org.apache.cxf.message.Message.PROTOCOL_HEADERS));\n                cxfExchange.getOutMessage().putIfAbsent(org.apache.cxf.message.Message.PROTOCOL_HEADERS, \n                                                        new TreeMap<>(String.CASE_INSENSITIVE_ORDER));\n                final Map<String, List<String>> cxfHeaders =\n                    CastUtils.cast((Map<?, ?>) cxfExchange.getOutMessage().get(org.apache.cxf.message.Message.PROTOCOL_HEADERS));\n                \n                for (Map.Entry<String, Object> ent : headers.entrySet()) {\n                    List<String> v;\n                    if (ent.getValue() instanceof List) {\n                        v = CastUtils.cast((List<?>)ent.getValue());\n                    } else {\n                        v = Arrays.asList(ent.getValue().toString());\n                    }\n                    cxfHeaders.put(ent.getKey(), v);\n                }\n            }\n            \n            \n            if (response.getHeader(Exchange.HTTP_RESPONSE_CODE) != null && !cxfExchange.containsKey(org.apache.cxf.message.Message.RESPONSE_CODE)) {\n                cxfExchange.put(org.apache.cxf.message.Message.RESPONSE_CODE, response.getHeader(Exchange.HTTP_RESPONSE_CODE, Integer.class));\n            }\n            if (response.getHeader(Exchange.CONTENT_TYPE) != null) {\n                cxfExchange.getOutMessage().putIfAbsent(org.apache.cxf.message.Message.PROTOCOL_HEADERS, \n                                                        new TreeMap<>(String.CASE_INSENSITIVE_ORDER));\n                final Map<String, List<String>> cxfHeaders =\n                    CastUtils.cast((Map<?, ?>) cxfExchange.getOutMessage().get(org.apache.cxf.message.Message.PROTOCOL_HEADERS));\n\n                if (!cxfHeaders.containsKey(Exchange.CONTENT_TYPE)) {\n                    List<String> a = Arrays.asList((String)response.getHeader(Exchange.CONTENT_TYPE));\n                    cxfHeaders.put(Exchange.CONTENT_TYPE, a);\n                    cxfExchange.getOutMessage().put(Exchange.CONTENT_TYPE, response.getHeader(Exchange.CONTENT_TYPE));\n                }\n            }\n        }\n        return o;\n    }"
        ]
    ],
    "409427932593ac2003a487435fe9cd9682326b2b": [
        [
            "HttpServerChannelHandler::beforeProcess(Exchange,ChannelHandlerContext,Object)",
            " 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  ",
            "    @Override\n    protected void beforeProcess(Exchange exchange, final ChannelHandlerContext ctx, final Object message) {\n        final NettyHttpConfiguration configuration = consumer.getConfiguration();\n\n        if (configuration.isBridgeEndpoint()) {\n            exchange.setProperty(Exchange.SKIP_GZIP_ENCODING, Boolean.TRUE);\n            exchange.setProperty(Exchange.SKIP_WWW_FORM_URLENCODED, Boolean.TRUE);\n        }\n        HttpRequest request = (HttpRequest) message;\n        // setup the connection property in case of the message header is removed\n        boolean keepAlive = HttpUtil.isKeepAlive(request);\n        if (!keepAlive) {\n            // Just make sure we close the connection this time.\n            exchange.setProperty(HttpHeaderNames.CONNECTION.toString(), HttpHeaderValues.CLOSE.toString());\n        }\n\n        final Message in = exchange.getIn();\n        if (configuration.isHttpProxy()) {\n            in.removeHeader(\"Proxy-Connection\");\n        }\n    }",
            " 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286 +\n 287  \n 288  \n 289  ",
            "    @Override\n    protected void beforeProcess(Exchange exchange, final ChannelHandlerContext ctx, final Object message) {\n        final NettyHttpConfiguration configuration = consumer.getConfiguration();\n\n        if (configuration.isBridgeEndpoint()) {\n            exchange.setProperty(Exchange.SKIP_GZIP_ENCODING, Boolean.TRUE);\n            exchange.setProperty(Exchange.SKIP_WWW_FORM_URLENCODED, Boolean.TRUE);\n        }\n        HttpRequest request = (HttpRequest) message;\n        // setup the connection property in case of the message header is removed\n        boolean keepAlive = HttpUtil.isKeepAlive(request);\n        if (!keepAlive) {\n            // Just make sure we close the connection this time.\n            exchange.setProperty(HttpHeaderNames.CONNECTION.toString(), HttpHeaderValues.CLOSE.toString());\n        }\n\n        final Message in = exchange.getIn();\n        if (configuration.isHttpProxy()) {\n            exchange.setProperty(NettyHttpConstants.PROXY_REQUEST, request);\n            in.removeHeader(\"Proxy-Connection\");\n        }\n    }"
        ],
        [
            "DefaultNettyHttpBinding::toNettyRequest(Message,String,NettyHttpConfiguration)",
            " 472  \n 473  \n 474  \n 475  \n 476  \n 477  \n 478  \n 479  \n 480  \n 481  \n 482  \n 483  \n 484  \n 485  \n 486  \n 487  \n 488  \n 489  \n 490  \n 491  \n 492  \n 493  \n 494  \n 495  \n 496  \n 497  \n 498  \n 499  \n 500  \n 501  \n 502  \n 503  \n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512 -\n 513 -\n 514 -\n 515 -\n 516 -\n 517 -\n 518 -\n 519 -\n 520 -\n 521 -\n 522 -\n 523 -\n 524 -\n 525 -\n 526 -\n 527  \n 528  \n 529  \n 530  \n 531 -\n 532 -\n 533 -\n 534 -\n 535 -\n 536 -\n 537 -\n 538  \n 539  \n 540 -\n 541 -\n 542 -\n 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564  \n 565  \n 566  \n 567  \n 568  \n 569  \n 570  \n 571  \n 572  \n 573  \n 574  \n 575  \n 576  \n 577  \n 578  \n 579  \n 580  \n 581  \n 582  \n 583  \n 584  \n 585  \n 586  \n 587  \n 588  \n 589  \n 590  \n 591  \n 592  \n 593  \n 594  \n 595  \n 596  \n 597  \n 598  \n 599  \n 600  \n 601  \n 602  \n 603  \n 604  \n 605  \n 606  \n 607  \n 608  \n 609  \n 610  \n 611  \n 612  \n 613  ",
            "    @Override\n    public HttpRequest toNettyRequest(Message message, String fullUri, NettyHttpConfiguration configuration) throws Exception {\n        LOG.trace(\"toNettyRequest: {}\", message);\n\n        Object body = message.getBody();\n        // the message body may already be a Netty HTTP response\n        if (body instanceof HttpRequest) {\n            return (HttpRequest) message.getBody();\n        }\n\n        String uriForRequest = fullUri;\n        if (configuration.isUseRelativePath()) {\n            final URI uri = new URI(uriForRequest);\n            final String rawPath = uri.getRawPath();\n            if (rawPath != null) {\n                uriForRequest = rawPath;\n            }\n            final String rawQuery = uri.getRawQuery();\n            if (rawQuery != null) {\n                uriForRequest += \"?\" + rawQuery;\n            }\n        }\n\n        final String headerProtocolVersion = message.getHeader(Exchange.HTTP_PROTOCOL_VERSION, String.class);\n        final HttpVersion protocol;\n        if (headerProtocolVersion == null) {\n            protocol = HttpVersion.HTTP_1_1;\n        } else {\n            protocol = HttpVersion.valueOf(headerProtocolVersion);\n        }\n\n        final String headerMethod = message.getHeader(Exchange.HTTP_METHOD, String.class);\n\n        final HttpMethod httpMethod;\n        if (headerMethod == null) {\n            httpMethod = HttpMethod.GET;\n        } else {\n            httpMethod = HttpMethod.valueOf(headerMethod);\n        }\n\n        FullHttpRequest request = new DefaultFullHttpRequest(protocol, httpMethod, uriForRequest);\n        if (body != null) {\n            // support bodies as native Netty\n            ByteBuf buffer;\n            if (body instanceof ByteBuf) {\n                buffer = (ByteBuf) body;\n            } else {\n                // try to convert to buffer first\n                buffer = message.getBody(ByteBuf.class);\n                if (buffer == null) {\n                    // fallback to byte array as last resort\n                    byte[] data = message.getMandatoryBody(byte[].class);\n\n                    if (data.length > 0) {\n                        buffer = NettyConverter.toByteBuffer(data);\n                    }\n                }\n            }\n\n            if (buffer != null && buffer.readableBytes() > 0) {\n                request = request.replace(buffer);\n                int len = buffer.readableBytes();\n                // set content-length\n                request.headers().set(HttpHeaderNames.CONTENT_LENGTH.toString(), len);\n                LOG.trace(\"Content-Length: {}\", len);\n            }\n        }\n\n        // update HTTP method accordingly as we know if we have a body or not\n        HttpMethod method = NettyHttpHelper.createMethod(message, body != null);\n        request.setMethod(method);\n\n        TypeConverter tc = message.getExchange().getContext().getTypeConverter();\n\n        // if we bridge endpoint then we need to skip matching headers with the HTTP_QUERY to avoid sending\n        // duplicated headers to the receiver, so use this skipRequestHeaders as the list of headers to skip\n        Map<String, Object> skipRequestHeaders = null;\n        if (configuration.isBridgeEndpoint()) {\n            String queryString = message.getHeader(Exchange.HTTP_QUERY, String.class);\n            if (queryString != null) {\n                skipRequestHeaders = URISupport.parseQuery(queryString, false, true);\n            }\n            // Need to remove the Host key as it should be not used\n            message.getHeaders().remove(\"host\");\n        }\n\n        // append headers\n        // must use entrySet to ensure case of keys is preserved\n        for (Map.Entry<String, Object> entry : message.getHeaders().entrySet()) {\n            String key = entry.getKey();\n            Object value = entry.getValue();\n\n            // we should not add headers for the parameters in the uri if we bridge the endpoint\n            // as then we would duplicate headers on both the endpoint uri, and in HTTP headers as well\n            if (skipRequestHeaders != null && skipRequestHeaders.containsKey(key)) {\n                continue;\n            }\n\n            // use an iterator as there can be multiple values. (must not use a delimiter)\n            final Iterator<?> it = ObjectHelper.createIterator(value, null, true);\n            while (it.hasNext()) {\n                String headerValue = tc.convertTo(String.class, it.next());\n\n                if (headerValue != null && headerFilterStrategy != null\n                        && !headerFilterStrategy.applyFilterToCamelHeaders(key, headerValue, message.getExchange())) {\n                    LOG.trace(\"HTTP-Header: {}={}\", key, headerValue);\n                    request.headers().add(key, headerValue);\n                }\n            }\n        }\n\n        // set the content type in the response.\n        String contentType = MessageHelper.getContentType(message);\n        if (contentType != null) {\n            // set content-type\n            request.headers().set(HttpHeaderNames.CONTENT_TYPE.toString(), contentType);\n            LOG.trace(\"Content-Type: {}\", contentType);\n        }\n\n        // must include HOST header as required by HTTP 1.1\n        // use URI as its faster than URL (no DNS lookup)\n        URI u = new URI(fullUri);\n        String hostHeader = u.getHost() + (u.getPort() == 80 ? \"\" : \":\" + u.getPort());\n        request.headers().set(HttpHeaderNames.HOST.toString(), hostHeader);\n        LOG.trace(\"Host: {}\", hostHeader);\n\n        // configure connection to accordingly to keep alive configuration\n        // favor using the header from the message\n        String connection = message.getHeader(HttpHeaderNames.CONNECTION.toString(), String.class);\n        if (connection == null) {\n            // fallback and use the keep alive from the configuration\n            if (configuration.isKeepAlive()) {\n                connection = HttpHeaderValues.KEEP_ALIVE.toString();\n            } else {\n                connection = HttpHeaderValues.CLOSE.toString();\n            }\n        }\n        request.headers().set(HttpHeaderNames.CONNECTION.toString(), connection);\n        LOG.trace(\"Connection: {}\", connection);\n\n        return request;\n    }",
            " 472  \n 473  \n 474  \n 475  \n 476  \n 477  \n 478  \n 479  \n 480  \n 481  \n 482  \n 483  \n 484  \n 485  \n 486  \n 487  \n 488  \n 489  \n 490  \n 491  \n 492  \n 493  \n 494  \n 495  \n 496  \n 497  \n 498  \n 499  \n 500  \n 501  \n 502  \n 503  \n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512 +\n 513 +\n 514 +\n 515 +\n 516 +\n 517 +\n 518 +\n 519 +\n 520 +\n 521 +\n 522 +\n 523 +\n 524 +\n 525 +\n 526 +\n 527 +\n 528 +\n 529 +\n 530 +\n 531 +\n 532 +\n 533 +\n 534 +\n 535 +\n 536 +\n 537 +\n 538 +\n 539 +\n 540 +\n 541 +\n 542 +\n 543 +\n 544 +\n 545 +\n 546 +\n 547 +\n 548 +\n 549 +\n 550 +\n 551 +\n 552 +\n 553 +\n 554 +\n 555 +\n 556 +\n 557 +\n 558 +\n 559 +\n 560 +\n 561 +\n 562 +\n 563 +\n 564 +\n 565  \n 566  \n 567  \n 568  \n 569 +\n 570 +\n 571 +\n 572  \n 573  \n 574  \n 575  \n 576  \n 577  \n 578  \n 579  \n 580  \n 581  \n 582  \n 583  \n 584  \n 585  \n 586  \n 587  \n 588  \n 589  \n 590  \n 591  \n 592  \n 593  \n 594  \n 595  \n 596  \n 597  \n 598  \n 599  \n 600  \n 601  \n 602  \n 603  \n 604  \n 605  \n 606  \n 607  \n 608  \n 609  \n 610  \n 611  \n 612  \n 613  \n 614  \n 615  \n 616  \n 617  \n 618  \n 619  \n 620  \n 621  \n 622  \n 623  \n 624  \n 625  \n 626  \n 627  \n 628  \n 629  \n 630  \n 631  \n 632  \n 633  \n 634  \n 635  \n 636  \n 637  \n 638  \n 639  \n 640  \n 641  \n 642  \n 643  \n 644  ",
            "    @Override\n    public HttpRequest toNettyRequest(Message message, String fullUri, NettyHttpConfiguration configuration) throws Exception {\n        LOG.trace(\"toNettyRequest: {}\", message);\n\n        Object body = message.getBody();\n        // the message body may already be a Netty HTTP response\n        if (body instanceof HttpRequest) {\n            return (HttpRequest) message.getBody();\n        }\n\n        String uriForRequest = fullUri;\n        if (configuration.isUseRelativePath()) {\n            final URI uri = new URI(uriForRequest);\n            final String rawPath = uri.getRawPath();\n            if (rawPath != null) {\n                uriForRequest = rawPath;\n            }\n            final String rawQuery = uri.getRawQuery();\n            if (rawQuery != null) {\n                uriForRequest += \"?\" + rawQuery;\n            }\n        }\n\n        final String headerProtocolVersion = message.getHeader(Exchange.HTTP_PROTOCOL_VERSION, String.class);\n        final HttpVersion protocol;\n        if (headerProtocolVersion == null) {\n            protocol = HttpVersion.HTTP_1_1;\n        } else {\n            protocol = HttpVersion.valueOf(headerProtocolVersion);\n        }\n\n        final String headerMethod = message.getHeader(Exchange.HTTP_METHOD, String.class);\n\n        final HttpMethod httpMethod;\n        if (headerMethod == null) {\n            httpMethod = HttpMethod.GET;\n        } else {\n            httpMethod = HttpMethod.valueOf(headerMethod);\n        }\n\n        final Exchange exchange = message.getExchange();\n        final Object proxyRequest;\n        if (exchange != null) {\n            proxyRequest = exchange.getProperty(NettyHttpConstants.PROXY_REQUEST);\n        } else {\n            proxyRequest = null;\n        }\n\n        FullHttpRequest request = null;\n        if (message instanceof NettyHttpMessage) {\n            // if the request is already given we should set the values\n            // from message headers and pass on the same request\n            final FullHttpRequest givenRequest = ((NettyHttpMessage) message).getHttpRequest();\n            // we need to make sure that the givenRequest is the original\n            // request received by the proxy\n            if (givenRequest != null && proxyRequest == givenRequest) {\n                request = givenRequest\n                        .setProtocolVersion(protocol)\n                        .setMethod(httpMethod)\n                        .setUri(uriForRequest);\n            }\n        }\n\n        if (request == null) {\n            request = new DefaultFullHttpRequest(protocol, httpMethod, uriForRequest);\n\n            if (body != null) {\n                // support bodies as native Netty\n                ByteBuf buffer;\n                if (body instanceof ByteBuf) {\n                    buffer = (ByteBuf) body;\n                } else {\n                    // try to convert to buffer first\n                    buffer = message.getBody(ByteBuf.class);\n                    if (buffer == null) {\n                        // fallback to byte array as last resort\n                        byte[] data = message.getMandatoryBody(byte[].class);\n    \n                        if (data.length > 0) {\n                            buffer = NettyConverter.toByteBuffer(data);\n                        }\n                    }\n                }\n    \n                if (buffer != null) {\n                    if (buffer.readableBytes() > 0) {\n                        request = request.replace(buffer);\n                        int len = buffer.readableBytes();\n                        // set content-length\n                        request.headers().set(HttpHeaderNames.CONTENT_LENGTH.toString(), len);\n                        LOG.trace(\"Content-Length: {}\", len);\n                    } else {\n                        buffer.release();\n                    }\n                }\n            }\n\n            // update HTTP method accordingly as we know if we have a body or not\n            HttpMethod method = NettyHttpHelper.createMethod(message, body != null);\n            request.setMethod(method);\n        }\n\n\n        TypeConverter tc = message.getExchange().getContext().getTypeConverter();\n\n        // if we bridge endpoint then we need to skip matching headers with the HTTP_QUERY to avoid sending\n        // duplicated headers to the receiver, so use this skipRequestHeaders as the list of headers to skip\n        Map<String, Object> skipRequestHeaders = null;\n        if (configuration.isBridgeEndpoint()) {\n            String queryString = message.getHeader(Exchange.HTTP_QUERY, String.class);\n            if (queryString != null) {\n                skipRequestHeaders = URISupport.parseQuery(queryString, false, true);\n            }\n            // Need to remove the Host key as it should be not used\n            message.getHeaders().remove(\"host\");\n        }\n\n        // append headers\n        // must use entrySet to ensure case of keys is preserved\n        for (Map.Entry<String, Object> entry : message.getHeaders().entrySet()) {\n            String key = entry.getKey();\n            Object value = entry.getValue();\n\n            // we should not add headers for the parameters in the uri if we bridge the endpoint\n            // as then we would duplicate headers on both the endpoint uri, and in HTTP headers as well\n            if (skipRequestHeaders != null && skipRequestHeaders.containsKey(key)) {\n                continue;\n            }\n\n            // use an iterator as there can be multiple values. (must not use a delimiter)\n            final Iterator<?> it = ObjectHelper.createIterator(value, null, true);\n            while (it.hasNext()) {\n                String headerValue = tc.convertTo(String.class, it.next());\n\n                if (headerValue != null && headerFilterStrategy != null\n                        && !headerFilterStrategy.applyFilterToCamelHeaders(key, headerValue, message.getExchange())) {\n                    LOG.trace(\"HTTP-Header: {}={}\", key, headerValue);\n                    request.headers().add(key, headerValue);\n                }\n            }\n        }\n\n        // set the content type in the response.\n        String contentType = MessageHelper.getContentType(message);\n        if (contentType != null) {\n            // set content-type\n            request.headers().set(HttpHeaderNames.CONTENT_TYPE.toString(), contentType);\n            LOG.trace(\"Content-Type: {}\", contentType);\n        }\n\n        // must include HOST header as required by HTTP 1.1\n        // use URI as its faster than URL (no DNS lookup)\n        URI u = new URI(fullUri);\n        String hostHeader = u.getHost() + (u.getPort() == 80 ? \"\" : \":\" + u.getPort());\n        request.headers().set(HttpHeaderNames.HOST.toString(), hostHeader);\n        LOG.trace(\"Host: {}\", hostHeader);\n\n        // configure connection to accordingly to keep alive configuration\n        // favor using the header from the message\n        String connection = message.getHeader(HttpHeaderNames.CONNECTION.toString(), String.class);\n        if (connection == null) {\n            // fallback and use the keep alive from the configuration\n            if (configuration.isKeepAlive()) {\n                connection = HttpHeaderValues.KEEP_ALIVE.toString();\n            } else {\n                connection = HttpHeaderValues.CLOSE.toString();\n            }\n        }\n        request.headers().set(HttpHeaderNames.CONNECTION.toString(), connection);\n        LOG.trace(\"Connection: {}\", connection);\n\n        return request;\n    }"
        ]
    ],
    "e61138b9f2834bf4a3d0c3e8cf868e5de8faea70": [
        [
            "PlatformEventsConsumerIntegrationTest::shouldConsumePlatformEvents()",
            "  35  \n  36  \n  37  \n  38  \n  39 -\n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  ",
            "    @Test\n    public void shouldConsumePlatformEvents() throws InterruptedException, ExecutionException {\n        final ExecutorService parallel = Executors.newSingleThreadExecutor();\n\n        final Future<PlatformEvent> futurePlatformEvent = parallel.submit(() -> consumer.receiveBody(\"salesforce:event/TestEvent__e\", PlatformEvent.class));\n\n        // it takes some time for the subscriber to subscribe, so we'll try to\n        // send repeated platform events and wait until the first one is\n        // received\n        Awaitility.await().atMost(10, TimeUnit.SECONDS).untilAsserted(() -> {\n            template.sendBody(\"direct:sendPlatformEvent\", \"{\\\"Test_Field__c\\\": \\\"data\\\"}\");\n\n            Assertions.assertThat(futurePlatformEvent.isDone()).isTrue();\n        });\n\n        final PlatformEvent platformEvent = futurePlatformEvent.get();\n        Assertions.assertThat(platformEvent).isNotNull();\n        Assertions.assertThat(platformEvent.getEventData()).containsOnly(entry(\"Test_Field__c\", \"data\"));\n    }",
            "  35  \n  36  \n  37  \n  38  \n  39 +\n  40  \n  41  \n  42  \n  43  \n  44  \n  45  \n  46  \n  47  \n  48  \n  49  \n  50  \n  51  \n  52  \n  53  ",
            "    @Test\n    public void shouldConsumePlatformEvents() throws InterruptedException, ExecutionException {\n        final ExecutorService parallel = Executors.newSingleThreadExecutor();\n\n        final Future<PlatformEvent> futurePlatformEvent = parallel.submit(() -> consumer.receiveBody(\"salesforce:event/TestEvent__e?replayId=-1\", PlatformEvent.class));\n\n        // it takes some time for the subscriber to subscribe, so we'll try to\n        // send repeated platform events and wait until the first one is\n        // received\n        Awaitility.await().atMost(10, TimeUnit.SECONDS).untilAsserted(() -> {\n            template.sendBody(\"direct:sendPlatformEvent\", \"{\\\"Test_Field__c\\\": \\\"data\\\"}\");\n\n            Assertions.assertThat(futurePlatformEvent.isDone()).isTrue();\n        });\n\n        final PlatformEvent platformEvent = futurePlatformEvent.get();\n        Assertions.assertThat(platformEvent).isNotNull();\n        Assertions.assertThat(platformEvent.getEventData()).containsOnly(entry(\"Test_Field__c\", \"data\"));\n    }"
        ],
        [
            "SalesforceComponentVerifierExtension::verifyConnectivity(Map)",
            "  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80 -\n  81 -\n  82  \n  83  \n  84  \n  85 -\n  86 -\n  87 -\n  88 -\n  89 -\n  90  \n  91 -\n  92 -\n  93 -\n  94  \n  95  \n  96  \n  97  ",
            "    @Override\n    protected Result verifyConnectivity(Map<String, Object> parameters) {\n        // Default is success\n        ResultBuilder builder = ResultBuilder.withStatusAndScope(Result.Status.OK, Scope.CONNECTIVITY);\n\n        try {\n            SalesforceClientTemplate.invoke(getCamelContext(), parameters, client -> {\n                client.getVersions(Collections.emptyMap(),\n                    (response, headers, exception) ->  processSalesforceException(builder, Optional.ofNullable(exception)));\n                return null;\n            });\n        } catch (NoSuchOptionException e) {\n            builder.error(\n                ResultErrorBuilder.withMissingOption(e.getOptionName()).build()\n            );\n        } catch (SalesforceException e) {\n            processSalesforceException(builder, Optional.of(e));\n        } catch (Exception e) {\n            builder.error(\n                ResultErrorBuilder.withException(e).build()\n            );\n        }\n\n        return builder.build();\n    }",
            "  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80 +\n  81  \n  82  \n  83  \n  84 +\n  85  \n  86 +\n  87 +\n  88 +\n  89 +\n  90 +\n  91  \n  92  \n  93  \n  94  ",
            "    @Override\n    protected Result verifyConnectivity(Map<String, Object> parameters) {\n        // Default is success\n        ResultBuilder builder = ResultBuilder.withStatusAndScope(Result.Status.OK, Scope.CONNECTIVITY);\n\n        try {\n            SalesforceClientTemplate.invoke(getCamelContext(), parameters, client -> {\n                client.getVersions(Collections.emptyMap(), (response, headers, exception) -> processSalesforceException(builder, Optional.ofNullable(exception)));\n                return null;\n            });\n        } catch (NoSuchOptionException e) {\n            builder.error(ResultErrorBuilder.withMissingOption(e.getOptionName()).build());\n        } catch (Exception e) {\n            if (e.getCause() instanceof SalesforceException) {\n                processSalesforceException(builder, Optional.of((SalesforceException)e.getCause()));\n            } else {\n                builder.error(ResultErrorBuilder.withException(e).build());\n            }\n        }\n\n        return builder.build();\n    }"
        ],
        [
            "HttpProxyIntegrationTest::setupServer()",
            "  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123 -\n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  ",
            "    @BeforeClass\n    public static void setupServer() throws Exception {\n        // start a local HTTP proxy using Jetty server\n        server = new Server();\n\n        ServerConnector connector = new ServerConnector(server);\n\n        connector.setHost(HTTP_PROXY_HOST);\n        server.addConnector(connector);\n\n        final String authenticationString = \"Basic \"\n            + B64Code.encode(HTTP_PROXY_USER_NAME + \":\" + HTTP_PROXY_PASSWORD, StringUtil.__ISO_8859_1);\n\n        ConnectHandler connectHandler = new ConnectHandler() {\n            @Override\n            protected boolean handleAuthentication(HttpServletRequest request, HttpServletResponse response, String address) {\n                // validate proxy-authentication header\n                final String header = request.getHeader(PROXY_AUTHORIZATION.toString());\n                if (!authenticationString.equals(header)) {\n                    LOG.warn(\"Missing header \" + PROXY_AUTHORIZATION);\n                    // ask for authentication header\n                    response.setHeader(PROXY_AUTHENTICATE.toString(), String.format(\"Basic realm=\\\"%s\\\"\", HTTP_PROXY_REALM));\n                    return false;\n                }\n                LOG.info(\"Request contains required header \" + PROXY_AUTHORIZATION);\n                WENT_TORUGH_PROXY.set(true);\n                return true;\n            }\n        };\n        server.setHandler(connectHandler);\n\n        LOG.info(\"Starting proxy server...\");\n        server.start();\n\n        httpProxyPort = connector.getLocalPort();\n        LOG.info(\"Started proxy server on port {}\", httpProxyPort);\n    }",
            "  98  \n  99  \n 100  \n 101  \n 102  \n 103  \n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123 +\n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  ",
            "    @BeforeClass\n    public static void setupServer() throws Exception {\n        // start a local HTTP proxy using Jetty server\n        server = new Server();\n\n        ServerConnector connector = new ServerConnector(server);\n\n        connector.setHost(HTTP_PROXY_HOST);\n        server.addConnector(connector);\n\n        final String authenticationString = \"Basic \"\n            + B64Code.encode(HTTP_PROXY_USER_NAME + \":\" + HTTP_PROXY_PASSWORD, StringUtil.__ISO_8859_1);\n\n        ConnectHandler connectHandler = new ConnectHandler() {\n            @Override\n            protected boolean handleAuthentication(HttpServletRequest request, HttpServletResponse response, String address) {\n                // validate proxy-authentication header\n                final String header = request.getHeader(PROXY_AUTHORIZATION.toString());\n                if (!authenticationString.equals(header)) {\n                    LOG.warn(\"Missing header \" + PROXY_AUTHORIZATION);\n                    // ask for authentication header\n                    response.setHeader(PROXY_AUTHENTICATE.toString(), String.format(\"Basic realm=\\\"%s\\\"\", HTTP_PROXY_REALM));\n                    return false;\n                }\n                LOG.info(\"Request contains required header \" + PROXY_AUTHORIZATION);\n                WENT_THROUGH_PROXY.set(true);\n                return true;\n            }\n        };\n        server.setHandler(connectHandler);\n\n        LOG.info(\"Starting proxy server...\");\n        server.start();\n\n        httpProxyPort = connector.getLocalPort();\n        LOG.info(\"Started proxy server on port {}\", httpProxyPort);\n    }"
        ],
        [
            "HttpProxyIntegrationTest::testGetVersions()",
            "  75  \n  76  \n  77  \n  78  \n  79  \n  80 -\n  81  ",
            "    @Test\n    public void testGetVersions() throws Exception {\n        doTestGetVersions(\"\");\n        doTestGetVersions(\"Xml\");\n\n        assertTrue(\"Should have gone through the test proxy\", WENT_TORUGH_PROXY.get());\n    }",
            "  75  \n  76  \n  77  \n  78  \n  79  \n  80 +\n  81  ",
            "    @Test\n    public void testGetVersions() throws Exception {\n        doTestGetVersions(\"\");\n        doTestGetVersions(\"Xml\");\n\n        assertTrue(\"Should have gone through the test proxy\", WENT_THROUGH_PROXY.get());\n    }"
        ]
    ],
    "138141e56ead726edb2c8cc5c03682bbed5371f6": [
        [
            "SalesforceComponent::createHttpClient(SslContextFactory)",
            " 714  \n 715  \n 716  \n 717  \n 718  \n 719  \n 720  \n 721  ",
            "    static SalesforceHttpClient createHttpClient(final SslContextFactory sslContextFactory) throws Exception {\n        final SalesforceHttpClient httpClient = new SalesforceHttpClient(sslContextFactory);\n        // default settings, use httpClientProperties to set other\n        // properties\n        httpClient.setConnectTimeout(CONNECTION_TIMEOUT);\n\n        return httpClient;\n    }",
            " 715  \n 716  \n 717  \n 718  \n 719  \n 720 +\n 721  \n 722  \n 723  ",
            "    static SalesforceHttpClient createHttpClient(final SslContextFactory sslContextFactory) throws Exception {\n        final SalesforceHttpClient httpClient = new SalesforceHttpClient(sslContextFactory);\n        // default settings, use httpClientProperties to set other\n        // properties\n        httpClient.setConnectTimeout(CONNECTION_TIMEOUT);\n        httpClient.setIdleTimeout(IDLE_TIMEOUT);\n\n        return httpClient;\n    }"
        ]
    ]
}