{
    "ce911bafbfc4bab88fbd0827273ab4e9ee2de0f7": [
        [
            "FailoverTransport::handleTransportFailure(IOException)",
            " 243  \n 244  \n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260 -\n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267  \n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  ",
            "    public final void handleTransportFailure(IOException e) throws InterruptedException {\n        synchronized (reconnectMutex) {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(this + \" handleTransportFailure: \" + e, e);\n            }\n\n            Transport transport = connectedTransport.getAndSet(null);\n\n            if (transport != null) {\n\n                disposeTransport(transport);\n\n                boolean reconnectOk = false;\n\n                if (canReconnect()) {\n                    reconnectOk = true;\n                }\n                LOG.warn(\"Transport (\" + transport + \") failed, reason:  \"\n                        + (reconnectOk ? \",\" : \", not\") + \" attempting to automatically reconnect\", e);\n\n                initialized = false;\n                failedConnectTransportURI = connectedTransportURI;\n                connectedTransportURI = null;\n                connected = false;\n                connectedToPriority = false;\n\n                if (reconnectOk) {\n                    // notify before any reconnect attempt so ack state can be whacked\n                    if (transportListener != null) {\n                        transportListener.transportInterupted();\n                    }\n\n                    updated.remove(failedConnectTransportURI);\n                    reconnectTask.wakeup();\n                } else if (!isDisposed()) {\n                    propagateFailureToExceptionListener(e);\n                }\n            }\n        }\n    }",
            " 244  \n 245  \n 246 +\n 247 +\n 248 +\n 249 +\n 250 +\n 251 +\n 252  \n 253  \n 254  \n 255  \n 256  \n 257  \n 258  \n 259  \n 260  \n 261  \n 262  \n 263  \n 264  \n 265  \n 266  \n 267 +\n 268  \n 269  \n 270  \n 271  \n 272  \n 273  \n 274  \n 275  \n 276  \n 277  \n 278  \n 279  \n 280  \n 281  \n 282  \n 283  \n 284  \n 285  \n 286  \n 287  \n 288  \n 289  ",
            "    public final void handleTransportFailure(IOException e) throws InterruptedException {\n        synchronized (reconnectMutex) {\n            if (shuttingDown) {\n                // shutdown info sent and remote socket closed and we see that before a local close\n                // let the close do the work\n                return;\n            }\n\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(this + \" handleTransportFailure: \" + e, e);\n            }\n\n            Transport transport = connectedTransport.getAndSet(null);\n\n            if (transport != null) {\n\n                disposeTransport(transport);\n\n                boolean reconnectOk = false;\n\n                if (canReconnect()) {\n                    reconnectOk = true;\n                }\n                LOG.warn(\"Transport (\" + transport + \") failed\"\n                        + (reconnectOk ? \",\" : \", not\") + \" attempting to automatically reconnect\", e);\n\n                initialized = false;\n                failedConnectTransportURI = connectedTransportURI;\n                connectedTransportURI = null;\n                connected = false;\n                connectedToPriority = false;\n\n                if (reconnectOk) {\n                    // notify before any reconnect attempt so ack state can be whacked\n                    if (transportListener != null) {\n                        transportListener.transportInterupted();\n                    }\n\n                    updated.remove(failedConnectTransportURI);\n                    reconnectTask.wakeup();\n                } else if (!isDisposed()) {\n                    propagateFailureToExceptionListener(e);\n                }\n            }\n        }\n    }"
        ],
        [
            "FailoverTransport::oneway(Object)",
            " 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564  \n 565  \n 566  \n 567  \n 568  \n 569  \n 570  \n 571  \n 572  \n 573  \n 574  \n 575  \n 576  \n 577  \n 578  \n 579  \n 580  \n 581  \n 582  \n 583  \n 584  \n 585  \n 586  \n 587  \n 588  \n 589  \n 590  \n 591  \n 592  \n 593  \n 594  \n 595  \n 596  \n 597  \n 598  \n 599  \n 600  \n 601  \n 602  \n 603  \n 604  \n 605  \n 606  \n 607  \n 608  \n 609  \n 610  \n 611  \n 612  \n 613  \n 614  \n 615  \n 616  \n 617  \n 618  \n 619  \n 620  \n 621  \n 622  \n 623  \n 624  \n 625  \n 626  \n 627  \n 628  \n 629  \n 630  \n 631  \n 632  \n 633  \n 634  \n 635  \n 636  \n 637  \n 638  \n 639  \n 640  \n 641  \n 642  \n 643  \n 644  \n 645  \n 646  \n 647  \n 648  \n 649  \n 650  \n 651  \n 652  \n 653  \n 654  \n 655  \n 656  \n 657  \n 658  \n 659  \n 660  \n 661  \n 662  \n 663  \n 664  \n 665  \n 666  \n 667  \n 668  \n 669  \n 670  \n 671  \n 672  \n 673  \n 674  \n 675  \n 676  \n 677  \n 678  \n 679  \n 680  \n 681  \n 682  \n 683  \n 684  \n 685  \n 686  \n 687  \n 688  \n 689  \n 690  \n 691  \n 692  \n 693  \n 694  \n 695  \n 696  \n 697  \n 698  \n 699  \n 700  \n 701  \n 702  \n 703  \n 704  \n 705  \n 706  \n 707  \n 708  \n 709  \n 710  \n 711  ",
            "    @Override\n    public void oneway(Object o) throws IOException {\n\n        Command command = (Command) o;\n        Exception error = null;\n        try {\n\n            synchronized (reconnectMutex) {\n\n                if (command != null && connectedTransport.get() == null) {\n                    if (command.isShutdownInfo()) {\n                        // Skipping send of ShutdownInfo command when not connected.\n                        return;\n                    } else if (command instanceof RemoveInfo || command.isMessageAck()) {\n                        // Simulate response to RemoveInfo command or MessageAck (as it will be stale)\n                        stateTracker.track(command);\n                        if (command.isResponseRequired()) {\n                            Response response = new Response();\n                            response.setCorrelationId(command.getCommandId());\n                            myTransportListener.onCommand(response);\n                        }\n                        return;\n                    } else if (command instanceof MessagePull) {\n                        // Simulate response to MessagePull if timed as we can't honor that now.\n                        MessagePull pullRequest = (MessagePull) command;\n                        if (pullRequest.getTimeout() != 0) {\n                            MessageDispatch dispatch = new MessageDispatch();\n                            dispatch.setConsumerId(pullRequest.getConsumerId());\n                            dispatch.setDestination(pullRequest.getDestination());\n                            myTransportListener.onCommand(dispatch);\n                        }\n                        return;\n                    }\n                }\n\n                // Keep trying until the message is sent.\n                for (int i = 0; !disposed; i++) {\n                    try {\n\n                        // Wait for transport to be connected.\n                        Transport transport = connectedTransport.get();\n                        long start = System.currentTimeMillis();\n                        boolean timedout = false;\n                        while (transport == null && !disposed && connectionFailure == null\n                                && !Thread.currentThread().isInterrupted()) {\n                            if (LOG.isTraceEnabled()) {\n                                LOG.trace(\"Waiting for transport to reconnect..: \" + command);\n                            }\n                            long end = System.currentTimeMillis();\n                            if (command.isMessage() && timeout > 0 && (end - start > timeout)) {\n                                timedout = true;\n                                if (LOG.isInfoEnabled()) {\n                                    LOG.info(\"Failover timed out after \" + (end - start) + \"ms\");\n                                }\n                                break;\n                            }\n                            try {\n                                reconnectMutex.wait(100);\n                            } catch (InterruptedException e) {\n                                Thread.currentThread().interrupt();\n                                if (LOG.isDebugEnabled()) {\n                                    LOG.debug(\"Interupted: \" + e, e);\n                                }\n                            }\n                            transport = connectedTransport.get();\n                        }\n\n                        if (transport == null) {\n                            // Previous loop may have exited due to use being\n                            // disposed.\n                            if (disposed) {\n                                error = new IOException(\"Transport disposed.\");\n                            } else if (connectionFailure != null) {\n                                error = connectionFailure;\n                            } else if (timedout == true) {\n                                error = new IOException(\"Failover timeout of \" + timeout + \" ms reached.\");\n                            } else {\n                                error = new IOException(\"Unexpected failure.\");\n                            }\n                            break;\n                        }\n\n                        Tracked tracked = null;\n                        try {\n                            tracked = stateTracker.track(command);\n                        } catch (IOException ioe) {\n                            LOG.debug(\"Cannot track the command \" + command, ioe);\n                        }\n                        // If it was a request and it was not being tracked by\n                        // the state tracker,\n                        // then hold it in the requestMap so that we can replay\n                        // it later.\n                        synchronized (requestMap) {\n                            if (tracked != null && tracked.isWaitingForResponse()) {\n                                requestMap.put(Integer.valueOf(command.getCommandId()), tracked);\n                            } else if (tracked == null && command.isResponseRequired()) {\n                                requestMap.put(Integer.valueOf(command.getCommandId()), command);\n                            }\n                        }\n\n                        // Send the message.\n                        try {\n                            transport.oneway(command);\n                            stateTracker.trackBack(command);\n                        } catch (IOException e) {\n\n                            // If the command was not tracked.. we will retry in\n                            // this method\n                            if (tracked == null) {\n\n                                // since we will retry in this method.. take it\n                                // out of the request\n                                // map so that it is not sent 2 times on\n                                // recovery\n                                if (command.isResponseRequired()) {\n                                    requestMap.remove(Integer.valueOf(command.getCommandId()));\n                                }\n\n                                // Rethrow the exception so it will handled by\n                                // the outer catch\n                                throw e;\n                            } else {\n                                // Handle the error but allow the method to return since the\n                                // tracked commands are replayed on reconnect.\n                                if (LOG.isDebugEnabled()) {\n                                    LOG.debug(\"Send oneway attempt: \" + i + \" failed for command:\" + command);\n                                }\n                                handleTransportFailure(e);\n                            }\n                        }\n\n                        return;\n\n                    } catch (IOException e) {\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Send oneway attempt: \" + i + \" failed for command:\" + command);\n                        }\n                        handleTransportFailure(e);\n                    }\n                }\n            }\n        } catch (InterruptedException e) {\n            // Some one may be trying to stop our thread.\n            Thread.currentThread().interrupt();\n            throw new InterruptedIOException();\n        }\n\n        if (!disposed) {\n            if (error != null) {\n                if (error instanceof IOException) {\n                    throw (IOException) error;\n                }\n                throw IOExceptionSupport.create(error);\n            }\n        }\n    }",
            " 563  \n 564  \n 565  \n 566  \n 567  \n 568  \n 569  \n 570  \n 571  \n 572  \n 573  \n 574  \n 575  \n 576  \n 577  \n 578  \n 579  \n 580  \n 581  \n 582  \n 583  \n 584  \n 585  \n 586  \n 587  \n 588  \n 589  \n 590  \n 591  \n 592  \n 593  \n 594  \n 595  \n 596  \n 597  \n 598  \n 599  \n 600  \n 601  \n 602  \n 603  \n 604  \n 605  \n 606  \n 607  \n 608  \n 609  \n 610  \n 611  \n 612  \n 613  \n 614  \n 615  \n 616  \n 617  \n 618  \n 619  \n 620  \n 621  \n 622  \n 623  \n 624  \n 625  \n 626  \n 627  \n 628  \n 629  \n 630  \n 631  \n 632  \n 633  \n 634  \n 635  \n 636  \n 637  \n 638  \n 639  \n 640  \n 641  \n 642  \n 643  \n 644  \n 645  \n 646  \n 647  \n 648  \n 649  \n 650  \n 651  \n 652  \n 653  \n 654  \n 655  \n 656  \n 657  \n 658  \n 659  \n 660  \n 661  \n 662  \n 663  \n 664  \n 665  \n 666  \n 667 +\n 668 +\n 669 +\n 670  \n 671  \n 672  \n 673  \n 674  \n 675  \n 676  \n 677  \n 678  \n 679  \n 680  \n 681  \n 682  \n 683  \n 684  \n 685  \n 686  \n 687  \n 688  \n 689  \n 690  \n 691  \n 692  \n 693  \n 694  \n 695  \n 696  \n 697  \n 698  \n 699  \n 700  \n 701  \n 702  \n 703  \n 704  \n 705  \n 706  \n 707  \n 708  \n 709  \n 710  \n 711  \n 712  \n 713  \n 714  \n 715  \n 716  \n 717  \n 718  \n 719  \n 720  \n 721  ",
            "    @Override\n    public void oneway(Object o) throws IOException {\n\n        Command command = (Command) o;\n        Exception error = null;\n        try {\n\n            synchronized (reconnectMutex) {\n\n                if (command != null && connectedTransport.get() == null) {\n                    if (command.isShutdownInfo()) {\n                        // Skipping send of ShutdownInfo command when not connected.\n                        return;\n                    } else if (command instanceof RemoveInfo || command.isMessageAck()) {\n                        // Simulate response to RemoveInfo command or MessageAck (as it will be stale)\n                        stateTracker.track(command);\n                        if (command.isResponseRequired()) {\n                            Response response = new Response();\n                            response.setCorrelationId(command.getCommandId());\n                            myTransportListener.onCommand(response);\n                        }\n                        return;\n                    } else if (command instanceof MessagePull) {\n                        // Simulate response to MessagePull if timed as we can't honor that now.\n                        MessagePull pullRequest = (MessagePull) command;\n                        if (pullRequest.getTimeout() != 0) {\n                            MessageDispatch dispatch = new MessageDispatch();\n                            dispatch.setConsumerId(pullRequest.getConsumerId());\n                            dispatch.setDestination(pullRequest.getDestination());\n                            myTransportListener.onCommand(dispatch);\n                        }\n                        return;\n                    }\n                }\n\n                // Keep trying until the message is sent.\n                for (int i = 0; !disposed; i++) {\n                    try {\n\n                        // Wait for transport to be connected.\n                        Transport transport = connectedTransport.get();\n                        long start = System.currentTimeMillis();\n                        boolean timedout = false;\n                        while (transport == null && !disposed && connectionFailure == null\n                                && !Thread.currentThread().isInterrupted()) {\n                            if (LOG.isTraceEnabled()) {\n                                LOG.trace(\"Waiting for transport to reconnect..: \" + command);\n                            }\n                            long end = System.currentTimeMillis();\n                            if (command.isMessage() && timeout > 0 && (end - start > timeout)) {\n                                timedout = true;\n                                if (LOG.isInfoEnabled()) {\n                                    LOG.info(\"Failover timed out after \" + (end - start) + \"ms\");\n                                }\n                                break;\n                            }\n                            try {\n                                reconnectMutex.wait(100);\n                            } catch (InterruptedException e) {\n                                Thread.currentThread().interrupt();\n                                if (LOG.isDebugEnabled()) {\n                                    LOG.debug(\"Interupted: \" + e, e);\n                                }\n                            }\n                            transport = connectedTransport.get();\n                        }\n\n                        if (transport == null) {\n                            // Previous loop may have exited due to use being\n                            // disposed.\n                            if (disposed) {\n                                error = new IOException(\"Transport disposed.\");\n                            } else if (connectionFailure != null) {\n                                error = connectionFailure;\n                            } else if (timedout == true) {\n                                error = new IOException(\"Failover timeout of \" + timeout + \" ms reached.\");\n                            } else {\n                                error = new IOException(\"Unexpected failure.\");\n                            }\n                            break;\n                        }\n\n                        Tracked tracked = null;\n                        try {\n                            tracked = stateTracker.track(command);\n                        } catch (IOException ioe) {\n                            LOG.debug(\"Cannot track the command \" + command, ioe);\n                        }\n                        // If it was a request and it was not being tracked by\n                        // the state tracker,\n                        // then hold it in the requestMap so that we can replay\n                        // it later.\n                        synchronized (requestMap) {\n                            if (tracked != null && tracked.isWaitingForResponse()) {\n                                requestMap.put(Integer.valueOf(command.getCommandId()), tracked);\n                            } else if (tracked == null && command.isResponseRequired()) {\n                                requestMap.put(Integer.valueOf(command.getCommandId()), command);\n                            }\n                        }\n\n                        // Send the message.\n                        try {\n                            transport.oneway(command);\n                            stateTracker.trackBack(command);\n                            if (command.isShutdownInfo()) {\n                                shuttingDown = true;\n                            }\n                        } catch (IOException e) {\n\n                            // If the command was not tracked.. we will retry in\n                            // this method\n                            if (tracked == null) {\n\n                                // since we will retry in this method.. take it\n                                // out of the request\n                                // map so that it is not sent 2 times on\n                                // recovery\n                                if (command.isResponseRequired()) {\n                                    requestMap.remove(Integer.valueOf(command.getCommandId()));\n                                }\n\n                                // Rethrow the exception so it will handled by\n                                // the outer catch\n                                throw e;\n                            } else {\n                                // Handle the error but allow the method to return since the\n                                // tracked commands are replayed on reconnect.\n                                if (LOG.isDebugEnabled()) {\n                                    LOG.debug(\"Send oneway attempt: \" + i + \" failed for command:\" + command);\n                                }\n                                handleTransportFailure(e);\n                            }\n                        }\n\n                        return;\n\n                    } catch (IOException e) {\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Send oneway attempt: \" + i + \" failed for command:\" + command);\n                        }\n                        handleTransportFailure(e);\n                    }\n                }\n            }\n        } catch (InterruptedException e) {\n            // Some one may be trying to stop our thread.\n            Thread.currentThread().interrupt();\n            throw new InterruptedIOException();\n        }\n\n        if (!disposed) {\n            if (error != null) {\n                if (error instanceof IOException) {\n                    throw (IOException) error;\n                }\n                throw IOExceptionSupport.create(error);\n            }\n        }\n    }"
        ]
    ],
    "7ebc6ceef8f97e2d0002df6a4befe04d528d8275": [
        [
            "MQTTProtocolConverter::onActiveMQCommand(Command)",
            " 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  \n 423  \n 424  \n 425  \n 426  \n 427  \n 428  \n 429  \n 430  \n 431  \n 432  ",
            "    /**\n     * Dispatch an ActiveMQ command\n     */\n    public void onActiveMQCommand(Command command) throws Exception {\n        if (command.isResponse()) {\n            Response response = (Response) command;\n            ResponseHandler rh = resposeHandlers.remove(Integer.valueOf(response.getCorrelationId()));\n            if (rh != null) {\n                rh.onResponse(this, response);\n            } else {\n                // Pass down any unexpected errors. Should this close the connection?\n                if (response.isException()) {\n                    Throwable exception = ((ExceptionResponse) response).getException();\n                    handleException(exception, null);\n                }\n            }\n        } else if (command.isMessageDispatch()) {\n            MessageDispatch md = (MessageDispatch) command;\n            MQTTSubscription sub = findSubscriptionStrategy().getSubscription(md.getConsumerId());\n            if (sub != null) {\n                MessageAck ack = sub.createMessageAck(md);\n                PUBLISH publish = sub.createPublish((ActiveMQMessage) md.getMessage());\n                switch (publish.qos()) {\n                    case AT_LEAST_ONCE:\n                    case EXACTLY_ONCE:\n                        publish.dup(publish.dup() ? true : md.getMessage().isRedelivered());\n                    case AT_MOST_ONCE:\n                }\n                if (ack != null && sub.expectAck(publish)) {\n                    synchronized (consumerAcks) {\n                        consumerAcks.put(publish.messageId(), ack);\n                    }\n                }\n                getMQTTTransport().sendToMQTT(publish.encode());\n                if (ack != null && !sub.expectAck(publish)) {\n                    getMQTTTransport().sendToActiveMQ(ack);\n                }\n            }\n        } else if (command.getDataStructureType() == ConnectionError.DATA_STRUCTURE_TYPE) {\n            // Pass down any unexpected async errors. Should this close the connection?\n            Throwable exception = ((ConnectionError) command).getException();\n            handleException(exception, null);\n        } else if (command.isBrokerInfo()) {\n            //ignore\n        } else {\n            LOG.debug(\"Do not know how to process ActiveMQ Command {}\", command);\n        }\n    }",
            " 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400  \n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420 +\n 421 +\n 422  \n 423  \n 424  \n 425  \n 426  \n 427  \n 428  \n 429  \n 430  \n 431  \n 432  \n 433  \n 434  \n 435  \n 436  ",
            "    /**\n     * Dispatch an ActiveMQ command\n     */\n    public void onActiveMQCommand(Command command) throws Exception {\n        if (command.isResponse()) {\n            Response response = (Response) command;\n            ResponseHandler rh = resposeHandlers.remove(Integer.valueOf(response.getCorrelationId()));\n            if (rh != null) {\n                rh.onResponse(this, response);\n            } else {\n                // Pass down any unexpected errors. Should this close the connection?\n                if (response.isException()) {\n                    Throwable exception = ((ExceptionResponse) response).getException();\n                    handleException(exception, null);\n                }\n            }\n        } else if (command.isMessageDispatch()) {\n            MessageDispatch md = (MessageDispatch) command;\n            MQTTSubscription sub = findSubscriptionStrategy().getSubscription(md.getConsumerId());\n            if (sub != null) {\n                MessageAck ack = sub.createMessageAck(md);\n                PUBLISH publish = sub.createPublish((ActiveMQMessage) md.getMessage());\n                switch (publish.qos()) {\n                    case AT_LEAST_ONCE:\n                    case EXACTLY_ONCE:\n                        publish.dup(publish.dup() ? true : md.getMessage().isRedelivered());\n                    case AT_MOST_ONCE:\n                }\n                if (ack != null && sub.expectAck(publish)) {\n                    synchronized (consumerAcks) {\n                        consumerAcks.put(publish.messageId(), ack);\n                    }\n                }\n                LOG.trace(\"MQTT Snd PUBLISH message:{} client:{} connection:{}\",\n                          publish.messageId(), clientId, connectionInfo.getConnectionId());\n                getMQTTTransport().sendToMQTT(publish.encode());\n                if (ack != null && !sub.expectAck(publish)) {\n                    getMQTTTransport().sendToActiveMQ(ack);\n                }\n            }\n        } else if (command.getDataStructureType() == ConnectionError.DATA_STRUCTURE_TYPE) {\n            // Pass down any unexpected async errors. Should this close the connection?\n            Throwable exception = ((ConnectionError) command).getException();\n            handleException(exception, null);\n        } else if (command.isBrokerInfo()) {\n            //ignore\n        } else {\n            LOG.debug(\"Do not know how to process ActiveMQ Command {}\", command);\n        }\n    }"
        ],
        [
            "MQTTProtocolConverter::onMQTTPubAck(PUBACK)",
            " 442  \n 443  \n 444  \n 445  \n 446  \n 447  \n 448  \n 449  \n 450  \n 451  \n 452  ",
            "    void onMQTTPubAck(PUBACK command) {\n        short messageId = command.messageId();\n        packetIdGenerator.ackPacketId(getClientId(), messageId);\n        MessageAck ack;\n        synchronized (consumerAcks) {\n            ack = consumerAcks.remove(messageId);\n        }\n        if (ack != null) {\n            getMQTTTransport().sendToActiveMQ(ack);\n        }\n    }",
            " 448  \n 449  \n 450 +\n 451 +\n 452  \n 453  \n 454  \n 455  \n 456  \n 457  \n 458  \n 459  \n 460  ",
            "    void onMQTTPubAck(PUBACK command) {\n        short messageId = command.messageId();\n        LOG.trace(\"MQTT Rcv PUBACK message:{} client:{} connection:{}\",\n                  messageId, clientId, connectionInfo.getConnectionId());\n        packetIdGenerator.ackPacketId(getClientId(), messageId);\n        MessageAck ack;\n        synchronized (consumerAcks) {\n            ack = consumerAcks.remove(messageId);\n        }\n        if (ack != null) {\n            getMQTTTransport().sendToActiveMQ(ack);\n        }\n    }"
        ],
        [
            "MQTTProtocolConverter::createResponseHandler(PUBLISH)",
            " 682  \n 683  \n 684  \n 685  \n 686  \n 687  \n 688  \n 689  \n 690  \n 691  \n 692  \n 693  \n 694  \n 695  \n 696  \n 697  \n 698  \n 699  \n 700  \n 701  \n 702  \n 703  \n 704  \n 705  \n 706  \n 707  \n 708  \n 709  \n 710  \n 711  \n 712  \n 713  \n 714  \n 715  \n 716  \n 717  \n 718  \n 719  ",
            "    ResponseHandler createResponseHandler(final PUBLISH command) {\n        if (command != null) {\n            switch (command.qos()) {\n                case AT_LEAST_ONCE:\n                    return new ResponseHandler() {\n                        @Override\n                        public void onResponse(MQTTProtocolConverter converter, Response response) throws IOException {\n                            if (response.isException()) {\n                                LOG.warn(\"Failed to send MQTT Publish: \", command, ((ExceptionResponse) response).getException());\n                            } else {\n                                PUBACK ack = new PUBACK();\n                                ack.messageId(command.messageId());\n                                converter.getMQTTTransport().sendToMQTT(ack.encode());\n                            }\n                        }\n                    };\n                case EXACTLY_ONCE:\n                    return new ResponseHandler() {\n                        @Override\n                        public void onResponse(MQTTProtocolConverter converter, Response response) throws IOException {\n                            if (response.isException()) {\n                                LOG.warn(\"Failed to send MQTT Publish: \", command, ((ExceptionResponse) response).getException());\n                            } else {\n                                PUBREC ack = new PUBREC();\n                                ack.messageId(command.messageId());\n                                synchronized (publisherRecs) {\n                                    publisherRecs.put(command.messageId(), ack);\n                                }\n                                converter.getMQTTTransport().sendToMQTT(ack.encode());\n                            }\n                        }\n                    };\n                case AT_MOST_ONCE:\n                    break;\n            }\n        }\n        return null;\n    }",
            " 694  \n 695  \n 696  \n 697  \n 698  \n 699  \n 700  \n 701  \n 702  \n 703  \n 704  \n 705  \n 706 +\n 707 +\n 708  \n 709  \n 710  \n 711  \n 712  \n 713  \n 714  \n 715  \n 716  \n 717  \n 718  \n 719  \n 720  \n 721  \n 722  \n 723  \n 724 +\n 725 +\n 726  \n 727  \n 728  \n 729  \n 730  \n 731  \n 732  \n 733  \n 734  \n 735  ",
            "    ResponseHandler createResponseHandler(final PUBLISH command) {\n        if (command != null) {\n            switch (command.qos()) {\n                case AT_LEAST_ONCE:\n                    return new ResponseHandler() {\n                        @Override\n                        public void onResponse(MQTTProtocolConverter converter, Response response) throws IOException {\n                            if (response.isException()) {\n                                LOG.warn(\"Failed to send MQTT Publish: \", command, ((ExceptionResponse) response).getException());\n                            } else {\n                                PUBACK ack = new PUBACK();\n                                ack.messageId(command.messageId());\n                                LOG.trace(\"MQTT Snd PUBACK message:{} client:{} connection:{}\",\n                                          command.messageId(), clientId, connectionInfo.getConnectionId());\n                                converter.getMQTTTransport().sendToMQTT(ack.encode());\n                            }\n                        }\n                    };\n                case EXACTLY_ONCE:\n                    return new ResponseHandler() {\n                        @Override\n                        public void onResponse(MQTTProtocolConverter converter, Response response) throws IOException {\n                            if (response.isException()) {\n                                LOG.warn(\"Failed to send MQTT Publish: \", command, ((ExceptionResponse) response).getException());\n                            } else {\n                                PUBREC ack = new PUBREC();\n                                ack.messageId(command.messageId());\n                                synchronized (publisherRecs) {\n                                    publisherRecs.put(command.messageId(), ack);\n                                }\n                                LOG.trace(\"MQTT Snd PUBACK message:{} client:{} connection:{}\",\n                                          command.messageId(), clientId, connectionInfo.getConnectionId());\n                                converter.getMQTTTransport().sendToMQTT(ack.encode());\n                            }\n                        }\n                    };\n                case AT_MOST_ONCE:\n                    break;\n            }\n        }\n        return null;\n    }"
        ],
        [
            "MQTTProtocolConverter::convertMessage(ActiveMQMessage)",
            " 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528  \n 529  \n 530  \n 531  \n 532  \n 533  \n 534  \n 535  \n 536  \n 537  \n 538  \n 539  \n 540  \n 541  \n 542  \n 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564  \n 565  \n 566  \n 567  \n 568  \n 569  \n 570  \n 571  \n 572  \n 573  \n 574  \n 575  \n 576  \n 577  \n 578  \n 579  \n 580  \n 581  \n 582  \n 583  \n 584  \n 585  \n 586  ",
            "    public PUBLISH convertMessage(ActiveMQMessage message) throws IOException, JMSException, DataFormatException {\n        PUBLISH result = new PUBLISH();\n        // packet id is set in MQTTSubscription\n        QoS qoS;\n        if (message.propertyExists(QOS_PROPERTY_NAME)) {\n            int ordinal = message.getIntProperty(QOS_PROPERTY_NAME);\n            qoS = QoS.values()[ordinal];\n\n        } else {\n            qoS = message.isPersistent() ? QoS.AT_MOST_ONCE : QoS.AT_LEAST_ONCE;\n        }\n        result.qos(qoS);\n        if (message.getBooleanProperty(RetainedMessageSubscriptionRecoveryPolicy.RETAINED_PROPERTY)) {\n            result.retain(true);\n        }\n\n        String topicName;\n        synchronized (mqttTopicMap) {\n            topicName = mqttTopicMap.get(message.getJMSDestination());\n            if (topicName == null) {\n                String amqTopicName = findSubscriptionStrategy().onSend(message.getDestination());\n                topicName = MQTTProtocolSupport.convertActiveMQToMQTT(amqTopicName);\n                mqttTopicMap.put(message.getJMSDestination(), topicName);\n            }\n        }\n        result.topicName(new UTF8Buffer(topicName));\n\n        if (message.getDataStructureType() == ActiveMQTextMessage.DATA_STRUCTURE_TYPE) {\n            ActiveMQTextMessage msg = (ActiveMQTextMessage) message.copy();\n            msg.setReadOnlyBody(true);\n            String messageText = msg.getText();\n            if (messageText != null) {\n                result.payload(new Buffer(messageText.getBytes(\"UTF-8\")));\n            }\n        } else if (message.getDataStructureType() == ActiveMQBytesMessage.DATA_STRUCTURE_TYPE) {\n            ActiveMQBytesMessage msg = (ActiveMQBytesMessage) message.copy();\n            msg.setReadOnlyBody(true);\n            byte[] data = new byte[(int) msg.getBodyLength()];\n            msg.readBytes(data);\n            result.payload(new Buffer(data));\n        } else if (message.getDataStructureType() == ActiveMQMapMessage.DATA_STRUCTURE_TYPE) {\n            ActiveMQMapMessage msg = (ActiveMQMapMessage) message.copy();\n            msg.setReadOnlyBody(true);\n            Map<String, Object> map = msg.getContentMap();\n            if (map != null) {\n                result.payload(new Buffer(map.toString().getBytes(\"UTF-8\")));\n            }\n        } else {\n            ByteSequence byteSequence = message.getContent();\n            if (byteSequence != null && byteSequence.getLength() > 0) {\n                if (message.isCompressed()) {\n                    Inflater inflater = new Inflater();\n                    inflater.setInput(byteSequence.data, byteSequence.offset, byteSequence.length);\n                    byte[] data = new byte[4096];\n                    int read;\n                    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();\n                    while ((read = inflater.inflate(data)) != 0) {\n                        bytesOut.write(data, 0, read);\n                    }\n                    byteSequence = bytesOut.toByteSequence();\n                    bytesOut.close();\n                }\n                result.payload(new Buffer(byteSequence.data, byteSequence.offset, byteSequence.length));\n            }\n        }\n        return result;\n    }",
            " 530  \n 531  \n 532  \n 533  \n 534  \n 535  \n 536  \n 537  \n 538  \n 539  \n 540  \n 541  \n 542  \n 543  \n 544  \n 545  \n 546  \n 547  \n 548  \n 549  \n 550  \n 551  \n 552  \n 553  \n 554  \n 555  \n 556  \n 557  \n 558  \n 559  \n 560  \n 561  \n 562  \n 563  \n 564  \n 565  \n 566  \n 567  \n 568  \n 569  \n 570  \n 571  \n 572  \n 573  \n 574  \n 575  \n 576  \n 577  \n 578  \n 579  \n 580  \n 581  \n 582  \n 583  \n 584  \n 585  \n 586  \n 587  \n 588  \n 589  \n 590  \n 591  \n 592  \n 593  \n 594  \n 595 +\n 596 +\n 597  \n 598  ",
            "    public PUBLISH convertMessage(ActiveMQMessage message) throws IOException, JMSException, DataFormatException {\n        PUBLISH result = new PUBLISH();\n        // packet id is set in MQTTSubscription\n        QoS qoS;\n        if (message.propertyExists(QOS_PROPERTY_NAME)) {\n            int ordinal = message.getIntProperty(QOS_PROPERTY_NAME);\n            qoS = QoS.values()[ordinal];\n\n        } else {\n            qoS = message.isPersistent() ? QoS.AT_MOST_ONCE : QoS.AT_LEAST_ONCE;\n        }\n        result.qos(qoS);\n        if (message.getBooleanProperty(RetainedMessageSubscriptionRecoveryPolicy.RETAINED_PROPERTY)) {\n            result.retain(true);\n        }\n\n        String topicName;\n        synchronized (mqttTopicMap) {\n            topicName = mqttTopicMap.get(message.getJMSDestination());\n            if (topicName == null) {\n                String amqTopicName = findSubscriptionStrategy().onSend(message.getDestination());\n                topicName = MQTTProtocolSupport.convertActiveMQToMQTT(amqTopicName);\n                mqttTopicMap.put(message.getJMSDestination(), topicName);\n            }\n        }\n        result.topicName(new UTF8Buffer(topicName));\n\n        if (message.getDataStructureType() == ActiveMQTextMessage.DATA_STRUCTURE_TYPE) {\n            ActiveMQTextMessage msg = (ActiveMQTextMessage) message.copy();\n            msg.setReadOnlyBody(true);\n            String messageText = msg.getText();\n            if (messageText != null) {\n                result.payload(new Buffer(messageText.getBytes(\"UTF-8\")));\n            }\n        } else if (message.getDataStructureType() == ActiveMQBytesMessage.DATA_STRUCTURE_TYPE) {\n            ActiveMQBytesMessage msg = (ActiveMQBytesMessage) message.copy();\n            msg.setReadOnlyBody(true);\n            byte[] data = new byte[(int) msg.getBodyLength()];\n            msg.readBytes(data);\n            result.payload(new Buffer(data));\n        } else if (message.getDataStructureType() == ActiveMQMapMessage.DATA_STRUCTURE_TYPE) {\n            ActiveMQMapMessage msg = (ActiveMQMapMessage) message.copy();\n            msg.setReadOnlyBody(true);\n            Map<String, Object> map = msg.getContentMap();\n            if (map != null) {\n                result.payload(new Buffer(map.toString().getBytes(\"UTF-8\")));\n            }\n        } else {\n            ByteSequence byteSequence = message.getContent();\n            if (byteSequence != null && byteSequence.getLength() > 0) {\n                if (message.isCompressed()) {\n                    Inflater inflater = new Inflater();\n                    inflater.setInput(byteSequence.data, byteSequence.offset, byteSequence.length);\n                    byte[] data = new byte[4096];\n                    int read;\n                    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();\n                    while ((read = inflater.inflate(data)) != 0) {\n                        bytesOut.write(data, 0, read);\n                    }\n                    byteSequence = bytesOut.toByteSequence();\n                    bytesOut.close();\n                }\n                result.payload(new Buffer(byteSequence.data, byteSequence.offset, byteSequence.length));\n            }\n        }\n        LOG.trace(\"ActiveMQ-->MQTT:MQTT_MSGID:{} client:{} connection:{} ActiveMQ_MSGID:{}\",\n                result.messageId(), clientId, connectionInfo.getConnectionId(), message.getMessageId());\n        return result;\n    }"
        ],
        [
            "MQTTProtocolConverter::convertMessage(PUBLISH)",
            " 486  \n 487  \n 488  \n 489  \n 490  \n 491  \n 492  \n 493  \n 494  \n 495  \n 496  \n 497  \n 498  \n 499  \n 500  \n 501  \n 502  \n 503  \n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512  \n 513  \n 514  \n 515  \n 516  \n 517  \n 518  ",
            "    ActiveMQMessage convertMessage(PUBLISH command) throws JMSException {\n        ActiveMQBytesMessage msg = new ActiveMQBytesMessage();\n\n        msg.setProducerId(producerId);\n        MessageId id = new MessageId(producerId, publisherIdGenerator.getNextSequenceId());\n        msg.setMessageId(id);\n        msg.setTimestamp(System.currentTimeMillis());\n        msg.setPriority((byte) Message.DEFAULT_PRIORITY);\n        msg.setPersistent(command.qos() != QoS.AT_MOST_ONCE && !command.retain());\n        msg.setIntProperty(QOS_PROPERTY_NAME, command.qos().ordinal());\n        if (command.retain()) {\n            msg.setBooleanProperty(RetainedMessageSubscriptionRecoveryPolicy.RETAIN_PROPERTY, true);\n        }\n\n        ActiveMQDestination destination;\n        synchronized (activeMQDestinationMap) {\n            destination = activeMQDestinationMap.get(command.topicName());\n            if (destination == null) {\n                String topicName = MQTTProtocolSupport.convertMQTTToActiveMQ(command.topicName().toString());\n                try {\n                    destination = findSubscriptionStrategy().onSend(topicName);\n                } catch (IOException e) {\n                    throw JMSExceptionSupport.create(e);\n                }\n\n                activeMQDestinationMap.put(command.topicName().toString(), destination);\n            }\n        }\n\n        msg.setJMSDestination(destination);\n        msg.writeBytes(command.payload().data, command.payload().offset, command.payload().length);\n        return msg;\n    }",
            " 494  \n 495  \n 496  \n 497  \n 498  \n 499  \n 500 +\n 501 +\n 502  \n 503  \n 504  \n 505  \n 506  \n 507  \n 508  \n 509  \n 510  \n 511  \n 512  \n 513  \n 514  \n 515  \n 516  \n 517  \n 518  \n 519  \n 520  \n 521  \n 522  \n 523  \n 524  \n 525  \n 526  \n 527  \n 528  ",
            "    ActiveMQMessage convertMessage(PUBLISH command) throws JMSException {\n        ActiveMQBytesMessage msg = new ActiveMQBytesMessage();\n\n        msg.setProducerId(producerId);\n        MessageId id = new MessageId(producerId, publisherIdGenerator.getNextSequenceId());\n        msg.setMessageId(id);\n        LOG.trace(\"MQTT-->ActiveMQ: MQTT_MSGID:{} client:{} connection:{} ActiveMQ_MSGID:{}\",\n                command.messageId(), clientId, connectionInfo.getConnectionId(), msg.getMessageId());\n        msg.setTimestamp(System.currentTimeMillis());\n        msg.setPriority((byte) Message.DEFAULT_PRIORITY);\n        msg.setPersistent(command.qos() != QoS.AT_MOST_ONCE && !command.retain());\n        msg.setIntProperty(QOS_PROPERTY_NAME, command.qos().ordinal());\n        if (command.retain()) {\n            msg.setBooleanProperty(RetainedMessageSubscriptionRecoveryPolicy.RETAIN_PROPERTY, true);\n        }\n\n        ActiveMQDestination destination;\n        synchronized (activeMQDestinationMap) {\n            destination = activeMQDestinationMap.get(command.topicName());\n            if (destination == null) {\n                String topicName = MQTTProtocolSupport.convertMQTTToActiveMQ(command.topicName().toString());\n                try {\n                    destination = findSubscriptionStrategy().onSend(topicName);\n                } catch (IOException e) {\n                    throw JMSExceptionSupport.create(e);\n                }\n\n                activeMQDestinationMap.put(command.topicName().toString(), destination);\n            }\n        }\n\n        msg.setJMSDestination(destination);\n        msg.writeBytes(command.payload().data, command.payload().offset, command.payload().length);\n        return msg;\n    }"
        ],
        [
            "MQTTProtocolConverter::onMQTTPublish(PUBLISH)",
            " 434  \n 435  \n 436  \n 437  \n 438  \n 439  \n 440  ",
            "    void onMQTTPublish(PUBLISH command) throws IOException, JMSException {\n        checkConnected();\n        ActiveMQMessage message = convertMessage(command);\n        message.setProducerId(producerId);\n        message.onSend();\n        sendToActiveMQ(message, createResponseHandler(command));\n    }",
            " 438  \n 439  \n 440 +\n 441 +\n 442  \n 443  \n 444  \n 445  \n 446  ",
            "    void onMQTTPublish(PUBLISH command) throws IOException, JMSException {\n        checkConnected();\n        LOG.trace(\"MQTT Rcv PUBLISH message:{} client:{} connection:{}\",\n                  command.messageId(), clientId, connectionInfo.getConnectionId());\n        ActiveMQMessage message = convertMessage(command);\n        message.setProducerId(producerId);\n        message.onSend();\n        sendToActiveMQ(message, createResponseHandler(command));\n    }"
        ],
        [
            "MQTTProtocolConverter::onSubscribe(SUBSCRIBE)",
            " 343  \n 344  \n 345  \n 346  \n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  ",
            "    void onSubscribe(SUBSCRIBE command) throws MQTTProtocolException {\n        checkConnected();\n        Topic[] topics = command.topics();\n        if (topics != null) {\n            byte[] qos = new byte[topics.length];\n            for (int i = 0; i < topics.length; i++) {\n                try {\n                    qos[i] = findSubscriptionStrategy().onSubscribe(topics[i]);\n                } catch (IOException e) {\n                    throw new MQTTProtocolException(\"Failed to process subscription request\", true, e);\n                }\n            }\n            SUBACK ack = new SUBACK();\n            ack.messageId(command.messageId());\n            ack.grantedQos(qos);\n            try {\n                getMQTTTransport().sendToMQTT(ack.encode());\n            } catch (IOException e) {\n                LOG.warn(\"Couldn't send SUBACK for \" + command, e);\n            }\n        } else {\n            LOG.warn(\"No topics defined for Subscription \" + command);\n        }\n    }",
            " 343  \n 344  \n 345 +\n 346 +\n 347  \n 348  \n 349  \n 350  \n 351  \n 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  ",
            "    void onSubscribe(SUBSCRIBE command) throws MQTTProtocolException {\n        checkConnected();\n        LOG.trace(\"MQTT SUBSCRIBE message:{} client:{} connection:{}\",\n                  command.messageId(), clientId, connectionInfo.getConnectionId());\n        Topic[] topics = command.topics();\n        if (topics != null) {\n            byte[] qos = new byte[topics.length];\n            for (int i = 0; i < topics.length; i++) {\n                try {\n                    qos[i] = findSubscriptionStrategy().onSubscribe(topics[i]);\n                } catch (IOException e) {\n                    throw new MQTTProtocolException(\"Failed to process subscription request\", true, e);\n                }\n            }\n            SUBACK ack = new SUBACK();\n            ack.messageId(command.messageId());\n            ack.grantedQos(qos);\n            try {\n                getMQTTTransport().sendToMQTT(ack.encode());\n            } catch (IOException e) {\n                LOG.warn(\"Couldn't send SUBACK for \" + command, e);\n            }\n        } else {\n            LOG.warn(\"No topics defined for Subscription \" + command);\n        }\n    }"
        ]
    ],
    "2013c6a54f483f0206e6727bd1088616ba98daa2": [
        [
            "AmqpSender::pumpOutbound()",
            " 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400 -\n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  \n 423  \n 424  \n 425  ",
            "    public void pumpOutbound() throws Exception {\n        while (!closed) {\n            while (currentBuffer != null) {\n                int sent = getEndpoint().send(currentBuffer.data, currentBuffer.offset, currentBuffer.length);\n                if (sent > 0) {\n                    currentBuffer.moveHead(sent);\n                    if (currentBuffer.length == 0) {\n                        if (presettle) {\n                            settle(currentDelivery, MessageAck.INDIVIDUAL_ACK_TYPE);\n                        } else {\n                            getEndpoint().advance();\n                        }\n                        currentBuffer = null;\n                        currentDelivery = null;\n                    }\n                } else {\n                    return;\n                }\n            }\n\n            if (outbound.isEmpty()) {\n                return;\n            }\n\n            final MessageDispatch md = outbound.removeFirst();\n            try {\n\n                ActiveMQMessage temp = null;\n                if (md.getMessage() != null) {\n\n                    // Topics can dispatch the same Message to more than one consumer\n                    // so we must copy to prevent concurrent read / write to the same\n                    // message object.\n                    if (md.getDestination().isTopic()) {\n                        synchronized (md.getMessage()) {\n                            temp = (ActiveMQMessage) md.getMessage().copy();\n                        }\n                    } else {\n                        temp = (ActiveMQMessage) md.getMessage();\n                    }\n\n                    if (!temp.getProperties().containsKey(MESSAGE_FORMAT_KEY)) {\n                        temp.setProperty(MESSAGE_FORMAT_KEY, 0);\n                    }\n                }\n\n                final ActiveMQMessage jms = temp;\n                if (jms == null) {\n                    LOG.info(\"End of browse signals endpoint drained.\");\n                    // It's the end of browse signal in response to a MessagePull\n                    getEndpoint().drained();\n                    draining = false;\n                } else {\n                    jms.setRedeliveryCounter(md.getRedeliveryCounter());\n                    jms.setReadOnlyBody(true);\n                    final EncodedMessage amqp = outboundTransformer.transform(jms);\n                    if (amqp != null && amqp.getLength() > 0) {\n                        currentBuffer = new Buffer(amqp.getArray(), amqp.getArrayOffset(), amqp.getLength());\n                        if (presettle) {\n                            currentDelivery = getEndpoint().delivery(EMPTY_BYTE_ARRAY, 0, 0);\n                        } else {\n                            final byte[] tag = tagCache.getNextTag();\n                            currentDelivery = getEndpoint().delivery(tag, 0, tag.length);\n                        }\n                        currentDelivery.setContext(md);\n                    } else {\n                        // TODO: message could not be generated what now?\n                    }\n                }\n            } catch (Exception e) {\n                LOG.warn(\"Error detected while flushing outbound messages: {}\", e.getMessage());\n            }\n        }\n    }",
            " 352  \n 353  \n 354  \n 355  \n 356  \n 357  \n 358  \n 359  \n 360  \n 361  \n 362  \n 363  \n 364  \n 365  \n 366  \n 367  \n 368  \n 369  \n 370  \n 371  \n 372  \n 373  \n 374  \n 375  \n 376  \n 377  \n 378  \n 379  \n 380  \n 381  \n 382  \n 383  \n 384  \n 385  \n 386  \n 387  \n 388  \n 389  \n 390  \n 391  \n 392  \n 393  \n 394  \n 395  \n 396  \n 397  \n 398  \n 399  \n 400 +\n 401  \n 402  \n 403  \n 404  \n 405  \n 406  \n 407  \n 408  \n 409  \n 410  \n 411  \n 412  \n 413  \n 414  \n 415  \n 416  \n 417  \n 418  \n 419  \n 420  \n 421  \n 422  \n 423  \n 424  \n 425  ",
            "    public void pumpOutbound() throws Exception {\n        while (!closed) {\n            while (currentBuffer != null) {\n                int sent = getEndpoint().send(currentBuffer.data, currentBuffer.offset, currentBuffer.length);\n                if (sent > 0) {\n                    currentBuffer.moveHead(sent);\n                    if (currentBuffer.length == 0) {\n                        if (presettle) {\n                            settle(currentDelivery, MessageAck.INDIVIDUAL_ACK_TYPE);\n                        } else {\n                            getEndpoint().advance();\n                        }\n                        currentBuffer = null;\n                        currentDelivery = null;\n                    }\n                } else {\n                    return;\n                }\n            }\n\n            if (outbound.isEmpty()) {\n                return;\n            }\n\n            final MessageDispatch md = outbound.removeFirst();\n            try {\n\n                ActiveMQMessage temp = null;\n                if (md.getMessage() != null) {\n\n                    // Topics can dispatch the same Message to more than one consumer\n                    // so we must copy to prevent concurrent read / write to the same\n                    // message object.\n                    if (md.getDestination().isTopic()) {\n                        synchronized (md.getMessage()) {\n                            temp = (ActiveMQMessage) md.getMessage().copy();\n                        }\n                    } else {\n                        temp = (ActiveMQMessage) md.getMessage();\n                    }\n\n                    if (!temp.getProperties().containsKey(MESSAGE_FORMAT_KEY)) {\n                        temp.setProperty(MESSAGE_FORMAT_KEY, 0);\n                    }\n                }\n\n                final ActiveMQMessage jms = temp;\n                if (jms == null) {\n                    LOG.trace(\"Sender:[{}] browse done.\", getEndpoint().getName());\n                    // It's the end of browse signal in response to a MessagePull\n                    getEndpoint().drained();\n                    draining = false;\n                } else {\n                    jms.setRedeliveryCounter(md.getRedeliveryCounter());\n                    jms.setReadOnlyBody(true);\n                    final EncodedMessage amqp = outboundTransformer.transform(jms);\n                    if (amqp != null && amqp.getLength() > 0) {\n                        currentBuffer = new Buffer(amqp.getArray(), amqp.getArrayOffset(), amqp.getLength());\n                        if (presettle) {\n                            currentDelivery = getEndpoint().delivery(EMPTY_BYTE_ARRAY, 0, 0);\n                        } else {\n                            final byte[] tag = tagCache.getNextTag();\n                            currentDelivery = getEndpoint().delivery(tag, 0, tag.length);\n                        }\n                        currentDelivery.setContext(md);\n                    } else {\n                        // TODO: message could not be generated what now?\n                    }\n                }\n            } catch (Exception e) {\n                LOG.warn(\"Error detected while flushing outbound messages: {}\", e.getMessage());\n            }\n        }\n    }"
        ],
        [
            "AmqpReceiver::processDelivery(Delivery,Buffer)",
            " 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223 -\n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244 -\n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  ",
            "    @Override\n    protected void processDelivery(final Delivery delivery, Buffer deliveryBytes) throws Exception {\n        if (!isClosed()) {\n            EncodedMessage em = new EncodedMessage(delivery.getMessageFormat(), deliveryBytes.data, deliveryBytes.offset, deliveryBytes.length);\n            final ActiveMQMessage message = (ActiveMQMessage) getInboundTransformer().transform(em);\n            current = null;\n\n            if (isAnonymous()) {\n                Destination toDestination = message.getJMSDestination();\n                if (toDestination == null || !(toDestination instanceof ActiveMQDestination)) {\n                    Rejected rejected = new Rejected();\n                    ErrorCondition condition = new ErrorCondition();\n                    condition.setCondition(Symbol.valueOf(\"failed\"));\n                    condition.setDescription(\"Missing to field for message sent to an anonymous producer\");\n                    rejected.setError(condition);\n                    delivery.disposition(rejected);\n                    return;\n                }\n            } else {\n                message.setJMSDestination(getDestination());\n            }\n\n            message.setProducerId(getProducerId());\n\n            // Always override the AMQP client's MessageId with our own.  Preserve\n            // the original in the TextView property for later Ack.\n            MessageId messageId = new MessageId(getProducerId(), messageIdGenerator.getNextSequenceId());\n\n            MessageId amqpMessageId = message.getMessageId();\n            if (amqpMessageId != null) {\n                if (amqpMessageId.getTextView() != null) {\n                    messageId.setTextView(amqpMessageId.getTextView());\n                } else {\n                    messageId.setTextView(amqpMessageId.toString());\n                }\n            }\n\n            message.setMessageId(messageId);\n\n            LOG.trace(\"Inbound Message:{} from Producer:{}\",\n                      message.getMessageId(), getProducerId() + \":\" + messageId.getProducerSequenceId());\n\n            final DeliveryState remoteState = delivery.getRemoteState();\n            if (remoteState != null && remoteState instanceof TransactionalState) {\n                TransactionalState s = (TransactionalState) remoteState;\n                long txid = toLong(s.getTxnId());\n                message.setTransactionId(new LocalTransactionId(session.getConnection().getConnectionId(), txid));\n            }\n\n            message.onSend();\n            if (!delivery.remotelySettled()) {\n                sendToActiveMQ(message, new ResponseHandler() {\n\n                    @Override\n                    public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {\n                        if (response.isException()) {\n                            ExceptionResponse er = (ExceptionResponse) response;\n                            Rejected rejected = new Rejected();\n                            ErrorCondition condition = new ErrorCondition();\n                            condition.setCondition(Symbol.valueOf(\"failed\"));\n                            condition.setDescription(er.getException().getMessage());\n                            rejected.setError(condition);\n                            delivery.disposition(rejected);\n                        } else {\n                            if (getEndpoint().getCredit() <= (getConfiguredReceiverCredit() * .2)) {\n                                LOG.trace(\"Sending more credit ({}) to producer: {}\", getConfiguredReceiverCredit() - getEndpoint().getCredit(), getProducerId());\n                                getEndpoint().flow(getConfiguredReceiverCredit() - getEndpoint().getCredit());\n                            }\n\n                            if (remoteState != null && remoteState instanceof TransactionalState) {\n                                TransactionalState txAccepted = new TransactionalState();\n                                txAccepted.setOutcome(Accepted.getInstance());\n                                txAccepted.setTxnId(((TransactionalState) remoteState).getTxnId());\n\n                                delivery.disposition(txAccepted);\n                            } else {\n                                delivery.disposition(Accepted.getInstance());\n                            }\n                        }\n\n                        delivery.settle();\n                        session.pumpProtonToSocket();\n                    }\n                });\n            } else {\n                if (getEndpoint().getCredit() <= (getConfiguredReceiverCredit() * .2)) {\n                    LOG.trace(\"Sending more credit ({}) to producer: {}\", getConfiguredReceiverCredit() - getEndpoint().getCredit(), getProducerId());\n                    getEndpoint().flow(getConfiguredReceiverCredit() - getEndpoint().getCredit());\n                    session.pumpProtonToSocket();\n                }\n\n                delivery.settle();\n                sendToActiveMQ(message);\n            }\n        }\n    }",
            " 158  \n 159  \n 160  \n 161  \n 162  \n 163  \n 164  \n 165  \n 166  \n 167  \n 168  \n 169  \n 170  \n 171  \n 172  \n 173  \n 174  \n 175  \n 176  \n 177  \n 178  \n 179  \n 180  \n 181  \n 182  \n 183  \n 184  \n 185  \n 186  \n 187  \n 188  \n 189  \n 190  \n 191  \n 192  \n 193  \n 194  \n 195  \n 196  \n 197  \n 198  \n 199  \n 200  \n 201  \n 202  \n 203  \n 204  \n 205  \n 206  \n 207  \n 208  \n 209  \n 210  \n 211  \n 212  \n 213  \n 214  \n 215  \n 216  \n 217  \n 218  \n 219  \n 220  \n 221  \n 222  \n 223 +\n 224  \n 225  \n 226  \n 227  \n 228  \n 229  \n 230  \n 231  \n 232  \n 233  \n 234  \n 235  \n 236  \n 237  \n 238  \n 239  \n 240  \n 241  \n 242  \n 243  \n 244 +\n 245  \n 246  \n 247  \n 248  \n 249  \n 250  \n 251  \n 252  \n 253  ",
            "    @Override\n    protected void processDelivery(final Delivery delivery, Buffer deliveryBytes) throws Exception {\n        if (!isClosed()) {\n            EncodedMessage em = new EncodedMessage(delivery.getMessageFormat(), deliveryBytes.data, deliveryBytes.offset, deliveryBytes.length);\n            final ActiveMQMessage message = (ActiveMQMessage) getInboundTransformer().transform(em);\n            current = null;\n\n            if (isAnonymous()) {\n                Destination toDestination = message.getJMSDestination();\n                if (toDestination == null || !(toDestination instanceof ActiveMQDestination)) {\n                    Rejected rejected = new Rejected();\n                    ErrorCondition condition = new ErrorCondition();\n                    condition.setCondition(Symbol.valueOf(\"failed\"));\n                    condition.setDescription(\"Missing to field for message sent to an anonymous producer\");\n                    rejected.setError(condition);\n                    delivery.disposition(rejected);\n                    return;\n                }\n            } else {\n                message.setJMSDestination(getDestination());\n            }\n\n            message.setProducerId(getProducerId());\n\n            // Always override the AMQP client's MessageId with our own.  Preserve\n            // the original in the TextView property for later Ack.\n            MessageId messageId = new MessageId(getProducerId(), messageIdGenerator.getNextSequenceId());\n\n            MessageId amqpMessageId = message.getMessageId();\n            if (amqpMessageId != null) {\n                if (amqpMessageId.getTextView() != null) {\n                    messageId.setTextView(amqpMessageId.getTextView());\n                } else {\n                    messageId.setTextView(amqpMessageId.toString());\n                }\n            }\n\n            message.setMessageId(messageId);\n\n            LOG.trace(\"Inbound Message:{} from Producer:{}\",\n                      message.getMessageId(), getProducerId() + \":\" + messageId.getProducerSequenceId());\n\n            final DeliveryState remoteState = delivery.getRemoteState();\n            if (remoteState != null && remoteState instanceof TransactionalState) {\n                TransactionalState s = (TransactionalState) remoteState;\n                long txid = toLong(s.getTxnId());\n                message.setTransactionId(new LocalTransactionId(session.getConnection().getConnectionId(), txid));\n            }\n\n            message.onSend();\n            if (!delivery.remotelySettled()) {\n                sendToActiveMQ(message, new ResponseHandler() {\n\n                    @Override\n                    public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {\n                        if (response.isException()) {\n                            ExceptionResponse er = (ExceptionResponse) response;\n                            Rejected rejected = new Rejected();\n                            ErrorCondition condition = new ErrorCondition();\n                            condition.setCondition(Symbol.valueOf(\"failed\"));\n                            condition.setDescription(er.getException().getMessage());\n                            rejected.setError(condition);\n                            delivery.disposition(rejected);\n                        } else {\n                            if (getEndpoint().getCredit() <= (getConfiguredReceiverCredit() * .2)) {\n                                LOG.debug(\"Sending more credit ({}) to producer: {}\", getConfiguredReceiverCredit() - getEndpoint().getCredit(), getProducerId());\n                                getEndpoint().flow(getConfiguredReceiverCredit() - getEndpoint().getCredit());\n                            }\n\n                            if (remoteState != null && remoteState instanceof TransactionalState) {\n                                TransactionalState txAccepted = new TransactionalState();\n                                txAccepted.setOutcome(Accepted.getInstance());\n                                txAccepted.setTxnId(((TransactionalState) remoteState).getTxnId());\n\n                                delivery.disposition(txAccepted);\n                            } else {\n                                delivery.disposition(Accepted.getInstance());\n                            }\n                        }\n\n                        delivery.settle();\n                        session.pumpProtonToSocket();\n                    }\n                });\n            } else {\n                if (getEndpoint().getCredit() <= (getConfiguredReceiverCredit() * .2)) {\n                    LOG.debug(\"Sending more credit ({}) to producer: {}\", getConfiguredReceiverCredit() - getEndpoint().getCredit(), getProducerId());\n                    getEndpoint().flow(getConfiguredReceiverCredit() - getEndpoint().getCredit());\n                    session.pumpProtonToSocket();\n                }\n\n                delivery.settle();\n                sendToActiveMQ(message);\n            }\n        }\n    }"
        ]
    ],
    "d2bd152960a74de6a61c2ddbea81ddcdcb70c177": [
        [
            "AutoTransportMaxConnectionsTest::testMaxConnectionControl()",
            "  98  \n  99  \n 100  \n 101  \n 102  \n 103 -\n 104  \n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111  \n 112  \n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  ",
            "    @Test\n    public void testMaxConnectionControl() throws Exception {\n        final ConnectionFactory cf = createConnectionFactory();\n        final CountDownLatch startupLatch = new CountDownLatch(1);\n\n        for(int i = 0; i < maxConnections + 20; i++) {\n            executor.submit(new Runnable() {\n                @Override\n                public void run() {\n                    Connection conn = null;\n                    try {\n                        startupLatch.await();\n                        conn = cf.createConnection();\n                        conn.start();\n                    } catch (Exception e) {\n                        //JmsUtils.closeConnection(conn);\n                    }\n                }\n            });\n        }\n\n        TcpTransportServer transportServer = (TcpTransportServer)connector.getServer();\n        // ensure the max connections is in effect\n        assertEquals(maxConnections, transportServer.getMaximumConnections());\n        // No connections at first\n        assertEquals(0, connector.getConnections().size());\n        // Release the latch to set up connections in parallel\n        startupLatch.countDown();\n\n        final TransportConnector connector = this.connector;\n\n        // Expect the max connections is created\n        assertTrue(\"Expected: \" + maxConnections + \" found: \" + connector.getConnections().size(),\n            Wait.waitFor(new Wait.Condition() {\n                @Override\n                public boolean isSatisified() throws Exception {\n                    return connector.getConnections().size() == maxConnections;\n                }\n            })",
            "  97  \n  98  \n  99  \n 100  \n 101  \n 102 +\n 103 +\n 104 +\n 105  \n 106  \n 107  \n 108  \n 109  \n 110  \n 111 +\n 112 +\n 113  \n 114  \n 115  \n 116  \n 117  \n 118  \n 119  \n 120  \n 121  \n 122  \n 123  \n 124  \n 125  \n 126  \n 127  \n 128  \n 129  \n 130  \n 131  \n 132  \n 133  \n 134  \n 135  \n 136  \n 137  \n 138  \n 139  ",
            "    @Test(timeout=60000)\n    public void testMaxConnectionControl() throws Exception {\n        final ConnectionFactory cf = createConnectionFactory();\n        final CountDownLatch startupLatch = new CountDownLatch(1);\n\n        //create an extra 10 connections above max\n        for(int i = 0; i < maxConnections + 10; i++) {\n            final int count = i;\n            executor.submit(new Runnable() {\n                @Override\n                public void run() {\n                    Connection conn = null;\n                    try {\n                        startupLatch.await();\n                        //sleep for a short period of time\n                        Thread.sleep(count * 3);\n                        conn = cf.createConnection();\n                        conn.start();\n                    } catch (Exception e) {\n                        //JmsUtils.closeConnection(conn);\n                    }\n                }\n            });\n        }\n\n        TcpTransportServer transportServer = (TcpTransportServer)connector.getServer();\n        // ensure the max connections is in effect\n        assertEquals(maxConnections, transportServer.getMaximumConnections());\n        // No connections at first\n        assertEquals(0, connector.getConnections().size());\n        // Release the latch to set up connections in parallel\n        startupLatch.countDown();\n\n        final TransportConnector connector = this.connector;\n\n        // Expect the max connections is created\n        assertTrue(\"Expected: \" + maxConnections + \" found: \" + connector.getConnections().size(),\n            Wait.waitFor(new Wait.Condition() {\n                @Override\n                public boolean isSatisified() throws Exception {\n                    return connector.getConnections().size() == maxConnections;\n                }\n            })"
        ],
        [
            "AutoNIOTransport::readFromBuffer()",
            "  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67  \n  68  \n  69  \n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  ",
            "    /**\n     * Read from the initial buffer if it is set\n     */\n    @Override\n    protected int readFromBuffer() throws IOException {\n        int readSize = 0;\n        if (!doneInitBuffer) {\n            if (initBuffer == null || initBuffer.readSize < 8) {\n                throw new IOException(\"Protocol type could not be determined.\");\n            }\n            if (nextFrameSize == -1) {\n                readSize = 4;\n                this.initBuffer.buffer.flip();\n                for (int i = 0; i < 4; i++) {\n                    currentBuffer.put(initBuffer.buffer.get());\n                }\n            } else {\n                for (int i = 0; i < 4; i++) {\n                    currentBuffer.put(initBuffer.buffer.get());\n                }\n                readSize = 4;\n                doneInitBuffer = true;\n            }\n\n        } else {\n            readSize += channel.read(currentBuffer);\n        }\n        return readSize;\n    }",
            "  54  \n  55  \n  56  \n  57  \n  58  \n  59  \n  60  \n  61  \n  62  \n  63  \n  64  \n  65  \n  66  \n  67 +\n  68 +\n  69 +\n  70  \n  71  \n  72  \n  73  \n  74  \n  75  \n  76  \n  77  \n  78  \n  79  \n  80  \n  81  \n  82  \n  83  \n  84  \n  85  ",
            "    /**\n     * Read from the initial buffer if it is set\n     */\n    @Override\n    protected int readFromBuffer() throws IOException {\n        int readSize = 0;\n        if (!doneInitBuffer) {\n            if (initBuffer == null || initBuffer.readSize < 8) {\n                throw new IOException(\"Protocol type could not be determined.\");\n            }\n            if (nextFrameSize == -1) {\n                readSize = 4;\n                this.initBuffer.buffer.flip();\n                if (this.initBuffer.buffer.remaining() < 8) {\n                    throw new IOException(\"Protocol type could not be determined.\");\n                }\n                for (int i = 0; i < 4; i++) {\n                    currentBuffer.put(initBuffer.buffer.get());\n                }\n            } else {\n                for (int i = 0; i < 4; i++) {\n                    currentBuffer.put(initBuffer.buffer.get());\n                }\n                readSize = 4;\n                doneInitBuffer = true;\n            }\n\n        } else {\n            readSize += channel.read(currentBuffer);\n        }\n        return readSize;\n    }"
        ]
    ]
}